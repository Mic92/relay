ALIAS_ANALYSIS {

FUNPTRS : cil
EXPS : fi_ci_eq
LVALS : fi_ci_eq
MAY_ALIAS : fi_ci_eq

}

SUMMARY_DB {

CENTRAL : false
PATHS : /home/jan/research/relay-race/scc_sum ; /output ; /media/win/temp/relay_sums ; /media/LACIE/jan/relay_sums

}

REQUEST {

SERVER_IP_FILE : server_ip.txt
SERVER_PORT : 13791
LOCAL_SRCS : /tmp/relay_scratch

}

DISTRIBUTED {

CENTRAL : false
LOG_PATH : relay_logs

}

FILE_SERVER {

PORT : 14440

}

LOCK_FUNCS {

down :void (struct semaphore * )$+/sem/w/f0$
down_interruptible :int (struct semaphore * )$(result==0)?+/sem/w/f0$
down_trylock :int (struct semaphore * )$(result==0)?+/sem/w/f0$
up :void (struct semaphore * )$-/sem/w/f0$
_spin_lock :void (spinlock_t * )$+/lock/w/f0$
_read_lock :void (rwlock_t * )$+/lock/r/f0$
_write_lock :void (rwlock_t * )$+/lock/w/f0$
_spin_lock_bh :void (spinlock_t * )$+/lock/w/f0$
_read_lock_bh :void (rwlock_t * )$+/lock/r/f0$
_write_lock_bh :void (rwlock_t * )$+/lock/w/f0$
_spin_lock_irq :void (spinlock_t * )$+/lock/w/f0$
_read_lock_irq :void (rwlock_t * )$+/lock/r/f0$
_write_lock_irq :void (rwlock_t * )$+/lock/w/f0$
_spin_lock_irqsave :unsigned long (spinlock_t * )$+/lock/w/f0$
_read_lock_irqsave :unsigned long (rwlock_t * )$+/lock/r/f0$
_write_lock_irqsave :unsigned long (rwlock_t * )$+/lock/w/f0$
_spin_trylock :int (spinlock_t * )$(result==0)?+/lock/w/f0$
_read_trylock :int (rwlock_t * )$(result==0)?+/lock/r/f0$
_write_trylock :int (rwlock_t * )$(result==0)?+/lock/w/f0$
_spin_unlock :void (spinlock_t * )$-/lock/w/f0$
_read_unlock :void (rwlock_t * )$-/lock/r/f0$
_write_unlock :void (rwlock_t * )$-/lock/w/f0$
_spin_unlock_bh :void (spinlock_t * )$-/lock/w/f0$
_read_unlock_bh :void (rwlock_t * )$-/lock/r/f0$
_write_unlock_bh :void (rwlock_t * )$-/lock/w/f0$
_spin_unlock_irq :void (spinlock_t * )$-/lock/w/f0$
_read_unlock_irq :void (rwlock_t * )$-/lock/r/f0$
_write_unlock_irq :void (rwlock_t * )$-/lock/w/f0$
_spin_unlock_irqrestore :void (spinlock_t * , unsigned long )$-/lock/w/f0$
_read_unlock_irqrestore :void (spinlock_t * , unsigned long )$-/lock/r/f0$
_write_unlock_irqrestore :void (spinlock_t * , unsigned long )$-/lock/w/f0$
lock_kernel :void (void)$+/kernel_sem/w/g,+/kernel_flag/w/g$
unlock_kernel :void (void)$-/kernel_sem/w/g,-/kernel_flag/w/g$
pthread_mutex_lock :int (pthread_mutex_t * )$+/__mutex/w/f0$
pthread_mutex_unlock :int (pthread_mutex_t * )$-/__mutex/w/f0$
pthread_mutex_trylock :int (pthread_mutex_t * )$(result==EBUSY)?-/__mutex/w/f0$
sem_post :int (sem_t * )$-/sem/w/f0$
sem_wait :int (sem_t * )$+/sem/w/f0$
sem_trywait :int (sem_t * )$(result==0)?+/sem/w/f0$

}

THREAD_FUNCS {

pthread_create :int (pthread_t * , pthread_attr_t * , void *(*)(void * ) , void * )$true$f2$f3
kthread_create :struct task_struct *(int (*)(void *data ) , void * , char * , ...)$false$wake_up_process$int (struct task_struct * )$f0$f1
kthread_run :struct task_struct *(int (*)(void *data ) , void * , char * , ...)$true$f0$f1
kernel_thread :int (int (*)(void * ) , void * , unsigned long )$true$f0$f1

}

EXIT_FUNCS {

panic :void (char * , ...)
exit :void (int )

}

SYM_EX {

ADJUST : true

}
