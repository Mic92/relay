/* Generated by CIL v. 1.3.5 */
/* print_CIL_Input is true */

#line 7 "lock.h"
struct _spinlock_t {
   int locked ;
};
#line 7 "lock.h"
typedef struct _spinlock_t spinlock_t;
#line 214 "/usr/lib/gcc/i486-linux-gnu/4.1.2/include/stddef.h"
typedef unsigned int size_t;
#line 59 "/usr/include/bits/types.h"
typedef long long __quad_t;
#line 144 "/usr/include/bits/types.h"
typedef long __off_t;
#line 145 "/usr/include/bits/types.h"
typedef __quad_t __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 176 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 182 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 267 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(int )((15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t ))] ;
};
#line 38 "fplock.c"
struct _dat_lock {
   spinlock_t l ;
   int x ;
};
#line 38 "fplock.c"
typedef struct _dat_lock dat_lock;
#line 43 "fplock.c"
struct _dispatch {
   void (*mun)(int * , spinlock_t * ) ;
   void (*acc)(void) ;
};
#line 43 "fplock.c"
typedef struct _dispatch dispatch;
#line 50 "fplock.c"
struct _recurStruct {
   struct _recurStruct *kids[2] ;
   int data ;
};
#line 50 "fplock.c"
typedef struct _recurStruct recurStruct;
#line 81 "fplock.c"
struct page {
   spinlock_t l ;
   int x ;
};
#line 114 "fplock.c"
struct page_address_slot {
   dispatch d ;
   spinlock_t lock ;
} __attribute__((__aligned__((1) <<  (7) ))) ;
#line 509
enum __anonenum_boolean_27 {
    false = 0,
    true = 1
}  __attribute__((__packed__)) ;
#line 509 "fplock.c"
typedef enum __anonenum_boolean_27 boolean;
#line 516 "fplock.c"
struct DAC960_SCSI_Inquiry {
   unsigned char PeripheralDeviceType : 5 ;
   unsigned char PeripheralQualifier : 3 ;
   unsigned char DeviceTypeModifier : 7 ;
   boolean RMB : 1 ;
   unsigned char ANSI_ApprovedVersion : 3 ;
   unsigned char ECMA_Version : 3 ;
   unsigned char ISO_Version : 2 ;
   unsigned char ResponseDataFormat : 4 ;
   unsigned char  : 2 ;
   boolean TrmIOP : 1 ;
   boolean AENC : 1 ;
   unsigned char AdditionalLength ;
   unsigned char  : 8 ;
   unsigned char  : 8 ;
   boolean SftRe : 1 ;
   boolean CmdQue : 1 ;
   boolean  : 1 ;
   boolean Linked : 1 ;
   boolean Sync : 1 ;
   boolean WBus16 : 1 ;
   boolean WBus32 : 1 ;
   boolean RelAdr : 1 ;
   unsigned char VendorIdentification[8] ;
   unsigned char ProductIdentification[16] ;
   unsigned char ProductRevisionLevel[4] ;
};
#line 516 "fplock.c"
typedef struct DAC960_SCSI_Inquiry DAC960_SCSI_Inquiry_T;
#line 549 "fplock.c"
struct DAC960_SCSI_Inquiry_UnitSerialNumber {
   unsigned char PeripheralDeviceType : 5 ;
   unsigned char PeripheralQualifier : 3 ;
   unsigned char PageCode ;
   unsigned char  : 8 ;
   unsigned char PageLength ;
   unsigned char ProductSerialNumber[28] ;
};
#line 549 "fplock.c"
typedef struct DAC960_SCSI_Inquiry_UnitSerialNumber DAC960_SCSI_Inquiry_UnitSerialNumber_T;
#line 635 "fplock.c"
struct idr_layer {
   unsigned long bitmap ;
   struct idr_layer *ary[32] ;
   int count ;
};
#line 641 "fplock.c"
struct idr {
   struct idr_layer *top ;
   struct idr_layer *id_free ;
   int layers ;
   int id_free_cnt ;
   spinlock_t lock ;
};
#line 1 "lock.o"
#pragma merger(0,"/tmp/cil-ysLHl9Lx.i","")
#line 11 "lock.h"
void _spin_lock(spinlock_t *lock ) ;
#line 13
int _spin_trylock(spinlock_t *lock ) ;
#line 15
void _spin_unlock(spinlock_t *lock ) ;
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 325
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 5 "lock.c"
void _spin_lock(spinlock_t *lock ) 
{ 

  {
#line 6
  lock->locked = 1;
#line 7
  return;
}
}
#line 10 "lock.c"
int _spin_trylock(spinlock_t *lock ) 
{ 

  {
#line 11
  if (lock->locked == 0) {
#line 12
    lock->locked = 1;
#line 13
    return (0);
  } else {
#line 15
    return (1);
  }
}
}
#line 19 "lock.c"
void _spin_unlock(spinlock_t *lock ) 
{ 

  {
#line 20
  if (lock->locked == 1) {
#line 21
    lock->locked = 0;
  } else {
#line 24
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Double unlock!\n");
  }
#line 27
  return;
}
}
#line 1 "fplock.o"
#pragma merger(0,"/tmp/cil-DDqj59dr.i","")
#line 498 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int rand(void) ;
#line 500
extern  __attribute__((__nothrow__)) void srand(unsigned int __seed ) ;
#line 589
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 603
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
#line 646
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
#line 87 "/usr/include/string.h"
 __attribute__((__nothrow__)) char *strncpy(char * __restrict  dest , char const   * __restrict  src ,
                                            size_t count )  __attribute__((__nonnull__(1,2))) ;
#line 242
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
#line 8 "fplock.c"
void (*fp_mun)(int * , spinlock_t * )  ;
#line 9 "fplock.c"
void (*fp_rec)(spinlock_t * )  ;
#line 10 "fplock.c"
void (*fp_rec2)(spinlock_t * )  ;
#line 11 "fplock.c"
void (*fp_acc)(void)  ;
#line 13 "fplock.c"
int g10  =    41;
#line 14 "fplock.c"
int g11  =    2;
#line 15 "fplock.c"
int g12  =    1;
#line 16 "fplock.c"
int g13  =    4;
#line 18 "fplock.c"
int v1  =    1;
#line 19 "fplock.c"
int v2  =    2;
#line 20 "fplock.c"
int v3  =    3;
#line 21 "fplock.c"
int v4  =    4;
#line 22 "fplock.c"
int v5  =    5;
#line 24 "fplock.c"
int *gp1  =    (int *)((void *)0);
#line 26 "fplock.c"
struct _spinlock_t gLock10  =    {0};
#line 27 "fplock.c"
struct _spinlock_t gLock11  =    {0};
#line 28 "fplock.c"
struct _spinlock_t gLock12  =    {0};
#line 30 "fplock.c"
struct _spinlock_t gLockV1  =    {0};
#line 31 "fplock.c"
struct _spinlock_t gLockV2  =    {0};
#line 32 "fplock.c"
struct _spinlock_t gLockV3  =    {0};
#line 33 "fplock.c"
struct _spinlock_t gLockV4  =    {0};
#line 34 "fplock.c"
struct _spinlock_t gLockV5  =    {0};
#line 55 "fplock.c"
dat_lock datArr[2][2]  ;
#line 56 "fplock.c"
dat_lock **datArr2  ;
#line 57 "fplock.c"
dispatch fArr[2][2]  ;
#line 59 "fplock.c"
dispatch *gfp  =    (dispatch *)0;
#line 62 "fplock.c"
recurStruct *recS[2]  ;
#line 64 "fplock.c"
void foo(void) 
{ 

  {
#line 65
  g10 ++;
#line 66
  return;
}
}
#line 68 "fplock.c"
void bar(void) 
{ 

  {
#line 69
  v4 ++;
#line 70
  return;
}
}
#line 72 "fplock.c"
int lockedOnEntry(void) 
{ 

  {
#line 73
  _spin_unlock(& gLock11);
#line 74
  g11 ++;
#line 75
  return (g11);
}
}
#line 114 "fplock.c"
static struct page_address_slot page_address_htable[128]  ;
#line 121
extern int ( /* missing proto */  hash_ptr)() ;
#line 120 "fplock.c"
static struct page_address_slot *page_slot(struct page *page ) 
{ int tmp ;

  {
#line 121
  tmp = hash_ptr(page, 7);
#line 121
  return (& page_address_htable[tmp]);
}
}
#line 125 "fplock.c"
void munge2(int *x , spinlock_t *l ) 
{ int i ;
  int *p ;

  {
#line 127
  i = 10;
#line 128
  p = & i;
#line 129
  (*p) ++;
#line 130
  _spin_lock(l);
#line 131
  (*x) ++;
#line 133
  _spin_unlock(l);
#line 134
  return;
}
}
#line 137 "fplock.c"
void munge(int *g10___0 , spinlock_t *gLock10___0 ) 
{ 

  {
#line 138
  munge2(g10___0, gLock10___0);
#line 139
  munge2(g10___0, gLock10___0);
#line 140
  return;
}
}
#line 142 "fplock.c"
void doubDerefMunge(int **ppi , spinlock_t *pl ) 
{ 

  {
#line 143
  _spin_lock(pl);
#line 144
  (*((*ppi))) ++;
#line 145
  _spin_unlock(pl);
#line 146
  return;
}
}
#line 148 "fplock.c"
void useDDM(int *pi , spinlock_t *pl ) 
{ 

  {
#line 149
  doubDerefMunge(& pi, pl);
#line 150
  return;
}
}
#line 152 "fplock.c"
void recurses(int *x , spinlock_t *l ) 
{ 

  {
#line 154
  _spin_lock(l);
#line 155
  (*x) --;
#line 156
  _spin_unlock(l);
#line 157
  if ((*x) > 0) {
#line 158
    recurses(x, l);
  }
#line 160
  return;
}
}
#line 162 "fplock.c"
void scc3_3(spinlock_t *l ) 
{ 

  {
#line 163
  _spin_lock(l);
#line 164
  bar();
#line 165
  _spin_unlock(l);
#line 166
  if (v4 > 0) {
#line 167
    ((*fp_rec))(l);
  }
#line 169
  return;
}
}
#line 172 "fplock.c"
void scc3_2(spinlock_t *l ) 
{ 

  {
#line 173
  _spin_lock(l);
#line 174
  bar();
#line 175
  _spin_unlock(l);
#line 176
  if (v4 > 0) {
#line 177
    ((*fp_rec))(l);
  }
#line 179
  return;
}
}
#line 182 "fplock.c"
void scc3_1(spinlock_t *l ) 
{ 

  {
#line 183
  _spin_lock(l);
#line 184
  bar();
#line 185
  _spin_unlock(l);
#line 186
  if (v4 > 0) {
#line 187
    ((*fp_rec))(l);
  }
#line 189
  return;
}
}
#line 197
void multi_recurses4(spinlock_t *l ) ;
#line 198
void multi_recurses5(spinlock_t *l1 , spinlock_t *l2 ) ;
#line 199
void multi_recurses6(spinlock_t *l1 , spinlock_t *l2 ) ;
#line 200
void multi_recurses7(spinlock_t *l1 , spinlock_t *l2 ) ;
#line 191 "fplock.c"
void multi_recurses3(spinlock_t *l ) 
{ 

  {
#line 193
  _spin_lock(l);
#line 194
  bar();
#line 195
  _spin_unlock(l);
#line 196
  if (v4 > 0) {
#line 197
    multi_recurses4(l);
#line 198
    multi_recurses5(l, l);
#line 199
    multi_recurses6(l, l);
#line 200
    multi_recurses7(l, l);
  }
#line 203
  return;
}
}
#line 206 "fplock.c"
void multi_recurses2(spinlock_t *l ) 
{ 

  {
#line 208
  _spin_lock(l);
#line 209
  bar();
#line 210
  _spin_unlock(l);
#line 211
  if (v4 > 0) {
#line 212
    multi_recurses3(l);
  }
#line 215
  return;
}
}
#line 217 "fplock.c"
void multi_recurses1(spinlock_t *l ) 
{ 

  {
#line 219
  _spin_lock(l);
#line 220
  bar();
#line 221
  _spin_unlock(l);
#line 222
  if (v4 > 0) {
#line 223
    multi_recurses2(l);
  }
#line 226
  return;
}
}
#line 229 "fplock.c"
void multi_recurses4(spinlock_t *l ) 
{ 

  {
#line 231
  _spin_lock(l);
#line 232
  bar();
#line 233
  _spin_unlock(l);
#line 234
  if (v4 > 0) {
#line 235
    multi_recurses1(l);
  }
#line 238
  return;
}
}
#line 240 "fplock.c"
void multi_recurses5(spinlock_t *l1 , spinlock_t *l2 ) 
{ 

  {
#line 242
  _spin_lock(l2);
#line 243
  bar();
#line 244
  if (v4 > 0) {
#line 245
    _spin_unlock(l2);
#line 246
    multi_recurses5(l2, l1);
  } else {
#line 248
    _spin_unlock(l2);
  }
#line 250
  return;
}
}
#line 252 "fplock.c"
void multi_recurses6(spinlock_t *l1 , spinlock_t *l2 ) 
{ 

  {
#line 253
  _spin_lock(l2);
#line 254
  bar();
#line 255
  if (v4 > 0) {
#line 256
    _spin_unlock(l2);
#line 257
    multi_recurses6(l1, l2);
  } else {
#line 259
    _spin_unlock(l2);
  }
#line 261
  return;
}
}
#line 264 "fplock.c"
void multi_recurses7(spinlock_t *l1 , spinlock_t *l2 ) 
{ 

  {
#line 265
  _spin_lock(l2);
#line 266
  bar();
#line 267
  _spin_unlock(l2);
#line 268
  if (v4 > 0) {
#line 269
    multi_recurses7(l1, l2);
  }
#line 271
  return;
}
}
#line 274 "fplock.c"
void structAcc(dat_lock d ) 
{ 

  {
#line 275
  munge(& d.x, & d.l);
#line 276
  return;
}
}
#line 278 "fplock.c"
void iterRecStruct(recurStruct *rs ) 
{ 

  {
#line 281
  while (rs) {
#line 282
    rs->data = 10;
#line 283
    rs = rs->kids[0];
  }
#line 285
  return;
}
}
#line 287 "fplock.c"
void recurseRecStruct(recurStruct *rs ) 
{ int i ;

  {
#line 290
  i = 0;
#line 290
  while (i < 2) {
#line 291
    if (rs->kids[i]) {
#line 292
      recurseRecStruct(rs->kids[i]);
    }
#line 290
    i ++;
  }
#line 294
  rs->data = 18;
#line 295
  return;
}
}
#line 298 "fplock.c"
void iterRecStructCast(void *arg ) 
{ recurStruct *rs ;

  {
#line 302
  rs = (recurStruct *)arg;
#line 304
  while (1) {
#line 304
    if (rs) {
#line 304
      if (! rs->kids[0]) {
#line 304
        break;
      }
    } else {
#line 304
      break;
    }
#line 305
    (rs->kids[0])->data = 24;
#line 306
    rs = rs->kids[0];
  }
#line 308
  return;
}
}
#line 310 "fplock.c"
void recurseRecStructCast(void *arg ) 
{ int i ;
  recurStruct *rs ;

  {
#line 314
  rs = (recurStruct *)arg;
#line 316
  i = 0;
#line 316
  while (i < 2) {
#line 317
    if (rs->kids[i]) {
#line 318
      (rs->kids[i])->data = 56;
#line 319
      recurseRecStruct(rs->kids[i]);
    }
#line 316
    i ++;
  }
#line 322
  return;
}
}
#line 324 "fplock.c"
void dyMunge(int *dyX , spinlock_t *dyL ) 
{ 

  {
#line 325
  _spin_lock(dyL);
#line 326
  (*dyX) ++;
#line 327
  _spin_unlock(dyL);
#line 328
  return;
}
}
#line 331 "fplock.c"
void dyAlloc(void) 
{ int *d1 ;
  int *d2 ;
  int *d3 ;
  spinlock_t *l1 ;
  spinlock_t *l2 ;
  int *a ;
  int *b ;
  int *c ;
  dat_lock dl ;
  recurStruct recStrct ;

  {
#line 340
  dl.x = 10;
#line 342
  d1 = (int *)malloc(sizeof(int ));
#line 343
  d2 = (int *)malloc(sizeof(int ));
#line 344
  d3 = (int *)malloc(sizeof(int ));
#line 346
  (*d1) = 1;
#line 346
  (*d2) = 2;
#line 346
  (*d3) = 3;
#line 348
  l1 = (spinlock_t *)malloc(sizeof(spinlock_t ));
#line 349
  l2 = (spinlock_t *)malloc(sizeof(spinlock_t ));
#line 351
  a = d1;
#line 353
  dyMunge(a, l1);
#line 355
  a = d2;
#line 357
  dyMunge(a, l2);
#line 359
  a = d3;
#line 361
  dyMunge(a, l2);
#line 363
  a = & dl.x;
#line 365
  dyMunge(a, l1);
#line 367
  a = (int *)(& dl + sizeof(spinlock_t ));
#line 369
  dyMunge(a, l2);
#line 371
  b = (int *)(& dl + sizeof(spinlock_t ));
#line 373
  dyMunge(b, l2);
#line 375
  c = & dl.x;
#line 377
  dyMunge(c, l1);
#line 379
  recStrct.kids[0] = & recStrct;
#line 381
  dyMunge((int *)recStrct.kids[0], l2);
#line 383
  free((void *)d1);
#line 383
  free((void *)d2);
#line 383
  free((void *)d3);
#line 384
  free((void *)l1);
#line 384
  free((void *)l2);
#line 386
  return;
}
}
#line 388 "fplock.c"
int *mallocInt(void) 
{ int *p ;

  {
#line 391
  p = (int *)malloc(sizeof((*p)));
#line 393
  return (p);
}
}
#line 396 "fplock.c"
dispatch *mallocDispatch(void) 
{ dispatch *p ;

  {
#line 399
  p = (dispatch *)malloc(sizeof(dispatch ));
#line 400
  p->mun = & munge;
#line 401
  p->acc = & bar;
#line 402
  return (p);
}
}
#line 405 "fplock.c"
void hitDifferentInt(spinlock_t *aLock ) 
{ 

  {
#line 406
  _spin_lock(aLock);
#line 407
  gp1 = mallocInt();
#line 408
  (*gp1) ++;
#line 409
  free((void *)gp1);
#line 410
  _spin_unlock(aLock);
#line 411
  return;
}
}
#line 413 "fplock.c"
void hitDifferentDispatch(spinlock_t *aLock ) 
{ 

  {
#line 414
  _spin_lock(aLock);
#line 415
  gfp = mallocDispatch();
#line 416
  free((void *)gfp);
#line 417
  _spin_unlock(aLock);
#line 418
  return;
}
}
#line 420 "fplock.c"
static int pointinrect(double const   *point , double (*coords)[2] ) 
{ double max[2] ;
  double min[2] ;
  int tmp ;

  {
#line 426
  if ((*(coords + 0))[0] > (*(coords + 1))[0]) {
#line 427
    max[0] = (*(coords + 0))[0];
#line 428
    min[0] = (*(coords + 1))[0];
  } else {
#line 430
    max[0] = (*(coords + 1))[0];
#line 431
    min[0] = (*(coords + 0))[0];
  }
#line 433
  if ((*(coords + 0))[1] > (*(coords + 1))[1]) {
#line 434
    max[1] = (*(coords + 0))[1];
#line 435
    min[1] = (*(coords + 1))[1];
  } else {
#line 437
    max[1] = (*(coords + 1))[1];
#line 438
    min[1] = (*(coords + 0))[1];
  }
#line 440
  if ((*(point + 0)) >= (double const   )min[0]) {
#line 441
    if ((*(point + 0)) <= (double const   )max[0]) {
#line 442
      if ((*(point + 1)) >= (double const   )min[1]) {
#line 443
        if ((*(point + 1)) <= (double const   )max[1]) {
#line 444
          tmp = 1;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        goto _L___1;
      }
    } else {
      goto _L___1;
    }
  } else {
    _L___1: 
#line 457
    tmp = 0;
  }
#line 459
  return (tmp);
}
}
#line 464 "fplock.c"
void funcWithLabelAtStart(void) 
{ int x ;
  int y ;

  {
  retry: 
#line 469
  x = rand();
#line 470
  y = rand();
#line 471
  if (x != y) {
    goto retry;
  }
#line 472
  return;
}
}
#line 489
 __attribute__((__nothrow__)) char *strncpy(char * __restrict  dest , char const   * __restrict  src ,
                                            size_t count )  __attribute__((__nonnull__(1,2))) ;
#line 489 "fplock.c"
char *strncpy(char * __restrict  dest , char const   * __restrict  src , size_t count ) 
{ char *tmp ;

  {
#line 491
  tmp = (char *)dest;
#line 493
  while (count) {
#line 494
    (*tmp) = (char )(*src);
#line 494
    if ((int )(*tmp) != 0) {
#line 495
      src ++;
    }
#line 496
    tmp ++;
#line 497
    count --;
  }
#line 499
  return ((char *)dest);
}
}
#line 566 "fplock.c"
static void DAC960_SanitizeInquiryData(DAC960_SCSI_Inquiry_T *InquiryStandardData ,
                                       DAC960_SCSI_Inquiry_UnitSerialNumber_T *InquiryUnitSerialNumber ,
                                       unsigned char *Vendor , unsigned char *Model ,
                                       unsigned char *Revision , unsigned char *SerialNumber ) 
{ int SerialNumberLength ;
  int i ;
  unsigned char VendorCharacter ;
  unsigned char ModelCharacter ;
  unsigned char RevisionCharacter ;
  unsigned char SerialNumberCharacter ;

  {
#line 576
  if ((int )InquiryStandardData->PeripheralDeviceType == 31) {
#line 576
    return;
  }
#line 577
  i = 0;
#line 577
  while ((unsigned int )i < sizeof(InquiryStandardData->VendorIdentification)) {
#line 579
    VendorCharacter = InquiryStandardData->VendorIdentification[i];
#line 581
    if ((int )VendorCharacter >= 32) {
#line 581
      if ((int )VendorCharacter <= 126) {
#line 581
        (*(Vendor + i)) = VendorCharacter;
      } else {
#line 581
        (*(Vendor + i)) = (unsigned char )' ';
      }
    } else {
#line 581
      (*(Vendor + i)) = (unsigned char )' ';
    }
#line 577
    i ++;
  }
#line 584
  (*(Vendor + sizeof(InquiryStandardData->VendorIdentification))) = (unsigned char )'\000';
#line 585
  i = 0;
#line 585
  while ((unsigned int )i < sizeof(InquiryStandardData->ProductIdentification)) {
#line 587
    ModelCharacter = InquiryStandardData->ProductIdentification[i];
#line 589
    if ((int )ModelCharacter >= 32) {
#line 589
      if ((int )ModelCharacter <= 126) {
#line 589
        (*(Model + i)) = ModelCharacter;
      } else {
#line 589
        (*(Model + i)) = (unsigned char )' ';
      }
    } else {
#line 589
      (*(Model + i)) = (unsigned char )' ';
    }
#line 585
    i ++;
  }
#line 592
  (*(Model + sizeof(InquiryStandardData->ProductIdentification))) = (unsigned char )'\000';
#line 593
  i = 0;
#line 593
  while ((unsigned int )i < sizeof(InquiryStandardData->ProductRevisionLevel)) {
#line 595
    RevisionCharacter = InquiryStandardData->ProductRevisionLevel[i];
#line 597
    if ((int )RevisionCharacter >= 32) {
#line 597
      if ((int )RevisionCharacter <= 126) {
#line 597
        (*(Revision + i)) = RevisionCharacter;
      } else {
#line 597
        (*(Revision + i)) = (unsigned char )' ';
      }
    } else {
#line 597
      (*(Revision + i)) = (unsigned char )' ';
    }
#line 593
    i ++;
  }
#line 600
  (*(Revision + sizeof(InquiryStandardData->ProductRevisionLevel))) = (unsigned char )'\000';
#line 601
  if ((int )InquiryUnitSerialNumber->PeripheralDeviceType == 31) {
#line 601
    return;
  }
#line 602
  SerialNumberLength = (int )InquiryUnitSerialNumber->PageLength;
#line 603
  if ((unsigned int )SerialNumberLength > sizeof(InquiryUnitSerialNumber->ProductSerialNumber)) {
#line 605
    SerialNumberLength = (int )sizeof(InquiryUnitSerialNumber->ProductSerialNumber);
  }
#line 606
  i = 0;
#line 606
  while (i < SerialNumberLength) {
#line 608
    SerialNumberCharacter = InquiryUnitSerialNumber->ProductSerialNumber[i];
#line 610
    if ((int )SerialNumberCharacter >= 32) {
#line 610
      if ((int )SerialNumberCharacter <= 126) {
#line 610
        (*(SerialNumber + i)) = SerialNumberCharacter;
      } else {
#line 610
        (*(SerialNumber + i)) = (unsigned char )' ';
      }
    } else {
#line 610
      (*(SerialNumber + i)) = (unsigned char )' ';
    }
#line 606
    i ++;
  }
#line 614
  (*(SerialNumber + SerialNumberLength)) = (unsigned char )'\000';
#line 615
  return;
}
}
#line 649 "fplock.c"
static struct idr_layer *alloc_layer(struct idr *idp ) 
{ struct idr_layer *p ;

  {
#line 653
  _spin_lock(& idp->lock);
#line 654
  p = idp->id_free;
#line 654
  if (p) {
#line 655
    idp->id_free = p->ary[0];
#line 656
    idp->id_free_cnt --;
#line 657
    p->ary[0] = (struct idr_layer *)((void *)0);
  }
#line 659
  _spin_unlock(& idp->lock);
#line 660
  return (p);
}
}
#line 663 "fplock.c"
static void free_layer(struct idr *idp , struct idr_layer *p ) 
{ 

  {
#line 668
  _spin_lock(& idp->lock);
#line 669
  p->ary[0] = idp->id_free;
#line 670
  idp->id_free = p;
#line 671
  idp->id_free_cnt ++;
#line 672
  _spin_unlock(& idp->lock);
#line 673
  return;
}
}
#line 675 "fplock.c"
static void sub_remove(struct idr *idp , int shift , int id ) 
{ struct idr_layer *p ;
  struct idr_layer **pa[(int )((((sizeof(int ) * 8U - 1U) + 5U) - 1U) / 5U)] ;
  struct idr_layer ***paa ;
  int n ;
  struct idr_layer ***tmp ;

  {
#line 677
  p = idp->top;
#line 679
  paa = pa;
#line 682
  (*paa) = (struct idr_layer **)((void *)0);
#line 683
  paa ++;
#line 683
  (*paa) = & idp->top;
#line 685
  while (1) {
#line 685
    if (shift > 0) {
#line 685
      if (! p) {
#line 685
        break;
      }
    } else {
#line 685
      break;
    }
#line 686
    n = (id >> shift) & 31;
#line 688
    paa ++;
#line 688
    (*paa) = & p->ary[n];
#line 689
    p = p->ary[n];
#line 690
    shift -= 5;
  }
#line 692
  n = id & 31;
#line 693
  if ((unsigned int )p != (unsigned int )((void *)0)) {
#line 695
    p->ary[n] = (struct idr_layer *)((void *)0);
#line 696
    while (1) {
#line 696
      if ((*paa)) {
#line 696
        ((*((*paa))))->count --;
#line 696
        if (((*((*paa))))->count) {
#line 696
          break;
        }
      } else {
#line 696
        break;
      }
#line 697
      free_layer(idp, (*((*paa))));
#line 698
      tmp = paa;
#line 698
      paa --;
#line 698
      (*((*tmp))) = (struct idr_layer *)((void *)0);
    }
#line 700
    if (! (*paa)) {
#line 701
      idp->layers = 0;
    }
  }
#line 704
  return;
}
}
#line 712 "fplock.c"
void idr_remove(struct idr *idp , int id ) 
{ struct idr_layer *p ;

  {
#line 717
  id = (int )((unsigned int )id & ((1U << (sizeof(int ) * 8U - 1U)) - 1U));
#line 719
  sub_remove(idp, (idp->layers - 1) * 5, id);
#line 720
  if (idp->top) {
#line 720
    if ((idp->top)->count == 1) {
#line 720
      if (idp->layers > 1) {
#line 720
        if ((idp->top)->ary[0]) {
#line 723
          p = (idp->top)->ary[0];
#line 724
          (idp->top)->count = 0;
#line 724
          (idp->top)->bitmap = (unsigned long )(idp->top)->count;
#line 725
          free_layer(idp, idp->top);
#line 726
          idp->top = p;
#line 727
          idp->layers --;
        }
      }
    }
  }
#line 729
  while ((unsigned int )idp->id_free_cnt >= (((sizeof(int ) * 8U - 1U) + 5U) - 1U) / 5U + (((sizeof(int ) * 8U - 1U) + 5U) - 1U) / 5U) {
#line 730
    p = alloc_layer(idp);
#line 732
    return;
  }
#line 734
  return;
}
}
#line 737 "fplock.c"
void voidNoReturn(int *dptr , spinlock_t *lptr ) 
{ int i ;
  int *p ;

  {
#line 740
  i = 10;
#line 741
  p = & i;
#line 742
  (*p) ++;
#line 743
  _spin_lock(lptr);
#line 744
  (*dptr) ++;
#line 745
  _spin_unlock(lptr);
#line 747
  return;
}
}
#line 749 "fplock.c"
struct _spinlock_t sccLock  =    {0};
#line 765
extern int ( /* missing proto */  time)() ;
#line 751 "fplock.c"
int main(int argc , char **argv ) 
{ int i ;
  int x ;
  int y ;
  void (*fp_mun2)(int * , spinlock_t * ) ;
  void (*fp_rec2___0)(spinlock_t * ) ;
  double *point ;
  double *rect[2] ;
  char *testStr ;
  char buf[81] ;
  dispatch *diss ;
  int tmp ;
  size_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 755
  x = 1;
#line 756
  y = 2;
#line 757
  fp_mun2 = (void (*)(int * , spinlock_t * ))0;
#line 761
  testStr = (char *)"hello world!\n";
#line 765
  tmp = time((void *)0);
#line 765
  srand((unsigned int )tmp);
#line 767
  fp_acc = & foo;
#line 768
  _spin_lock(& gLock10);
#line 770
  ((*fp_acc))();
#line 771
  _spin_lock(& gLock11);
#line 773
  munge(& g11, & gLock11);
#line 775
  g11 ++;
#line 776
  lockedOnEntry();
#line 778
  _spin_unlock(& gLock10);
#line 780
  if (y < x) {
    goto label1;
  }
#line 783
  x ++;
#line 784
  y ++;
#line 786
  fp_mun2 = & munge2;
#line 787
  fp_mun = & munge;
#line 788
  ((*fp_mun))(& v1, & gLockV1);
#line 789
  ((*fp_mun))(& v2, & gLockV2);
#line 790
  ((*fp_mun))(& v3, & gLockV3);
#line 792
  recurses(& v1, & gLockV1);
#line 794
  fp_rec = & multi_recurses2;
#line 795
  fp_rec = & multi_recurses3;
#line 796
  fp_rec = & multi_recurses1;
#line 798
  fp_rec2___0 = & scc3_1;
#line 799
  fp_rec2___0 = & scc3_2;
#line 800
  fp_rec2___0 = & scc3_3;
#line 802
  ((*fp_rec))(& gLockV4);
#line 804
  ((*fp_rec2___0))(& sccLock);
#line 806
  ((*fp_mun))(& datArr[0][0].x, & datArr[0][0].l);
#line 808
  structAcc(datArr[0][0]);
#line 810
  datArr2 = (dat_lock **)malloc(2U * sizeof(dat_lock *));
#line 811
  (*datArr2) = (dat_lock *)malloc(sizeof(dat_lock ));
#line 812
  (*(datArr2 + 1)) = (dat_lock *)malloc(sizeof(dat_lock ));
#line 814
  structAcc((*((*datArr2))));
#line 816
  fArr[0][0].mun = & munge;
#line 817
  fArr[0][0].acc = & bar;
#line 819
  ((*(fArr[0][0].mun)))(& v1, & gLockV1);
#line 820
  ((*((fArr[0] + 1)->acc)))();
#line 822
  diss = (dispatch *)page_slot((struct page *)0);
#line 824
  hitDifferentInt(& gLockV1);
#line 825
  hitDifferentInt(& gLockV2);
#line 827
  hitDifferentDispatch(& gLockV1);
#line 828
  hitDifferentDispatch(& gLockV2);
#line 831
  recS[0] = (recurStruct *)malloc(sizeof(recurStruct ));
#line 832
  recurseRecStruct(recS[0]);
#line 834
  recurseRecStructCast((void *)recS[0]);
#line 835
  iterRecStructCast((void *)recS[0]);
#line 837
  useDDM(& v5, & gLockV5);
#line 838
  voidNoReturn(& v5, & gLockV5);
#line 840
  point = (double *)malloc(sizeof(double ) * 2U);
#line 841
  (*(point + 0)) = 0.0;
#line 842
  (*(point + 1)) = 1.0;
#line 843
  (*((*((rect + 0) + 0)))) = 0.0;
#line 844
  (*((*((rect + 1) + 0)))) = 0.0;
#line 845
  (*((*((rect + 0) + 1)))) = 1.0;
#line 846
  (*((*((rect + 1) + 1)))) = 1.0;
#line 849
  i = pointinrect((double const   *)point, (double (*)[2])(rect));
#line 851
  funcWithLabelAtStart();
#line 854
  tmp___8 = strlen((char const   *)testStr);
#line 854
  if (tmp___8 < sizeof(buf) - 1U) {
#line 854
    tmp___7 = strlen((char const   *)testStr);
  } else {
#line 854
    tmp___7 = sizeof(buf) - 1U;
  }
#line 854
  strncpy((char * __restrict  )(buf), (char const   * __restrict  )testStr, tmp___7);
#line 856
  DAC960_SanitizeInquiryData((DAC960_SCSI_Inquiry_T *)0, (DAC960_SCSI_Inquiry_UnitSerialNumber_T *)0,
                             (unsigned char *)0, (unsigned char *)0, (unsigned char *)0,
                             (unsigned char *)0);
#line 864
  y ++;
#line 865
  exit(0);
  label1: 
#line 868
  x ++;
#line 869
  exit(1);
#line 872
  return (0);
}
}
