/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef unsigned int size_t;
typedef int __int32_t;
typedef long long __quad_t;
typedef unsigned long long __u_quad_t;
typedef __u_quad_t __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef __u_quad_t __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long __off_t;
typedef __quad_t __off64_t;
typedef int __pid_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef __quad_t __blkcnt64_t;
typedef int __ssize_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
typedef int int32_t;
typedef long long int64_t;
struct __anonstruct___sigset_t_8 {
   unsigned long __val[1024U / (8U * sizeof(unsigned long ))] ;
};
typedef struct __anonstruct___sigset_t_8 __sigset_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef unsigned long pthread_t;
struct __pthread_internal_slist {
   struct __pthread_internal_slist *__next ;
};
typedef struct __pthread_internal_slist __pthread_slist_t;
union __anonunion___pthread_mutex_s____missing_field_name_12 {
   int __spins ;
   __pthread_slist_t __list ;
};
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   int __kind ;
   unsigned int __nusers ;
   union __anonunion___pthread_mutex_s____missing_field_name_12 __annonCompField1 ;
};
union __anonunion_pthread_mutex_t_11 {
   struct __pthread_mutex_s __data ;
   char __size[24] ;
   long __align ;
};
typedef union __anonunion_pthread_mutex_t_11 pthread_mutex_t;
union __anonunion_pthread_mutexattr_t_13 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_mutexattr_t_13 pthread_mutexattr_t;
typedef int pthread_once_t;
struct __anonstruct___anonunion_pthread_rwlock_t_17___data_18 {
   int __lock ;
   unsigned int __nr_readers ;
   unsigned int __readers_wakeup ;
   unsigned int __writer_wakeup ;
   unsigned int __nr_readers_queued ;
   unsigned int __nr_writers_queued ;
   unsigned char __flags ;
   unsigned char __shared ;
   unsigned char __pad1 ;
   unsigned char __pad2 ;
   int __writer ;
};
union __anonunion_pthread_rwlock_t_17 {
   struct __anonstruct___anonunion_pthread_rwlock_t_17___data_18 __data ;
   char __size[32] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlock_t_17 pthread_rwlock_t;
union __anonunion_pthread_rwlockattr_t_19 {
   char __size[8] ;
   long __align ;
};
typedef union __anonunion_pthread_rwlockattr_t_19 pthread_rwlockattr_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;
typedef long long intmax_t;
typedef unsigned long long uintmax_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
struct __anonstruct_TCXSTR_27 {
   char *ptr ;
   int size ;
   int asize ;
};
typedef struct __anonstruct_TCXSTR_27 TCXSTR;
struct __anonstruct_TCLISTDATUM_28 {
   char *ptr ;
   int size ;
};
typedef struct __anonstruct_TCLISTDATUM_28 TCLISTDATUM;
struct __anonstruct_TCLIST_29 {
   TCLISTDATUM *array ;
   int anum ;
   int start ;
   int num ;
};
typedef struct __anonstruct_TCLIST_29 TCLIST;
struct _TCMAPREC {
   int32_t ksiz ;
   int32_t vsiz ;
   struct _TCMAPREC *left ;
   struct _TCMAPREC *right ;
   struct _TCMAPREC *prev ;
   struct _TCMAPREC *next ;
};
typedef struct _TCMAPREC TCMAPREC;
struct __anonstruct_TCMAP_30 {
   TCMAPREC **buckets ;
   TCMAPREC *first ;
   TCMAPREC *last ;
   TCMAPREC *cur ;
   uint32_t bnum ;
   uint64_t rnum ;
   uint64_t msiz ;
};
typedef struct __anonstruct_TCMAP_30 TCMAP;
struct _TCTREEREC {
   int32_t ksiz ;
   int32_t vsiz ;
   struct _TCTREEREC *left ;
   struct _TCTREEREC *right ;
};
typedef struct _TCTREEREC TCTREEREC;
struct __anonstruct_TCTREE_31 {
   TCTREEREC *root ;
   TCTREEREC *cur ;
   uint64_t rnum ;
   uint64_t msiz ;
   int (*cmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
   void *cmpop ;
};
typedef struct __anonstruct_TCTREE_31 TCTREE;
struct __anonstruct_TCMDB_32 {
   void **mmtxs ;
   void *imtx ;
   TCMAP **maps ;
   int iter ;
};
typedef struct __anonstruct_TCMDB_32 TCMDB;
struct __anonstruct_TCNDB_33 {
   void *mmtx ;
   TCTREE *tree ;
};
typedef struct __anonstruct_TCNDB_33 TCNDB;
struct __anonstruct_TCMPELEM_34 {
   void *ptr ;
   void (*del)(void * ) ;
};
typedef struct __anonstruct_TCMPELEM_34 TCMPELEM;
struct __anonstruct_TCMPOOL_35 {
   void *mutex ;
   TCMPELEM *elems ;
   int anum ;
   int num ;
};
typedef struct __anonstruct_TCMPOOL_35 TCMPOOL;
struct __anonstruct_TCCHIDXNODE_38 {
   uint32_t seq ;
   uint32_t hash ;
};
typedef struct __anonstruct_TCCHIDXNODE_38 TCCHIDXNODE;
struct __anonstruct_TCCHIDX_39 {
   TCCHIDXNODE *nodes ;
   int nnum ;
};
typedef struct __anonstruct_TCCHIDX_39 TCCHIDX;
struct __anonstruct_TCTMPL_40 {
   TCLIST *elems ;
   char *begsep ;
   char *endsep ;
   TCMAP *conf ;
};
typedef struct __anonstruct_TCTMPL_40 TCTMPL;
struct __anonstruct_TCPTRLIST_41 {
   void **array ;
   int anum ;
   int start ;
   int num ;
};
typedef struct __anonstruct_TCPTRLIST_41 TCPTRLIST;
struct __anonstruct_TCBITSTRM_42 {
   uint8_t *sp ;
   uint8_t *cp ;
   int idx ;
   int size ;
};
typedef struct __anonstruct_TCBITSTRM_42 TCBITSTRM;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef __builtin_va_list __gnuc_va_list;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
typedef struct _IO_FILE _IO_FILE;
typedef __gnuc_va_list va_list;
typedef int __gwchar_t;
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct stat64 {
   __dev_t st_dev ;
   unsigned int __pad1 ;
   __ino_t __st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned int __pad2 ;
   __off64_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt64_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __ino64_t st_ino ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone * __restrict  __timezone_ptr_t;
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
typedef struct __dirstream DIR;
typedef unsigned long reg_syntax_t;
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
typedef struct re_pattern_buffer regex_t;
typedef int regoff_t;
struct __anonstruct_regmatch_t_81 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
typedef struct __anonstruct_regmatch_t_81 regmatch_t;
struct __anonstruct_glob_t_82 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * __restrict   , struct stat * __restrict   ) ;
   int (*gl_stat)(char const   * __restrict   , struct stat * __restrict   ) ;
};
typedef struct __anonstruct_glob_t_82 glob_t;
typedef unsigned char md5_byte_t;
typedef unsigned int md5_word_t;
struct md5_state_s {
   md5_word_t count[2] ;
   md5_word_t abcd[4] ;
   md5_byte_t buf[64] ;
};
typedef struct md5_state_s md5_state_t;
union __anonunion___u_98 {
   int __in ;
   int __i ;
};
union __anonunion___u_99 {
   int __in ;
   int __i ;
};
struct __anonstruct_TCBWTREC_100 {
   int fchr ;
   int tchr ;
};
typedef struct __anonstruct_TCBWTREC_100 TCBWTREC;
//JAN for locksmith
typedef char _Bool;
typedef __off_t off_t;
typedef signed char int8_t;
typedef unsigned int pthread_key_t;
typedef void *(*TCCODEC)(void const   *ptr , int size , int *sp , void *op );
struct __anonstruct_TCHDB_50 {
   void *mmtx ;
   void *rmtxs ;
   void *dmtx ;
   void *tmtx ;
   void *wmtx ;
   void *eckey ;
   char *rpath ;
   uint8_t type ;
   uint8_t flags ;
   uint64_t bnum ;
   uint8_t apow ;
   uint8_t fpow ;
   uint8_t opts ;
   char *path ;
   int fd ;
   uint32_t omode ;
   uint64_t rnum ;
   uint64_t fsiz ;
   uint64_t frec ;
   uint64_t dfcur ;
   uint64_t iter ;
   char *map ;
   uint64_t msiz ;
   uint64_t xmsiz ;
   uint64_t xfsiz ;
   uint32_t *ba32 ;
   uint64_t *ba64 ;
   uint32_t align ;
   uint32_t runit ;
   _Bool zmode ;
   int32_t fbpmax ;
   void *fbpool ;
   int32_t fbpnum ;
   int32_t fbpmis ;
   _Bool async ;
   TCXSTR *drpool ;
   TCXSTR *drpdef ;
   uint64_t drpoff ;
   TCMDB *recc ;
   uint32_t rcnum ;
   void *(*enc)(void const   *ptr , int size , int *sp , void *op ) ;
   void *encop ;
   void *(*dec)(void const   *ptr , int size , int *sp , void *op ) ;
   void *decop ;
   int ecode ;
   _Bool fatal ;
   uint64_t inode ;
   time_t mtime ;
   uint32_t dfunit ;
   uint32_t dfcnt ;
   _Bool tran ;
   int walfd ;
   uint64_t walend ;
   int dbgfd ;
   int64_t cnt_writerec ;
   int64_t cnt_reuserec ;
   int64_t cnt_moverec ;
   int64_t cnt_readrec ;
   int64_t cnt_searchfbp ;
   int64_t cnt_insertfbp ;
   int64_t cnt_splicefbp ;
   int64_t cnt_dividefbp ;
   int64_t cnt_mergefbp ;
   int64_t cnt_reducefbp ;
   int64_t cnt_appenddrp ;
   int64_t cnt_deferdrp ;
   int64_t cnt_flushdrp ;
   int64_t cnt_adjrecc ;
   int64_t cnt_defrag ;
   int64_t cnt_shiftrec ;
   int64_t cnt_trunc ;
};
typedef struct __anonstruct_TCHDB_50 TCHDB;
struct __anonstruct_TCHREC_108 {
   uint64_t off ;
   uint32_t rsiz ;
   uint8_t magic ;
   uint8_t hash ;
   uint64_t left ;
   uint64_t right ;
   uint32_t ksiz ;
   uint32_t vsiz ;
   uint16_t psiz ;
   char const   *kbuf ;
   char const   *vbuf ;
   uint64_t boff ;
   char *bbuf ;
};
typedef struct __anonstruct_TCHREC_108 TCHREC;
struct __anonstruct_HDBFB_109 {
   uint64_t off ;
   uint32_t rsiz ;
};
typedef struct __anonstruct_HDBFB_109 HDBFB;
struct __anonstruct_HDBPDPROCOP_112 {
   void *(*proc)(void const   *vbuf , int vsiz , int *sp , void *op ) ;
   void *op ;
};
typedef struct __anonstruct_HDBPDPROCOP_112 HDBPDPROCOP;
typedef int (*TCCMP)(char const   *aptr , int asiz , char const   *bptr , int bsiz ,
                     void *op );
struct __anonstruct_TCBDB_54 {
   void *mmtx ;
   void *cmtx ;
   TCHDB *hdb ;
   char *opaque ;
   _Bool open ;
   _Bool wmode ;
   uint32_t lmemb ;
   uint32_t nmemb ;
   uint8_t opts ;
   uint64_t root ;
   uint64_t first ;
   uint64_t last ;
   uint64_t lnum ;
   uint64_t nnum ;
   uint64_t rnum ;
   TCMAP *leafc ;
   TCMAP *nodec ;
   int (*cmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
   void *cmpop ;
   uint32_t lcnum ;
   uint32_t ncnum ;
   uint32_t lsmax ;
   uint32_t lschk ;
   uint64_t capnum ;
   uint64_t *hist ;
   int hnum ;
   uint64_t hleaf ;
   uint64_t lleaf ;
   _Bool tran ;
   char *rbopaque ;
   uint64_t clock ;
   int64_t cnt_saveleaf ;
   int64_t cnt_loadleaf ;
   int64_t cnt_killleaf ;
   int64_t cnt_adjleafc ;
   int64_t cnt_savenode ;
   int64_t cnt_loadnode ;
   int64_t cnt_adjnodec ;
};
typedef struct __anonstruct_TCBDB_54 TCBDB;
struct __anonstruct_BDBCUR_58 {
   TCBDB *bdb ;
   uint64_t clock ;
   uint64_t id ;
   int32_t kidx ;
   int32_t vidx ;
};
typedef struct __anonstruct_BDBCUR_58 BDBCUR;
struct __anonstruct_BDBREC_108 {
   int ksiz ;
   int vsiz ;
   TCLIST *rest ;
};
typedef struct __anonstruct_BDBREC_108 BDBREC;
struct __anonstruct_BDBLEAF_109 {
   uint64_t id ;
   TCPTRLIST *recs ;
   int size ;
   uint64_t prev ;
   uint64_t next ;
   _Bool dirty ;
   _Bool dead ;
};
typedef struct __anonstruct_BDBLEAF_109 BDBLEAF;
struct __anonstruct_BDBIDX_110 {
   uint64_t pid ;
   int ksiz ;
};
typedef struct __anonstruct_BDBIDX_110 BDBIDX;
struct __anonstruct_BDBNODE_111 {
   uint64_t id ;
   uint64_t heir ;
   TCPTRLIST *idxs ;
   _Bool dirty ;
   _Bool dead ;
};
typedef struct __anonstruct_BDBNODE_111 BDBNODE;
struct __anonstruct_BDBPDPROCOP_113 {
   void *(*proc)(void const   *vbuf , int vsiz , int *sp , void *op ) ;
   void *op ;
};
typedef struct __anonstruct_BDBPDPROCOP_113 BDBPDPROCOP;
struct __anonstruct_TCFDB_50 {
   void *mmtx ;
   void *amtx ;
   void *rmtxs ;
   void *tmtx ;
   void *wmtx ;
   void *eckey ;
   char *rpath ;
   uint8_t type ;
   uint8_t flags ;
   uint32_t width ;
   uint64_t limsiz ;
   int wsiz ;
   int rsiz ;
   uint64_t limid ;
   char *path ;
   int fd ;
   uint32_t omode ;
   uint64_t rnum ;
   uint64_t fsiz ;
   uint64_t min ;
   uint64_t max ;
   uint64_t iter ;
   char *map ;
   unsigned char *array ;
   int ecode ;
   _Bool fatal ;
   uint64_t inode ;
   time_t mtime ;
   _Bool tran ;
   int walfd ;
   uint64_t walend ;
   int dbgfd ;
   int64_t cnt_writerec ;
   int64_t cnt_readrec ;
   int64_t cnt_truncfile ;
};
typedef struct __anonstruct_TCFDB_50 TCFDB;
struct __anonstruct_FDBPDPROCOP_103 {
   void *(*proc)(void const   *vbuf , int vsiz , int *sp , void *op ) ;
   void *op ;
};
typedef struct __anonstruct_FDBPDPROCOP_103 FDBPDPROCOP;
typedef unsigned char TCBITMAP;
struct __anonstruct_TDBIDX_60 {
   char *name ;
   int type ;
   void *db ;
   void *cc ;
};
typedef struct __anonstruct_TDBIDX_60 TDBIDX;
struct __anonstruct_TCTDB_61 {
   void *mmtx ;
   TCHDB *hdb ;
   _Bool open ;
   _Bool wmode ;
   uint8_t opts ;
   int32_t lcnum ;
   int32_t ncnum ;
   int64_t iccmax ;
   double iccsync ;
   TDBIDX *idxs ;
   int inum ;
   _Bool tran ;
};
typedef struct __anonstruct_TCTDB_61 TCTDB;
struct __anonstruct_TDBCOND_66 {
   char *name ;
   int nsiz ;
   int op ;
   _Bool sign ;
   _Bool noidx ;
   char *expr ;
   int esiz ;
   void *regex ;
   void *ftsunits ;
   int ftsnum ;
   _Bool alive ;
};
typedef struct __anonstruct_TDBCOND_66 TDBCOND;
struct __anonstruct_TDBQRY_67 {
   TCTDB *tdb ;
   TDBCOND *conds ;
   int cnum ;
   char *oname ;
   int otype ;
   int max ;
   int skip ;
   TCXSTR *hint ;
   int count ;
};
typedef struct __anonstruct_TDBQRY_67 TDBQRY;
struct __anonstruct_TDBSORTKEY_121 {
   char const   *kbuf ;
   int ksiz ;
   char *vbuf ;
   int vsiz ;
};
typedef struct __anonstruct_TDBSORTKEY_121 TDBSORTKEY;
struct __anonstruct_TDBFTSUNIT_122 {
   TCLIST *tokens ;
   _Bool sign ;
};
typedef struct __anonstruct_TDBFTSUNIT_122 TDBFTSUNIT;
struct __anonstruct_TDBFTSSTROCR_123 {
   char const   *pkbuf ;
   int32_t pksiz ;
   int32_t off ;
   uint16_t seq ;
   uint16_t hash ;
};
typedef struct __anonstruct_TDBFTSSTROCR_123 TDBFTSSTROCR;
struct __anonstruct_TDBFTSNUMOCR_124 {
   int64_t pkid ;
   int32_t off ;
   uint16_t seq ;
   uint16_t hash ;
};
typedef struct __anonstruct_TDBFTSNUMOCR_124 TDBFTSNUMOCR;
struct __anonstruct_TCADB_76 {
   int omode ;
   TCMDB *mdb ;
   TCNDB *ndb ;
   TCHDB *hdb ;
   TCBDB *bdb ;
   TCFDB *fdb ;
   TCTDB *tdb ;
   int64_t capnum ;
   int64_t capsiz ;
   uint32_t capcnt ;
   BDBCUR *cur ;
   void *skel ;
};
typedef struct __anonstruct_TCADB_76 TCADB;
struct __anonstruct_ADBSKEL_78 {
   void *opq ;
   void (*del)(void * ) ;
   _Bool (*open)(void * , char const   * ) ;
   _Bool (*close)(void * ) ;
   _Bool (*put)(void * , void const   * , int  , void const   * , int  ) ;
   _Bool (*putkeep)(void * , void const   * , int  , void const   * , int  ) ;
   _Bool (*putcat)(void * , void const   * , int  , void const   * , int  ) ;
   _Bool (*out)(void * , void const   * , int  ) ;
   void *(*get)(void * , void const   * , int  , int * ) ;
   int (*vsiz)(void * , void const   * , int  ) ;
   _Bool (*iterinit)(void * ) ;
   void *(*iternext)(void * , int * ) ;
   TCLIST *(*fwmkeys)(void * , void const   * , int  , int  ) ;
   int (*addint)(void * , void const   * , int  , int  ) ;
   double (*adddouble)(void * , void const   * , int  , double  ) ;
   _Bool (*sync)(void * ) ;
   _Bool (*optimize)(void * , char const   * ) ;
   _Bool (*vanish)(void * ) ;
   _Bool (*copy)(void * , char const   * ) ;
   _Bool (*tranbegin)(void * ) ;
   _Bool (*trancommit)(void * ) ;
   _Bool (*tranabort)(void * ) ;
   char const   *(*path)(void * ) ;
   uint64_t (*rnum)(void * ) ;
   uint64_t (*size)(void * ) ;
   TCLIST *(*misc)(void * , char const   * , TCLIST const   * ) ;
   _Bool (*putproc)(void * , void const   * , int  , void const   * , int  , void *(*)(void const   *vbuf ,
                                                                                       int vsiz ,
                                                                                       int *sp ,
                                                                                       void *op ) ,
                    void * ) ;
   _Bool (*foreach)(void * , _Bool (*)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                       int vsiz , void *op ) , void * ) ;
};
typedef struct __anonstruct_ADBSKEL_78 ADBSKEL;
struct __anonstruct_ADBMAPBDB_127 {
   TCADB *adb ;
   TCBDB *bdb ;
   TCLIST *recs ;
   int64_t rsiz ;
   int64_t csiz ;
   _Bool (*proc)(void *map , char const   *kbuf , int ksiz , char const   *vbuf ,
                 int vsiz , void *op ) ;
   void *op ;
};
typedef struct __anonstruct_ADBMAPBDB_127 ADBMAPBDB;
union __anonunion___u_6 {
   float __f ;
   int __i ;
};
union __anonunion___u_7 {
   double __d ;
   int __i[2] ;
};
union __anonunion___u_8 {
   long double __l ;
   int __i[3] ;
};
typedef unsigned char Byte;
typedef unsigned int uInt;
typedef unsigned long uLong;
typedef Byte Bytef;
typedef void *voidpf;
struct internal_state;
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
typedef struct z_stream_s z_stream;
typedef z_stream *z_streamp;
struct internal_state {
   int dummy ;
};
struct __anonstruct_bz_stream_80 {
   char *next_in ;
   unsigned int avail_in ;
   unsigned int total_in_lo32 ;
   unsigned int total_in_hi32 ;
   char *next_out ;
   unsigned int avail_out ;
   unsigned int total_out_lo32 ;
   unsigned int total_out_hi32 ;
   void *state ;
   void *(*bzalloc)(void * , int  , int  ) ;
   void (*bzfree)(void * , void * ) ;
   void *opaque ;
};
typedef struct __anonstruct_bz_stream_80 bz_stream;
typedef unsigned int __socklen_t;
struct __anonstruct___anonunion_pthread_cond_t_14___data_15 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
union __anonunion_pthread_cond_t_14 {
   struct __anonstruct___anonunion_pthread_cond_t_14___data_15 __data ;
   char __size[48] ;
   long long __align ;
};
typedef union __anonunion_pthread_cond_t_14 pthread_cond_t;
union __anonunion___u_24 {
   float __f ;
   int __i ;
};
union __anonunion___u_25 {
   double __d ;
   int __i[2] ;
};
union __anonunion___u_26 {
   long double __l ;
   int __i[3] ;
};
typedef int __jmp_buf[6];
struct __anonstruct___anonstruct___pthread_unwind_buf_t_90___cancel_jmp_buf_91 {
   __jmp_buf __cancel_jmp_buf ;
   int __mask_was_saved ;
};
struct __anonstruct___pthread_unwind_buf_t_90 {
   struct __anonstruct___anonstruct___pthread_unwind_buf_t_90___cancel_jmp_buf_91 __cancel_jmp_buf[1] ;
   void *__pad[4] ;
};
typedef struct __anonstruct___pthread_unwind_buf_t_90  __attribute__((__aligned__)) __pthread_unwind_buf_t;
struct __jmp_buf_tag;
struct __anonstruct_TTSOCK_92 {
   int fd ;
   char buf[65536] ;
   char *rp ;
   char *ep ;
   _Bool end ;
   double dl ;
};
typedef struct __anonstruct_TTSOCK_92 TTSOCK;
struct _TTSERV;
struct _TTTIMER {
   pthread_t thid ;
   _Bool alive ;
   struct _TTSERV *serv ;
   double freq_timed ;
   void (*do_timed)(void * ) ;
   void *opq_timed ;
};
typedef struct _TTTIMER TTTIMER;
struct _TTREQ {
   pthread_t thid ;
   _Bool alive ;
   struct _TTSERV *serv ;
   int epfd ;
   double mtime ;
   _Bool keep ;
   int idx ;
};
typedef struct _TTREQ TTREQ;
struct _TTSERV {
   char host[1024] ;
   char addr[1024] ;
   uint16_t port ;
   TCLIST *queue ;
   pthread_mutex_t qmtx ;
   pthread_cond_t qcnd ;
   pthread_mutex_t tmtx ;
   pthread_cond_t tcnd ;
   int thnum ;
   double timeout ;
   _Bool term ;
   void (*do_log)(int  , char const   * , void * ) ;
   void *opq_log ;
   TTTIMER timers[8] ;
   int timernum ;
   void (*do_task)(TTSOCK * , void * , TTREQ * ) ;
   void *opq_task ;
   void (*do_term)(void * ) ;
   void *opq_term ;
};
typedef struct _TTSERV TTSERV;
struct __anonstruct_TCULOG_94 {
   pthread_mutex_t rmtxs[31] ;
   pthread_rwlock_t rwlck ;
   pthread_cond_t cnd ;
   pthread_mutex_t wmtx ;
   char *base ;
   uint64_t limsiz ;
   int max ;
   int fd ;
   uint64_t size ;
   void *aiocbs ;
   int aiocbi ;
   uint64_t aioend ;
};
typedef struct __anonstruct_TCULOG_94 TCULOG;
struct __anonstruct_TCULRD_95 {
   TCULOG *ulog ;
   uint64_t ts ;
   int num ;
   int fd ;
   char *rbuf ;
   int rsiz ;
};
typedef struct __anonstruct_TCULRD_95 TCULRD;
struct __anonstruct_TCREPL_96 {
   int fd ;
   TTSOCK *sock ;
   char *rbuf ;
   int rsiz ;
   uint16_t mid ;
};
typedef struct __anonstruct_TCREPL_96 TCREPL;
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
typedef void (*__sighandler_t)(int  );
typedef __socklen_t socklen_t;
enum __rusage_who {
    RUSAGE_SELF = 0,
    RUSAGE_CHILDREN = -1
} ;
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
typedef enum __rusage_who __rusage_who_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
struct __anonstruct_LOGARG_154 {
   int fd ;
};
typedef struct __anonstruct_LOGARG_154 LOGARG;
struct __anonstruct_REPLARG_155 {
   char host[1024] ;
   int port ;
   char const   *rtspath ;
   uint64_t rts ;
   int opts ;
   TCADB *adb ;
   TCULOG *ulog ;
   uint32_t sid ;
   _Bool fail ;
   _Bool recon ;
   _Bool fatal ;
   uint64_t mts ;
};
typedef struct __anonstruct_REPLARG_155 REPLARG;
struct __anonstruct_EXTPCARG_156 {
   char const   *name ;
   TCADB *adb ;
   TCULOG *ulog ;
   uint32_t sid ;
   REPLARG *sarg ;
   void *scrext ;
};
typedef struct __anonstruct_EXTPCARG_156 EXTPCARG;
struct __anonstruct_TASKARG_157 {
   uint64_t mask ;
   TCADB *adb ;
   TCULOG *ulog ;
   uint32_t sid ;
   REPLARG *sarg ;
   pthread_mutex_t rmtxs[31] ;
   void **screxts ;
};
typedef struct __anonstruct_TASKARG_157 TASKARG;
struct __anonstruct_TERMARG_158 {
   int thnum ;
   TCADB *adb ;
   REPLARG *sarg ;
   void **screxts ;
   EXTPCARG *pcargs ;
   int pcnum ;
   _Bool err ;
};
typedef struct __anonstruct_TERMARG_158 TERMARG;
union __anonunion___u_6___0 {
   float __f ;
   int __i ;
};
union __anonunion___u_7___0 {
   double __d ;
   int __i[2] ;
};
union __anonunion___u_8___0 {
   long double __l ;
   int __i[3] ;
};
struct _SCREXT {
   struct _SCREXT **screxts ;
   int thnum ;
   int thid ;
   char *path ;
   TCADB *adb ;
   TCULOG *ulog ;
   uint32_t sid ;
   TCMDB *stash ;
   TCMDB *lock ;
   void (*logger)(int  , char const   * , void * ) ;
   void *logopq ;
   _Bool term ;
};
typedef struct _SCREXT SCREXT;
typedef __sigset_t sigset_t;
union __anonunion_pthread_attr_t_10 {
   char __size[36] ;
   long __align ;
};
typedef union __anonunion_pthread_attr_t_10 pthread_attr_t;
union __anonunion_pthread_condattr_t_16 {
   char __size[4] ;
   int __align ;
};
typedef union __anonunion_pthread_condattr_t_16 pthread_condattr_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_in;
struct sockaddr_un;
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
typedef uint16_t in_port_t;
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
union epoll_data {
   void *ptr ;
   int fd ;
   uint32_t u32 ;
   uint64_t u64 ;
};
typedef union epoll_data epoll_data_t;
struct epoll_event {
   uint32_t events ;
   epoll_data_t data ;
} __attribute__((__packed__)) ;
struct sigevent;
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
typedef union sigval sigval_t;
struct __anonstruct___anonunion_sigevent__sigev_un_114__sigev_thread_115 {
   void (*_function)(sigval_t  ) ;
   void *_attribute ;
};
union __anonunion_sigevent__sigev_un_114 {
   int _pad[64U / sizeof(int ) - 3U] ;
   __pid_t _tid ;
   struct __anonstruct___anonunion_sigevent__sigev_un_114__sigev_thread_115 _sigev_thread ;
};
struct sigevent {
   sigval_t sigev_value ;
   int sigev_signo ;
   int sigev_notify ;
   union __anonunion_sigevent__sigev_un_114 _sigev_un ;
};
struct aiocb {
   int aio_fildes ;
   int aio_lio_opcode ;
   int aio_reqprio ;
   void volatile   *aio_buf ;
   size_t aio_nbytes ;
   struct sigevent aio_sigevent ;
   struct aiocb *__next_prio ;
   int __abs_prio ;
   int __policy ;
   int __error_code ;
   __ssize_t __return_value ;
   __off_t aio_offset ;
   char __pad[sizeof(__off64_t ) - sizeof(__off_t )] ;
   char __unused[32] ;
};
struct __anonstruct_TCRDB_94 {
   pthread_mutex_t mmtx ;
   pthread_key_t eckey ;
   char *host ;
   int port ;
   char *expr ;
   int fd ;
   TTSOCK *sock ;
   double timeout ;
   int opts ;
};
typedef struct __anonstruct_TCRDB_94 TCRDB;
struct __anonstruct_RDBQRY_101 {
   TCRDB *rdb ;
   TCLIST *args ;
   TCXSTR *hint ;
};
typedef struct __anonstruct_RDBQRY_101 RDBQRY;
union __anonunion___u_6___1 {
   float __f ;
   int __i ;
};
union __anonunion___u_7___1 {
   double __d ;
   int __i[2] ;
};
union __anonunion___u_8___1 {
   long double __l ;
   int __i[3] ;
};
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned int  , void * ) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#pragma merger(0,"/tmp/cil-E3zrjtQD.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
#pragma merger(0,"/tmp/cil-NTSN6V0v.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) double strtod(char const   * __restrict  __nptr ,
                                                   char ** __restrict  __endptr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long strtol(char const   * __restrict  __nptr ,
                                                 char ** __restrict  __endptr , int __base )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) long long strtoll(char const   * __restrict  __nptr ,
                                                       char ** __restrict  __endptr ,
                                                       int __base )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) double atof(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
__inline extern double atof(char const   *__nptr ) 
{ double tmp ;

  {
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int atoi(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
__inline extern int atoi(char const   *__nptr ) 
{ long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return ((int )tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long atol(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
__inline extern long atol(char const   *__nptr ) 
{ long tmp ;

  {
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) long long atoll(char const   *__nptr )  __attribute__((__pure__,
__nonnull__(1))) ;
__inline extern long long atoll(char const   *__nptr ) 
{ long long tmp ;

  {
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_major(unsigned long long __dev ) ;
__inline extern unsigned int gnu_dev_major(unsigned long long __dev ) 
{ 

  {
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
__inline extern  __attribute__((__nothrow__)) unsigned int gnu_dev_minor(unsigned long long __dev ) ;
__inline extern unsigned int gnu_dev_minor(unsigned long long __dev ) 
{ 

  {
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
__inline extern  __attribute__((__nothrow__)) unsigned long long gnu_dev_makedev(unsigned int __major ,
                                                                                 unsigned int __minor ) ;
__inline extern unsigned long long gnu_dev_makedev(unsigned int __major , unsigned int __minor ) 
{ 

  {
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
extern  __attribute__((__nothrow__)) void *malloc(size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void *realloc(void *__ptr , size_t __size )  __attribute__((__warn_unused_result__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) int atexit(void (*__func)(void) )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__, __noreturn__)) void exit(int __status ) ;
extern int system(char const   *__command ) ;
extern  __attribute__((__nothrow__)) char *realpath(char const   * __restrict  __name ,
                                                    char * __restrict  __resolved ) ;
extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                     size_t __size , int (*__compar)(void const   * , void const   * ) )  __attribute__((__nonnull__(1,2,5))) ;
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) )  __attribute__((__nonnull__(1,4))) ;
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) time_t time(time_t *__timer ) ;
extern  __attribute__((__nothrow__)) struct tm *gmtime_r(time_t const   * __restrict  __timer ,
                                                         struct tm * __restrict  __tp ) ;
extern  __attribute__((__nothrow__)) void tzset(void) ;
extern long timezone ;
extern  __attribute__((__nothrow__)) time_t timegm(struct tm *__tp ) ;
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
extern  __attribute__((__nothrow__)) double cos(double __x ) ;
extern  __attribute__((__nothrow__)) double log(double __x ) ;
extern  __attribute__((__nothrow__)) double modf(double __x , double *__iptr ) ;
extern  __attribute__((__nothrow__)) double pow(double __x , double __y ) ;
extern  __attribute__((__nothrow__)) double sqrt(double __x ) ;
extern  __attribute__((__nothrow__)) double nan(char const   *__tagb )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __fpclassify(double __value )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int __signbit(double __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __fpclassifyf(float __value )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int __signbitf(float __x )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __fpclassifyl(long double __value )  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int __signbitl(long double __x )  __attribute__((__const__)) ;
char const   *tcversion ;
void (*tcfatalfunc)(char const   *message ) ;

/* JAN
void *tcmalloc(size_t size ) ;
void *tccalloc(size_t nmemb , size_t size ) ;
void *tcrealloc(void *ptr , size_t size ) ;
*/

void *tcmemdup(void const   *ptr , size_t size ) ;
char *tcstrdup(void const   *str ) ;

#define tcfree free
/* JAN
   void tcfree(void *ptr ) ; 
*/
TCXSTR *tcxstrnew(void) ;
TCXSTR *tcxstrnew2(char const   *str ) ;
TCXSTR *tcxstrnew3(int asiz ) ;
TCXSTR *tcxstrdup(TCXSTR const   *xstr ) ;
void tcxstrdel(TCXSTR *xstr ) ;
void tcxstrcat(TCXSTR *xstr , void const   *ptr , int size ) ;
void tcxstrcat2(TCXSTR *xstr , char const   *str ) ;
void const   *tcxstrptr(TCXSTR const   *xstr ) ;
int tcxstrsize(TCXSTR const   *xstr ) ;
void tcxstrclear(TCXSTR *xstr ) ;
void tcxstrprintf(TCXSTR *xstr , char const   *format  , ...) ;
char *tcsprintf(char const   *format  , ...) ;
void *tcxstrtomalloc(TCXSTR *xstr ) ;
TCXSTR *tcxstrfrommalloc(void *ptr , int size ) ;
TCLIST *tclistnew(void) ;
TCLIST *tclistnew2(int anum ) ;
TCLIST *tclistnew3(char const   *str  , ...) ;
TCLIST *tclistdup(TCLIST const   *list ) ;
void tclistdel(TCLIST *list ) ;
int tclistnum(TCLIST const   *list ) ;
void const   *tclistval(TCLIST const   *list , int index___0 , int *sp ) ;
char const   *tclistval2(TCLIST const   *list , int index___0 ) ;
void tclistpush(TCLIST *list , void const   *ptr , int size ) ;
void tclistpush2(TCLIST *list , char const   *str ) ;
void *tclistpop(TCLIST *list , int *sp ) ;
char *tclistpop2(TCLIST *list ) ;
void tclistunshift(TCLIST *list , void const   *ptr , int size ) ;
void tclistunshift2(TCLIST *list , char const   *str ) ;
void *tclistshift(TCLIST *list , int *sp ) ;
char *tclistshift2(TCLIST *list ) ;
void tclistinsert(TCLIST *list , int index___0 , void const   *ptr , int size ) ;
void tclistinsert2(TCLIST *list , int index___0 , char const   *str ) ;
void *tclistremove(TCLIST *list , int index___0 , int *sp ) ;
char *tclistremove2(TCLIST *list , int index___0 ) ;
void tclistover(TCLIST *list , int index___0 , void const   *ptr , int size ) ;
void tclistover2(TCLIST *list , int index___0 , char const   *str ) ;
void tclistsort(TCLIST *list ) ;
int tclistlsearch(TCLIST const   *list , void const   *ptr , int size ) ;
int tclistbsearch(TCLIST const   *list , void const   *ptr , int size ) ;
void tclistclear(TCLIST *list ) ;
void *tclistdump(TCLIST const   *list , int *sp ) ;
TCLIST *tclistload(void const   *ptr , int size ) ;
void tclistpushmalloc(TCLIST *list , void *ptr , int size ) ;
void tclistsortci(TCLIST *list ) ;
void tclistsortex(TCLIST *list , int (*cmp)(TCLISTDATUM const   * , TCLISTDATUM const   * ) ) ;
void tclistinvert(TCLIST *list ) ;
void tclistprintf(TCLIST *list , char const   *format  , ...) ;
TCMAP *tcmapnew(void) ;
TCMAP *tcmapnew2(uint32_t bnum ) ;
TCMAP *tcmapnew3(char const   *str  , ...) ;
TCMAP *tcmapdup(TCMAP const   *map ) ;
void tcmapdel(TCMAP *map ) ;
void tcmapput(TCMAP *map , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) ;
void tcmapput2(TCMAP *map , char const   *kstr , char const   *vstr ) ;
_Bool tcmapputkeep(TCMAP *map , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) ;
_Bool tcmapputkeep2(TCMAP *map , char const   *kstr , char const   *vstr ) ;
void tcmapputcat(TCMAP *map , void const   *kbuf , int ksiz , void const   *vbuf ,
                 int vsiz ) ;
void tcmapputcat2(TCMAP *map , char const   *kstr , char const   *vstr ) ;
_Bool tcmapout(TCMAP *map , void const   *kbuf , int ksiz ) ;
_Bool tcmapout2(TCMAP *map , char const   *kstr ) ;
void const   *tcmapget(TCMAP const   *map , void const   *kbuf , int ksiz , int *sp ) ;
char const   *tcmapget2(TCMAP const   *map , char const   *kstr ) ;
_Bool tcmapmove(TCMAP *map , void const   *kbuf , int ksiz , _Bool head ) ;
_Bool tcmapmove2(TCMAP *map , char const   *kstr , _Bool head ) ;
void tcmapiterinit(TCMAP *map ) ;
void const   *tcmapiternext(TCMAP *map , int *sp ) ;
char const   *tcmapiternext2(TCMAP *map ) ;
uint64_t tcmaprnum(TCMAP const   *map ) ;
uint64_t tcmapmsiz(TCMAP const   *map ) ;
TCLIST *tcmapkeys(TCMAP const   *map ) ;
TCLIST *tcmapvals(TCMAP const   *map ) ;
int tcmapaddint(TCMAP *map , void const   *kbuf , int ksiz , int num ) ;
double tcmapadddouble(TCMAP *map , void const   *kbuf , int ksiz , double num ) ;
void tcmapclear(TCMAP *map ) ;
void tcmapcutfront(TCMAP *map , int num ) ;
void *tcmapdump(TCMAP const   *map , int *sp ) ;
TCMAP *tcmapload(void const   *ptr , int size ) ;
void tcmapput3(TCMAP *map , void const   *kbuf , int ksiz , char const   *vbuf , int vsiz ) ;
void tcmapput4(TCMAP *map , void const   *kbuf , int ksiz , void const   *fvbuf ,
               int fvsiz , void const   *lvbuf , int lvsiz ) ;
void tcmapputcat3(TCMAP *map , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) ;
_Bool tcmapputproc(TCMAP *map , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) ;
void const   *tcmapget3(TCMAP *map , void const   *kbuf , int ksiz , int *sp ) ;
char const   *tcmapget4(TCMAP *map , char const   *kstr , char const   *dstr ) ;
void tcmapiterinit2(TCMAP *map , void const   *kbuf , int ksiz ) ;
void tcmapiterinit3(TCMAP *map , char const   *kstr ) ;
void const   *tcmapiterval(void const   *kbuf , int *sp ) ;
char const   *tcmapiterval2(char const   *kstr ) ;
char const   **tcmapkeys2(TCMAP const   *map , int *np ) ;
char const   **tcmapvals2(TCMAP const   *map , int *np ) ;
void *tcmaploadone(void const   *ptr , int size , void const   *kbuf , int ksiz ,
                   int *sp ) ;
void tcmapprintf(TCMAP *map , char const   *kstr , char const   *format  , ...) ;
TCTREE *tctreenew(void) ;
TCTREE *tctreenew2(int (*cmp)(char const   *aptr , int asiz , char const   *bptr ,
                              int bsiz , void *op ) , void *cmpop ) ;
TCTREE *tctreedup(TCTREE const   *tree ) ;
void tctreedel(TCTREE *tree ) ;
void tctreeput(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
               int vsiz ) ;
void tctreeput2(TCTREE *tree , char const   *kstr , char const   *vstr ) ;
_Bool tctreeputkeep(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                    int vsiz ) ;
_Bool tctreeputkeep2(TCTREE *tree , char const   *kstr , char const   *vstr ) ;
void tctreeputcat(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) ;
void tctreeputcat2(TCTREE *tree , char const   *kstr , char const   *vstr ) ;
_Bool tctreeputproc(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                    int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                 void *op ) , void *op ) ;
_Bool tctreeout(TCTREE *tree , void const   *kbuf , int ksiz ) ;
_Bool tctreeout2(TCTREE *tree , char const   *kstr ) ;
void const   *tctreeget(TCTREE *tree , void const   *kbuf , int ksiz , int *sp ) ;
char const   *tctreeget2(TCTREE *tree , char const   *kstr ) ;
void tctreeiterinit(TCTREE *tree ) ;
void const   *tctreeiternext(TCTREE *tree , int *sp ) ;
char const   *tctreeiternext2(TCTREE *tree ) ;
uint64_t tctreernum(TCTREE const   *tree ) ;
uint64_t tctreemsiz(TCTREE const   *tree ) ;
TCLIST *tctreekeys(TCTREE const   *tree ) ;
TCLIST *tctreevals(TCTREE const   *tree ) ;
int tctreeaddint(TCTREE *tree , void const   *kbuf , int ksiz , int num ) ;
double tctreeadddouble(TCTREE *tree , void const   *kbuf , int ksiz , double num ) ;
void tctreeclear(TCTREE *tree ) ;
void tctreecutfringe(TCTREE *tree , int num ) ;
void *tctreedump(TCTREE const   *tree , int *sp ) ;
TCTREE *tctreeload(void const   *ptr , int size , int (*cmp)(char const   *aptr ,
                                                             int asiz , char const   *bptr ,
                                                             int bsiz , void *op ) ,
                   void *cmpop ) ;
void tctreeput3(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                int vsiz ) ;
_Bool tctreeputkeep3(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                     int vsiz ) ;
void tctreeputcat3(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) ;
void const   *tctreeget3(TCTREE const   *tree , void const   *kbuf , int ksiz , int *sp ) ;
char const   *tctreeget4(TCTREE *tree , char const   *kstr , char const   *dstr ) ;
void tctreeiterinit2(TCTREE *tree , void const   *kbuf , int ksiz ) ;
void tctreeiterinit3(TCTREE *tree , char const   *kstr ) ;
void const   *tctreeiterval(void const   *kbuf , int *sp ) ;
char const   *tctreeiterval2(char const   *kstr ) ;
char const   **tctreekeys2(TCTREE const   *tree , int *np ) ;
char const   **tctreevals2(TCTREE const   *tree , int *np ) ;
void *tctreeloadone(void const   *ptr , int size , void const   *kbuf , int ksiz ,
                    int *sp ) ;
void tctreeprintf(TCTREE *tree , char const   *kstr , char const   *format  , ...) ;
TCMDB *tcmdbnew(void) ;
TCMDB *tcmdbnew2(uint32_t bnum ) ;
void tcmdbdel(TCMDB *mdb ) ;
void tcmdbput(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) ;
void tcmdbput2(TCMDB *mdb , char const   *kstr , char const   *vstr ) ;
_Bool tcmdbputkeep(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) ;
_Bool tcmdbputkeep2(TCMDB *mdb , char const   *kstr , char const   *vstr ) ;
void tcmdbputcat(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                 int vsiz ) ;
void tcmdbputcat2(TCMDB *mdb , char const   *kstr , char const   *vstr ) ;
_Bool tcmdbout(TCMDB *mdb , void const   *kbuf , int ksiz ) ;
_Bool tcmdbout2(TCMDB *mdb , char const   *kstr ) ;
void *tcmdbget(TCMDB *mdb , void const   *kbuf , int ksiz , int *sp ) ;
char *tcmdbget2(TCMDB *mdb , char const   *kstr ) ;
int tcmdbvsiz(TCMDB *mdb , void const   *kbuf , int ksiz ) ;
int tcmdbvsiz2(TCMDB *mdb , char const   *kstr ) ;
void tcmdbiterinit(TCMDB *mdb ) ;
void *tcmdbiternext(TCMDB *mdb , int *sp ) ;
char *tcmdbiternext2(TCMDB *mdb ) ;
TCLIST *tcmdbfwmkeys(TCMDB *mdb , void const   *pbuf , int psiz , int max ) ;
TCLIST *tcmdbfwmkeys2(TCMDB *mdb , char const   *pstr , int max ) ;
uint64_t tcmdbrnum(TCMDB *mdb ) ;
uint64_t tcmdbmsiz(TCMDB *mdb ) ;
int tcmdbaddint(TCMDB *mdb , void const   *kbuf , int ksiz , int num ) ;
double tcmdbadddouble(TCMDB *mdb , void const   *kbuf , int ksiz , double num ) ;
void tcmdbvanish(TCMDB *mdb ) ;
void tcmdbcutfront(TCMDB *mdb , int num ) ;
void tcmdbput3(TCMDB *mdb , void const   *kbuf , int ksiz , char const   *vbuf , int vsiz ) ;
void tcmdbput4(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *fvbuf ,
               int fvsiz , void const   *lvbuf , int lvsiz ) ;
void tcmdbputcat3(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) ;
_Bool tcmdbputproc(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) ;
void *tcmdbget3(TCMDB *mdb , void const   *kbuf , int ksiz , int *sp ) ;
void tcmdbiterinit2(TCMDB *mdb , void const   *kbuf , int ksiz ) ;
void tcmdbiterinit3(TCMDB *mdb , char const   *kstr ) ;
void tcmdbforeach(TCMDB *mdb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                             int vsiz , void *op ) , void *op ) ;
TCNDB *tcndbnew(void) ;
TCNDB *tcndbnew2(int (*cmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz ,
                            void *op ) , void *cmpop ) ;
void tcndbdel(TCNDB *ndb ) ;
void tcndbput(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) ;
void tcndbput2(TCNDB *ndb , char const   *kstr , char const   *vstr ) ;
_Bool tcndbputkeep(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) ;
_Bool tcndbputkeep2(TCNDB *ndb , char const   *kstr , char const   *vstr ) ;
void tcndbputcat(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf ,
                 int vsiz ) ;
void tcndbputcat2(TCNDB *ndb , char const   *kstr , char const   *vstr ) ;
_Bool tcndbout(TCNDB *ndb , void const   *kbuf , int ksiz ) ;
_Bool tcndbout2(TCNDB *ndb , char const   *kstr ) ;
void *tcndbget(TCNDB *ndb , void const   *kbuf , int ksiz , int *sp ) ;
char *tcndbget2(TCNDB *ndb , char const   *kstr ) ;
int tcndbvsiz(TCNDB *ndb , void const   *kbuf , int ksiz ) ;
int tcndbvsiz2(TCNDB *ndb , char const   *kstr ) ;
void tcndbiterinit(TCNDB *ndb ) ;
void *tcndbiternext(TCNDB *ndb , int *sp ) ;
char *tcndbiternext2(TCNDB *ndb ) ;
TCLIST *tcndbfwmkeys(TCNDB *ndb , void const   *pbuf , int psiz , int max ) ;
TCLIST *tcndbfwmkeys2(TCNDB *ndb , char const   *pstr , int max ) ;
uint64_t tcndbrnum(TCNDB *ndb ) ;
uint64_t tcndbmsiz(TCNDB *ndb ) ;
int tcndbaddint(TCNDB *ndb , void const   *kbuf , int ksiz , int num ) ;
double tcndbadddouble(TCNDB *ndb , void const   *kbuf , int ksiz , double num ) ;
void tcndbvanish(TCNDB *ndb ) ;
void tcndbcutfringe(TCNDB *ndb , int num ) ;
void tcndbput3(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) ;
_Bool tcndbputkeep3(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf ,
                    int vsiz ) ;
void tcndbputcat3(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) ;
_Bool tcndbputproc(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) ;
void *tcndbget3(TCNDB *ndb , void const   *kbuf , int ksiz , int *sp ) ;
void tcndbiterinit2(TCNDB *ndb , void const   *kbuf , int ksiz ) ;
void tcndbiterinit3(TCNDB *ndb , char const   *kstr ) ;
void tcndbforeach(TCNDB *ndb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                             int vsiz , void *op ) , void *op ) ;
TCMPOOL *tcmpoolnew(void) ;
void tcmpooldel(TCMPOOL *mpool ) ;
void *tcmpoolpush(TCMPOOL *mpool , void *ptr , void (*del)(void * ) ) ;
void *tcmpoolpushptr(TCMPOOL *mpool , void *ptr ) ;
TCXSTR *tcmpoolpushxstr(TCMPOOL *mpool , TCXSTR *xstr ) ;
TCLIST *tcmpoolpushlist(TCMPOOL *mpool , TCLIST *list ) ;
TCMAP *tcmpoolpushmap(TCMPOOL *mpool , TCMAP *map ) ;
TCTREE *tcmpoolpushtree(TCMPOOL *mpool , TCTREE *tree ) ;
void *tcmpoolmalloc(TCMPOOL *mpool , size_t size ) ;
TCXSTR *tcmpoolxstrnew(TCMPOOL *mpool ) ;
TCLIST *tcmpoollistnew(TCMPOOL *mpool ) ;
TCMAP *tcmpoolmapnew(TCMPOOL *mpool ) ;
TCTREE *tcmpooltreenew(TCMPOOL *mpool ) ;
void tcmpoolpop(TCMPOOL *mpool , _Bool exe ) ;
TCMPOOL *tcmpoolglobal(void) ;
long tclmax(long a , long b ) ;
long tclmin(long a , long b ) ;
unsigned long tclrand(void) ;
double tcdrand(void) ;
double tcdrandnd(double avg , double sd ) ;
int tcstricmp(char const   *astr , char const   *bstr ) ;
_Bool tcstrfwm(char const   *str , char const   *key ) ;
_Bool tcstrifwm(char const   *str , char const   *key ) ;
_Bool tcstrbwm(char const   *str , char const   *key ) ;
_Bool tcstribwm(char const   *str , char const   *key ) ;
int tcstrdist(char const   *astr , char const   *bstr ) ;
int tcstrdistutf(char const   *astr , char const   *bstr ) ;
char *tcstrtoupper(char *str ) ;
char *tcstrtolower(char *str ) ;
char *tcstrtrim(char *str ) ;
char *tcstrsqzspc(char *str ) ;
char *tcstrsubchr(char *str , char const   *rstr , char const   *sstr ) ;
int tcstrcntutf(char const   *str ) ;
char *tcstrcututf(char *str , int num ) ;
void tcstrutftoucs(char const   *str , uint16_t *ary , int *np ) ;
int tcstrucstoutf(uint16_t const   *ary , int num , char *str ) ;
TCLIST *tcstrsplit(char const   *str , char const   *delims ) ;
char *tcstrjoin(TCLIST const   *list , char delim ) ;
int64_t tcatoi(char const   *str ) ;
int64_t tcatoix(char const   *str ) ;
double tcatof(char const   *str ) ;
_Bool tcregexmatch(char const   *str , char const   *regex ) ;
char *tcregexreplace(char const   *str , char const   *regex , char const   *alt ) ;
void tcmd5hash(void const   *ptr , int size , char *buf ) ;
void tcarccipher(void const   *ptr , int size , void const   *kbuf , int ksiz , void *obuf ) ;
double tctime(void) ;
void tccalendar(int64_t t , int jl , int *yearp , int *monp , int *dayp , int *hourp ,
                int *minp , int *secp ) ;
void tcdatestrwww(int64_t t , int jl , char *buf ) ;
void tcdatestrhttp(int64_t t , int jl , char *buf ) ;
int64_t tcstrmktime(char const   *str ) ;
int tcjetlag(void) ;
int tcdayofweek(int year , int mon , int day ) ;
_Bool tcstrisnum(char const   *str ) ;
int64_t tcatoih(char const   *str ) ;
char const   *tcstrskipspc(char const   *str ) ;
char *tcstrutfnorm(char *str , int opts ) ;
int tcstrucsnorm(uint16_t *ary , int num , int opts ) ;
TCLIST *tcstrkwic(char const   *str , TCLIST const   *words , int width , int opts ) ;
TCLIST *tcstrtokenize(char const   *str ) ;
TCLIST *tcstrsplit2(void const   *ptr , int size ) ;
TCMAP *tcstrsplit3(char const   *str , char const   *delims ) ;
TCMAP *tcstrsplit4(void const   *ptr , int size ) ;
void *tcstrjoin2(TCLIST const   *list , int *sp ) ;
char *tcstrjoin3(TCMAP const   *map , char delim ) ;
void *tcstrjoin4(TCMAP const   *map , int *sp ) ;
void tctopsort(void *base , size_t nmemb , size_t size , size_t top , int (*compar)(void const   * ,
                                                                                    void const   * ) ) ;
_Bool tcsleep(double sec ) ;
TCMAP *tcsysinfo(void) ;
TCCHIDX *tcchidxnew(int range ) ;
void tcchidxdel(TCCHIDX *chidx ) ;
int tcchidxhash(TCCHIDX *chidx , void const   *ptr , int size ) ;
char *tcrealpath(char const   *path ) ;
_Bool tcstatfile(char const   *path , _Bool *isdirp , int64_t *sizep , int64_t *mtimep ) ;
void *tcreadfile(char const   *path , int limit , int *sp ) ;
TCLIST *tcreadfilelines(char const   *path ) ;
_Bool tcwritefile(char const   *path , void const   *ptr , int size ) ;
_Bool tccopyfile(char const   *src , char const   *dest ) ;
TCLIST *tcreaddir(char const   *path ) ;
TCLIST *tcglobpat(char const   *pattern ) ;
_Bool tcremovelink(char const   *path ) ;
_Bool tcwrite(int fd , void const   *buf , size_t size ) ;
_Bool tcread(int fd , void *buf , size_t size ) ;
_Bool tclock(int fd , _Bool ex , _Bool nb ) ;
_Bool tcunlock(int fd ) ;
int tcsystem(char const   **args , int anum ) ;
char *tcurlencode(char const   *ptr , int size ) ;
char *tcurldecode(char const   *str , int *sp ) ;
TCMAP *tcurlbreak(char const   *str ) ;
char *tcurlresolve(char const   *base , char const   *target ) ;
char *tcbaseencode(char const   *ptr , int size ) ;
char *tcbasedecode(char const   *str , int *sp ) ;
char *tcquoteencode(char const   *ptr , int size ) ;
char *tcquotedecode(char const   *str , int *sp ) ;
char *tcmimeencode(char const   *str , char const   *encname , _Bool base ) ;
char *tcmimedecode(char const   *str , char *enp ) ;
char *tcmimebreak(char const   *ptr , int size , TCMAP *headers , int *sp ) ;
TCLIST *tcmimeparts(char const   *ptr , int size , char const   *boundary ) ;
char *tchexencode(char const   *ptr , int size ) ;
char *tchexdecode(char const   *str , int *sp ) ;
char *tcpackencode(char const   *ptr , int size , int *sp ) ;
char *tcpackdecode(char const   *ptr , int size , int *sp ) ;
char *tcbsencode(char const   *ptr , int size , int *sp ) ;
char *tcbsdecode(char const   *ptr , int size , int *sp ) ;
char *tcdeflate(char const   *ptr , int size , int *sp ) ;
char *tcinflate(char const   *ptr , int size , int *sp ) ;
char *tcgzipencode(char const   *ptr , int size , int *sp ) ;
char *tcgzipdecode(char const   *ptr , int size , int *sp ) ;
unsigned int tcgetcrc(char const   *ptr , int size ) ;
char *tcbzipencode(char const   *ptr , int size , int *sp ) ;
char *tcbzipdecode(char const   *ptr , int size , int *sp ) ;
char *tcberencode(unsigned int const   *ary , int anum , int *sp ) ;
unsigned int *tcberdecode(char const   *ptr , int size , int *np ) ;
char *tcxmlescape(char const   *str ) ;
char *tcxmlunescape(char const   *str ) ;
char *tcwwwformencode(TCMAP const   *params ) ;
void tcwwwformdecode(char const   *str , TCMAP *params ) ;
void tcwwwformdecode2(void const   *ptr , int size , char const   *type , TCMAP *params ) ;
TCLIST *tcxmlbreak(char const   *str ) ;
TCMAP *tcxmlattrs(char const   *str ) ;
char *tccstrescape(char const   *str ) ;
char *tccstrunescape(char const   *str ) ;
char *tcjsonescape(char const   *str ) ;
char *tcjsonunescape(char const   *str ) ;
TCTMPL *tctmplnew(void) ;
void tctmpldel(TCTMPL *tmpl ) ;
void tctmplsetsep(TCTMPL *tmpl , char const   *begsep , char const   *endsep ) ;
void tctmplload(TCTMPL *tmpl , char const   *str ) ;
_Bool tctmplload2(TCTMPL *tmpl , char const   *path ) ;
char *tctmpldump(TCTMPL *tmpl , TCMAP const   *vars ) ;
char const   *tctmplconf(TCTMPL *tmpl , char const   *name ) ;
void tclistpushlist(TCLIST *list , TCLIST const   *obj ) ;
void tclistpushmap(TCLIST *list , TCMAP const   *obj ) ;
void tcmapputlist(TCMAP *map , char const   *kstr , TCLIST const   *obj ) ;
void tcmapputmap(TCMAP *map , char const   *kstr , TCMAP const   *obj ) ;
TCPTRLIST *tcptrlistnew(void) ;
TCPTRLIST *tcptrlistnew2(int anum ) ;
TCPTRLIST *tcptrlistdup(TCPTRLIST const   *ptrlist ) ;
void tcptrlistdel(TCPTRLIST *ptrlist ) ;
int tcptrlistnum(TCPTRLIST const   *ptrlist ) ;
void *tcptrlistval(TCPTRLIST const   *ptrlist , int index___0 ) ;
void tcptrlistpush(TCPTRLIST *ptrlist , void *ptr ) ;
void *tcptrlistpop(TCPTRLIST *ptrlist ) ;
void tcptrlistunshift(TCPTRLIST *ptrlist , void *ptr ) ;
void *tcptrlistshift(TCPTRLIST *ptrlist ) ;
void tcptrlistinsert(TCPTRLIST *ptrlist , int index___0 , void *ptr ) ;
void *tcptrlistremove(TCPTRLIST *ptrlist , int index___0 ) ;
void tcptrlistover(TCPTRLIST *ptrlist , int index___0 , void *ptr ) ;
void tcptrlistclear(TCPTRLIST *ptrlist ) ;
extern int __uflow(_IO_FILE * ) ;
extern int __overflow(_IO_FILE * , int  ) ;
extern int _IO_getc(_IO_FILE *__fp ) ;
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern struct _IO_FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
__inline extern int getchar(void) ;
__inline extern int getchar_unlocked(void) ;
__inline extern int fgetc_unlocked(FILE *__fp ) ;
__inline extern int putchar(int __c ) ;
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
__inline extern int putchar_unlocked(int __c ) ;
extern __ssize_t __getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                            int __delimiter , FILE * __restrict  __stream ) ;
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream ) ;
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream ) ;
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
__inline extern int vprintf(char const   * __restrict  __fmt , __gnuc_va_list __arg ) 
{ int tmp ;

  {
  tmp = vfprintf((FILE * __restrict  )stdout, __fmt, __arg);
  return (tmp);
}
}
__inline extern int getchar(void) 
{ int tmp ;

  {
  tmp = _IO_getc(stdin);
  return (tmp);
}
}
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned int )__fp->_IO_read_ptr >= (unsigned int )__fp->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(__fp);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = __fp->_IO_read_ptr;
    (__fp->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int getchar_unlocked(void) 
{ int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
  tmp___3 = __builtin_expect((long )((unsigned int )stdin->_IO_read_ptr >= (unsigned int )stdin->_IO_read_end),
                             0L);
  if (tmp___3) {
    tmp___0 = __uflow(stdin);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = stdin->_IO_read_ptr;
    (stdin->_IO_read_ptr) ++;
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
  return (tmp___2);
}
}
__inline extern int putchar(int __c ) 
{ int tmp ;

  {
  tmp = _IO_putc(__c, stdout);
  return (tmp);
}
}
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned int )__stream->_IO_write_ptr >= (unsigned int )__stream->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = __stream->_IO_write_ptr;
    (__stream->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern int putchar_unlocked(int __c ) 
{ int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
  tmp___4 = __builtin_expect((long )((unsigned int )stdout->_IO_write_ptr >= (unsigned int )stdout->_IO_write_end),
                             0L);
  if (tmp___4) {
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
    tmp___3 = tmp___0;
  } else {
    tmp___1 = stdout->_IO_write_ptr;
    (stdout->_IO_write_ptr) ++;
    tmp___2 = (char )__c;
    *tmp___1 = tmp___2;
    tmp___3 = (int )((unsigned char )tmp___2);
  }
  return (tmp___3);
}
}
__inline extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                                  FILE * __restrict  __stream ) 
{ __ssize_t tmp ;

  {
  tmp = __getdelim(__lineptr, __n, '\n', __stream);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int feof_unlocked(FILE *__stream ) ;
__inline extern int feof_unlocked(FILE *__stream ) 
{ 

  {
  return ((__stream->_flags & 16) != 0);
}
}
__inline extern  __attribute__((__nothrow__)) int ferror_unlocked(FILE *__stream ) ;
__inline extern int ferror_unlocked(FILE *__stream ) 
{ 

  {
  return ((__stream->_flags & 32) != 0);
}
}
char const   *tcerrmsg(int ecode ) ;
void *tcmyfatal(char const   *message ) ;
void *tczeromap(uint64_t size ) ;
void tczerounmap(void *ptr ) ;
_Bool tcglobalmutexlock(void) ;
_Bool tcglobalmutexlockshared(void) ;
_Bool tcglobalmutexunlock(void) ;
_Bool tcpathlock(char const   *path ) ;
_Bool tcpathunlock(char const   *path ) ;
int tcnumtostrbin(uint64_t num , char *buf , int col , int fc ) ;
int tccmplexical(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
int tccmpdecimal(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
int tccmpint32(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
int tccmpint64(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
char *tcbwtencode(char const   *ptr , int size , int *idxp ) ;
char *tcbwtdecode(char const   *ptr , int size , int idx ) ;
long tclog2l(long num ) ;
double tclog2d(double num ) ;
uint64_t tcpagealign(uint64_t off ) ;
extern __int32_t const   **__ctype_tolower_loc(void)  __attribute__((__const__)) ;
extern __int32_t const   **__ctype_toupper_loc(void)  __attribute__((__const__)) ;
__inline extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
__inline extern  __attribute__((__nothrow__)) int tolower(int __c ) ;
__inline extern int tolower(int __c ) 
{ __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_tolower_loc();
      tmp___0 = (int )*(*tmp + __c);
    } else {
      tmp___0 = (int )((int const   )__c);
    }
  } else {
    tmp___0 = (int )((int const   )__c);
  }
  return (tmp___0);
}
}
__inline extern  __attribute__((__nothrow__)) int toupper(int __c ) ;
__inline extern int toupper(int __c ) 
{ __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
  if (__c >= -128) {
    if (__c < 256) {
      tmp = __ctype_toupper_loc();
      tmp___0 = (int )*(*tmp + __c);
    } else {
      tmp___0 = (int )((int const   )__c);
    }
  } else {
    tmp___0 = (int )((int const   )__c);
  }
  return (tmp___0);
}
}
extern  __attribute__((__nothrow__)) int *__errno_location(void)  __attribute__((__const__)) ;
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) ;
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) ;
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) ;
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;
  int tmp ;

  {
  __mask = 1UL << (unsigned int )(__sig - 1) % (8U * sizeof(unsigned long ));
  __word = (unsigned long )((unsigned int )(__sig - 1) / (8U * sizeof(unsigned long )));
  if (__set->__val[__word] & __mask) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;

  {
  __mask = 1UL << (unsigned int )(__sig - 1) % (8U * sizeof(unsigned long ));
  __word = (unsigned long )((unsigned int )(__sig - 1) / (8U * sizeof(unsigned long )));
  __set->__val[__word] |= __mask;
  return (0);
}
}
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) 
{ unsigned long __mask ;
  unsigned long __word ;

  {
  __mask = 1UL << (unsigned int )(__sig - 1) % (8U * sizeof(unsigned long ));
  __word = (unsigned long )((unsigned int )(__sig - 1) / (8U * sizeof(unsigned long )));
  __set->__val[__word] &= ~ __mask;
  return (0);
}
}
extern  __attribute__((__nothrow__)) void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                                                  size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) void *memmove(void *__dest , void const   *__src ,
                                                   size_t __n )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t __n )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int memcmp(void const   *__s1 , void const   *__s2 ,
                                                size_t __n )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) char *strrchr(char const   *__s , int __c )  __attribute__((__pure__,
__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *strstr(char const   *__haystack , char const   *__needle )  __attribute__((__pure__,
__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) size_t strlen(char const   *__s )  __attribute__((__pure__,
__nonnull__(1))) ;
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ register size_t __result ;

  {
  __result = 0U;
  while (1) {
    if ((int const   )*(__s + __result) != 0) {
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
        break;
      }
    } else {
      break;
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ register size_t __result ;

  {
  __result = 0U;
  while (1) {
    if ((int const   )*(__s + __result) != 0) {
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ register size_t __result ;

  {
  __result = 0U;
  while (1) {
    if ((int const   )*(__s + __result) != 0) {
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ register size_t __result ;

  {
  __result = 0U;
  while ((int const   )*(__s + __result) == (int const   )__accept) {
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ register size_t __result ;

  {
  __result = 0U;
  while (1) {
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
        break;
      }
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ register size_t __result ;

  {
  __result = 0U;
  while (1) {
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
          break;
        }
      }
    }
    __result ++;
  }
  return (__result);
}
}
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ char *tmp ;

  {
  while (1) {
    if ((int const   )*__s != 0) {
      if ((int const   )*__s != (int const   )__accept1) {
        if (! ((int const   )*__s != (int const   )__accept2)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __s ++;
  }
  if ((int const   )*__s == 0) {
    tmp = (char *)((void *)0);
  } else {
    tmp = (char *)((unsigned int )__s);
  }
  return (tmp);
}
}
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ char *tmp ;

  {
  while (1) {
    if ((int const   )*__s != 0) {
      if ((int const   )*__s != (int const   )__accept1) {
        if ((int const   )*__s != (int const   )__accept2) {
          if (! ((int const   )*__s != (int const   )__accept3)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    __s ++;
  }
  if ((int const   )*__s == 0) {
    tmp = (char *)((void *)0);
  } else {
    tmp = (char *)((unsigned int )__s);
  }
  return (tmp);
}
}
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
  if ((unsigned int )__s == (unsigned int )((void *)0)) {
    __s = *__nextp;
  }
  while ((int )*__s == (int )__sep) {
    __s ++;
  }
  __result = (char *)((void *)0);
  if ((int )*__s != 0) {
    tmp = __s;
    __s ++;
    __result = tmp;
    while ((int )*__s != 0) {
      tmp___0 = __s;
      __s ++;
      if ((int )*tmp___0 == (int )__sep) {
        *(__s + -1) = (char )'\000';
        break;
      }
    }
    *__nextp = __s;
  }
  return (__result);
}
}
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
  __retval = *__s;
  if ((unsigned int )__retval != (unsigned int )((void *)0)) {
    tmp___2 = __builtin_strchr(__retval, (int )__reject);
    tmp___0 = tmp___2;
    *__s = tmp___0;
    if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
      tmp = *__s;
      (*__s) ++;
      *tmp = (char )'\000';
    }
  }
  return (__retval);
}
}
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
  __retval = *__s;
  if ((unsigned int )__retval != (unsigned int )((void *)0)) {
    __cp = __retval;
    while (1) {
      if ((int )*__cp == 0) {
        __cp = (char *)((void *)0);
        break;
      }
      if ((int )*__cp == (int )__reject1) {
        tmp = __cp;
        __cp ++;
        *tmp = (char )'\000';
        break;
      } else {
        if ((int )*__cp == (int )__reject2) {
          tmp = __cp;
          __cp ++;
          *tmp = (char )'\000';
          break;
        }
      }
      __cp ++;
    }
    *__s = __cp;
  }
  return (__retval);
}
}
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
  __retval = *__s;
  if ((unsigned int )__retval != (unsigned int )((void *)0)) {
    __cp = __retval;
    while (1) {
      if ((int )*__cp == 0) {
        __cp = (char *)((void *)0);
        break;
      }
      if ((int )*__cp == (int )__reject1) {
        tmp = __cp;
        __cp ++;
        *tmp = (char )'\000';
        break;
      } else {
        if ((int )*__cp == (int )__reject2) {
          tmp = __cp;
          __cp ++;
          *tmp = (char )'\000';
          break;
        } else {
          if ((int )*__cp == (int )__reject3) {
            tmp = __cp;
            __cp ++;
            *tmp = (char )'\000';
            break;
          }
        }
      }
      __cp ++;
    }
    *__s = __cp;
  }
  return (__retval);
}
}
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   * __restrict  nptr ,
                                                                 char ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   * __restrict  nptr ,
                                                                  char ** __restrict  endptr ,
                                                                  int base ) ;
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr ,
                                                                 __gwchar_t ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr ,
                                                                  __gwchar_t ** __restrict  endptr ,
                                                                  int base ) ;
extern  __attribute__((__nothrow__)) long long __strtoll_internal(char const   * __restrict  __nptr ,
                                                                  char ** __restrict  __endptr ,
                                                                  int __base , int __group )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) intmax_t strtoimax(char const   * __restrict  nptr ,
                                                                 char ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern intmax_t strtoimax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                   int base ) 
{ long long tmp ;

  {
  tmp = __strtoll_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long long __strtoull_internal(char const   * __restrict  __nptr ,
                                                                            char ** __restrict  __endptr ,
                                                                            int __base ,
                                                                            int __group )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t strtoumax(char const   * __restrict  nptr ,
                                                                  char ** __restrict  endptr ,
                                                                  int base ) ;
__inline extern uintmax_t strtoumax(char const   * __restrict  nptr , char ** __restrict  endptr ,
                                    int base ) 
{ unsigned long long tmp ;

  {
  tmp = __strtoull_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) long long __wcstoll_internal(__gwchar_t const   * __restrict  __nptr ,
                                                                  __gwchar_t ** __restrict  __endptr ,
                                                                  int __base , int __group )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr ,
                                                                 __gwchar_t ** __restrict  endptr ,
                                                                 int base ) ;
__inline extern intmax_t wcstoimax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                   int base ) 
{ long long tmp ;

  {
  tmp = __wcstoll_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) unsigned long long __wcstoull_internal(__gwchar_t const   * __restrict  __nptr ,
                                                                            __gwchar_t ** __restrict  __endptr ,
                                                                            int __base ,
                                                                            int __group )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr ,
                                                                  __gwchar_t ** __restrict  endptr ,
                                                                  int base ) ;
__inline extern uintmax_t wcstoumax(__gwchar_t const   * __restrict  nptr , __gwchar_t ** __restrict  endptr ,
                                    int base ) 
{ unsigned long long tmp ;

  {
  tmp = __wcstoull_internal(nptr, endptr, base, 0);
  return (tmp);
}
}
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
extern  __attribute__((__nothrow__)) long sysconf(int __name ) ;
extern  __attribute__((__nothrow__)) __pid_t getpid(void) ;
extern  __attribute__((__nothrow__)) int unlink(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int rmdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline extern  __attribute__((__nothrow__)) int stat64(char const   * __restrict  __path ,
                                                         struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   * __restrict  __filename ,
                                                          struct stat * __restrict  __statbuf ,
                                                          int __flag )  __attribute__((__nonnull__(2,3))) ;
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   * __restrict  __filename ,
                                                            struct stat64 * __restrict  __statbuf ,
                                                            int __flag )  __attribute__((__nonnull__(2,3))) ;
__inline extern  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   * __restrict  __path ,
                                                          struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) int __fxstat(int __ver , int __fildes , struct stat *__stat_buf )  __attribute__((__nonnull__(3))) ;
extern  __attribute__((__nothrow__)) int __xstat(int __ver , char const   *__filename ,
                                                 struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) int __lxstat(int __ver , char const   *__filename ,
                                                  struct stat *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) int __fxstatat(int __ver , int __fildes , char const   *__filename ,
                                                    struct stat *__stat_buf , int __flag )  __attribute__((__nonnull__(3,4))) ;
extern  __attribute__((__nothrow__)) int __fxstat64(int __ver , int __fildes , struct stat64 *__stat_buf )  __attribute__((__nonnull__(3))) ;
extern  __attribute__((__nothrow__)) int __xstat64(int __ver , char const   *__filename ,
                                                   struct stat64 *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) int __lxstat64(int __ver , char const   *__filename ,
                                                    struct stat64 *__stat_buf )  __attribute__((__nonnull__(2,3))) ;
extern  __attribute__((__nothrow__)) int __fxstatat64(int __ver , int __fildes , char const   *__filename ,
                                                      struct stat64 *__stat_buf ,
                                                      int __flag )  __attribute__((__nonnull__(3,4))) ;
extern  __attribute__((__nothrow__)) int __xmknod(int __ver , char const   *__path ,
                                                  __mode_t __mode , __dev_t *__dev )  __attribute__((__nonnull__(2,4))) ;
extern  __attribute__((__nothrow__)) int __xmknodat(int __ver , int __fd , char const   *__path ,
                                                    __mode_t __mode , __dev_t *__dev )  __attribute__((__nonnull__(3,5))) ;
__inline extern  __attribute__((__nothrow__)) int stat(char const   * __restrict  __path ,
                                                       struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern int stat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
  tmp = __xstat(3, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int lstat(char const   * __restrict  __path ,
                                                        struct stat * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern int lstat(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) 
{ int tmp ;

  {
  tmp = __lxstat(3, (char const   *)__path, (struct stat *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int fstat(int __fd , struct stat *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline extern int fstat(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat(3, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int fstatat(int __fd , char const   * __restrict  __filename ,
                                                          struct stat * __restrict  __statbuf ,
                                                          int __flag )  __attribute__((__nonnull__(2,3))) ;
__inline extern int fstatat(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                            int __flag ) 
{ int tmp ;

  {
  tmp = __fxstatat(3, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int mknod(char const   *__path , __mode_t __mode ,
                                                        __dev_t __dev )  __attribute__((__nonnull__(1))) ;
__inline extern int mknod(char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ int tmp ;

  {
  tmp = __xmknod(1, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int mknodat(int __fd , char const   *__path ,
                                                          __mode_t __mode , __dev_t __dev )  __attribute__((__nonnull__(2))) ;
__inline extern int mknodat(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) 
{ int tmp ;

  {
  tmp = __xmknodat(1, __fd, __path, __mode, & __dev);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int stat64(char const   * __restrict  __path ,
                                                         struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern int stat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) 
{ int tmp ;

  {
  tmp = __xstat64(3, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int lstat64(char const   * __restrict  __path ,
                                                          struct stat64 * __restrict  __statbuf )  __attribute__((__nonnull__(1,2))) ;
__inline extern int lstat64(char const   * __restrict  __path , struct stat64 * __restrict  __statbuf ) 
{ int tmp ;

  {
  tmp = __lxstat64(3, (char const   *)__path, (struct stat64 *)__statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int fstat64(int __fd , struct stat64 *__statbuf )  __attribute__((__nonnull__(2))) ;
__inline extern int fstat64(int __fd , struct stat64 *__statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat64(3, __fd, __statbuf);
  return (tmp);
}
}
__inline extern  __attribute__((__nothrow__)) int fstatat64(int __fd , char const   * __restrict  __filename ,
                                                            struct stat64 * __restrict  __statbuf ,
                                                            int __flag )  __attribute__((__nonnull__(2,3))) ;
__inline extern int fstatat64(int __fd , char const   * __restrict  __filename , struct stat64 * __restrict  __statbuf ,
                              int __flag ) 
{ int tmp ;

  {
  tmp = __fxstatat64(3, __fd, (char const   *)__filename, (struct stat64 *)__statbuf,
                     __flag);
  return (tmp);
}
}
extern  __attribute__((__nothrow__)) void *mmap(void *__addr , size_t __len , int __prot ,
                                                int __flags , int __fd , __off_t __offset ) ;
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t __len ) ;
extern  __attribute__((__nothrow__)) int gettimeofday(struct timeval * __restrict  __tv ,
                                                      __timezone_ptr_t __tz )  __attribute__((__nonnull__(1))) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern int open(char const   *__file , int __oflag  , ...)  __attribute__((__nonnull__(1))) ;
extern DIR *opendir(char const   *__name )  __attribute__((__nonnull__(1))) ;
extern int closedir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
extern struct dirent *readdir(DIR *__dirp )  __attribute__((__nonnull__(1))) ;
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
extern void regfree(regex_t *__preg ) ;
extern  __attribute__((__nothrow__)) int glob(char const   * __restrict  __pattern ,
                                              int __flags , int (*__errfunc)(char const   * ,
                                                                             int  ) ,
                                              glob_t * __restrict  __pglob ) ;
extern  __attribute__((__nothrow__)) void globfree(glob_t *__pglob ) ;
extern  __attribute__((__nothrow__)) int sched_yield(void) ;
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 ) ;
extern int pthread_once(pthread_once_t *__once_control , void (*__init_routine)(void) )  __attribute__((__nonnull__(1,2))) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_init(pthread_mutex_t *__mutex ,
                                                            pthread_mutexattr_t const   *__mutexattr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t *__mutex )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_rwlock_init(pthread_rwlock_t * __restrict  __rwlock ,
                                                             pthread_rwlockattr_t const   * __restrict  __attr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_rwlock_destroy(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_rwlock_rdlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_rwlock_wrlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_rwlock_unlock(pthread_rwlock_t *__rwlock )  __attribute__((__nonnull__(1))) ;
__inline extern  __attribute__((__nothrow__)) int pthread_equal(pthread_t __thread1 ,
                                                                pthread_t __thread2 ) ;
__inline extern int pthread_equal(pthread_t __thread1 , pthread_t __thread2 ) 
{ 

  {
  return (__thread1 == __thread2);
}
}
char *(*_tc_deflate)(char const   * , int  , int * , int  ) ;
char *(*_tc_inflate)(char const   * , int  , int * , int  ) ;
unsigned int (*_tc_getcrc)(char const   * , int  ) ;
char *(*_tc_bzcompress)(char const   * , int  , int * ) ;
char *(*_tc_bzdecompress)(char const   * , int  , int * ) ;
void _tc_md5_init(md5_state_t *pms ) ;
void _tc_md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) ;
void _tc_md5_finish(md5_state_t *pms , md5_byte_t *digest ) ;
char const   *tcversion  =    "1.4.33";
void (*tcfatalfunc)(char const   *message )  =    (void (*)(char const   *message ))((void *)0);
/* JAN MOD
void *tcmalloc(size_t size ) 
{ char *p ;
  void *tmp ;

  {
  while (1) {
    tmp = malloc(size);
    p = (char *)tmp;
    if (! p) {
      tcmyfatal("out of memory");
    }
    break;
  }
  return ((void *)p);
}
}*/
#define tcmalloc malloc
 /* JAN mod
void *tccalloc(size_t nmemb , size_t size ) 
{ char *p ;
  void *tmp ;

  {
  while (1) {
    tmp = calloc(nmemb, size);
    p = (char *)tmp;
    if (! p) {
      tcmyfatal("out of memory");
    }
    break;
  }
  return ((void *)p);
}
}
 */
#define tccalloc calloc

 /* JAN mod
void *tcrealloc(void *ptr , size_t size ) 
{ char *p ;
  void *tmp ;

  {
  while (1) {
    tmp = realloc(ptr, size);
    p = (char *)tmp;
    if (! p) {
      tcmyfatal("out of memory");
    }
    break;
  }
  return ((void *)p);
}
}
 */
#define tcrealloc realloc

void *tcmemdup(void const   *ptr , size_t size ) 
{ 
  char *p ;
  void *tmp ;

  {
  while (1) {
    tmp = malloc(size + 1U);
    p = (char *)tmp;
    if (! p) {
      tcmyfatal("out of memory");
    }
    break;
  }
  memcpy((void * __restrict  )p, (void const   * __restrict  )ptr, size);
  *(p + size) = (char )'\000';
  return ((void *)p);
}
}
char *tcstrdup(void const   *str ) 
{ int size ;
  size_t tmp ;
  char *p ;
  void *tmp___0 ;

  {
  tmp = strlen((char const   *)str);
  size = (int )tmp;
  while (1) {
    tmp___0 = malloc((unsigned int )(size + 1));
    p = (char *)tmp___0;
    if (! p) {
      tcmyfatal("out of memory");
    }
    break;
  }
  memcpy((void * __restrict  )p, (void const   * __restrict  )str, (unsigned int )size);
  *(p + size) = (char )'\000';
  return (p);
}
}
/* JAN
void tcfree(void *ptr ) 
{ 

  {
  while (1) {
    free(ptr);
    break;
  }
  return;
}
} */
static void tcvxstrprintf(TCXSTR *xstr , char const   *format , va_list ap ) ;
TCXSTR *tcxstrnew(void) 
{ TCXSTR *xstr ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*xstr)));
    xstr = (TCXSTR *)tmp;
    if (! xstr) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___1 = malloc(12U);
    tmp___0 = (char *)tmp___1;
    xstr->ptr = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  xstr->size = 0;
  xstr->asize = 12;
  *(xstr->ptr + 0) = (char )'\000';
  return (xstr);
}
}
TCXSTR *tcxstrnew2(char const   *str ) 
{ TCXSTR *xstr ;
  void *tmp ;
  int size ;
  size_t tmp___0 ;
  int asize ;
  long tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*xstr)));
    xstr = (TCXSTR *)tmp;
    if (! xstr) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tmp___0 = strlen(str);
  size = (int )tmp___0;
  tmp___1 = tclmax((long )(size + 1), 12L);
  asize = (int )tmp___1;
  while (1) {
    tmp___3 = malloc((unsigned int )asize);
    tmp___2 = (char *)tmp___3;
    xstr->ptr = tmp___2;
    if (! tmp___2) {
      tcmyfatal("out of memory");
    }
    break;
  }
  xstr->size = size;
  xstr->asize = asize;
  memcpy((void * __restrict  )xstr->ptr, (void const   * __restrict  )str, (unsigned int )(size + 1));
  return (xstr);
}
}
TCXSTR *tcxstrnew3(int asiz ) 
{ long tmp ;
  TCXSTR *xstr ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  tmp = tclmax((long )asiz, 12L);
  asiz = (int )tmp;
  while (1) {
    tmp___0 = malloc((unsigned int )((int )sizeof(*xstr)));
    xstr = (TCXSTR *)tmp___0;
    if (! xstr) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___2 = malloc((unsigned int )asiz);
    tmp___1 = (char *)tmp___2;
    xstr->ptr = tmp___1;
    if (! tmp___1) {
      tcmyfatal("out of memory");
    }
    break;
  }
  xstr->size = 0;
  xstr->asize = asiz;
  *(xstr->ptr + 0) = (char )'\000';
  return (xstr);
}
}
TCXSTR *tcxstrdup(TCXSTR const   *xstr ) 
{ TCXSTR *nxstr ;
  void *tmp ;
  int asize ;
  long tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*nxstr)));
    nxstr = (TCXSTR *)tmp;
    if (! nxstr) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tmp___0 = tclmax((long )(xstr->size + 1), 12L);
  asize = (int )tmp___0;
  while (1) {
    tmp___2 = malloc((unsigned int )asize);
    tmp___1 = (char *)tmp___2;
    nxstr->ptr = tmp___1;
    if (! tmp___1) {
      tcmyfatal("out of memory");
    }
    break;
  }
  nxstr->size = (int )xstr->size;
  nxstr->asize = asize;
  memcpy((void * __restrict  )nxstr->ptr, (void const   * __restrict  )xstr->ptr,
         (unsigned int )(xstr->size + 1));
  return (nxstr);
}
}
void tcxstrdel(TCXSTR *xstr ) 
{ 

  {
  while (1) {
    free((void *)xstr->ptr);
    break;
  }
  while (1) {
    free((void *)xstr);
    break;
  }
  return;
}
}
void tcxstrcat(TCXSTR *xstr , void const   *ptr , int size ) 
{ int nsize ;
  char *tmp ;
  void *tmp___0 ;

  {
  nsize = (xstr->size + size) + 1;
  if (xstr->asize < nsize) {
    while (xstr->asize < nsize) {
      xstr->asize *= 2;
      if (xstr->asize < nsize) {
        xstr->asize = nsize;
      }
    }
    while (1) {
      tmp___0 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
      tmp = (char *)tmp___0;
      xstr->ptr = tmp;
      if (! tmp) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )ptr,
         (unsigned int )size);
  xstr->size += size;
  *(xstr->ptr + xstr->size) = (char )'\000';
  return;
}
}
void tcxstrcat2(TCXSTR *xstr , char const   *str ) 
{ int size ;
  size_t tmp ;
  int nsize ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = strlen(str);
  size = (int )tmp;
  nsize = (xstr->size + size) + 1;
  if (xstr->asize < nsize) {
    while (xstr->asize < nsize) {
      xstr->asize *= 2;
      if (xstr->asize < nsize) {
        xstr->asize = nsize;
      }
    }
    while (1) {
      tmp___1 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
      tmp___0 = (char *)tmp___1;
      xstr->ptr = tmp___0;
      if (! tmp___0) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )str,
         (unsigned int )(size + 1));
  xstr->size += size;
  return;
}
}
void const   *tcxstrptr(TCXSTR const   *xstr ) 
{ 

  {
  return ((void const   *)xstr->ptr);
}
}
int tcxstrsize(TCXSTR const   *xstr ) 
{ 

  {
  return ((int )xstr->size);
}
}
void tcxstrclear(TCXSTR *xstr ) 
{ 

  {
  xstr->size = 0;
  *(xstr->ptr + 0) = (char )'\000';
  return;
}
}
void tcxstrprintf(TCXSTR *xstr , char const   *format  , ...) 
{ va_list ap ;

  {
  __builtin_va_start(ap, format);
  tcvxstrprintf(xstr, format, ap);
  __builtin_va_end(ap);
  return;
}
}
char *tcsprintf(char const   *format  , ...) 
{ TCXSTR *xstr ;
  TCXSTR *tmp ;
  va_list ap ;
  void *tmp___0 ;

  {
  tmp = tcxstrnew();
  xstr = tmp;
  __builtin_va_start(ap, format);
  tcvxstrprintf(xstr, format, ap);
  __builtin_va_end(ap);
  tmp___0 = tcxstrtomalloc(xstr);
  return ((char *)tmp___0);
}
}
static void tcvxstrprintf(TCXSTR *xstr , char const   *format , va_list ap ) 
{ char cbuf[32] ;
  int cblen ;
  int lnum ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tlen ;
  char *tmp___4 ;
  char tbuf[128] ;
  long long tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___8 ;
  void *tmp___9 ;
  unsigned long long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned int tmp___12 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___13 ;
  void *tmp___14 ;
  long double tmp___15 ;
  double tmp___16 ;
  int TC_mysize___1 ;
  int TC_nsize___1 ;
  char *tmp___17 ;
  void *tmp___18 ;
  int TC_mysize___2 ;
  int TC_nsize___2 ;
  char *tmp___19 ;
  void *tmp___20 ;
  int TC_mysize___3 ;
  int TC_nsize___3 ;
  char *tmp___21 ;
  void *tmp___22 ;
  int TC_mysize___4 ;
  int TC_nsize___4 ;
  char *tmp___23 ;
  void *tmp___24 ;
  int TC_mysize___5 ;
  int TC_nsize___5 ;
  char *tmp___25 ;
  void *tmp___26 ;
  int TC_mysize___6 ;
  int TC_nsize___6 ;
  char *tmp___27 ;
  void *tmp___28 ;
  unsigned char c ;
  int TC_mysize___7 ;
  int TC_nsize___7 ;
  char *tmp___29 ;
  void *tmp___30 ;
  int TC_mysize___8 ;
  int TC_nsize___8 ;
  char *tmp___31 ;
  void *tmp___32 ;
  char *tmp___34 ;
  int tmp___35 ;
  int64_t tmp___36 ;
  unsigned long long tmp___37 ;
  int tmp___38 ;
  int64_t tmp___39 ;
  unsigned long tmp___40 ;
  int tmp___41 ;
  int64_t tmp___42 ;
  unsigned int tmp___43 ;
  int TC_mysize___9 ;
  int TC_nsize___9 ;
  char *tmp___44 ;
  void *tmp___45 ;
  int TC_mysize___10 ;
  int TC_nsize___10 ;
  char *tmp___46 ;
  void *tmp___47 ;
  int TC_mysize___11 ;
  int TC_nsize___11 ;
  char *tmp___48 ;
  void *tmp___49 ;

  {
  while ((int const   )*format != 0) {
    if ((int const   )*format == 37) {
      cbuf[0] = (char )'%';
      cblen = 1;
      lnum = 0;
      format ++;
      while (1) {
        tmp___2 = __builtin_strchr((char *)"0123456789 .+-hlLz", (int )*format);
        if (tmp___2) {
          if ((int const   )*format != 0) {
            if (! (cblen < 31)) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
        if ((int const   )*format == 108) {
          lnum ++;
        } else {
          if ((int const   )*format == 76) {
            lnum ++;
          }
        }
        tmp = cblen;
        cblen ++;
        tmp___0 = format;
        format ++;
        cbuf[tmp] = (char )*tmp___0;
      }
      tmp___3 = cblen;
      cblen ++;
      cbuf[tmp___3] = (char )*format;
      cbuf[cblen] = (char )'\000';
      switch ((int )*format) {
      case 115: 
      tmp___4 = __builtin_va_arg(ap, char *);
      if (! tmp___4) {
        tmp___4 = (char *)"(null)";
      }
      tcxstrcat2(xstr, (char const   *)tmp___4);
      break;
      case 100: 
      if (lnum >= 2) {
        tmp___5 = __builtin_va_arg(ap, long long );
        tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                       tmp___5);
      } else {
        if (lnum >= 1) {
          tmp___6 = __builtin_va_arg(ap, long );
          tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                         tmp___6);
        } else {
          tmp___7 = __builtin_va_arg(ap, int );
          tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                         tmp___7);
        }
      }
      while (1) {
        TC_mysize = tlen;
        TC_nsize = (xstr->size + TC_mysize) + 1;
        if (xstr->asize < TC_nsize) {
          while (xstr->asize < TC_nsize) {
            xstr->asize *= 2;
            if (xstr->asize < TC_nsize) {
              xstr->asize = TC_nsize;
            }
          }
          while (1) {
            tmp___9 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
            tmp___8 = (char *)tmp___9;
            xstr->ptr = tmp___8;
            if (! tmp___8) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )(tbuf),
               (unsigned int )TC_mysize);
        xstr->size += TC_mysize;
        *(xstr->ptr + xstr->size) = (char )'\000';
        break;
      }
      break;
      case 111: 
      case 117: 
      case 120: 
      case 88: 
      case 99: 
      if (lnum >= 2) {
        tmp___10 = __builtin_va_arg(ap, unsigned long long );
        tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                       tmp___10);
      } else {
        if (lnum >= 1) {
          tmp___11 = __builtin_va_arg(ap, unsigned long );
          tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                         tmp___11);
        } else {
          tmp___12 = __builtin_va_arg(ap, unsigned int );
          tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                         tmp___12);
        }
      }
      while (1) {
        TC_mysize___0 = tlen;
        TC_nsize___0 = (xstr->size + TC_mysize___0) + 1;
        if (xstr->asize < TC_nsize___0) {
          while (xstr->asize < TC_nsize___0) {
            xstr->asize *= 2;
            if (xstr->asize < TC_nsize___0) {
              xstr->asize = TC_nsize___0;
            }
          }
          while (1) {
            tmp___14 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
            tmp___13 = (char *)tmp___14;
            xstr->ptr = tmp___13;
            if (! tmp___13) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )(tbuf),
               (unsigned int )TC_mysize___0);
        xstr->size += TC_mysize___0;
        *(xstr->ptr + xstr->size) = (char )'\000';
        break;
      }
      break;
      case 101: 
      case 69: 
      case 102: 
      case 103: 
      case 71: 
      if (lnum >= 1) {
        tmp___15 = __builtin_va_arg(ap, long double );
        tlen = snprintf((char * __restrict  )(tbuf), (unsigned int )((int )sizeof(tbuf)),
                        (char const   * __restrict  )(cbuf), tmp___15);
      } else {
        tmp___16 = __builtin_va_arg(ap, double );
        tlen = snprintf((char * __restrict  )(tbuf), (unsigned int )((int )sizeof(tbuf)),
                        (char const   * __restrict  )(cbuf), tmp___16);
      }
      if (tlen < 0) {
        tbuf[(int )sizeof(tbuf) - 1] = (char )'*';
        tlen = (int )sizeof(tbuf);
      } else {
        if (tlen > (int )sizeof(tbuf)) {
          tbuf[(int )sizeof(tbuf) - 1] = (char )'*';
          tlen = (int )sizeof(tbuf);
        }
      }
      while (1) {
        TC_mysize___1 = tlen;
        TC_nsize___1 = (xstr->size + TC_mysize___1) + 1;
        if (xstr->asize < TC_nsize___1) {
          while (xstr->asize < TC_nsize___1) {
            xstr->asize *= 2;
            if (xstr->asize < TC_nsize___1) {
              xstr->asize = TC_nsize___1;
            }
          }
          while (1) {
            tmp___18 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
            tmp___17 = (char *)tmp___18;
            xstr->ptr = tmp___17;
            if (! tmp___17) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )(tbuf),
               (unsigned int )TC_mysize___1);
        xstr->size += TC_mysize___1;
        *(xstr->ptr + xstr->size) = (char )'\000';
        break;
      }
      break;
      case 64: 
      tmp___4 = __builtin_va_arg(ap, char *);
      if (! tmp___4) {
        tmp___4 = (char *)"(null)";
      }
      while (*tmp___4) {
        switch ((int )*tmp___4) {
        case 38: 
        while (1) {
          TC_mysize___2 = 5;
          TC_nsize___2 = (xstr->size + TC_mysize___2) + 1;
          if (xstr->asize < TC_nsize___2) {
            while (xstr->asize < TC_nsize___2) {
              xstr->asize *= 2;
              if (xstr->asize < TC_nsize___2) {
                xstr->asize = TC_nsize___2;
              }
            }
            while (1) {
              tmp___20 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
              tmp___19 = (char *)tmp___20;
              xstr->ptr = tmp___19;
              if (! tmp___19) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )"&amp;",
                 (unsigned int )TC_mysize___2);
          xstr->size += TC_mysize___2;
          *(xstr->ptr + xstr->size) = (char )'\000';
          break;
        }
        break;
        case 60: 
        while (1) {
          TC_mysize___3 = 4;
          TC_nsize___3 = (xstr->size + TC_mysize___3) + 1;
          if (xstr->asize < TC_nsize___3) {
            while (xstr->asize < TC_nsize___3) {
              xstr->asize *= 2;
              if (xstr->asize < TC_nsize___3) {
                xstr->asize = TC_nsize___3;
              }
            }
            while (1) {
              tmp___22 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
              tmp___21 = (char *)tmp___22;
              xstr->ptr = tmp___21;
              if (! tmp___21) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )"&lt;",
                 (unsigned int )TC_mysize___3);
          xstr->size += TC_mysize___3;
          *(xstr->ptr + xstr->size) = (char )'\000';
          break;
        }
        break;
        case 62: 
        while (1) {
          TC_mysize___4 = 4;
          TC_nsize___4 = (xstr->size + TC_mysize___4) + 1;
          if (xstr->asize < TC_nsize___4) {
            while (xstr->asize < TC_nsize___4) {
              xstr->asize *= 2;
              if (xstr->asize < TC_nsize___4) {
                xstr->asize = TC_nsize___4;
              }
            }
            while (1) {
              tmp___24 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
              tmp___23 = (char *)tmp___24;
              xstr->ptr = tmp___23;
              if (! tmp___23) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )"&gt;",
                 (unsigned int )TC_mysize___4);
          xstr->size += TC_mysize___4;
          *(xstr->ptr + xstr->size) = (char )'\000';
          break;
        }
        break;
        case 34: 
        while (1) {
          TC_mysize___5 = 6;
          TC_nsize___5 = (xstr->size + TC_mysize___5) + 1;
          if (xstr->asize < TC_nsize___5) {
            while (xstr->asize < TC_nsize___5) {
              xstr->asize *= 2;
              if (xstr->asize < TC_nsize___5) {
                xstr->asize = TC_nsize___5;
              }
            }
            while (1) {
              tmp___26 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
              tmp___25 = (char *)tmp___26;
              xstr->ptr = tmp___25;
              if (! tmp___25) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )"&quot;",
                 (unsigned int )TC_mysize___5);
          xstr->size += TC_mysize___5;
          *(xstr->ptr + xstr->size) = (char )'\000';
          break;
        }
        break;
        default: ;
        if ((int )*tmp___4 >= 0) {
          if (! ((int )*tmp___4 <= 8)) {
            goto _L___0;
          }
        } else {
          _L___0: 
          if ((int )*tmp___4 >= 14) {
            if (! ((int )*tmp___4 <= 31)) {
              goto _L;
            }
          } else {
            _L: 
            while (1) {
              TC_mysize___6 = 1;
              TC_nsize___6 = (xstr->size + TC_mysize___6) + 1;
              if (xstr->asize < TC_nsize___6) {
                while (xstr->asize < TC_nsize___6) {
                  xstr->asize *= 2;
                  if (xstr->asize < TC_nsize___6) {
                    xstr->asize = TC_nsize___6;
                  }
                }
                while (1) {
                  tmp___28 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                  tmp___27 = (char *)tmp___28;
                  xstr->ptr = tmp___27;
                  if (! tmp___27) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )tmp___4,
                     (unsigned int )TC_mysize___6);
              xstr->size += TC_mysize___6;
              *(xstr->ptr + xstr->size) = (char )'\000';
              break;
            }
          }
        }
        break;
        }
        tmp___4 ++;
      }
      break;
      case 63: 
      tmp___4 = __builtin_va_arg(ap, char *);
      if (! tmp___4) {
        tmp___4 = (char *)"(null)";
      }
      while (*tmp___4) {
        c = *((unsigned char *)tmp___4);
        if ((int )c >= 65) {
          if ((int )c <= 90) {
            goto _L___1;
          } else {
            goto _L___5;
          }
        } else {
          _L___5: 
          if ((int )c >= 97) {
            if ((int )c <= 122) {
              goto _L___1;
            } else {
              goto _L___4;
            }
          } else {
            _L___4: 
            if ((int )c >= 48) {
              if ((int )c <= 57) {
                goto _L___1;
              } else {
                goto _L___3;
              }
            } else {
              _L___3: 
              if ((int )c != 0) {
                tmp___34 = __builtin_strchr((char *)"_-.", (int )c);
                if (tmp___34) {
                  _L___1: 
                  while (1) {
                    TC_mysize___7 = 1;
                    TC_nsize___7 = (xstr->size + TC_mysize___7) + 1;
                    if (xstr->asize < TC_nsize___7) {
                      while (xstr->asize < TC_nsize___7) {
                        xstr->asize *= 2;
                        if (xstr->asize < TC_nsize___7) {
                          xstr->asize = TC_nsize___7;
                        }
                      }
                      while (1) {
                        tmp___30 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                        tmp___29 = (char *)tmp___30;
                        xstr->ptr = tmp___29;
                        if (! tmp___29) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )tmp___4,
                           (unsigned int )TC_mysize___7);
                    xstr->size += TC_mysize___7;
                    *(xstr->ptr + xstr->size) = (char )'\000';
                    break;
                  }
                } else {
                  goto _L___2;
                }
              } else {
                _L___2: 
                tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )"%%%02X",
                               c);
                while (1) {
                  TC_mysize___8 = tlen;
                  TC_nsize___8 = (xstr->size + TC_mysize___8) + 1;
                  if (xstr->asize < TC_nsize___8) {
                    while (xstr->asize < TC_nsize___8) {
                      xstr->asize *= 2;
                      if (xstr->asize < TC_nsize___8) {
                        xstr->asize = TC_nsize___8;
                      }
                    }
                    while (1) {
                      tmp___32 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                      tmp___31 = (char *)tmp___32;
                      xstr->ptr = tmp___31;
                      if (! tmp___31) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                  }
                  memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )(tbuf),
                         (unsigned int )TC_mysize___8);
                  xstr->size += TC_mysize___8;
                  *(xstr->ptr + xstr->size) = (char )'\000';
                  break;
                }
              }
            }
          }
        }
        tmp___4 ++;
      }
      break;
      case 98: 
      if (lnum >= 2) {
        if ((int )cbuf[1] == 48) {
          tmp___35 = '0';
        } else {
          tmp___35 = ' ';
        }
        tmp___36 = tcatoi((char const   *)(cbuf + 1));
        tmp___37 = __builtin_va_arg(ap, unsigned long long );
        tlen = tcnumtostrbin(tmp___37, tbuf, (int )tmp___36, tmp___35);
      } else {
        if (lnum >= 1) {
          if ((int )cbuf[1] == 48) {
            tmp___38 = '0';
          } else {
            tmp___38 = ' ';
          }
          tmp___39 = tcatoi((char const   *)(cbuf + 1));
          tmp___40 = __builtin_va_arg(ap, unsigned long );
          tlen = tcnumtostrbin((unsigned long long )tmp___40, tbuf, (int )tmp___39,
                               tmp___38);
        } else {
          if ((int )cbuf[1] == 48) {
            tmp___41 = '0';
          } else {
            tmp___41 = ' ';
          }
          tmp___42 = tcatoi((char const   *)(cbuf + 1));
          tmp___43 = __builtin_va_arg(ap, unsigned int );
          tlen = tcnumtostrbin((unsigned long long )tmp___43, tbuf, (int )tmp___42,
                               tmp___41);
        }
      }
      while (1) {
        TC_mysize___9 = tlen;
        TC_nsize___9 = (xstr->size + TC_mysize___9) + 1;
        if (xstr->asize < TC_nsize___9) {
          while (xstr->asize < TC_nsize___9) {
            xstr->asize *= 2;
            if (xstr->asize < TC_nsize___9) {
              xstr->asize = TC_nsize___9;
            }
          }
          while (1) {
            tmp___45 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
            tmp___44 = (char *)tmp___45;
            xstr->ptr = tmp___44;
            if (! tmp___44) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )(tbuf),
               (unsigned int )TC_mysize___9);
        xstr->size += TC_mysize___9;
        *(xstr->ptr + xstr->size) = (char )'\000';
        break;
      }
      break;
      case 37: 
      while (1) {
        TC_mysize___10 = 1;
        TC_nsize___10 = (xstr->size + TC_mysize___10) + 1;
        if (xstr->asize < TC_nsize___10) {
          while (xstr->asize < TC_nsize___10) {
            xstr->asize *= 2;
            if (xstr->asize < TC_nsize___10) {
              xstr->asize = TC_nsize___10;
            }
          }
          while (1) {
            tmp___47 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
            tmp___46 = (char *)tmp___47;
            xstr->ptr = tmp___46;
            if (! tmp___46) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )"%",
               (unsigned int )TC_mysize___10);
        xstr->size += TC_mysize___10;
        *(xstr->ptr + xstr->size) = (char )'\000';
        break;
      }
      break;
      }
    } else {
      while (1) {
        TC_mysize___11 = 1;
        TC_nsize___11 = (xstr->size + TC_mysize___11) + 1;
        if (xstr->asize < TC_nsize___11) {
          while (xstr->asize < TC_nsize___11) {
            xstr->asize *= 2;
            if (xstr->asize < TC_nsize___11) {
              xstr->asize = TC_nsize___11;
            }
          }
          while (1) {
            tmp___49 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
            tmp___48 = (char *)tmp___49;
            xstr->ptr = tmp___48;
            if (! tmp___48) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )format,
               (unsigned int )TC_mysize___11);
        xstr->size += TC_mysize___11;
        *(xstr->ptr + xstr->size) = (char )'\000';
        break;
      }
    }
    format ++;
  }
  return;
}
}
void *tcxstrtomalloc(TCXSTR *xstr ) 
{ char *ptr ;

  {
  ptr = xstr->ptr;
  while (1) {
    free((void *)xstr);
    break;
  }
  return ((void *)ptr);
}
}
TCXSTR *tcxstrfrommalloc(void *ptr , int size ) 
{ TCXSTR *xstr ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*xstr)));
    xstr = (TCXSTR *)tmp;
    if (! xstr) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___1 = realloc(ptr, (unsigned int )(size + 1));
    tmp___0 = (char *)tmp___1;
    xstr->ptr = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  *(xstr->ptr + size) = (char )'\000';
  xstr->size = size;
  xstr->asize = size;
  return (xstr);
}
}
static int tclistelemcmp(void const   *a , void const   *b ) ;
static int tclistelemcmpci(void const   *a , void const   *b ) ;
TCLIST *tclistnew(void) 
{ TCLIST *list ;
  void *tmp ;
  TCLISTDATUM *tmp___0 ;
  void *tmp___1 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*list)));
    list = (TCLIST *)tmp;
    if (! list) {
      tcmyfatal("out of memory");
    }
    break;
  }
  list->anum = 64;
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(*(list->array + 0)) * list->anum));
    tmp___0 = (TCLISTDATUM *)tmp___1;
    list->array = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  list->start = 0;
  list->num = 0;
  return (list);
}
}
TCLIST *tclistnew2(int anum ) 
{ TCLIST *list ;
  void *tmp ;
  TCLISTDATUM *tmp___0 ;
  void *tmp___1 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*list)));
    list = (TCLIST *)tmp;
    if (! list) {
      tcmyfatal("out of memory");
    }
    break;
  }
  if (anum < 1) {
    anum = 1;
  }
  list->anum = anum;
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(*(list->array + 0)) * list->anum));
    tmp___0 = (TCLISTDATUM *)tmp___1;
    list->array = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  list->start = 0;
  list->num = 0;
  return (list);
}
}
TCLIST *tclistnew3(char const   *str  , ...) 
{ TCLIST *list ;
  TCLIST *tmp ;
  va_list ap ;
  char const   *elem ;

  {
  tmp = tclistnew();
  list = tmp;
  if (str) {
    tclistpush2(list, str);
    __builtin_va_start(ap, str);
    while (1) {
      elem = __builtin_va_arg(ap, char *);
      if (! ((unsigned int )elem != (unsigned int )((void *)0))) {
        break;
      }
      tclistpush2(list, elem);
    }
    __builtin_va_end(ap);
  }
  return (list);
}
}
TCLIST *tclistdup(TCLIST const   *list ) 
{ int num ;
  TCLIST *tmp ;
  TCLISTDATUM const   *array ;
  TCLIST *nlist ;
  void *tmp___0 ;
  TCLISTDATUM *narray ;
  void *tmp___1 ;
  int i ;
  int size ;
  char *tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;

  {
  num = (int )list->num;
  if (num < 1) {
    tmp = tclistnew();
    return (tmp);
  }
  array = (TCLISTDATUM const   *)(list->array + list->start);
  while (1) {
    tmp___0 = malloc((unsigned int )((int )sizeof(*nlist)));
    nlist = (TCLIST *)tmp___0;
    if (! nlist) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(*(list->array + 0)) * num));
    narray = (TCLISTDATUM *)tmp___1;
    if (! narray) {
      tcmyfatal("out of memory");
    }
    break;
  }
  i = 0;
  while (i < num) {
    size = (int )(array + i)->size;
    while (1) {
      tmp___3 = tclmax((long )(size + 1), 12L);
      tmp___4 = malloc((unsigned int )tmp___3);
      tmp___2 = (char *)tmp___4;
      (narray + i)->ptr = tmp___2;
      if (! tmp___2) {
        tcmyfatal("out of memory");
      }
      break;
    }
    memcpy((void * __restrict  )(narray + i)->ptr, (void const   * __restrict  )(array + i)->ptr,
           (unsigned int )(size + 1));
    (narray + i)->size = (int )(array + i)->size;
    i ++;
  }
  nlist->anum = num;
  nlist->array = narray;
  nlist->start = 0;
  nlist->num = num;
  return (nlist);
}
}
void tclistdel(TCLIST *list ) 
{ TCLISTDATUM *array ;
  int end ;
  int i ;

  {
  array = list->array;
  end = list->start + list->num;
  i = list->start;
  while (i < end) {
    while (1) {
      free((void *)(array + i)->ptr);
      break;
    }
    i ++;
  }
  while (1) {
    free((void *)list->array);
    break;
  }
  while (1) {
    free((void *)list);
    break;
  }
  return;
}
}
int tclistnum(TCLIST const   *list ) 
{ 

  {
  return ((int )list->num);
}
}
void const   *tclistval(TCLIST const   *list , int index___0 , int *sp ) 
{ 

  {
  if (index___0 >= (int )list->num) {
    return ((void const   *)((void *)0));
  }
  index___0 += (int )list->start;
  *sp = (list->array + index___0)->size;
  return ((void const   *)(list->array + index___0)->ptr);
}
}
char const   *tclistval2(TCLIST const   *list , int index___0 ) 
{ 

  {
  if (index___0 >= (int )list->num) {
    return ((char const   *)((void *)0));
  }
  index___0 += (int )list->start;
  return ((char const   *)(list->array + index___0)->ptr);
}
}
void tclistpush(TCLIST *list , void const   *ptr , int size ) 
{ int index___0 ;
  TCLISTDATUM *tmp ;
  void *tmp___0 ;
  TCLISTDATUM *array ;
  char *tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;

  {
  index___0 = list->start + list->num;
  if (index___0 >= list->anum) {
    list->anum += list->num + 1;
    while (1) {
      tmp___0 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
      tmp = (TCLISTDATUM *)tmp___0;
      list->array = tmp;
      if (! tmp) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  array = list->array;
  while (1) {
    tmp___2 = tclmax((long )(size + 1), 12L);
    tmp___3 = malloc((unsigned int )tmp___2);
    tmp___1 = (char *)tmp___3;
    (array + index___0)->ptr = tmp___1;
    if (! tmp___1) {
      tcmyfatal("out of memory");
    }
    break;
  }
  memcpy((void * __restrict  )(array + index___0)->ptr, (void const   * __restrict  )ptr,
         (unsigned int )size);
  *((array + index___0)->ptr + size) = (char )'\000';
  (array + index___0)->size = size;
  (list->num) ++;
  return;
}
}
void tclistpush2(TCLIST *list , char const   *str ) 
{ int index___0 ;
  TCLISTDATUM *tmp ;
  void *tmp___0 ;
  int size ;
  size_t tmp___1 ;
  TCLISTDATUM *array ;
  char *tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;

  {
  index___0 = list->start + list->num;
  if (index___0 >= list->anum) {
    list->anum += list->num + 1;
    while (1) {
      tmp___0 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
      tmp = (TCLISTDATUM *)tmp___0;
      list->array = tmp;
      if (! tmp) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  tmp___1 = strlen(str);
  size = (int )tmp___1;
  array = list->array;
  while (1) {
    tmp___3 = tclmax((long )(size + 1), 12L);
    tmp___4 = malloc((unsigned int )tmp___3);
    tmp___2 = (char *)tmp___4;
    (array + index___0)->ptr = tmp___2;
    if (! tmp___2) {
      tcmyfatal("out of memory");
    }
    break;
  }
  memcpy((void * __restrict  )(array + index___0)->ptr, (void const   * __restrict  )str,
         (unsigned int )(size + 1));
  (array + index___0)->size = size;
  (list->num) ++;
  return;
}
}
void *tclistpop(TCLIST *list , int *sp ) 
{ int index___0 ;

  {
  if (list->num < 1) {
    return ((void *)0);
  }
  index___0 = (list->start + list->num) - 1;
  (list->num) --;
  *sp = (list->array + index___0)->size;
  return ((void *)(list->array + index___0)->ptr);
}
}
char *tclistpop2(TCLIST *list ) 
{ int index___0 ;

  {
  if (list->num < 1) {
    return ((char *)((void *)0));
  }
  index___0 = (list->start + list->num) - 1;
  (list->num) --;
  return ((list->array + index___0)->ptr);
}
}
void tclistunshift(TCLIST *list , void const   *ptr , int size ) 
{ TCLISTDATUM *tmp ;
  void *tmp___0 ;
  int index___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;

  {
  if (list->start < 1) {
    if (list->start + list->num >= list->anum) {
      list->anum += list->num + 1;
      while (1) {
        tmp___0 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
        tmp = (TCLISTDATUM *)tmp___0;
        list->array = tmp;
        if (! tmp) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    list->start = list->anum - list->num;
    memmove((void *)(list->array + list->start), (void const   *)list->array, (unsigned int )(list->num * (int )sizeof(*(list->array + 0))));
  }
  index___0 = list->start - 1;
  while (1) {
    tmp___2 = tclmax((long )(size + 1), 12L);
    tmp___3 = malloc((unsigned int )tmp___2);
    tmp___1 = (char *)tmp___3;
    (list->array + index___0)->ptr = tmp___1;
    if (! tmp___1) {
      tcmyfatal("out of memory");
    }
    break;
  }
  memcpy((void * __restrict  )(list->array + index___0)->ptr, (void const   * __restrict  )ptr,
         (unsigned int )size);
  *((list->array + index___0)->ptr + size) = (char )'\000';
  (list->array + index___0)->size = size;
  (list->start) --;
  (list->num) ++;
  return;
}
}
void tclistunshift2(TCLIST *list , char const   *str ) 
{ TCLISTDATUM *tmp ;
  void *tmp___0 ;
  int index___0 ;
  int size ;
  size_t tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;

  {
  if (list->start < 1) {
    if (list->start + list->num >= list->anum) {
      list->anum += list->num + 1;
      while (1) {
        tmp___0 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
        tmp = (TCLISTDATUM *)tmp___0;
        list->array = tmp;
        if (! tmp) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    list->start = list->anum - list->num;
    memmove((void *)(list->array + list->start), (void const   *)list->array, (unsigned int )(list->num * (int )sizeof(*(list->array + 0))));
  }
  index___0 = list->start - 1;
  tmp___1 = strlen(str);
  size = (int )tmp___1;
  while (1) {
    tmp___3 = tclmax((long )(size + 1), 12L);
    tmp___4 = malloc((unsigned int )tmp___3);
    tmp___2 = (char *)tmp___4;
    (list->array + index___0)->ptr = tmp___2;
    if (! tmp___2) {
      tcmyfatal("out of memory");
    }
    break;
  }
  memcpy((void * __restrict  )(list->array + index___0)->ptr, (void const   * __restrict  )str,
         (unsigned int )(size + 1));
  (list->array + index___0)->size = size;
  (list->start) --;
  (list->num) ++;
  return;
}
}
void *tclistshift(TCLIST *list , int *sp ) 
{ int index___0 ;
  void *rv ;

  {
  if (list->num < 1) {
    return ((void *)0);
  }
  index___0 = list->start;
  (list->start) ++;
  (list->num) --;
  *sp = (list->array + index___0)->size;
  rv = (void *)(list->array + index___0)->ptr;
  if ((list->start & 255) == 0) {
    if (list->start > list->num >> 1) {
      memmove((void *)list->array, (void const   *)(list->array + list->start), (unsigned int )(list->num * (int )sizeof(*(list->array + 0))));
      list->start = 0;
    }
  }
  return (rv);
}
}
char *tclistshift2(TCLIST *list ) 
{ int index___0 ;
  void *rv ;

  {
  if (list->num < 1) {
    return ((char *)((void *)0));
  }
  index___0 = list->start;
  (list->start) ++;
  (list->num) --;
  rv = (void *)(list->array + index___0)->ptr;
  if ((list->start & 255) == 0) {
    if (list->start > list->num >> 1) {
      memmove((void *)list->array, (void const   *)(list->array + list->start), (unsigned int )(list->num * (int )sizeof(*(list->array + 0))));
      list->start = 0;
    }
  }
  return ((char *)rv);
}
}
void tclistinsert(TCLIST *list , int index___0 , void const   *ptr , int size ) 
{ TCLISTDATUM *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;

  {
  if (index___0 > list->num) {
    return;
  }
  index___0 += list->start;
  if (list->start + list->num >= list->anum) {
    list->anum += list->num + 1;
    while (1) {
      tmp___0 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
      tmp = (TCLISTDATUM *)tmp___0;
      list->array = tmp;
      if (! tmp) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  memmove((void *)((list->array + index___0) + 1), (void const   *)(list->array + index___0),
          (unsigned int )((int )sizeof(*(list->array + 0)) * ((list->start + list->num) - index___0)));
  while (1) {
    tmp___2 = tclmax((long )(size + 1), 12L);
    tmp___3 = malloc((unsigned int )tmp___2);
    tmp___1 = (char *)tmp___3;
    (list->array + index___0)->ptr = tmp___1;
    if (! tmp___1) {
      tcmyfatal("out of memory");
    }
    break;
  }
  memcpy((void * __restrict  )(list->array + index___0)->ptr, (void const   * __restrict  )ptr,
         (unsigned int )size);
  *((list->array + index___0)->ptr + size) = (char )'\000';
  (list->array + index___0)->size = size;
  (list->num) ++;
  return;
}
}
void tclistinsert2(TCLIST *list , int index___0 , char const   *str ) 
{ TCLISTDATUM *tmp ;
  void *tmp___0 ;
  int size ;
  size_t tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;

  {
  if (index___0 > list->num) {
    return;
  }
  index___0 += list->start;
  if (list->start + list->num >= list->anum) {
    list->anum += list->num + 1;
    while (1) {
      tmp___0 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
      tmp = (TCLISTDATUM *)tmp___0;
      list->array = tmp;
      if (! tmp) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  memmove((void *)((list->array + index___0) + 1), (void const   *)(list->array + index___0),
          (unsigned int )((int )sizeof(*(list->array + 0)) * ((list->start + list->num) - index___0)));
  tmp___1 = strlen(str);
  size = (int )tmp___1;
  while (1) {
    tmp___3 = tclmax((long )(size + 1), 12L);
    tmp___4 = malloc((unsigned int )tmp___3);
    tmp___2 = (char *)tmp___4;
    (list->array + index___0)->ptr = tmp___2;
    if (! tmp___2) {
      tcmyfatal("out of memory");
    }
    break;
  }
  memcpy((void * __restrict  )(list->array + index___0)->ptr, (void const   * __restrict  )str,
         (unsigned int )size);
  *((list->array + index___0)->ptr + size) = (char )'\000';
  (list->array + index___0)->size = size;
  (list->num) ++;
  return;
}
}
void *tclistremove(TCLIST *list , int index___0 , int *sp ) 
{ void *rv ;

  {
  if (index___0 >= list->num) {
    return ((void *)0);
  }
  index___0 += list->start;
  rv = (void *)(list->array + index___0)->ptr;
  *sp = (list->array + index___0)->size;
  (list->num) --;
  memmove((void *)(list->array + index___0), (void const   *)((list->array + index___0) + 1),
          (unsigned int )((int )sizeof(*(list->array + 0)) * ((list->start + list->num) - index___0)));
  return (rv);
}
}
char *tclistremove2(TCLIST *list , int index___0 ) 
{ void *rv ;

  {
  if (index___0 >= list->num) {
    return ((char *)((void *)0));
  }
  index___0 += list->start;
  rv = (void *)(list->array + index___0)->ptr;
  (list->num) --;
  memmove((void *)(list->array + index___0), (void const   *)((list->array + index___0) + 1),
          (unsigned int )((int )sizeof(*(list->array + 0)) * ((list->start + list->num) - index___0)));
  return ((char *)rv);
}
}
void tclistover(TCLIST *list , int index___0 , void const   *ptr , int size ) 
{ char *tmp ;
  void *tmp___0 ;

  {
  if (index___0 >= list->num) {
    return;
  }
  index___0 += list->start;
  if (size > (list->array + index___0)->size) {
    while (1) {
      tmp___0 = realloc((void *)(list->array + index___0)->ptr, (unsigned int )(size + 1));
      tmp = (char *)tmp___0;
      (list->array + index___0)->ptr = tmp;
      if (! tmp) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  memcpy((void * __restrict  )(list->array + index___0)->ptr, (void const   * __restrict  )ptr,
         (unsigned int )size);
  (list->array + index___0)->size = size;
  *((list->array + index___0)->ptr + size) = (char )'\000';
  return;
}
}
void tclistover2(TCLIST *list , int index___0 , char const   *str ) 
{ int size ;
  size_t tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  if (index___0 >= list->num) {
    return;
  }
  index___0 += list->start;
  tmp = strlen(str);
  size = (int )tmp;
  if (size > (list->array + index___0)->size) {
    while (1) {
      tmp___1 = realloc((void *)(list->array + index___0)->ptr, (unsigned int )(size + 1));
      tmp___0 = (char *)tmp___1;
      (list->array + index___0)->ptr = tmp___0;
      if (! tmp___0) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  memcpy((void * __restrict  )(list->array + index___0)->ptr, (void const   * __restrict  )str,
         (unsigned int )(size + 1));
  (list->array + index___0)->size = size;
  return;
}
}
void tclistsort(TCLIST *list ) 
{ 

  {
  qsort((void *)(list->array + list->start), (unsigned int )list->num, (unsigned int )((int )sizeof(*(list->array + 0))),
        & tclistelemcmp);
  return;
}
}
int tclistlsearch(TCLIST const   *list , void const   *ptr , int size ) 
{ int end ;
  int i ;
  int tmp ;

  {
  end = (int )(list->start + list->num);
  i = (int )list->start;
  while (i < end) {
    if ((list->array + i)->size == size) {
      tmp = memcmp((void const   *)(list->array + i)->ptr, ptr, (unsigned int )size);
      if (! tmp) {
        return (i - (int )list->start);
      }
    }
    i ++;
  }
  return (-1);
}
}
int tclistbsearch(TCLIST const   *list , void const   *ptr , int size ) 
{ TCLISTDATUM key ;
  TCLISTDATUM *res ;
  void *tmp ;
  int tmp___0 ;

  {
  key.ptr = (char *)ptr;
  key.size = size;
  tmp = bsearch((void const   *)(& key), (void const   *)(list->array + list->start),
                (unsigned int )list->num, (unsigned int )((int )sizeof(*(list->array + 0))),
                & tclistelemcmp);
  res = (TCLISTDATUM *)tmp;
  if (res) {
    tmp___0 = (res - (TCLISTDATUM *)list->array) - (int )list->start;
  } else {
    tmp___0 = -1;
  }
  return (tmp___0);
}
}
void tclistclear(TCLIST *list ) 
{ TCLISTDATUM *array ;
  int end ;
  int i ;

  {
  array = list->array;
  end = list->start + list->num;
  i = list->start;
  while (i < end) {
    while (1) {
      free((void *)(array + i)->ptr);
      break;
    }
    i ++;
  }
  list->start = 0;
  list->num = 0;
  return;
}
}
void *tclistdump(TCLIST const   *list , int *sp ) 
{ TCLISTDATUM const   *array ;
  int end ;
  int tsiz ;
  int i ;
  char *buf ;
  void *tmp ;
  char *wp ;
  int i___0 ;
  int step ;
  int _TC_num ;
  int _TC_rem ;

  {
  array = (TCLISTDATUM const   *)list->array;
  end = (int )(list->start + list->num);
  tsiz = 0;
  i = (int )list->start;
  while (i < end) {
    tsiz += (int )((array + i)->size + (int const   )((int )sizeof(int )));
    i ++;
  }
  while (1) {
    tmp = malloc((unsigned int )(tsiz + 1));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  i___0 = (int )list->start;
  while (i___0 < end) {
    while (1) {
      _TC_num = (int )(array + i___0)->size;
      if (_TC_num == 0) {
        *((signed char *)wp + 0) = (signed char)0;
        step = 1;
      } else {
        step = 0;
        while (_TC_num > 0) {
          _TC_rem = _TC_num & 127;
          _TC_num >>= 7;
          if (_TC_num > 0) {
            *((signed char *)wp + step) = (signed char )(- _TC_rem - 1);
          } else {
            *((signed char *)wp + step) = (signed char )_TC_rem;
          }
          step ++;
        }
      }
      break;
    }
    wp += step;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(array + i___0)->ptr,
           (unsigned int )(array + i___0)->size);
    wp += (array + i___0)->size;
    i___0 ++;
  }
  *sp = wp - buf;
  return ((void *)buf);
}
}
TCLIST *tclistload(void const   *ptr , int size ) 
{ TCLIST *list ;
  void *tmp ;
  int anum ;
  TCLISTDATUM *array ;
  void *tmp___0 ;
  int num ;
  char const   *rp ;
  char const   *ep ;
  int step ;
  int vsiz ;
  int _TC_base ;
  int _TC_i ;
  void *tmp___1 ;
  char *tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*list)));
    list = (TCLIST *)tmp;
    if (! list) {
      tcmyfatal("out of memory");
    }
    break;
  }
  anum = size / (int )sizeof(int ) + 1;
  while (1) {
    tmp___0 = malloc((unsigned int )((int )sizeof(*(array + 0)) * anum));
    array = (TCLISTDATUM *)tmp___0;
    if (! array) {
      tcmyfatal("out of memory");
    }
    break;
  }
  num = 0;
  rp = (char const   *)ptr;
  ep = (char const   *)((char *)ptr + size);
  while ((unsigned int )rp < (unsigned int )ep) {
    while (1) {
      vsiz = 0;
      _TC_base = 1;
      _TC_i = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i) >= 0) {
          vsiz += (int )*((signed char *)rp + _TC_i) * _TC_base;
          break;
        }
        vsiz += (_TC_base * ((int )*((signed char *)rp + _TC_i) + 1)) * -1;
        _TC_base <<= 7;
        _TC_i ++;
      }
      step = _TC_i + 1;
      break;
    }
    rp += step;
    if (num >= anum) {
      anum *= 2;
      while (1) {
        tmp___1 = realloc((void *)array, (unsigned int )(anum * (int )sizeof(*(array + 0))));
        array = (TCLISTDATUM *)tmp___1;
        if (! array) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    while (1) {
      tmp___3 = tclmax((long )(vsiz + 1), 12L);
      tmp___4 = malloc((unsigned int )tmp___3);
      tmp___2 = (char *)tmp___4;
      (array + num)->ptr = tmp___2;
      if (! tmp___2) {
        tcmyfatal("out of memory");
      }
      break;
    }
    memcpy((void * __restrict  )(array + num)->ptr, (void const   * __restrict  )rp,
           (unsigned int )vsiz);
    *((array + num)->ptr + vsiz) = (char )'\000';
    (array + num)->size = vsiz;
    num ++;
    rp += vsiz;
  }
  list->anum = anum;
  list->array = array;
  list->start = 0;
  list->num = num;
  return (list);
}
}
static int tclistelemcmp(void const   *a , void const   *b ) 
{ unsigned char *ao ;
  unsigned char *bo ;
  int size ;
  int tmp ;
  int i ;

  {
  ao = (unsigned char *)((TCLISTDATUM *)a)->ptr;
  bo = (unsigned char *)((TCLISTDATUM *)b)->ptr;
  if (((TCLISTDATUM *)a)->size < ((TCLISTDATUM *)b)->size) {
    tmp = ((TCLISTDATUM *)a)->size;
  } else {
    tmp = ((TCLISTDATUM *)b)->size;
  }
  size = tmp;
  i = 0;
  while (i < size) {
    if ((int )*(ao + i) > (int )*(bo + i)) {
      return (1);
    }
    if ((int )*(ao + i) < (int )*(bo + i)) {
      return (-1);
    }
    i ++;
  }
  return (((TCLISTDATUM *)a)->size - ((TCLISTDATUM *)b)->size);
}
}
static int tclistelemcmpci(void const   *a , void const   *b ) 
{ TCLISTDATUM *ap ;
  TCLISTDATUM *bp ;
  unsigned char *ao ;
  unsigned char *bo ;
  int size ;
  int tmp ;
  int i ;
  int ac ;
  _Bool ab ;
  int bc ;
  _Bool bb ;

  {
  ap = (TCLISTDATUM *)a;
  bp = (TCLISTDATUM *)b;
  ao = (unsigned char *)ap->ptr;
  bo = (unsigned char *)bp->ptr;
  if (ap->size < bp->size) {
    tmp = ap->size;
  } else {
    tmp = bp->size;
  }
  size = tmp;
  i = 0;
  while (i < size) {
    ac = (int )*(ao + i);
    ab = (_Bool)0;
    if (ac >= 65) {
      if (ac <= 90) {
        ac += 32;
        ab = (_Bool)1;
      }
    }
    bc = (int )*(bo + i);
    bb = (_Bool)0;
    if (bc >= 65) {
      if (bc <= 90) {
        bc += 32;
        bb = (_Bool)1;
      }
    }
    if (ac > bc) {
      return (1);
    }
    if (ac < bc) {
      return (-1);
    }
    if (! ab) {
      if (bb) {
        return (1);
      }
    }
    if (ab) {
      if (! bb) {
        return (-1);
      }
    }
    i ++;
  }
  return (ap->size - bp->size);
}
}
void tclistpushmalloc(TCLIST *list , void *ptr , int size ) 
{ int index___0 ;
  TCLISTDATUM *tmp ;
  void *tmp___0 ;
  TCLISTDATUM *array ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
  index___0 = list->start + list->num;
  if (index___0 >= list->anum) {
    list->anum += list->num + 1;
    while (1) {
      tmp___0 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
      tmp = (TCLISTDATUM *)tmp___0;
      list->array = tmp;
      if (! tmp) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  array = list->array;
  while (1) {
    tmp___2 = realloc(ptr, (unsigned int )(size + 1));
    tmp___1 = (char *)tmp___2;
    (array + index___0)->ptr = tmp___1;
    if (! tmp___1) {
      tcmyfatal("out of memory");
    }
    break;
  }
  *((array + index___0)->ptr + size) = (char )'\000';
  (array + index___0)->size = size;
  (list->num) ++;
  return;
}
}
void tclistsortci(TCLIST *list ) 
{ 

  {
  qsort((void *)(list->array + list->start), (unsigned int )list->num, (unsigned int )((int )sizeof(*(list->array + 0))),
        & tclistelemcmpci);
  return;
}
}
void tclistsortex(TCLIST *list , int (*cmp)(TCLISTDATUM const   * , TCLISTDATUM const   * ) ) 
{ 

  {
  qsort((void *)(list->array + list->start), (unsigned int )list->num, (unsigned int )((int )sizeof(*(list->array + 0))),
        (int (*)(void const   * , void const   * ))cmp);
  return;
}
}
void tclistinvert(TCLIST *list ) 
{ TCLISTDATUM *top ;
  TCLISTDATUM *bot ;
  TCLISTDATUM swap ;

  {
  top = list->array + list->start;
  bot = (top + list->num) - 1;
  while ((unsigned int )top < (unsigned int )bot) {
    swap = *top;
    *top = *bot;
    *bot = swap;
    top ++;
    bot --;
  }
  return;
}
}
void tclistprintf(TCLIST *list , char const   *format  , ...) 
{ TCXSTR *xstr ;
  TCXSTR *tmp ;
  va_list ap ;
  int size ;
  char *ptr ;
  void *tmp___0 ;

  {
  tmp = tcxstrnew();
  xstr = tmp;
  __builtin_va_start(ap, format);
  tcvxstrprintf(xstr, format, ap);
  __builtin_va_end(ap);
  size = xstr->size;
  tmp___0 = tcxstrtomalloc(xstr);
  ptr = (char *)tmp___0;
  tclistpushmalloc(list, (void *)ptr, size);
  return;
}
}
TCMAP *tcmapnew(void) 
{ TCMAP *tmp ;

  {
  tmp = tcmapnew2(4093U);
  return (tmp);
}
}
TCMAP *tcmapnew2(uint32_t bnum ) 
{ TCMAP *map ;
  void *tmp ;
  TCMAPREC **buckets ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  if (bnum < 1U) {
    bnum = 1U;
  }
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*map)));
    map = (TCMAP *)tmp;
    if (! map) {
      tcmyfatal("out of memory");
    }
    break;
  }
  if (bnum >= (unsigned int )(131072 / (int )sizeof(*buckets))) {
    tmp___0 = tczeromap((unsigned long long )(bnum * (unsigned int )((int )sizeof(*buckets))));
    buckets = (TCMAPREC **)tmp___0;
  } else {
    while (1) {
      tmp___1 = calloc(bnum, (unsigned int )((int )sizeof(*buckets)));
      buckets = (TCMAPREC **)tmp___1;
      if (! buckets) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  map->buckets = buckets;
  map->first = (TCMAPREC *)((void *)0);
  map->last = (TCMAPREC *)((void *)0);
  map->cur = (TCMAPREC *)((void *)0);
  map->bnum = bnum;
  map->rnum = 0ULL;
  map->msiz = 0ULL;
  return (map);
}
}
TCMAP *tcmapnew3(char const   *str  , ...) 
{ TCMAP *map ;
  TCMAP *tmp ;
  va_list ap ;
  char const   *key ;
  char const   *elem ;

  {
  tmp = tcmapnew2(31U);
  map = tmp;
  if (str) {
    __builtin_va_start(ap, str);
    key = str;
    while (1) {
      elem = __builtin_va_arg(ap, char *);
      if (! ((unsigned int )elem != (unsigned int )((void *)0))) {
        break;
      }
      if (key) {
        tcmapput2(map, key, elem);
        key = (char const   *)((void *)0);
      } else {
        key = elem;
      }
    }
    __builtin_va_end(ap);
  }
  return (map);
}
}
TCMAP *tcmapdup(TCMAP const   *map ) 
{ TCMAP *nmap ;
  long tmp ;
  long tmp___0 ;
  TCMAP *tmp___1 ;
  TCMAPREC *rec ;
  char *dbuf ;
  uint32_t rksiz ;

  {
  tmp = tclmax((long )map->bnum, (long )map->rnum);
  tmp___0 = tclmax(tmp, 4093L);
  tmp___1 = tcmapnew2((unsigned int )tmp___0);
  nmap = tmp___1;
  rec = (TCMAPREC *)map->first;
  while (rec) {
    dbuf = (char *)rec + (int )sizeof(*rec);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    tcmapput(nmap, (void const   *)dbuf, (int )rksiz, (void const   *)((dbuf + rksiz) + (((rksiz | (unsigned int )(~ (- ((int )sizeof(void *))))) + 1U) - rksiz)),
             rec->vsiz);
    rec = rec->next;
  }
  return (nmap);
}
}
void tcmapdel(TCMAP *map ) 
{ TCMAPREC *rec ;
  TCMAPREC *next ;

  {
  rec = map->first;
  while (rec) {
    next = rec->next;
    while (1) {
      free((void *)rec);
      break;
    }
    rec = next;
  }
  if (map->bnum >= (unsigned int )(131072 / (int )sizeof(*(map->buckets + 0)))) {
    tczerounmap((void *)map->buckets);
  } else {
    while (1) {
      free((void *)map->buckets);
      break;
    }
  }
  while (1) {
    free((void *)map);
    break;
  }
  return;
}
}
void tcmapput(TCMAP *map , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int bidx ;
  TCMAPREC *rec ;
  TCMAPREC **entp ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int psiz ;
  TCMAPREC *old ;
  void *tmp___6 ;
  int psiz___0 ;
  void *tmp___7 ;
  char *dbuf___0 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  bidx = (int )(hash % map->bnum);
  rec = *(map->buckets + bidx);
  entp = map->buckets + bidx;
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (hash < rhash) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          entp = & rec->left;
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            entp = & rec->right;
            rec = rec->right;
          } else {
            map->msiz += (unsigned long long )(vsiz - rec->vsiz);
            psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
            if (vsiz > rec->vsiz) {
              old = rec;
              while (1) {
                tmp___6 = realloc((void *)rec, (unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + vsiz) + 1));
                rec = (TCMAPREC *)tmp___6;
                if (! rec) {
                  tcmyfatal("out of memory");
                }
                break;
              }
              if ((unsigned int )rec != (unsigned int )old) {
                if ((unsigned int )map->first == (unsigned int )old) {
                  map->first = rec;
                }
                if ((unsigned int )map->last == (unsigned int )old) {
                  map->last = rec;
                }
                if ((unsigned int )map->cur == (unsigned int )old) {
                  map->cur = rec;
                }
                *entp = rec;
                if (rec->prev) {
                  (rec->prev)->next = rec;
                }
                if (rec->next) {
                  (rec->next)->prev = rec;
                }
                dbuf = (char *)rec + (int )sizeof(*rec);
              }
            }
            memcpy((void * __restrict  )((dbuf + ksiz) + psiz), (void const   * __restrict  )vbuf,
                   (unsigned int )vsiz);
            *(dbuf + ((ksiz + psiz) + vsiz)) = (char )'\000';
            rec->vsiz = vsiz;
            return;
          }
        }
      }
    }
  }
  psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  map->msiz += (unsigned long long )(ksiz + vsiz);
  while (1) {
    tmp___7 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz___0) + vsiz) + 1));
    rec = (TCMAPREC *)tmp___7;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = (int )((unsigned int )ksiz | hash);
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
         (unsigned int )vsiz);
  *(dbuf___0 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
  rec->vsiz = vsiz;
  rec->left = (struct _TCMAPREC *)((void *)0);
  rec->right = (struct _TCMAPREC *)((void *)0);
  rec->prev = map->last;
  rec->next = (struct _TCMAPREC *)((void *)0);
  *entp = rec;
  if (! map->first) {
    map->first = rec;
  }
  if (map->last) {
    (map->last)->next = rec;
  }
  map->last = rec;
  (map->rnum) ++;
  return;
}
}
void tcmapput2(TCMAP *map , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tcmapput(map, (void const   *)kstr, (int )tmp___0, (void const   *)vstr, (int )tmp);
  return;
}
}
_Bool tcmapputkeep(TCMAP *map , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int bidx ;
  TCMAPREC *rec ;
  TCMAPREC **entp ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int psiz ;
  void *tmp___6 ;
  char *dbuf___0 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  bidx = (int )(hash % map->bnum);
  rec = *(map->buckets + bidx);
  entp = map->buckets + bidx;
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (hash < rhash) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          entp = & rec->left;
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            entp = & rec->right;
            rec = rec->right;
          } else {
            return ((_Bool)0);
          }
        }
      }
    }
  }
  psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  map->msiz += (unsigned long long )(ksiz + vsiz);
  while (1) {
    tmp___6 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + vsiz) + 1));
    rec = (TCMAPREC *)tmp___6;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = (int )((unsigned int )ksiz | hash);
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz), (void const   * __restrict  )vbuf,
         (unsigned int )vsiz);
  *(dbuf___0 + ((ksiz + psiz) + vsiz)) = (char )'\000';
  rec->vsiz = vsiz;
  rec->left = (struct _TCMAPREC *)((void *)0);
  rec->right = (struct _TCMAPREC *)((void *)0);
  rec->prev = map->last;
  rec->next = (struct _TCMAPREC *)((void *)0);
  *entp = rec;
  if (! map->first) {
    map->first = rec;
  }
  if (map->last) {
    (map->last)->next = rec;
  }
  map->last = rec;
  (map->rnum) ++;
  return ((_Bool)1);
}
}
_Bool tcmapputkeep2(TCMAP *map , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcmapputkeep(map, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                         (int )tmp);
  return (tmp___1);
}
}
void tcmapputcat(TCMAP *map , void const   *kbuf , int ksiz , void const   *vbuf ,
                 int vsiz ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int bidx ;
  TCMAPREC *rec ;
  TCMAPREC **entp ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int psiz ;
  int asiz ;
  int unit ;
  int tmp___6 ;
  TCMAPREC *old ;
  void *tmp___7 ;
  int psiz___0 ;
  int asiz___0 ;
  int unit___0 ;
  int tmp___8 ;
  void *tmp___9 ;
  char *dbuf___0 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  bidx = (int )(hash % map->bnum);
  rec = *(map->buckets + bidx);
  entp = map->buckets + bidx;
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (hash < rhash) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          entp = & rec->left;
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            entp = & rec->right;
            rec = rec->right;
          } else {
            map->msiz += (unsigned long long )vsiz;
            psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
            asiz = (((((int )sizeof(*rec) + ksiz) + psiz) + rec->vsiz) + vsiz) + 1;
            if (asiz <= 52) {
              tmp___6 = 52;
            } else {
              tmp___6 = 252;
            }
            unit = tmp___6;
            asiz = ((asiz - 1) + unit) - (asiz - 1) % unit;
            old = rec;
            while (1) {
              tmp___7 = realloc((void *)rec, (unsigned int )asiz);
              rec = (TCMAPREC *)tmp___7;
              if (! rec) {
                tcmyfatal("out of memory");
              }
              break;
            }
            if ((unsigned int )rec != (unsigned int )old) {
              if ((unsigned int )map->first == (unsigned int )old) {
                map->first = rec;
              }
              if ((unsigned int )map->last == (unsigned int )old) {
                map->last = rec;
              }
              if ((unsigned int )map->cur == (unsigned int )old) {
                map->cur = rec;
              }
              *entp = rec;
              if (rec->prev) {
                (rec->prev)->next = rec;
              }
              if (rec->next) {
                (rec->next)->prev = rec;
              }
              dbuf = (char *)rec + (int )sizeof(*rec);
            }
            memcpy((void * __restrict  )(((dbuf + ksiz) + psiz) + rec->vsiz), (void const   * __restrict  )vbuf,
                   (unsigned int )vsiz);
            rec->vsiz += vsiz;
            *(dbuf + ((ksiz + psiz) + rec->vsiz)) = (char )'\000';
            return;
          }
        }
      }
    }
  }
  psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  asiz___0 = ((((int )sizeof(*rec) + ksiz) + psiz___0) + vsiz) + 1;
  if (asiz___0 <= 52) {
    tmp___8 = 52;
  } else {
    tmp___8 = 252;
  }
  unit___0 = tmp___8;
  asiz___0 = ((asiz___0 - 1) + unit___0) - (asiz___0 - 1) % unit___0;
  map->msiz += (unsigned long long )(ksiz + vsiz);
  while (1) {
    tmp___9 = malloc((unsigned int )asiz___0);
    rec = (TCMAPREC *)tmp___9;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = (int )((unsigned int )ksiz | hash);
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
         (unsigned int )vsiz);
  *(dbuf___0 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
  rec->vsiz = vsiz;
  rec->left = (struct _TCMAPREC *)((void *)0);
  rec->right = (struct _TCMAPREC *)((void *)0);
  rec->prev = map->last;
  rec->next = (struct _TCMAPREC *)((void *)0);
  *entp = rec;
  if (! map->first) {
    map->first = rec;
  }
  if (map->last) {
    (map->last)->next = rec;
  }
  map->last = rec;
  (map->rnum) ++;
  return;
}
}
void tcmapputcat2(TCMAP *map , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tcmapputcat(map, (void const   *)kstr, (int )tmp___0, (void const   *)vstr, (int )tmp);
  return;
}
}
_Bool tcmapout(TCMAP *map , void const   *kbuf , int ksiz ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int bidx ;
  TCMAPREC *rec ;
  TCMAPREC **entp ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  TCMAPREC *tmp___6 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  bidx = (int )(hash % map->bnum);
  rec = *(map->buckets + bidx);
  entp = map->buckets + bidx;
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (hash < rhash) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          entp = & rec->left;
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            entp = & rec->right;
            rec = rec->right;
          } else {
            (map->rnum) --;
            map->msiz -= (unsigned long long )(rksiz + (unsigned int )rec->vsiz);
            if (rec->prev) {
              (rec->prev)->next = rec->next;
            }
            if (rec->next) {
              (rec->next)->prev = rec->prev;
            }
            if ((unsigned int )rec == (unsigned int )map->first) {
              map->first = rec->next;
            }
            if ((unsigned int )rec == (unsigned int )map->last) {
              map->last = rec->prev;
            }
            if ((unsigned int )rec == (unsigned int )map->cur) {
              map->cur = rec->next;
            }
            if (rec->left) {
              if (! rec->right) {
                *entp = rec->left;
              } else {
                goto _L___1;
              }
            } else {
              _L___1: 
              if (! rec->left) {
                if (rec->right) {
                  *entp = rec->right;
                } else {
                  goto _L___0;
                }
              } else {
                _L___0: 
                if (! rec->left) {
                  if (! rec->left) {
                    *entp = (TCMAPREC *)((void *)0);
                  } else {
                    goto _L;
                  }
                } else {
                  _L: 
                  *entp = rec->left;
                  tmp___6 = *entp;
                  while (tmp___6->right) {
                    tmp___6 = tmp___6->right;
                  }
                  tmp___6->right = rec->right;
                }
              }
            }
            while (1) {
              free((void *)rec);
              break;
            }
            return ((_Bool)1);
          }
        }
      }
    }
  }
  return ((_Bool)0);
}
}
_Bool tcmapout2(TCMAP *map , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcmapout(map, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
void const   *tcmapget(TCMAP const   *map , void const   *kbuf , int ksiz , int *sp ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  TCMAPREC *rec ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  rec = *(map->buckets + hash % (unsigned int )map->bnum);
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      rec = rec->left;
    } else {
      if (hash < rhash) {
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            rec = rec->right;
          } else {
            *sp = rec->vsiz;
            return ((void const   *)((dbuf + rksiz) + (((rksiz | (unsigned int )(~ (- ((int )sizeof(void *))))) + 1U) - rksiz)));
          }
        }
      }
    }
  }
  return ((void const   *)((void *)0));
}
}
char const   *tcmapget2(TCMAP const   *map , char const   *kstr ) 
{ int ksiz ;
  size_t tmp ;
  uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;
  TCMAPREC *rec ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___2 ;
  int tmp___3 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  tmp = strlen(kstr);
  ksiz = (int )tmp;
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kstr;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___1 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___1) {
        break;
      }
      tmp___0 = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp___0;
    }
    break;
  }
  rec = *(map->buckets + hash % (unsigned int )map->bnum);
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kstr + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___3 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___3) {
        break;
      }
      tmp___2 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___2;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      rec = rec->left;
    } else {
      if (hash < rhash) {
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___6 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___5 = -1;
          } else {
            tmp___4 = memcmp((void const   *)kstr, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___5 = tmp___4;
          }
          tmp___6 = tmp___5;
        }
        kcmp = tmp___6;
        if (kcmp < 0) {
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            rec = rec->right;
          } else {
            return ((char const   *)((dbuf + rksiz) + (((rksiz | (unsigned int )(~ (- ((int )sizeof(void *))))) + 1U) - rksiz)));
          }
        }
      }
    }
  }
  return ((char const   *)((void *)0));
}
}
_Bool tcmapmove(TCMAP *map , void const   *kbuf , int ksiz , _Bool head ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  TCMAPREC *rec ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  rec = *(map->buckets + hash % map->bnum);
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      rec = rec->left;
    } else {
      if (hash < rhash) {
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            rec = rec->right;
          } else {
            if (head) {
              if ((unsigned int )map->first == (unsigned int )rec) {
                return ((_Bool)1);
              }
              if ((unsigned int )map->last == (unsigned int )rec) {
                map->last = rec->prev;
              }
              if (rec->prev) {
                (rec->prev)->next = rec->next;
              }
              if (rec->next) {
                (rec->next)->prev = rec->prev;
              }
              rec->prev = (struct _TCMAPREC *)((void *)0);
              rec->next = map->first;
              (map->first)->prev = rec;
              map->first = rec;
            } else {
              if ((unsigned int )map->last == (unsigned int )rec) {
                return ((_Bool)1);
              }
              if ((unsigned int )map->first == (unsigned int )rec) {
                map->first = rec->next;
              }
              if (rec->prev) {
                (rec->prev)->next = rec->next;
              }
              if (rec->next) {
                (rec->next)->prev = rec->prev;
              }
              rec->prev = map->last;
              rec->next = (struct _TCMAPREC *)((void *)0);
              (map->last)->next = rec;
              map->last = rec;
            }
            return ((_Bool)1);
          }
        }
      }
    }
  }
  return ((_Bool)0);
}
}
_Bool tcmapmove2(TCMAP *map , char const   *kstr , _Bool head ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcmapmove(map, (void const   *)kstr, (int )tmp, head);
  return (tmp___0);
}
}
void tcmapiterinit(TCMAP *map ) 
{ 

  {
  map->cur = map->first;
  return;
}
}
void const   *tcmapiternext(TCMAP *map , int *sp ) 
{ TCMAPREC *rec ;

  {
  if (! map->cur) {
    return ((void const   *)((void *)0));
  }
  rec = map->cur;
  map->cur = rec->next;
  *sp = rec->ksiz & 1048575;
  return ((void const   *)((char *)rec + (int )sizeof(*rec)));
}
}
char const   *tcmapiternext2(TCMAP *map ) 
{ TCMAPREC *rec ;

  {
  if (! map->cur) {
    return ((char const   *)((void *)0));
  }
  rec = map->cur;
  map->cur = rec->next;
  return ((char const   *)((char *)rec + (int )sizeof(*rec)));
}
}
uint64_t tcmaprnum(TCMAP const   *map ) 
{ 

  {
  return ((unsigned long long )map->rnum);
}
}
uint64_t tcmapmsiz(TCMAP const   *map ) 
{ 

  {
  return ((unsigned long long )((map->msiz + map->rnum * (unsigned long long const   )((int )sizeof(*(map->first)) + (int )sizeof(void *))) + (unsigned long long const   )(map->bnum * (unsigned int const   )((int )sizeof(void *)))));
}
}
TCLIST *tcmapkeys(TCMAP const   *map ) 
{ TCLIST *list ;
  TCLIST *tmp ;
  TCMAPREC *rec ;
  char *dbuf ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___0 ;
  void *tmp___1 ;
  TCLISTDATUM *array ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  tmp = tclistnew2((int )map->rnum);
  list = tmp;
  rec = (TCMAPREC *)map->first;
  while (rec) {
    dbuf = (char *)rec + (int )sizeof(*rec);
    while (1) {
      TC_mysize = rec->ksiz & 1048575;
      TC_index = list->start + list->num;
      if (TC_index >= list->anum) {
        list->anum += list->num + 1;
        while (1) {
          tmp___1 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
          tmp___0 = (TCLISTDATUM *)tmp___1;
          list->array = tmp___0;
          if (! tmp___0) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array = list->array;
      while (1) {
        tmp___3 = malloc((unsigned int )(TC_mysize + 1));
        tmp___2 = (char *)tmp___3;
        (array + TC_index)->ptr = tmp___2;
        if (! tmp___2) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )dbuf,
             (unsigned int )TC_mysize);
      *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
      (array + TC_index)->size = TC_mysize;
      (list->num) ++;
      break;
    }
    rec = rec->next;
  }
  return (list);
}
}
TCLIST *tcmapvals(TCMAP const   *map ) 
{ TCLIST *list ;
  TCLIST *tmp ;
  TCMAPREC *rec ;
  char *dbuf ;
  uint32_t rksiz ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___0 ;
  void *tmp___1 ;
  TCLISTDATUM *array ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  tmp = tclistnew2((int )map->rnum);
  list = tmp;
  rec = (TCMAPREC *)map->first;
  while (rec) {
    dbuf = (char *)rec + (int )sizeof(*rec);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    while (1) {
      TC_mysize = rec->vsiz;
      TC_index = list->start + list->num;
      if (TC_index >= list->anum) {
        list->anum += list->num + 1;
        while (1) {
          tmp___1 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
          tmp___0 = (TCLISTDATUM *)tmp___1;
          list->array = tmp___0;
          if (! tmp___0) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array = list->array;
      while (1) {
        tmp___3 = malloc((unsigned int )(TC_mysize + 1));
        tmp___2 = (char *)tmp___3;
        (array + TC_index)->ptr = tmp___2;
        if (! tmp___2) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )((dbuf + rksiz) + (((rksiz | (unsigned int )(~ (- ((int )sizeof(void *))))) + 1U) - rksiz)),
             (unsigned int )TC_mysize);
      *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
      (array + TC_index)->size = TC_mysize;
      (list->num) ++;
      break;
    }
    rec = rec->next;
  }
  return (list);
}
}
int tcmapaddint(TCMAP *map , void const   *kbuf , int ksiz , int num ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int bidx ;
  TCMAPREC *rec ;
  TCMAPREC **entp ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *resp ;
  int psiz ;
  void *tmp___6 ;
  char *dbuf___0 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  bidx = (int )(hash % map->bnum);
  rec = *(map->buckets + bidx);
  entp = map->buckets + bidx;
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (hash < rhash) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          entp = & rec->left;
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            entp = & rec->right;
            rec = rec->right;
          } else {
            if (rec->vsiz != (int )sizeof(num)) {
              return ((-0x7FFFFFFF-1));
            }
            resp = (int *)((dbuf + ksiz) + (((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz));
            *resp += num;
            return (*resp);
          }
        }
      }
    }
  }
  psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  while (1) {
    tmp___6 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + (int )sizeof(num)) + 1));
    rec = (TCMAPREC *)tmp___6;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = (int )((unsigned int )ksiz | hash);
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz), (void const   * __restrict  )(& num),
         (unsigned int )((int )sizeof(num)));
  *(dbuf___0 + ((ksiz + psiz) + (int )sizeof(num))) = (char )'\000';
  rec->vsiz = (int )sizeof(num);
  rec->left = (struct _TCMAPREC *)((void *)0);
  rec->right = (struct _TCMAPREC *)((void *)0);
  rec->prev = map->last;
  rec->next = (struct _TCMAPREC *)((void *)0);
  *entp = rec;
  if (! map->first) {
    map->first = rec;
  }
  if (map->last) {
    (map->last)->next = rec;
  }
  map->last = rec;
  (map->rnum) ++;
  return (num);
}
}
double tcmapadddouble(TCMAP *map , void const   *kbuf , int ksiz , double num ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int bidx ;
  TCMAPREC *rec ;
  TCMAPREC **entp ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double tmp___6 ;
  double *resp ;
  int psiz ;
  void *tmp___7 ;
  char *dbuf___0 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  bidx = (int )(hash % map->bnum);
  rec = *(map->buckets + bidx);
  entp = map->buckets + bidx;
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (hash < rhash) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          entp = & rec->left;
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            entp = & rec->right;
            rec = rec->right;
          } else {
            if (rec->vsiz != (int )sizeof(num)) {
              tmp___6 = nan("");
              return (tmp___6);
            }
            resp = (double *)((dbuf + ksiz) + (((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz));
            *resp += num;
            return (*resp);
          }
        }
      }
    }
  }
  psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  while (1) {
    tmp___7 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + (int )sizeof(num)) + 1));
    rec = (TCMAPREC *)tmp___7;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = (int )((unsigned int )ksiz | hash);
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz), (void const   * __restrict  )(& num),
         (unsigned int )((int )sizeof(num)));
  *(dbuf___0 + ((ksiz + psiz) + (int )sizeof(num))) = (char )'\000';
  rec->vsiz = (int )sizeof(num);
  rec->left = (struct _TCMAPREC *)((void *)0);
  rec->right = (struct _TCMAPREC *)((void *)0);
  rec->prev = map->last;
  rec->next = (struct _TCMAPREC *)((void *)0);
  *entp = rec;
  if (! map->first) {
    map->first = rec;
  }
  if (map->last) {
    (map->last)->next = rec;
  }
  map->last = rec;
  (map->rnum) ++;
  return (num);
}
}
void tcmapclear(TCMAP *map ) 
{ TCMAPREC *rec ;
  TCMAPREC *next ;
  TCMAPREC **buckets ;
  int bnum ;
  int i ;

  {
  rec = map->first;
  while (rec) {
    next = rec->next;
    while (1) {
      free((void *)rec);
      break;
    }
    rec = next;
  }
  buckets = map->buckets;
  bnum = (int )map->bnum;
  i = 0;
  while (i < bnum) {
    *(buckets + i) = (TCMAPREC *)((void *)0);
    i ++;
  }
  map->first = (TCMAPREC *)((void *)0);
  map->last = (TCMAPREC *)((void *)0);
  map->cur = (TCMAPREC *)((void *)0);
  map->rnum = 0ULL;
  map->msiz = 0ULL;
  return;
}
}
void tcmapcutfront(TCMAP *map , int num ) 
{ int ksiz ;
  char const   *kbuf ;
  void const   *tmp ;
  int tmp___0 ;

  {
  tcmapiterinit(map);
  while (1) {
    tmp___0 = num;
    num --;
    if (! (tmp___0 > 0)) {
      break;
    }
    tmp = tcmapiternext(map, & ksiz);
    kbuf = (char const   *)tmp;
    if (! kbuf) {
      break;
    }
    tcmapout(map, (void const   *)kbuf, ksiz);
  }
  return;
}
}
void *tcmapdump(TCMAP const   *map , int *sp ) 
{ int tsiz ;
  TCMAPREC *rec ;
  char *buf ;
  void *tmp ;
  char *wp ;
  char const   *kbuf ;
  int ksiz ;
  char const   *vbuf ;
  int vsiz ;
  int step ;
  int _TC_num ;
  int _TC_rem ;
  int _TC_num___0 ;
  int _TC_rem___0 ;

  {
  tsiz = 0;
  rec = (TCMAPREC *)map->first;
  while (rec) {
    tsiz += ((rec->ksiz & 1048575) + rec->vsiz) + (int )sizeof(int ) * 2;
    rec = rec->next;
  }
  while (1) {
    tmp = malloc((unsigned int )(tsiz + 1));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  rec = (TCMAPREC *)map->first;
  while (rec) {
    kbuf = (char const   *)((char *)rec + (int )sizeof(*rec));
    ksiz = rec->ksiz & 1048575;
    vbuf = (kbuf + ksiz) + (((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz);
    vsiz = rec->vsiz;
    while (1) {
      _TC_num = ksiz;
      if (_TC_num == 0) {
        *((signed char *)wp + 0) = (signed char)0;
        step = 1;
      } else {
        step = 0;
        while (_TC_num > 0) {
          _TC_rem = _TC_num & 127;
          _TC_num >>= 7;
          if (_TC_num > 0) {
            *((signed char *)wp + step) = (signed char )(- _TC_rem - 1);
          } else {
            *((signed char *)wp + step) = (signed char )_TC_rem;
          }
          step ++;
        }
      }
      break;
    }
    wp += step;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    wp += ksiz;
    while (1) {
      _TC_num___0 = vsiz;
      if (_TC_num___0 == 0) {
        *((signed char *)wp + 0) = (signed char)0;
        step = 1;
      } else {
        step = 0;
        while (_TC_num___0 > 0) {
          _TC_rem___0 = _TC_num___0 & 127;
          _TC_num___0 >>= 7;
          if (_TC_num___0 > 0) {
            *((signed char *)wp + step) = (signed char )(- _TC_rem___0 - 1);
          } else {
            *((signed char *)wp + step) = (signed char )_TC_rem___0;
          }
          step ++;
        }
      }
      break;
    }
    wp += step;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
    wp += vsiz;
    rec = rec->next;
  }
  *sp = wp - buf;
  return ((void *)buf);
}
}
TCMAP *tcmapload(void const   *ptr , int size ) 
{ TCMAP *map ;
  long tmp ;
  TCMAP *tmp___0 ;
  char const   *rp ;
  char const   *ep ;
  int step ;
  int ksiz ;
  int vsiz ;
  int _TC_base ;
  int _TC_i ;
  char const   *kbuf ;
  int _TC_base___0 ;
  int _TC_i___0 ;

  {
  tmp = tclmin((long )(size / 6 + 1), 4093L);
  tmp___0 = tcmapnew2((unsigned int )tmp);
  map = tmp___0;
  rp = (char const   *)ptr;
  ep = (char const   *)((char *)ptr + size);
  while ((unsigned int )rp < (unsigned int )ep) {
    while (1) {
      ksiz = 0;
      _TC_base = 1;
      _TC_i = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i) >= 0) {
          ksiz += (int )*((signed char *)rp + _TC_i) * _TC_base;
          break;
        }
        ksiz += (_TC_base * ((int )*((signed char *)rp + _TC_i) + 1)) * -1;
        _TC_base <<= 7;
        _TC_i ++;
      }
      step = _TC_i + 1;
      break;
    }
    rp += step;
    kbuf = rp;
    rp += ksiz;
    while (1) {
      vsiz = 0;
      _TC_base___0 = 1;
      _TC_i___0 = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i___0) >= 0) {
          vsiz += (int )*((signed char *)rp + _TC_i___0) * _TC_base___0;
          break;
        }
        vsiz += (_TC_base___0 * ((int )*((signed char *)rp + _TC_i___0) + 1)) * -1;
        _TC_base___0 <<= 7;
        _TC_i___0 ++;
      }
      step = _TC_i___0 + 1;
      break;
    }
    rp += step;
    tcmapputkeep(map, (void const   *)kbuf, ksiz, (void const   *)rp, vsiz);
    rp += vsiz;
  }
  return (map);
}
}
void tcmapput3(TCMAP *map , void const   *kbuf , int ksiz , char const   *vbuf , int vsiz ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int bidx ;
  TCMAPREC *rec ;
  TCMAPREC **entp ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int psiz ;
  TCMAPREC *old ;
  void *tmp___6 ;
  int psiz___0 ;
  void *tmp___7 ;
  char *dbuf___0 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  bidx = (int )(hash % map->bnum);
  rec = *(map->buckets + bidx);
  entp = map->buckets + bidx;
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (hash < rhash) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          entp = & rec->left;
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            entp = & rec->right;
            rec = rec->right;
          } else {
            map->msiz += (unsigned long long )(vsiz - rec->vsiz);
            psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
            if (vsiz > rec->vsiz) {
              old = rec;
              while (1) {
                tmp___6 = realloc((void *)rec, (unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + vsiz) + 1));
                rec = (TCMAPREC *)tmp___6;
                if (! rec) {
                  tcmyfatal("out of memory");
                }
                break;
              }
              if ((unsigned int )rec != (unsigned int )old) {
                if ((unsigned int )map->first == (unsigned int )old) {
                  map->first = rec;
                }
                if ((unsigned int )map->last == (unsigned int )old) {
                  map->last = rec;
                }
                if ((unsigned int )map->cur == (unsigned int )old) {
                  map->cur = rec;
                }
                *entp = rec;
                if (rec->prev) {
                  (rec->prev)->next = rec;
                }
                if (rec->next) {
                  (rec->next)->prev = rec;
                }
                dbuf = (char *)rec + (int )sizeof(*rec);
              }
            }
            memcpy((void * __restrict  )((dbuf + ksiz) + psiz), (void const   * __restrict  )vbuf,
                   (unsigned int )vsiz);
            *(dbuf + ((ksiz + psiz) + vsiz)) = (char )'\000';
            rec->vsiz = vsiz;
            if ((unsigned int )map->last != (unsigned int )rec) {
              if ((unsigned int )map->first == (unsigned int )rec) {
                map->first = rec->next;
              }
              if (rec->prev) {
                (rec->prev)->next = rec->next;
              }
              if (rec->next) {
                (rec->next)->prev = rec->prev;
              }
              rec->prev = map->last;
              rec->next = (struct _TCMAPREC *)((void *)0);
              (map->last)->next = rec;
              map->last = rec;
            }
            return;
          }
        }
      }
    }
  }
  psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  map->msiz += (unsigned long long )(ksiz + vsiz);
  while (1) {
    tmp___7 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz___0) + vsiz) + 1));
    rec = (TCMAPREC *)tmp___7;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = (int )((unsigned int )ksiz | hash);
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
         (unsigned int )vsiz);
  *(dbuf___0 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
  rec->vsiz = vsiz;
  rec->left = (struct _TCMAPREC *)((void *)0);
  rec->right = (struct _TCMAPREC *)((void *)0);
  rec->prev = map->last;
  rec->next = (struct _TCMAPREC *)((void *)0);
  *entp = rec;
  if (! map->first) {
    map->first = rec;
  }
  if (map->last) {
    (map->last)->next = rec;
  }
  map->last = rec;
  (map->rnum) ++;
  return;
}
}
void tcmapput4(TCMAP *map , void const   *kbuf , int ksiz , void const   *fvbuf ,
               int fvsiz , void const   *lvbuf , int lvsiz ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int bidx ;
  TCMAPREC *rec ;
  TCMAPREC **entp ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int vsiz ;
  int psiz ;
  TCMAPREC *old ;
  void *tmp___6 ;
  int vsiz___0 ;
  int psiz___0 ;
  void *tmp___7 ;
  char *dbuf___0 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  bidx = (int )(hash % map->bnum);
  rec = *(map->buckets + bidx);
  entp = map->buckets + bidx;
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (hash < rhash) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          entp = & rec->left;
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            entp = & rec->right;
            rec = rec->right;
          } else {
            vsiz = fvsiz + lvsiz;
            map->msiz += (unsigned long long )(vsiz - rec->vsiz);
            psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
            ksiz += psiz;
            if (vsiz > rec->vsiz) {
              old = rec;
              while (1) {
                tmp___6 = realloc((void *)rec, (unsigned int )((((int )sizeof(*rec) + ksiz) + vsiz) + 1));
                rec = (TCMAPREC *)tmp___6;
                if (! rec) {
                  tcmyfatal("out of memory");
                }
                break;
              }
              if ((unsigned int )rec != (unsigned int )old) {
                if ((unsigned int )map->first == (unsigned int )old) {
                  map->first = rec;
                }
                if ((unsigned int )map->last == (unsigned int )old) {
                  map->last = rec;
                }
                if ((unsigned int )map->cur == (unsigned int )old) {
                  map->cur = rec;
                }
                *entp = rec;
                if (rec->prev) {
                  (rec->prev)->next = rec;
                }
                if (rec->next) {
                  (rec->next)->prev = rec;
                }
                dbuf = (char *)rec + (int )sizeof(*rec);
              }
            }
            memcpy((void * __restrict  )(dbuf + ksiz), (void const   * __restrict  )fvbuf,
                   (unsigned int )fvsiz);
            memcpy((void * __restrict  )((dbuf + ksiz) + fvsiz), (void const   * __restrict  )lvbuf,
                   (unsigned int )lvsiz);
            *(dbuf + (ksiz + vsiz)) = (char )'\000';
            rec->vsiz = vsiz;
            return;
          }
        }
      }
    }
  }
  vsiz___0 = fvsiz + lvsiz;
  psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  map->msiz += (unsigned long long )(ksiz + vsiz___0);
  while (1) {
    tmp___7 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz___0) + vsiz___0) + 1));
    rec = (TCMAPREC *)tmp___7;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = (int )((unsigned int )ksiz | hash);
  ksiz += psiz___0;
  memcpy((void * __restrict  )(dbuf___0 + ksiz), (void const   * __restrict  )fvbuf,
         (unsigned int )fvsiz);
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + fvsiz), (void const   * __restrict  )lvbuf,
         (unsigned int )lvsiz);
  *(dbuf___0 + (ksiz + vsiz___0)) = (char )'\000';
  rec->vsiz = vsiz___0;
  rec->left = (struct _TCMAPREC *)((void *)0);
  rec->right = (struct _TCMAPREC *)((void *)0);
  rec->prev = map->last;
  rec->next = (struct _TCMAPREC *)((void *)0);
  *entp = rec;
  if (! map->first) {
    map->first = rec;
  }
  if (map->last) {
    (map->last)->next = rec;
  }
  map->last = rec;
  (map->rnum) ++;
  return;
}
}
void tcmapputcat3(TCMAP *map , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int bidx ;
  TCMAPREC *rec ;
  TCMAPREC **entp ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int psiz ;
  int asiz ;
  int unit ;
  int tmp___6 ;
  TCMAPREC *old ;
  void *tmp___7 ;
  int psiz___0 ;
  int asiz___0 ;
  int unit___0 ;
  int tmp___8 ;
  void *tmp___9 ;
  char *dbuf___0 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  bidx = (int )(hash % map->bnum);
  rec = *(map->buckets + bidx);
  entp = map->buckets + bidx;
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (hash < rhash) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          entp = & rec->left;
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            entp = & rec->right;
            rec = rec->right;
          } else {
            map->msiz += (unsigned long long )vsiz;
            psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
            asiz = (((((int )sizeof(*rec) + ksiz) + psiz) + rec->vsiz) + vsiz) + 1;
            if (asiz <= 52) {
              tmp___6 = 52;
            } else {
              tmp___6 = 252;
            }
            unit = tmp___6;
            asiz = ((asiz - 1) + unit) - (asiz - 1) % unit;
            old = rec;
            while (1) {
              tmp___7 = realloc((void *)rec, (unsigned int )asiz);
              rec = (TCMAPREC *)tmp___7;
              if (! rec) {
                tcmyfatal("out of memory");
              }
              break;
            }
            if ((unsigned int )rec != (unsigned int )old) {
              if ((unsigned int )map->first == (unsigned int )old) {
                map->first = rec;
              }
              if ((unsigned int )map->last == (unsigned int )old) {
                map->last = rec;
              }
              if ((unsigned int )map->cur == (unsigned int )old) {
                map->cur = rec;
              }
              *entp = rec;
              if (rec->prev) {
                (rec->prev)->next = rec;
              }
              if (rec->next) {
                (rec->next)->prev = rec;
              }
              dbuf = (char *)rec + (int )sizeof(*rec);
            }
            memcpy((void * __restrict  )(((dbuf + ksiz) + psiz) + rec->vsiz), (void const   * __restrict  )vbuf,
                   (unsigned int )vsiz);
            rec->vsiz += vsiz;
            *(dbuf + ((ksiz + psiz) + rec->vsiz)) = (char )'\000';
            if ((unsigned int )map->last != (unsigned int )rec) {
              if ((unsigned int )map->first == (unsigned int )rec) {
                map->first = rec->next;
              }
              if (rec->prev) {
                (rec->prev)->next = rec->next;
              }
              if (rec->next) {
                (rec->next)->prev = rec->prev;
              }
              rec->prev = map->last;
              rec->next = (struct _TCMAPREC *)((void *)0);
              (map->last)->next = rec;
              map->last = rec;
            }
            return;
          }
        }
      }
    }
  }
  psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  asiz___0 = ((((int )sizeof(*rec) + ksiz) + psiz___0) + vsiz) + 1;
  if (asiz___0 <= 52) {
    tmp___8 = 52;
  } else {
    tmp___8 = 252;
  }
  unit___0 = tmp___8;
  asiz___0 = ((asiz___0 - 1) + unit___0) - (asiz___0 - 1) % unit___0;
  map->msiz += (unsigned long long )(ksiz + vsiz);
  while (1) {
    tmp___9 = malloc((unsigned int )asiz___0);
    rec = (TCMAPREC *)tmp___9;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = (int )((unsigned int )ksiz | hash);
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
         (unsigned int )vsiz);
  *(dbuf___0 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
  rec->vsiz = vsiz;
  rec->left = (struct _TCMAPREC *)((void *)0);
  rec->right = (struct _TCMAPREC *)((void *)0);
  rec->prev = map->last;
  rec->next = (struct _TCMAPREC *)((void *)0);
  *entp = rec;
  if (! map->first) {
    map->first = rec;
  }
  if (map->last) {
    (map->last)->next = rec;
  }
  map->last = rec;
  (map->rnum) ++;
  return;
}
}
_Bool tcmapputproc(TCMAP *map , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int bidx ;
  TCMAPREC *rec ;
  TCMAPREC **entp ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int psiz ;
  int nvsiz ;
  char *nvbuf ;
  void *tmp___6 ;
  TCMAPREC *tmp___7 ;
  TCMAPREC *old ;
  void *tmp___8 ;
  int psiz___0 ;
  int asiz ;
  int unit ;
  int tmp___9 ;
  void *tmp___10 ;
  char *dbuf___0 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  bidx = (int )(hash % map->bnum);
  rec = *(map->buckets + bidx);
  entp = map->buckets + bidx;
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (hash < rhash) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          entp = & rec->left;
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            entp = & rec->right;
            rec = rec->right;
          } else {
            psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
            tmp___6 = (*proc___0)((void const   *)((dbuf + ksiz) + psiz), rec->vsiz,
                                  & nvsiz, op);
            nvbuf = (char *)tmp___6;
            if ((unsigned int )nvbuf == (unsigned int )((void *)-1)) {
              (map->rnum) --;
              map->msiz -= (unsigned long long )(rksiz + (unsigned int )rec->vsiz);
              if (rec->prev) {
                (rec->prev)->next = rec->next;
              }
              if (rec->next) {
                (rec->next)->prev = rec->prev;
              }
              if ((unsigned int )rec == (unsigned int )map->first) {
                map->first = rec->next;
              }
              if ((unsigned int )rec == (unsigned int )map->last) {
                map->last = rec->prev;
              }
              if ((unsigned int )rec == (unsigned int )map->cur) {
                map->cur = rec->next;
              }
              if (rec->left) {
                if (! rec->right) {
                  *entp = rec->left;
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: 
                if (! rec->left) {
                  if (rec->right) {
                    *entp = rec->right;
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: 
                  if (! rec->left) {
                    if (! rec->left) {
                      *entp = (TCMAPREC *)((void *)0);
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: 
                    *entp = rec->left;
                    tmp___7 = *entp;
                    while (tmp___7->right) {
                      tmp___7 = tmp___7->right;
                    }
                    tmp___7->right = rec->right;
                  }
                }
              }
              while (1) {
                free((void *)rec);
                break;
              }
              return ((_Bool)1);
            }
            if (! nvbuf) {
              return ((_Bool)0);
            }
            map->msiz += (unsigned long long )(nvsiz - rec->vsiz);
            if (nvsiz > rec->vsiz) {
              old = rec;
              while (1) {
                tmp___8 = realloc((void *)rec, (unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + nvsiz) + 1));
                rec = (TCMAPREC *)tmp___8;
                if (! rec) {
                  tcmyfatal("out of memory");
                }
                break;
              }
              if ((unsigned int )rec != (unsigned int )old) {
                if ((unsigned int )map->first == (unsigned int )old) {
                  map->first = rec;
                }
                if ((unsigned int )map->last == (unsigned int )old) {
                  map->last = rec;
                }
                if ((unsigned int )map->cur == (unsigned int )old) {
                  map->cur = rec;
                }
                *entp = rec;
                if (rec->prev) {
                  (rec->prev)->next = rec;
                }
                if (rec->next) {
                  (rec->next)->prev = rec;
                }
                dbuf = (char *)rec + (int )sizeof(*rec);
              }
            }
            memcpy((void * __restrict  )((dbuf + ksiz) + psiz), (void const   * __restrict  )nvbuf,
                   (unsigned int )nvsiz);
            *(dbuf + ((ksiz + psiz) + nvsiz)) = (char )'\000';
            rec->vsiz = nvsiz;
            while (1) {
              free((void *)nvbuf);
              break;
            }
            return ((_Bool)1);
          }
        }
      }
    }
  }
  if (! vbuf) {
    return ((_Bool)0);
  }
  psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  asiz = ((((int )sizeof(*rec) + ksiz) + psiz___0) + vsiz) + 1;
  if (asiz <= 52) {
    tmp___9 = 52;
  } else {
    tmp___9 = 252;
  }
  unit = tmp___9;
  asiz = ((asiz - 1) + unit) - (asiz - 1) % unit;
  map->msiz += (unsigned long long )(ksiz + vsiz);
  while (1) {
    tmp___10 = malloc((unsigned int )asiz);
    rec = (TCMAPREC *)tmp___10;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = (int )((unsigned int )ksiz | hash);
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
         (unsigned int )vsiz);
  *(dbuf___0 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
  rec->vsiz = vsiz;
  rec->left = (struct _TCMAPREC *)((void *)0);
  rec->right = (struct _TCMAPREC *)((void *)0);
  rec->prev = map->last;
  rec->next = (struct _TCMAPREC *)((void *)0);
  *entp = rec;
  if (! map->first) {
    map->first = rec;
  }
  if (map->last) {
    (map->last)->next = rec;
  }
  map->last = rec;
  (map->rnum) ++;
  return ((_Bool)1);
}
}
void const   *tcmapget3(TCMAP *map , void const   *kbuf , int ksiz , int *sp ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  TCMAPREC *rec ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  rec = *(map->buckets + hash % map->bnum);
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      rec = rec->left;
    } else {
      if (hash < rhash) {
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            rec = rec->right;
          } else {
            if ((unsigned int )map->last != (unsigned int )rec) {
              if ((unsigned int )map->first == (unsigned int )rec) {
                map->first = rec->next;
              }
              if (rec->prev) {
                (rec->prev)->next = rec->next;
              }
              if (rec->next) {
                (rec->next)->prev = rec->prev;
              }
              rec->prev = map->last;
              rec->next = (struct _TCMAPREC *)((void *)0);
              (map->last)->next = rec;
              map->last = rec;
            }
            *sp = rec->vsiz;
            return ((void const   *)((dbuf + rksiz) + (((rksiz | (unsigned int )(~ (- ((int )sizeof(void *))))) + 1U) - rksiz)));
          }
        }
      }
    }
  }
  return ((void const   *)((void *)0));
}
}
char const   *tcmapget4(TCMAP *map , char const   *kstr , char const   *dstr ) 
{ int vsiz ;
  char const   *vbuf ;
  size_t tmp ;
  void const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcmapget((TCMAP const   *)map, (void const   *)kstr, (int )tmp, & vsiz);
  vbuf = (char const   *)tmp___0;
  if (vbuf) {
    tmp___1 = vbuf;
  } else {
    tmp___1 = dstr;
  }
  return (tmp___1);
}
}
void tcmapiterinit2(TCMAP *map , void const   *kbuf , int ksiz ) 
{ uint32_t hash ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  TCMAPREC *rec ;
  unsigned char const   *_TC_p___0 ;
  int _TC_ksiz___0 ;
  unsigned char const   *tmp___1 ;
  int tmp___2 ;
  uint32_t rhash ;
  uint32_t rksiz ;
  char *dbuf ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (ksiz > 1048575) {
    ksiz = 1048575;
  }
  while (1) {
    _TC_p = (unsigned char const   *)kbuf;
    _TC_ksiz = ksiz;
    hash = 19780211U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p ++;
      hash = hash * 37U + (unsigned int )*tmp;
    }
    break;
  }
  rec = *(map->buckets + hash % map->bnum);
  while (1) {
    _TC_p___0 = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz___0 = ksiz;
    hash = 324508639U;
    while (1) {
      tmp___2 = _TC_ksiz___0;
      _TC_ksiz___0 --;
      if (! tmp___2) {
        break;
      }
      tmp___1 = _TC_p___0;
      _TC_p___0 --;
      hash = hash * 31U + (unsigned int )*tmp___1;
    }
    break;
  }
  hash &= 4293918720U;
  while (rec) {
    rhash = (unsigned int )(rec->ksiz & -1048576);
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    if (hash > rhash) {
      rec = rec->left;
    } else {
      if (hash < rhash) {
        rec = rec->right;
      } else {
        dbuf = (char *)rec + (int )sizeof(*rec);
        if ((unsigned int )ksiz > rksiz) {
          tmp___5 = 1;
        } else {
          if ((unsigned int )ksiz < rksiz) {
            tmp___4 = -1;
          } else {
            tmp___3 = memcmp(kbuf, (void const   *)dbuf, (unsigned int )ksiz);
            tmp___4 = tmp___3;
          }
          tmp___5 = tmp___4;
        }
        kcmp = tmp___5;
        if (kcmp < 0) {
          rec = rec->left;
        } else {
          if (kcmp > 0) {
            rec = rec->right;
          } else {
            map->cur = rec;
            return;
          }
        }
      }
    }
  }
  return;
}
}
void tcmapiterinit3(TCMAP *map , char const   *kstr ) 
{ size_t tmp ;

  {
  tmp = strlen(kstr);
  tcmapiterinit2(map, (void const   *)kstr, (int )tmp);
  return;
}
}
void const   *tcmapiterval(void const   *kbuf , int *sp ) 
{ TCMAPREC *rec ;
  uint32_t rksiz ;

  {
  rec = (TCMAPREC *)((char *)kbuf - (int )sizeof(*rec));
  rksiz = (unsigned int )(rec->ksiz & 1048575);
  *sp = rec->vsiz;
  return ((void const   *)(((char *)kbuf + rksiz) + (((rksiz | (unsigned int )(~ (- ((int )sizeof(void *))))) + 1U) - rksiz)));
}
}
char const   *tcmapiterval2(char const   *kstr ) 
{ TCMAPREC *rec ;
  uint32_t rksiz ;

  {
  rec = (TCMAPREC *)(kstr - (int )sizeof(*rec));
  rksiz = (unsigned int )(rec->ksiz & 1048575);
  return ((kstr + rksiz) + (((rksiz | (unsigned int )(~ (- ((int )sizeof(void *))))) + 1U) - rksiz));
}
}
char const   **tcmapkeys2(TCMAP const   *map , int *np ) 
{ char const   **ary ;
  void *tmp ;
  int anum ;
  TCMAPREC *rec ;
  int tmp___0 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*ary)) * map->rnum + 1ULL));
    ary = (char const   **)tmp;
    if (! ary) {
      tcmyfatal("out of memory");
    }
    break;
  }
  anum = 0;
  rec = (TCMAPREC *)map->first;
  while (rec) {
    tmp___0 = anum;
    anum ++;
    *(ary + tmp___0) = (char const   *)((char *)rec + (int )sizeof(*rec));
    rec = rec->next;
  }
  *np = anum;
  return (ary);
}
}
char const   **tcmapvals2(TCMAP const   *map , int *np ) 
{ char const   **ary ;
  void *tmp ;
  int anum ;
  TCMAPREC *rec ;
  uint32_t rksiz ;
  int tmp___0 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*ary)) * map->rnum + 1ULL));
    ary = (char const   **)tmp;
    if (! ary) {
      tcmyfatal("out of memory");
    }
    break;
  }
  anum = 0;
  rec = (TCMAPREC *)map->first;
  while (rec) {
    rksiz = (unsigned int )(rec->ksiz & 1048575);
    tmp___0 = anum;
    anum ++;
    *(ary + tmp___0) = (char const   *)((((char *)rec + (int )sizeof(*rec)) + rksiz) + (((rksiz | (unsigned int )(~ (- ((int )sizeof(void *))))) + 1U) - rksiz));
    rec = rec->next;
  }
  *np = anum;
  return (ary);
}
}
void *tcmaploadone(void const   *ptr , int size , void const   *kbuf , int ksiz ,
                   int *sp ) 
{ char const   *rp ;
  char const   *ep ;
  int step ;
  int rsiz ;
  int _TC_base ;
  int _TC_i ;
  int _TC_base___0 ;
  int _TC_i___0 ;
  char *rv ;
  void *tmp ;
  int tmp___0 ;
  int _TC_base___1 ;
  int _TC_i___1 ;

  {
  rp = (char const   *)ptr;
  ep = (char const   *)((char *)ptr + size);
  while ((unsigned int )rp < (unsigned int )ep) {
    while (1) {
      rsiz = 0;
      _TC_base = 1;
      _TC_i = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i) >= 0) {
          rsiz += (int )*((signed char *)rp + _TC_i) * _TC_base;
          break;
        }
        rsiz += (_TC_base * ((int )*((signed char *)rp + _TC_i) + 1)) * -1;
        _TC_base <<= 7;
        _TC_i ++;
      }
      step = _TC_i + 1;
      break;
    }
    rp += step;
    if (rsiz == ksiz) {
      tmp___0 = memcmp(kbuf, (void const   *)rp, (unsigned int )rsiz);
      if (! tmp___0) {
        rp += rsiz;
        while (1) {
          rsiz = 0;
          _TC_base___0 = 1;
          _TC_i___0 = 0;
          while (1) {
            if ((int )*((signed char *)rp + _TC_i___0) >= 0) {
              rsiz += (int )*((signed char *)rp + _TC_i___0) * _TC_base___0;
              break;
            }
            rsiz += (_TC_base___0 * ((int )*((signed char *)rp + _TC_i___0) + 1)) * -1;
            _TC_base___0 <<= 7;
            _TC_i___0 ++;
          }
          step = _TC_i___0 + 1;
          break;
        }
        rp += step;
        *sp = rsiz;
        while (1) {
          while (1) {
            tmp = malloc((unsigned int )(rsiz + 1));
            rv = (char *)tmp;
            if (! rv) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )rv, (void const   * __restrict  )rp, (unsigned int )rsiz);
          *(rv + rsiz) = (char )'\000';
          break;
        }
        return ((void *)rv);
      }
    }
    rp += rsiz;
    while (1) {
      rsiz = 0;
      _TC_base___1 = 1;
      _TC_i___1 = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i___1) >= 0) {
          rsiz += (int )*((signed char *)rp + _TC_i___1) * _TC_base___1;
          break;
        }
        rsiz += (_TC_base___1 * ((int )*((signed char *)rp + _TC_i___1) + 1)) * -1;
        _TC_base___1 <<= 7;
        _TC_i___1 ++;
      }
      step = _TC_i___1 + 1;
      break;
    }
    rp += step;
    rp += rsiz;
  }
  return ((void *)0);
}
}
void tcmapprintf(TCMAP *map , char const   *kstr , char const   *format  , ...) 
{ TCXSTR *xstr ;
  TCXSTR *tmp ;
  va_list ap ;
  size_t tmp___0 ;

  {
  tmp = tcxstrnew();
  xstr = tmp;
  __builtin_va_start(ap, format);
  tcvxstrprintf(xstr, format, ap);
  __builtin_va_end(ap);
  tmp___0 = strlen(kstr);
  tcmapput(map, (void const   *)kstr, (int )tmp___0, (void const   *)xstr->ptr, xstr->size);
  tcxstrdel(xstr);
  return;
}
}
static TCTREEREC *tctreesplay(TCTREE *tree , void const   *kbuf , int ksiz ) ;
TCTREE *tctreenew(void) 
{ TCTREE *tmp ;

  {
  tmp = tctreenew2(& tccmplexical, (void *)0);
  return (tmp);
}
}
TCTREE *tctreenew2(int (*cmp)(char const   *aptr , int asiz , char const   *bptr ,
                              int bsiz , void *op ) , void *cmpop ) 
{ TCTREE *tree ;
  void *tmp ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*tree)));
    tree = (TCTREE *)tmp;
    if (! tree) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tree->root = (TCTREEREC *)((void *)0);
  tree->cur = (TCTREEREC *)((void *)0);
  tree->rnum = 0ULL;
  tree->msiz = 0ULL;
  tree->cmp = cmp;
  tree->cmpop = cmpop;
  return (tree);
}
}
TCTREE *tctreedup(TCTREE const   *tree ) 
{ TCTREE *ntree ;
  TCTREE *tmp ;
  TCTREEREC *histbuf[2048] ;
  TCTREEREC **history ;
  int hnum ;
  int tmp___0 ;
  TCTREEREC *rec ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *dbuf ;

  {
  tmp = tctreenew2((int (*)(char const   *aptr , int asiz , char const   *bptr , int bsiz ,
                            void *op ))tree->cmp, (void *)tree->cmpop);
  ntree = tmp;
  if (tree->root) {
    history = histbuf;
    hnum = 0;
    tmp___0 = hnum;
    hnum ++;
    *(history + tmp___0) = (TCTREEREC *)tree->root;
    while (hnum > 0) {
      hnum --;
      rec = *(history + hnum);
      if (hnum >= 2046) {
        if ((unsigned int )history == (unsigned int )(histbuf)) {
          while (1) {
            tmp___1 = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*history)) * tree->rnum));
            history = (TCTREEREC **)tmp___1;
            if (! history) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )history, (void const   * __restrict  )(histbuf),
                 (unsigned int )((int )sizeof(*history) * hnum));
        }
      }
      if (rec->left) {
        tmp___2 = hnum;
        hnum ++;
        *(history + tmp___2) = rec->left;
      }
      if (rec->right) {
        tmp___3 = hnum;
        hnum ++;
        *(history + tmp___3) = rec->right;
      }
      dbuf = (char *)rec + (int )sizeof(*rec);
      tctreeput(ntree, (void const   *)dbuf, rec->ksiz, (void const   *)((dbuf + rec->ksiz) + (((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz)),
                rec->vsiz);
    }
    if ((unsigned int )history != (unsigned int )(histbuf)) {
      while (1) {
        free((void *)history);
        break;
      }
    }
  }
  return (ntree);
}
}
void tctreedel(TCTREE *tree ) 
{ TCTREEREC *histbuf[2048] ;
  TCTREEREC **history ;
  int hnum ;
  int tmp ;
  TCTREEREC *rec ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (tree->root) {
    history = histbuf;
    hnum = 0;
    tmp = hnum;
    hnum ++;
    *(history + tmp) = tree->root;
    while (hnum > 0) {
      hnum --;
      rec = *(history + hnum);
      if (hnum >= 2046) {
        if ((unsigned int )history == (unsigned int )(histbuf)) {
          while (1) {
            tmp___0 = malloc((unsigned int )((unsigned long long )((int )sizeof(*history)) * tree->rnum));
            history = (TCTREEREC **)tmp___0;
            if (! history) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )history, (void const   * __restrict  )(histbuf),
                 (unsigned int )((int )sizeof(*history) * hnum));
        }
      }
      if (rec->left) {
        tmp___1 = hnum;
        hnum ++;
        *(history + tmp___1) = rec->left;
      }
      if (rec->right) {
        tmp___2 = hnum;
        hnum ++;
        *(history + tmp___2) = rec->right;
      }
      while (1) {
        free((void *)rec);
        break;
      }
    }
    if ((unsigned int )history != (unsigned int )(histbuf)) {
      while (1) {
        free((void *)history);
        break;
      }
    }
  }
  while (1) {
    free((void *)tree);
    break;
  }
  return;
}
}
void tctreeput(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
               int vsiz ) 
{ TCTREEREC *top ;
  TCTREEREC *tmp ;
  int psiz ;
  TCTREEREC *rec ;
  void *tmp___0 ;
  char *dbuf ;
  char *dbuf___0 ;
  int cv ;
  int tmp___1 ;
  int psiz___0 ;
  TCTREEREC *rec___0 ;
  void *tmp___2 ;
  int psiz___1 ;
  TCTREEREC *rec___1 ;
  void *tmp___3 ;
  int psiz___2 ;
  TCTREEREC *old ;
  void *tmp___4 ;

  {
  tmp = tctreesplay(tree, kbuf, ksiz);
  top = tmp;
  if (! top) {
    psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___0 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + vsiz) + 1));
      rec = (TCTREEREC *)tmp___0;
      if (! rec) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf = (char *)rec + (int )sizeof(*rec);
    memcpy((void * __restrict  )dbuf, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf + ksiz) = (char )'\000';
    rec->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf + ksiz) + psiz), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf + ((ksiz + psiz) + vsiz)) = (char )'\000';
    rec->vsiz = vsiz;
    rec->left = (struct _TCTREEREC *)((void *)0);
    rec->right = (struct _TCTREEREC *)((void *)0);
    tree->root = rec;
    tree->rnum = 1ULL;
    tree->msiz = (unsigned long long )(ksiz + vsiz);
    return;
  }
  dbuf___0 = (char *)top + (int )sizeof(*top);
  tmp___1 = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf___0, top->ksiz,
                           tree->cmpop);
  cv = tmp___1;
  if (cv < 0) {
    psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___2 = malloc((unsigned int )(((((int )sizeof(*rec___0) + ksiz) + psiz___0) + vsiz) + 1));
      rec___0 = (TCTREEREC *)tmp___2;
      if (! rec___0) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf___0 = (char *)rec___0 + (int )sizeof(*rec___0);
    memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf___0 + ksiz) = (char )'\000';
    rec___0->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf___0 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
    rec___0->vsiz = vsiz;
    rec___0->left = top->left;
    rec___0->right = top;
    top->left = (struct _TCTREEREC *)((void *)0);
    (tree->rnum) ++;
    tree->msiz += (unsigned long long )(ksiz + vsiz);
    tree->root = rec___0;
  } else {
    if (cv > 0) {
      psiz___1 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
      while (1) {
        tmp___3 = malloc((unsigned int )(((((int )sizeof(*rec___1) + ksiz) + psiz___1) + vsiz) + 1));
        rec___1 = (TCTREEREC *)tmp___3;
        if (! rec___1) {
          tcmyfatal("out of memory");
        }
        break;
      }
      dbuf___0 = (char *)rec___1 + (int )sizeof(*rec___1);
      memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      *(dbuf___0 + ksiz) = (char )'\000';
      rec___1->ksiz = ksiz;
      memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___1), (void const   * __restrict  )vbuf,
             (unsigned int )vsiz);
      *(dbuf___0 + ((ksiz + psiz___1) + vsiz)) = (char )'\000';
      rec___1->vsiz = vsiz;
      rec___1->left = top;
      rec___1->right = top->right;
      top->right = (struct _TCTREEREC *)((void *)0);
      (tree->rnum) ++;
      tree->msiz += (unsigned long long )(ksiz + vsiz);
      tree->root = rec___1;
    } else {
      tree->msiz += (unsigned long long )(vsiz - top->vsiz);
      psiz___2 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
      if (vsiz > top->vsiz) {
        old = top;
        while (1) {
          tmp___4 = realloc((void *)top, (unsigned int )(((((int )sizeof(*top) + ksiz) + psiz___2) + vsiz) + 1));
          top = (TCTREEREC *)tmp___4;
          if (! top) {
            tcmyfatal("out of memory");
          }
          break;
        }
        if ((unsigned int )top != (unsigned int )old) {
          if ((unsigned int )tree->cur == (unsigned int )old) {
            tree->cur = top;
          }
          dbuf___0 = (char *)top + (int )sizeof(*top);
        }
      }
      memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___2), (void const   * __restrict  )vbuf,
             (unsigned int )vsiz);
      *(dbuf___0 + ((ksiz + psiz___2) + vsiz)) = (char )'\000';
      top->vsiz = vsiz;
      tree->root = top;
    }
  }
  return;
}
}
void tctreeput2(TCTREE *tree , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tctreeput(tree, (void const   *)kstr, (int )tmp___0, (void const   *)vstr, (int )tmp);
  return;
}
}
_Bool tctreeputkeep(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                    int vsiz ) 
{ TCTREEREC *top ;
  TCTREEREC *tmp ;
  int psiz ;
  TCTREEREC *rec ;
  void *tmp___0 ;
  char *dbuf ;
  char *dbuf___0 ;
  int cv ;
  int tmp___1 ;
  int psiz___0 ;
  TCTREEREC *rec___0 ;
  void *tmp___2 ;
  int psiz___1 ;
  TCTREEREC *rec___1 ;
  void *tmp___3 ;

  {
  tmp = tctreesplay(tree, kbuf, ksiz);
  top = tmp;
  if (! top) {
    psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___0 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + vsiz) + 1));
      rec = (TCTREEREC *)tmp___0;
      if (! rec) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf = (char *)rec + (int )sizeof(*rec);
    memcpy((void * __restrict  )dbuf, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf + ksiz) = (char )'\000';
    rec->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf + ksiz) + psiz), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf + ((ksiz + psiz) + vsiz)) = (char )'\000';
    rec->vsiz = vsiz;
    rec->left = (struct _TCTREEREC *)((void *)0);
    rec->right = (struct _TCTREEREC *)((void *)0);
    tree->root = rec;
    tree->rnum = 1ULL;
    tree->msiz = (unsigned long long )(ksiz + vsiz);
    return ((_Bool)1);
  }
  dbuf___0 = (char *)top + (int )sizeof(*top);
  tmp___1 = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf___0, top->ksiz,
                           tree->cmpop);
  cv = tmp___1;
  if (cv < 0) {
    psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___2 = malloc((unsigned int )(((((int )sizeof(*rec___0) + ksiz) + psiz___0) + vsiz) + 1));
      rec___0 = (TCTREEREC *)tmp___2;
      if (! rec___0) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf___0 = (char *)rec___0 + (int )sizeof(*rec___0);
    memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf___0 + ksiz) = (char )'\000';
    rec___0->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf___0 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
    rec___0->vsiz = vsiz;
    rec___0->left = top->left;
    rec___0->right = top;
    top->left = (struct _TCTREEREC *)((void *)0);
    (tree->rnum) ++;
    tree->msiz += (unsigned long long )(ksiz + vsiz);
    tree->root = rec___0;
  } else {
    if (cv > 0) {
      psiz___1 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
      while (1) {
        tmp___3 = malloc((unsigned int )(((((int )sizeof(*rec___1) + ksiz) + psiz___1) + vsiz) + 1));
        rec___1 = (TCTREEREC *)tmp___3;
        if (! rec___1) {
          tcmyfatal("out of memory");
        }
        break;
      }
      dbuf___0 = (char *)rec___1 + (int )sizeof(*rec___1);
      memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      *(dbuf___0 + ksiz) = (char )'\000';
      rec___1->ksiz = ksiz;
      memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___1), (void const   * __restrict  )vbuf,
             (unsigned int )vsiz);
      *(dbuf___0 + ((ksiz + psiz___1) + vsiz)) = (char )'\000';
      rec___1->vsiz = vsiz;
      rec___1->left = top;
      rec___1->right = top->right;
      top->right = (struct _TCTREEREC *)((void *)0);
      (tree->rnum) ++;
      tree->msiz += (unsigned long long )(ksiz + vsiz);
      tree->root = rec___1;
    } else {
      tree->root = top;
      return ((_Bool)0);
    }
  }
  return ((_Bool)1);
}
}
_Bool tctreeputkeep2(TCTREE *tree , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tctreeputkeep(tree, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                          (int )tmp);
  return (tmp___1);
}
}
void tctreeputcat(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) 
{ TCTREEREC *top ;
  TCTREEREC *tmp ;
  int psiz ;
  TCTREEREC *rec ;
  void *tmp___0 ;
  char *dbuf ;
  char *dbuf___0 ;
  int cv ;
  int tmp___1 ;
  int psiz___0 ;
  TCTREEREC *rec___0 ;
  void *tmp___2 ;
  int psiz___1 ;
  TCTREEREC *rec___1 ;
  void *tmp___3 ;
  int psiz___2 ;
  int asiz ;
  int unit ;
  int tmp___4 ;
  TCTREEREC *old ;
  void *tmp___5 ;

  {
  tmp = tctreesplay(tree, kbuf, ksiz);
  top = tmp;
  if (! top) {
    psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___0 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + vsiz) + 1));
      rec = (TCTREEREC *)tmp___0;
      if (! rec) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf = (char *)rec + (int )sizeof(*rec);
    memcpy((void * __restrict  )dbuf, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf + ksiz) = (char )'\000';
    rec->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf + ksiz) + psiz), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf + ((ksiz + psiz) + vsiz)) = (char )'\000';
    rec->vsiz = vsiz;
    rec->left = (struct _TCTREEREC *)((void *)0);
    rec->right = (struct _TCTREEREC *)((void *)0);
    tree->root = rec;
    tree->rnum = 1ULL;
    tree->msiz = (unsigned long long )(ksiz + vsiz);
    return;
  }
  dbuf___0 = (char *)top + (int )sizeof(*top);
  tmp___1 = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf___0, top->ksiz,
                           tree->cmpop);
  cv = tmp___1;
  if (cv < 0) {
    psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___2 = malloc((unsigned int )(((((int )sizeof(*rec___0) + ksiz) + psiz___0) + vsiz) + 1));
      rec___0 = (TCTREEREC *)tmp___2;
      if (! rec___0) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf___0 = (char *)rec___0 + (int )sizeof(*rec___0);
    memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf___0 + ksiz) = (char )'\000';
    rec___0->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf___0 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
    rec___0->vsiz = vsiz;
    rec___0->left = top->left;
    rec___0->right = top;
    top->left = (struct _TCTREEREC *)((void *)0);
    (tree->rnum) ++;
    tree->msiz += (unsigned long long )(ksiz + vsiz);
    tree->root = rec___0;
  } else {
    if (cv > 0) {
      psiz___1 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
      while (1) {
        tmp___3 = malloc((unsigned int )(((((int )sizeof(*rec___1) + ksiz) + psiz___1) + vsiz) + 1));
        rec___1 = (TCTREEREC *)tmp___3;
        if (! rec___1) {
          tcmyfatal("out of memory");
        }
        break;
      }
      dbuf___0 = (char *)rec___1 + (int )sizeof(*rec___1);
      memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      *(dbuf___0 + ksiz) = (char )'\000';
      rec___1->ksiz = ksiz;
      memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___1), (void const   * __restrict  )vbuf,
             (unsigned int )vsiz);
      *(dbuf___0 + ((ksiz + psiz___1) + vsiz)) = (char )'\000';
      rec___1->vsiz = vsiz;
      rec___1->left = top;
      rec___1->right = top->right;
      top->right = (struct _TCTREEREC *)((void *)0);
      (tree->rnum) ++;
      tree->msiz += (unsigned long long )(ksiz + vsiz);
      tree->root = rec___1;
    } else {
      tree->msiz += (unsigned long long )vsiz;
      psiz___2 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
      asiz = (((((int )sizeof(*top) + ksiz) + psiz___2) + top->vsiz) + vsiz) + 1;
      if (asiz <= 52) {
        tmp___4 = 52;
      } else {
        tmp___4 = 252;
      }
      unit = tmp___4;
      asiz = ((asiz - 1) + unit) - (asiz - 1) % unit;
      old = top;
      while (1) {
        tmp___5 = realloc((void *)top, (unsigned int )asiz);
        top = (TCTREEREC *)tmp___5;
        if (! top) {
          tcmyfatal("out of memory");
        }
        break;
      }
      if ((unsigned int )top != (unsigned int )old) {
        if ((unsigned int )tree->cur == (unsigned int )old) {
          tree->cur = top;
        }
        dbuf___0 = (char *)top + (int )sizeof(*top);
      }
      memcpy((void * __restrict  )(((dbuf___0 + ksiz) + psiz___2) + top->vsiz), (void const   * __restrict  )vbuf,
             (unsigned int )vsiz);
      top->vsiz += vsiz;
      *(dbuf___0 + ((ksiz + psiz___2) + top->vsiz)) = (char )'\000';
      tree->root = top;
    }
  }
  return;
}
}
void tctreeputcat2(TCTREE *tree , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tctreeputcat(tree, (void const   *)kstr, (int )tmp___0, (void const   *)vstr, (int )tmp);
  return;
}
}
_Bool tctreeputproc(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                    int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                 void *op ) , void *op ) 
{ TCTREEREC *top ;
  TCTREEREC *tmp ;
  int psiz ;
  TCTREEREC *rec ;
  void *tmp___0 ;
  char *dbuf ;
  char *dbuf___0 ;
  int cv ;
  int tmp___1 ;
  int psiz___0 ;
  TCTREEREC *rec___0 ;
  void *tmp___2 ;
  int psiz___1 ;
  TCTREEREC *rec___1 ;
  void *tmp___3 ;
  int psiz___2 ;
  int nvsiz ;
  char *nvbuf ;
  void *tmp___4 ;
  TCTREEREC *rec___2 ;
  TCTREEREC *rec___3 ;
  TCTREEREC *tmp___5 ;
  TCTREEREC *old ;
  void *tmp___6 ;

  {
  tmp = tctreesplay(tree, kbuf, ksiz);
  top = tmp;
  if (! top) {
    if (! vbuf) {
      return ((_Bool)0);
    }
    psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___0 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + vsiz) + 1));
      rec = (TCTREEREC *)tmp___0;
      if (! rec) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf = (char *)rec + (int )sizeof(*rec);
    memcpy((void * __restrict  )dbuf, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf + ksiz) = (char )'\000';
    rec->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf + ksiz) + psiz), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf + ((ksiz + psiz) + vsiz)) = (char )'\000';
    rec->vsiz = vsiz;
    rec->left = (struct _TCTREEREC *)((void *)0);
    rec->right = (struct _TCTREEREC *)((void *)0);
    tree->root = rec;
    tree->rnum = 1ULL;
    tree->msiz = (unsigned long long )(ksiz + vsiz);
    return ((_Bool)1);
  }
  dbuf___0 = (char *)top + (int )sizeof(*top);
  tmp___1 = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf___0, top->ksiz,
                           tree->cmpop);
  cv = tmp___1;
  if (cv < 0) {
    if (! vbuf) {
      tree->root = top;
      return ((_Bool)0);
    }
    psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___2 = malloc((unsigned int )(((((int )sizeof(*rec___0) + ksiz) + psiz___0) + vsiz) + 1));
      rec___0 = (TCTREEREC *)tmp___2;
      if (! rec___0) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf___0 = (char *)rec___0 + (int )sizeof(*rec___0);
    memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf___0 + ksiz) = (char )'\000';
    rec___0->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf___0 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
    rec___0->vsiz = vsiz;
    rec___0->left = top->left;
    rec___0->right = top;
    top->left = (struct _TCTREEREC *)((void *)0);
    (tree->rnum) ++;
    tree->msiz += (unsigned long long )(ksiz + vsiz);
    tree->root = rec___0;
  } else {
    if (cv > 0) {
      if (! vbuf) {
        tree->root = top;
        return ((_Bool)0);
      }
      psiz___1 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
      while (1) {
        tmp___3 = malloc((unsigned int )(((((int )sizeof(*rec___1) + ksiz) + psiz___1) + vsiz) + 1));
        rec___1 = (TCTREEREC *)tmp___3;
        if (! rec___1) {
          tcmyfatal("out of memory");
        }
        break;
      }
      dbuf___0 = (char *)rec___1 + (int )sizeof(*rec___1);
      memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      *(dbuf___0 + ksiz) = (char )'\000';
      rec___1->ksiz = ksiz;
      memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___1), (void const   * __restrict  )vbuf,
             (unsigned int )vsiz);
      *(dbuf___0 + ((ksiz + psiz___1) + vsiz)) = (char )'\000';
      rec___1->vsiz = vsiz;
      rec___1->left = top;
      rec___1->right = top->right;
      top->right = (struct _TCTREEREC *)((void *)0);
      (tree->rnum) ++;
      tree->msiz += (unsigned long long )(ksiz + vsiz);
      tree->root = rec___1;
    } else {
      psiz___2 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
      tmp___4 = (*proc___0)((void const   *)((dbuf___0 + ksiz) + psiz___2), top->vsiz,
                            & nvsiz, op);
      nvbuf = (char *)tmp___4;
      if ((unsigned int )nvbuf == (unsigned int )((void *)-1)) {
        (tree->rnum) --;
        tree->msiz -= (unsigned long long )(top->ksiz + top->vsiz);
        if ((unsigned int )tree->cur == (unsigned int )top) {
          rec___2 = top->right;
          if (rec___2) {
            while (rec___2->left) {
              rec___2 = rec___2->left;
            }
          }
          tree->cur = rec___2;
        }
        if (! top->left) {
          tree->root = top->right;
        } else {
          if (! top->right) {
            tree->root = top->left;
          } else {
            tree->root = top->left;
            tmp___5 = tctreesplay(tree, kbuf, ksiz);
            rec___3 = tmp___5;
            rec___3->right = top->right;
            tree->root = rec___3;
          }
        }
        while (1) {
          free((void *)top);
          break;
        }
        return ((_Bool)1);
      }
      if (! nvbuf) {
        tree->root = top;
        return ((_Bool)0);
      }
      tree->msiz += (unsigned long long )(nvsiz - top->vsiz);
      if (nvsiz > top->vsiz) {
        old = top;
        while (1) {
          tmp___6 = realloc((void *)top, (unsigned int )(((((int )sizeof(*top) + ksiz) + psiz___2) + nvsiz) + 1));
          top = (TCTREEREC *)tmp___6;
          if (! top) {
            tcmyfatal("out of memory");
          }
          break;
        }
        if ((unsigned int )top != (unsigned int )old) {
          if ((unsigned int )tree->cur == (unsigned int )old) {
            tree->cur = top;
          }
          dbuf___0 = (char *)top + (int )sizeof(*top);
        }
      }
      memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___2), (void const   * __restrict  )nvbuf,
             (unsigned int )nvsiz);
      *(dbuf___0 + ((ksiz + psiz___2) + nvsiz)) = (char )'\000';
      top->vsiz = nvsiz;
      while (1) {
        free((void *)nvbuf);
        break;
      }
      tree->root = top;
    }
  }
  return ((_Bool)1);
}
}
_Bool tctreeout(TCTREE *tree , void const   *kbuf , int ksiz ) 
{ TCTREEREC *top ;
  TCTREEREC *tmp ;
  char *dbuf ;
  int cv ;
  int tmp___0 ;
  TCTREEREC *rec ;
  TCTREEREC *rec___0 ;
  TCTREEREC *tmp___1 ;

  {
  tmp = tctreesplay(tree, kbuf, ksiz);
  top = tmp;
  if (! top) {
    return ((_Bool)0);
  }
  dbuf = (char *)top + (int )sizeof(*top);
  tmp___0 = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf, top->ksiz,
                           tree->cmpop);
  cv = tmp___0;
  if (cv != 0) {
    tree->root = top;
    return ((_Bool)0);
  }
  (tree->rnum) --;
  tree->msiz -= (unsigned long long )(top->ksiz + top->vsiz);
  if ((unsigned int )tree->cur == (unsigned int )top) {
    rec = top->right;
    if (rec) {
      while (rec->left) {
        rec = rec->left;
      }
    }
    tree->cur = rec;
  }
  if (! top->left) {
    tree->root = top->right;
  } else {
    if (! top->right) {
      tree->root = top->left;
    } else {
      tree->root = top->left;
      tmp___1 = tctreesplay(tree, kbuf, ksiz);
      rec___0 = tmp___1;
      rec___0->right = top->right;
      tree->root = rec___0;
    }
  }
  while (1) {
    free((void *)top);
    break;
  }
  return ((_Bool)1);
}
}
_Bool tctreeout2(TCTREE *tree , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tctreeout(tree, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
void const   *tctreeget(TCTREE *tree , void const   *kbuf , int ksiz , int *sp ) 
{ TCTREEREC *top ;
  TCTREEREC *tmp ;
  char *dbuf ;
  int cv ;
  int tmp___0 ;

  {
  tmp = tctreesplay(tree, kbuf, ksiz);
  top = tmp;
  if (! top) {
    return ((void const   *)((void *)0));
  }
  dbuf = (char *)top + (int )sizeof(*top);
  tmp___0 = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf, top->ksiz,
                           tree->cmpop);
  cv = tmp___0;
  if (cv != 0) {
    tree->root = top;
    return ((void const   *)((void *)0));
  }
  tree->root = top;
  *sp = top->vsiz;
  return ((void const   *)((dbuf + top->ksiz) + (((top->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - top->ksiz)));
}
}
char const   *tctreeget2(TCTREE *tree , char const   *kstr ) 
{ int vsiz ;
  size_t tmp ;
  void const   *tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tctreeget(tree, (void const   *)kstr, (int )tmp, & vsiz);
  return ((char const   *)tmp___0);
}
}
void tctreeiterinit(TCTREE *tree ) 
{ TCTREEREC *rec ;

  {
  rec = tree->root;
  if (! rec) {
    return;
  }
  while (rec->left) {
    rec = rec->left;
  }
  tree->cur = rec;
  return;
}
}
void const   *tctreeiternext(TCTREE *tree , int *sp ) 
{ TCTREEREC *rec ;
  char const   *kbuf ;
  int ksiz ;

  {
  if (! tree->cur) {
    return ((void const   *)((void *)0));
  }
  rec = tree->cur;
  kbuf = (char const   *)((char *)rec + (int )sizeof(*rec));
  ksiz = rec->ksiz;
  rec = tctreesplay(tree, (void const   *)kbuf, ksiz);
  if (! rec) {
    return ((void const   *)((void *)0));
  }
  tree->root = rec;
  rec = rec->right;
  if (rec) {
    while (rec->left) {
      rec = rec->left;
    }
  }
  tree->cur = rec;
  *sp = ksiz;
  return ((void const   *)kbuf);
}
}
char const   *tctreeiternext2(TCTREE *tree ) 
{ int ksiz ;
  void const   *tmp ;

  {
  tmp = tctreeiternext(tree, & ksiz);
  return ((char const   *)tmp);
}
}
uint64_t tctreernum(TCTREE const   *tree ) 
{ 

  {
  return ((unsigned long long )tree->rnum);
}
}
uint64_t tctreemsiz(TCTREE const   *tree ) 
{ 

  {
  return ((unsigned long long )(tree->msiz + tree->rnum * (unsigned long long const   )((int )sizeof(*(tree->root)) + (int )sizeof(void *))));
}
}
TCLIST *tctreekeys(TCTREE const   *tree ) 
{ TCLIST *list ;
  TCLIST *tmp ;
  TCTREEREC **history ;
  void *tmp___0 ;
  TCTREEREC **result ;
  void *tmp___1 ;
  int hnum ;
  int tmp___2 ;
  TCTREEREC *rec ;
  char *dbuf ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___3 ;
  void *tmp___4 ;
  TCLISTDATUM *array ;
  char *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  tmp = tclistnew2((int )tree->rnum);
  list = tmp;
  if (tree->root) {
    while (1) {
      tmp___0 = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*history)) * tree->rnum));
      history = (TCTREEREC **)tmp___0;
      if (! history) {
        tcmyfatal("out of memory");
      }
      break;
    }
    while (1) {
      tmp___1 = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*history)) * tree->rnum));
      result = (TCTREEREC **)tmp___1;
      if (! result) {
        tcmyfatal("out of memory");
      }
      break;
    }
    hnum = 0;
    tmp___2 = hnum;
    hnum ++;
    *(history + tmp___2) = (TCTREEREC *)tree->root;
    while (hnum > 0) {
      hnum --;
      rec = *(history + hnum);
      if (! rec) {
        rec = *(result + hnum);
        dbuf = (char *)rec + (int )sizeof(*rec);
        while (1) {
          TC_mysize = rec->ksiz;
          TC_index = list->start + list->num;
          if (TC_index >= list->anum) {
            list->anum += list->num + 1;
            while (1) {
              tmp___4 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
              tmp___3 = (TCLISTDATUM *)tmp___4;
              list->array = tmp___3;
              if (! tmp___3) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          array = list->array;
          while (1) {
            tmp___6 = malloc((unsigned int )(TC_mysize + 1));
            tmp___5 = (char *)tmp___6;
            (array + TC_index)->ptr = tmp___5;
            if (! tmp___5) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )dbuf,
                 (unsigned int )TC_mysize);
          *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
          (array + TC_index)->size = TC_mysize;
          (list->num) ++;
          break;
        }
        continue;
      }
      if (rec->right) {
        tmp___7 = hnum;
        hnum ++;
        *(history + tmp___7) = rec->right;
      }
      *(history + hnum) = (TCTREEREC *)((void *)0);
      *(result + hnum) = rec;
      hnum ++;
      if (rec->left) {
        tmp___8 = hnum;
        hnum ++;
        *(history + tmp___8) = rec->left;
      }
    }
    while (1) {
      free((void *)result);
      break;
    }
    while (1) {
      free((void *)history);
      break;
    }
  }
  return (list);
}
}
TCLIST *tctreevals(TCTREE const   *tree ) 
{ TCLIST *list ;
  TCLIST *tmp ;
  TCTREEREC **history ;
  void *tmp___0 ;
  TCTREEREC **result ;
  void *tmp___1 ;
  int hnum ;
  int tmp___2 ;
  TCTREEREC *rec ;
  char *dbuf ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___3 ;
  void *tmp___4 ;
  TCLISTDATUM *array ;
  char *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  tmp = tclistnew2((int )tree->rnum);
  list = tmp;
  if (tree->root) {
    while (1) {
      tmp___0 = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*history)) * tree->rnum));
      history = (TCTREEREC **)tmp___0;
      if (! history) {
        tcmyfatal("out of memory");
      }
      break;
    }
    while (1) {
      tmp___1 = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*history)) * tree->rnum));
      result = (TCTREEREC **)tmp___1;
      if (! result) {
        tcmyfatal("out of memory");
      }
      break;
    }
    hnum = 0;
    tmp___2 = hnum;
    hnum ++;
    *(history + tmp___2) = (TCTREEREC *)tree->root;
    while (hnum > 0) {
      hnum --;
      rec = *(history + hnum);
      if (! rec) {
        rec = *(result + hnum);
        dbuf = (char *)rec + (int )sizeof(*rec);
        while (1) {
          TC_mysize = rec->vsiz;
          TC_index = list->start + list->num;
          if (TC_index >= list->anum) {
            list->anum += list->num + 1;
            while (1) {
              tmp___4 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
              tmp___3 = (TCLISTDATUM *)tmp___4;
              list->array = tmp___3;
              if (! tmp___3) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          array = list->array;
          while (1) {
            tmp___6 = malloc((unsigned int )(TC_mysize + 1));
            tmp___5 = (char *)tmp___6;
            (array + TC_index)->ptr = tmp___5;
            if (! tmp___5) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )((dbuf + rec->ksiz) + (((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz)),
                 (unsigned int )TC_mysize);
          *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
          (array + TC_index)->size = TC_mysize;
          (list->num) ++;
          break;
        }
        continue;
      }
      if (rec->right) {
        tmp___7 = hnum;
        hnum ++;
        *(history + tmp___7) = rec->right;
      }
      *(history + hnum) = (TCTREEREC *)((void *)0);
      *(result + hnum) = rec;
      hnum ++;
      if (rec->left) {
        tmp___8 = hnum;
        hnum ++;
        *(history + tmp___8) = rec->left;
      }
    }
    while (1) {
      free((void *)result);
      break;
    }
    while (1) {
      free((void *)history);
      break;
    }
  }
  return (list);
}
}
int tctreeaddint(TCTREE *tree , void const   *kbuf , int ksiz , int num ) 
{ TCTREEREC *top ;
  TCTREEREC *tmp ;
  int psiz ;
  TCTREEREC *rec ;
  void *tmp___0 ;
  char *dbuf ;
  char *dbuf___0 ;
  int cv ;
  int tmp___1 ;
  int psiz___0 ;
  TCTREEREC *rec___0 ;
  void *tmp___2 ;
  int psiz___1 ;
  TCTREEREC *rec___1 ;
  void *tmp___3 ;
  int *resp ;

  {
  tmp = tctreesplay(tree, kbuf, ksiz);
  top = tmp;
  if (! top) {
    psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___0 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + (int )sizeof(num)) + 1));
      rec = (TCTREEREC *)tmp___0;
      if (! rec) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf = (char *)rec + (int )sizeof(*rec);
    memcpy((void * __restrict  )dbuf, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf + ksiz) = (char )'\000';
    rec->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf + ksiz) + psiz), (void const   * __restrict  )(& num),
           (unsigned int )((int )sizeof(num)));
    *(dbuf + ((ksiz + psiz) + (int )sizeof(num))) = (char )'\000';
    rec->vsiz = (int )sizeof(num);
    rec->left = (struct _TCTREEREC *)((void *)0);
    rec->right = (struct _TCTREEREC *)((void *)0);
    tree->root = rec;
    tree->rnum = 1ULL;
    tree->msiz = (unsigned long long )(ksiz + (int )sizeof(num));
    return (num);
  }
  dbuf___0 = (char *)top + (int )sizeof(*top);
  tmp___1 = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf___0, top->ksiz,
                           tree->cmpop);
  cv = tmp___1;
  if (cv < 0) {
    psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___2 = malloc((unsigned int )(((((int )sizeof(*rec___0) + ksiz) + psiz___0) + (int )sizeof(num)) + 1));
      rec___0 = (TCTREEREC *)tmp___2;
      if (! rec___0) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf___0 = (char *)rec___0 + (int )sizeof(*rec___0);
    memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf___0 + ksiz) = (char )'\000';
    rec___0->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )(& num),
           (unsigned int )((int )sizeof(num)));
    *(dbuf___0 + ((ksiz + psiz___0) + (int )sizeof(num))) = (char )'\000';
    rec___0->vsiz = (int )sizeof(num);
    rec___0->left = top->left;
    rec___0->right = top;
    top->left = (struct _TCTREEREC *)((void *)0);
    (tree->rnum) ++;
    tree->msiz += (unsigned long long )(ksiz + (int )sizeof(num));
    tree->root = rec___0;
  } else {
    if (cv > 0) {
      psiz___1 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
      while (1) {
        tmp___3 = malloc((unsigned int )(((((int )sizeof(*rec___1) + ksiz) + psiz___1) + (int )sizeof(num)) + 1));
        rec___1 = (TCTREEREC *)tmp___3;
        if (! rec___1) {
          tcmyfatal("out of memory");
        }
        break;
      }
      dbuf___0 = (char *)rec___1 + (int )sizeof(*rec___1);
      memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      *(dbuf___0 + ksiz) = (char )'\000';
      rec___1->ksiz = ksiz;
      memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___1), (void const   * __restrict  )(& num),
             (unsigned int )((int )sizeof(num)));
      *(dbuf___0 + ((ksiz + psiz___1) + (int )sizeof(num))) = (char )'\000';
      rec___1->vsiz = (int )sizeof(num);
      rec___1->left = top;
      rec___1->right = top->right;
      top->right = (struct _TCTREEREC *)((void *)0);
      (tree->rnum) ++;
      tree->msiz += (unsigned long long )(ksiz + (int )sizeof(num));
      tree->root = rec___1;
    } else {
      tree->root = top;
      if (top->vsiz != (int )sizeof(num)) {
        return ((-0x7FFFFFFF-1));
      }
      resp = (int *)((dbuf___0 + ksiz) + (((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz));
      *resp += num;
      return (*resp);
    }
  }
  return (num);
}
}
double tctreeadddouble(TCTREE *tree , void const   *kbuf , int ksiz , double num ) 
{ TCTREEREC *top ;
  TCTREEREC *tmp ;
  int psiz ;
  TCTREEREC *rec ;
  void *tmp___0 ;
  char *dbuf ;
  char *dbuf___0 ;
  int cv ;
  int tmp___1 ;
  int psiz___0 ;
  TCTREEREC *rec___0 ;
  void *tmp___2 ;
  int psiz___1 ;
  TCTREEREC *rec___1 ;
  void *tmp___3 ;
  double tmp___4 ;
  double *resp ;

  {
  tmp = tctreesplay(tree, kbuf, ksiz);
  top = tmp;
  if (! top) {
    psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___0 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + (int )sizeof(num)) + 1));
      rec = (TCTREEREC *)tmp___0;
      if (! rec) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf = (char *)rec + (int )sizeof(*rec);
    memcpy((void * __restrict  )dbuf, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf + ksiz) = (char )'\000';
    rec->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf + ksiz) + psiz), (void const   * __restrict  )(& num),
           (unsigned int )((int )sizeof(num)));
    *(dbuf + ((ksiz + psiz) + (int )sizeof(num))) = (char )'\000';
    rec->vsiz = (int )sizeof(num);
    rec->left = (struct _TCTREEREC *)((void *)0);
    rec->right = (struct _TCTREEREC *)((void *)0);
    tree->root = rec;
    tree->rnum = 1ULL;
    tree->msiz = (unsigned long long )(ksiz + (int )sizeof(num));
    return (num);
  }
  dbuf___0 = (char *)top + (int )sizeof(*top);
  tmp___1 = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf___0, top->ksiz,
                           tree->cmpop);
  cv = tmp___1;
  if (cv < 0) {
    psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___2 = malloc((unsigned int )(((((int )sizeof(*rec___0) + ksiz) + psiz___0) + (int )sizeof(num)) + 1));
      rec___0 = (TCTREEREC *)tmp___2;
      if (! rec___0) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf___0 = (char *)rec___0 + (int )sizeof(*rec___0);
    memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf___0 + ksiz) = (char )'\000';
    rec___0->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )(& num),
           (unsigned int )((int )sizeof(num)));
    *(dbuf___0 + ((ksiz + psiz___0) + (int )sizeof(num))) = (char )'\000';
    rec___0->vsiz = (int )sizeof(num);
    rec___0->left = top->left;
    rec___0->right = top;
    top->left = (struct _TCTREEREC *)((void *)0);
    (tree->rnum) ++;
    tree->msiz += (unsigned long long )(ksiz + (int )sizeof(num));
    tree->root = rec___0;
  } else {
    if (cv > 0) {
      psiz___1 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
      while (1) {
        tmp___3 = malloc((unsigned int )(((((int )sizeof(*rec___1) + ksiz) + psiz___1) + (int )sizeof(num)) + 1));
        rec___1 = (TCTREEREC *)tmp___3;
        if (! rec___1) {
          tcmyfatal("out of memory");
        }
        break;
      }
      dbuf___0 = (char *)rec___1 + (int )sizeof(*rec___1);
      memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      *(dbuf___0 + ksiz) = (char )'\000';
      rec___1->ksiz = ksiz;
      memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___1), (void const   * __restrict  )(& num),
             (unsigned int )((int )sizeof(num)));
      *(dbuf___0 + ((ksiz + psiz___1) + (int )sizeof(num))) = (char )'\000';
      rec___1->vsiz = (int )sizeof(num);
      rec___1->left = top;
      rec___1->right = top->right;
      top->right = (struct _TCTREEREC *)((void *)0);
      (tree->rnum) ++;
      tree->msiz += (unsigned long long )(ksiz + (int )sizeof(num));
      tree->root = rec___1;
    } else {
      tree->root = top;
      if (top->vsiz != (int )sizeof(num)) {
        tmp___4 = nan("");
        return (tmp___4);
      }
      resp = (double *)((dbuf___0 + ksiz) + (((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz));
      *resp += num;
      return (*resp);
    }
  }
  return (num);
}
}
void tctreeclear(TCTREE *tree ) 
{ TCTREEREC *histbuf[2048] ;
  TCTREEREC **history ;
  int hnum ;
  int tmp ;
  TCTREEREC *rec ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  if (tree->root) {
    history = histbuf;
    hnum = 0;
    tmp = hnum;
    hnum ++;
    *(history + tmp) = tree->root;
    while (hnum > 0) {
      hnum --;
      rec = *(history + hnum);
      if (hnum >= 2046) {
        if ((unsigned int )history == (unsigned int )(histbuf)) {
          while (1) {
            tmp___0 = malloc((unsigned int )((unsigned long long )((int )sizeof(*history)) * tree->rnum));
            history = (TCTREEREC **)tmp___0;
            if (! history) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )history, (void const   * __restrict  )(histbuf),
                 (unsigned int )((int )sizeof(*history) * hnum));
        }
      }
      if (rec->left) {
        tmp___1 = hnum;
        hnum ++;
        *(history + tmp___1) = rec->left;
      }
      if (rec->right) {
        tmp___2 = hnum;
        hnum ++;
        *(history + tmp___2) = rec->right;
      }
      while (1) {
        free((void *)rec);
        break;
      }
    }
    if ((unsigned int )history != (unsigned int )(histbuf)) {
      while (1) {
        free((void *)history);
        break;
      }
    }
  }
  tree->root = (TCTREEREC *)((void *)0);
  tree->cur = (TCTREEREC *)((void *)0);
  tree->rnum = 0ULL;
  tree->msiz = 0ULL;
  return;
}
}
void tctreecutfringe(TCTREE *tree , int num ) 
{ TCTREEREC **history ;
  void *tmp ;
  int hnum ;
  int tmp___0 ;
  int i ;
  TCTREEREC *rec ;
  int tmp___1 ;
  int tmp___2 ;
  TCTREEREC *cur ;
  int i___0 ;
  TCTREEREC *rec___0 ;
  TCTREEREC *child ;
  TCTREEREC *child___0 ;
  char *dbuf ;

  {
  if (! tree->root) {
    return;
  } else {
    if (num < 1) {
      return;
    }
  }
  while (1) {
    tmp = malloc((unsigned int )((unsigned long long )((int )sizeof(*history)) * tree->rnum));
    history = (TCTREEREC **)tmp;
    if (! history) {
      tcmyfatal("out of memory");
    }
    break;
  }
  hnum = 0;
  tmp___0 = hnum;
  hnum ++;
  *(history + tmp___0) = tree->root;
  i = 0;
  while (i < hnum) {
    rec = *(history + i);
    if (rec->left) {
      tmp___1 = hnum;
      hnum ++;
      *(history + tmp___1) = rec->left;
    }
    if (rec->right) {
      tmp___2 = hnum;
      hnum ++;
      *(history + tmp___2) = rec->right;
    }
    i ++;
  }
  cur = (TCTREEREC *)((void *)0);
  i___0 = hnum - 1;
  while (i___0 >= 0) {
    rec___0 = *(history + i___0);
    if (rec___0->left) {
      child = rec___0->left;
      (tree->rnum) --;
      tree->msiz -= (unsigned long long )(child->ksiz + child->vsiz);
      rec___0->left = (struct _TCTREEREC *)((void *)0);
      if ((unsigned int )tree->cur == (unsigned int )child) {
        tree->cur = (TCTREEREC *)((void *)0);
        cur = child;
      } else {
        while (1) {
          free((void *)child);
          break;
        }
      }
      num --;
      if (num < 1) {
        break;
      }
    }
    if (rec___0->right) {
      child___0 = rec___0->right;
      (tree->rnum) --;
      tree->msiz -= (unsigned long long )(child___0->ksiz + child___0->vsiz);
      rec___0->right = (struct _TCTREEREC *)((void *)0);
      if ((unsigned int )tree->cur == (unsigned int )child___0) {
        tree->cur = (TCTREEREC *)((void *)0);
        cur = child___0;
      } else {
        while (1) {
          free((void *)child___0);
          break;
        }
      }
      num --;
      if (num < 1) {
        break;
      }
    }
    i___0 --;
  }
  if (num > 0) {
    while (1) {
      free((void *)tree->root);
      break;
    }
    tree->root = (TCTREEREC *)((void *)0);
    tree->cur = (TCTREEREC *)((void *)0);
    tree->rnum = 0ULL;
    tree->msiz = 0ULL;
  }
  if (cur) {
    dbuf = (char *)cur + (int )sizeof(*cur);
    tctreeiterinit2(tree, (void const   *)dbuf, cur->ksiz);
    while (1) {
      free((void *)cur);
      break;
    }
  }
  while (1) {
    free((void *)history);
    break;
  }
  return;
}
}
void *tctreedump(TCTREE const   *tree , int *sp ) 
{ int tsiz ;
  TCTREEREC *histbuf[2048] ;
  TCTREEREC **history ;
  int hnum ;
  int tmp ;
  TCTREEREC *rec ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *buf ;
  void *tmp___3 ;
  char *wp ;
  TCTREEREC *histbuf___0[2048] ;
  TCTREEREC **history___0 ;
  int hnum___0 ;
  int tmp___4 ;
  TCTREEREC *rec___0 ;
  void *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *kbuf ;
  int ksiz ;
  char const   *vbuf ;
  int vsiz ;
  int step ;
  int _TC_num ;
  int _TC_rem ;
  int _TC_num___0 ;
  int _TC_rem___0 ;

  {
  tsiz = 0;
  if (tree->root) {
    history = histbuf;
    hnum = 0;
    tmp = hnum;
    hnum ++;
    *(history + tmp) = (TCTREEREC *)tree->root;
    while (hnum > 0) {
      hnum --;
      rec = *(history + hnum);
      if (hnum >= 2046) {
        if ((unsigned int )history == (unsigned int )(histbuf)) {
          while (1) {
            tmp___0 = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*history)) * tree->rnum));
            history = (TCTREEREC **)tmp___0;
            if (! history) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )history, (void const   * __restrict  )(histbuf),
                 (unsigned int )((int )sizeof(*history) * hnum));
        }
      }
      if (rec->left) {
        tmp___1 = hnum;
        hnum ++;
        *(history + tmp___1) = rec->left;
      }
      if (rec->right) {
        tmp___2 = hnum;
        hnum ++;
        *(history + tmp___2) = rec->right;
      }
      tsiz += (rec->ksiz + rec->vsiz) + (int )sizeof(int ) * 2;
    }
    if ((unsigned int )history != (unsigned int )(histbuf)) {
      while (1) {
        free((void *)history);
        break;
      }
    }
  }
  while (1) {
    tmp___3 = malloc((unsigned int )(tsiz + 1));
    buf = (char *)tmp___3;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  if (tree->root) {
    history___0 = histbuf___0;
    hnum___0 = 0;
    tmp___4 = hnum___0;
    hnum___0 ++;
    *(history___0 + tmp___4) = (TCTREEREC *)tree->root;
    while (hnum___0 > 0) {
      hnum___0 --;
      rec___0 = *(history___0 + hnum___0);
      if (hnum___0 >= 2046) {
        if ((unsigned int )history___0 == (unsigned int )(histbuf___0)) {
          while (1) {
            tmp___5 = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*history___0)) * tree->rnum));
            history___0 = (TCTREEREC **)tmp___5;
            if (! history___0) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )history___0, (void const   * __restrict  )(histbuf___0),
                 (unsigned int )((int )sizeof(*history___0) * hnum___0));
        }
      }
      if (rec___0->left) {
        tmp___6 = hnum___0;
        hnum___0 ++;
        *(history___0 + tmp___6) = rec___0->left;
      }
      if (rec___0->right) {
        tmp___7 = hnum___0;
        hnum___0 ++;
        *(history___0 + tmp___7) = rec___0->right;
      }
      kbuf = (char const   *)((char *)rec___0 + (int )sizeof(*rec___0));
      ksiz = rec___0->ksiz;
      vbuf = (kbuf + ksiz) + (((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz);
      vsiz = rec___0->vsiz;
      while (1) {
        _TC_num = ksiz;
        if (_TC_num == 0) {
          *((signed char *)wp + 0) = (signed char)0;
          step = 1;
        } else {
          step = 0;
          while (_TC_num > 0) {
            _TC_rem = _TC_num & 127;
            _TC_num >>= 7;
            if (_TC_num > 0) {
              *((signed char *)wp + step) = (signed char )(- _TC_rem - 1);
            } else {
              *((signed char *)wp + step) = (signed char )_TC_rem;
            }
            step ++;
          }
        }
        break;
      }
      wp += step;
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      while (1) {
        _TC_num___0 = vsiz;
        if (_TC_num___0 == 0) {
          *((signed char *)wp + 0) = (signed char)0;
          step = 1;
        } else {
          step = 0;
          while (_TC_num___0 > 0) {
            _TC_rem___0 = _TC_num___0 & 127;
            _TC_num___0 >>= 7;
            if (_TC_num___0 > 0) {
              *((signed char *)wp + step) = (signed char )(- _TC_rem___0 - 1);
            } else {
              *((signed char *)wp + step) = (signed char )_TC_rem___0;
            }
            step ++;
          }
        }
        break;
      }
      wp += step;
      memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      wp += vsiz;
    }
    if ((unsigned int )history___0 != (unsigned int )(histbuf___0)) {
      while (1) {
        free((void *)history___0);
        break;
      }
    }
  }
  *sp = wp - buf;
  return ((void *)buf);
}
}
TCTREE *tctreeload(void const   *ptr , int size , int (*cmp)(char const   *aptr ,
                                                             int asiz , char const   *bptr ,
                                                             int bsiz , void *op ) ,
                   void *cmpop ) 
{ TCTREE *tree ;
  TCTREE *tmp ;
  char const   *rp ;
  char const   *ep ;
  int step ;
  int ksiz ;
  int vsiz ;
  int _TC_base ;
  int _TC_i ;
  char const   *kbuf ;
  int _TC_base___0 ;
  int _TC_i___0 ;

  {
  tmp = tctreenew2(cmp, cmpop);
  tree = tmp;
  rp = (char const   *)ptr;
  ep = (char const   *)((char *)ptr + size);
  while ((unsigned int )rp < (unsigned int )ep) {
    while (1) {
      ksiz = 0;
      _TC_base = 1;
      _TC_i = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i) >= 0) {
          ksiz += (int )*((signed char *)rp + _TC_i) * _TC_base;
          break;
        }
        ksiz += (_TC_base * ((int )*((signed char *)rp + _TC_i) + 1)) * -1;
        _TC_base <<= 7;
        _TC_i ++;
      }
      step = _TC_i + 1;
      break;
    }
    rp += step;
    kbuf = rp;
    rp += ksiz;
    while (1) {
      vsiz = 0;
      _TC_base___0 = 1;
      _TC_i___0 = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i___0) >= 0) {
          vsiz += (int )*((signed char *)rp + _TC_i___0) * _TC_base___0;
          break;
        }
        vsiz += (_TC_base___0 * ((int )*((signed char *)rp + _TC_i___0) + 1)) * -1;
        _TC_base___0 <<= 7;
        _TC_i___0 ++;
      }
      step = _TC_i___0 + 1;
      break;
    }
    rp += step;
    tctreeputkeep(tree, (void const   *)kbuf, ksiz, (void const   *)rp, vsiz);
    rp += vsiz;
  }
  return (tree);
}
}
static TCTREEREC *tctreesplay(TCTREE *tree , void const   *kbuf , int ksiz ) 
{ TCTREEREC *top ;
  int (*cmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
  void *cmpop ;
  TCTREEREC ent ;
  TCTREEREC *lrec ;
  TCTREEREC *rrec ;
  char *dbuf ;
  int cv ;
  int tmp ;
  TCTREEREC *swap ;
  TCTREEREC *swap___0 ;

  {
  top = tree->root;
  if (! top) {
    return ((TCTREEREC *)((void *)0));
  }
  cmp = tree->cmp;
  cmpop = tree->cmpop;
  ent.left = (struct _TCTREEREC *)((void *)0);
  ent.right = (struct _TCTREEREC *)((void *)0);
  lrec = & ent;
  rrec = & ent;
  while (1) {
    dbuf = (char *)top + (int )sizeof(*top);
    tmp = (*cmp)((char const   *)kbuf, ksiz, (char const   *)dbuf, top->ksiz, cmpop);
    cv = tmp;
    if (cv < 0) {
      if (! top->left) {
        break;
      }
      dbuf = (char *)top->left + (int )sizeof(*top);
      cv = (*cmp)((char const   *)kbuf, ksiz, (char const   *)dbuf, (top->left)->ksiz,
                  cmpop);
      if (cv < 0) {
        swap = top->left;
        top->left = swap->right;
        swap->right = top;
        top = swap;
        if (! top->left) {
          break;
        }
      }
      rrec->left = top;
      rrec = top;
      top = top->left;
    } else {
      if (cv > 0) {
        if (! top->right) {
          break;
        }
        dbuf = (char *)top->right + (int )sizeof(*top);
        cv = (*cmp)((char const   *)kbuf, ksiz, (char const   *)dbuf, (top->right)->ksiz,
                    cmpop);
        if (cv > 0) {
          swap___0 = top->right;
          top->right = swap___0->left;
          swap___0->left = top;
          top = swap___0;
          if (! top->right) {
            break;
          }
        }
        lrec->right = top;
        lrec = top;
        top = top->right;
      } else {
        break;
      }
    }
  }
  lrec->right = top->left;
  rrec->left = top->right;
  top->left = ent.right;
  top->right = ent.left;
  return (top);
}
}
void tctreeput3(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                int vsiz ) 
{ TCTREEREC *rec ;
  TCTREEREC **entp ;
  char *dbuf ;
  int cv ;
  int tmp ;
  int psiz ;
  TCTREEREC *old ;
  void *tmp___0 ;
  int psiz___0 ;
  void *tmp___1 ;
  char *dbuf___0 ;

  {
  rec = tree->root;
  entp = (TCTREEREC **)((void *)0);
  while (rec) {
    dbuf = (char *)rec + (int )sizeof(*rec);
    tmp = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf, rec->ksiz,
                         tree->cmpop);
    cv = tmp;
    if (cv < 0) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (cv > 0) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        tree->msiz += (unsigned long long )(vsiz - rec->vsiz);
        psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
        if (vsiz > rec->vsiz) {
          old = rec;
          while (1) {
            tmp___0 = realloc((void *)rec, (unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + vsiz) + 1));
            rec = (TCTREEREC *)tmp___0;
            if (! rec) {
              tcmyfatal("out of memory");
            }
            break;
          }
          if ((unsigned int )rec != (unsigned int )old) {
            if ((unsigned int )tree->root == (unsigned int )old) {
              tree->root = rec;
            }
            if ((unsigned int )tree->cur == (unsigned int )old) {
              tree->cur = rec;
            }
            if (entp) {
              *entp = rec;
            }
            dbuf = (char *)rec + (int )sizeof(*rec);
          }
        }
        memcpy((void * __restrict  )((dbuf + ksiz) + psiz), (void const   * __restrict  )vbuf,
               (unsigned int )vsiz);
        *(dbuf + ((ksiz + psiz) + vsiz)) = (char )'\000';
        rec->vsiz = vsiz;
        return;
      }
    }
  }
  psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  while (1) {
    tmp___1 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz___0) + vsiz) + 1));
    rec = (TCTREEREC *)tmp___1;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = ksiz;
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
         (unsigned int )vsiz);
  *(dbuf___0 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
  rec->vsiz = vsiz;
  rec->left = (struct _TCTREEREC *)((void *)0);
  rec->right = (struct _TCTREEREC *)((void *)0);
  if (entp) {
    *entp = rec;
  } else {
    tree->root = rec;
  }
  (tree->rnum) ++;
  tree->msiz += (unsigned long long )(ksiz + vsiz);
  return;
}
}
_Bool tctreeputkeep3(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                     int vsiz ) 
{ TCTREEREC *rec ;
  TCTREEREC **entp ;
  char *dbuf ;
  int cv ;
  int tmp ;
  int psiz ;
  void *tmp___0 ;
  char *dbuf___0 ;

  {
  rec = tree->root;
  entp = (TCTREEREC **)((void *)0);
  while (rec) {
    dbuf = (char *)rec + (int )sizeof(*rec);
    tmp = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf, rec->ksiz,
                         tree->cmpop);
    cv = tmp;
    if (cv < 0) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (cv > 0) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        return ((_Bool)0);
      }
    }
  }
  psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  while (1) {
    tmp___0 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz) + vsiz) + 1));
    rec = (TCTREEREC *)tmp___0;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = ksiz;
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz), (void const   * __restrict  )vbuf,
         (unsigned int )vsiz);
  *(dbuf___0 + ((ksiz + psiz) + vsiz)) = (char )'\000';
  rec->vsiz = vsiz;
  rec->left = (struct _TCTREEREC *)((void *)0);
  rec->right = (struct _TCTREEREC *)((void *)0);
  if (entp) {
    *entp = rec;
  } else {
    tree->root = rec;
  }
  (tree->rnum) ++;
  tree->msiz += (unsigned long long )(ksiz + vsiz);
  return ((_Bool)1);
}
}
void tctreeputcat3(TCTREE *tree , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) 
{ TCTREEREC *rec ;
  TCTREEREC **entp ;
  char *dbuf ;
  int cv ;
  int tmp ;
  int psiz ;
  int asiz ;
  int unit ;
  int tmp___0 ;
  TCTREEREC *old ;
  void *tmp___1 ;
  int psiz___0 ;
  void *tmp___2 ;
  char *dbuf___0 ;

  {
  rec = tree->root;
  entp = (TCTREEREC **)((void *)0);
  while (rec) {
    dbuf = (char *)rec + (int )sizeof(*rec);
    tmp = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf, rec->ksiz,
                         tree->cmpop);
    cv = tmp;
    if (cv < 0) {
      entp = & rec->left;
      rec = rec->left;
    } else {
      if (cv > 0) {
        entp = & rec->right;
        rec = rec->right;
      } else {
        tree->msiz += (unsigned long long )vsiz;
        psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
        asiz = (((((int )sizeof(*rec) + ksiz) + psiz) + rec->vsiz) + vsiz) + 1;
        if (asiz <= 52) {
          tmp___0 = 52;
        } else {
          tmp___0 = 252;
        }
        unit = tmp___0;
        asiz = ((asiz - 1) + unit) - (asiz - 1) % unit;
        old = rec;
        while (1) {
          tmp___1 = realloc((void *)rec, (unsigned int )asiz);
          rec = (TCTREEREC *)tmp___1;
          if (! rec) {
            tcmyfatal("out of memory");
          }
          break;
        }
        if ((unsigned int )rec != (unsigned int )old) {
          if ((unsigned int )tree->root == (unsigned int )old) {
            tree->root = rec;
          }
          if ((unsigned int )tree->cur == (unsigned int )old) {
            tree->cur = rec;
          }
          if (entp) {
            *entp = rec;
          }
          dbuf = (char *)rec + (int )sizeof(*rec);
        }
        memcpy((void * __restrict  )(((dbuf + ksiz) + psiz) + rec->vsiz), (void const   * __restrict  )vbuf,
               (unsigned int )vsiz);
        rec->vsiz += vsiz;
        *(dbuf + ((ksiz + psiz) + rec->vsiz)) = (char )'\000';
        return;
      }
    }
  }
  psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
  while (1) {
    tmp___2 = malloc((unsigned int )(((((int )sizeof(*rec) + ksiz) + psiz___0) + vsiz) + 1));
    rec = (TCTREEREC *)tmp___2;
    if (! rec) {
      tcmyfatal("out of memory");
    }
    break;
  }
  dbuf___0 = (char *)rec + (int )sizeof(*rec);
  memcpy((void * __restrict  )dbuf___0, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(dbuf___0 + ksiz) = (char )'\000';
  rec->ksiz = ksiz;
  memcpy((void * __restrict  )((dbuf___0 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
         (unsigned int )vsiz);
  *(dbuf___0 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
  rec->vsiz = vsiz;
  rec->left = (struct _TCTREEREC *)((void *)0);
  rec->right = (struct _TCTREEREC *)((void *)0);
  if (entp) {
    *entp = rec;
  } else {
    tree->root = rec;
  }
  (tree->rnum) ++;
  tree->msiz += (unsigned long long )(ksiz + vsiz);
  return;
}
}
void const   *tctreeget3(TCTREE const   *tree , void const   *kbuf , int ksiz , int *sp ) 
{ TCTREEREC *rec ;
  char *dbuf ;
  int cv ;
  int tmp ;

  {
  rec = (TCTREEREC *)tree->root;
  while (rec) {
    dbuf = (char *)rec + (int )sizeof(*rec);
    tmp = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf, rec->ksiz,
                         (void *)tree->cmpop);
    cv = tmp;
    if (cv < 0) {
      rec = rec->left;
    } else {
      if (cv > 0) {
        rec = rec->right;
      } else {
        *sp = rec->vsiz;
        return ((void const   *)((dbuf + rec->ksiz) + (((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz)));
      }
    }
  }
  return ((void const   *)((void *)0));
}
}
char const   *tctreeget4(TCTREE *tree , char const   *kstr , char const   *dstr ) 
{ int vsiz ;
  char const   *vbuf ;
  size_t tmp ;
  void const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tctreeget(tree, (void const   *)kstr, (int )tmp, & vsiz);
  vbuf = (char const   *)tmp___0;
  if (vbuf) {
    tmp___1 = vbuf;
  } else {
    tmp___1 = dstr;
  }
  return (tmp___1);
}
}
void tctreeiterinit2(TCTREE *tree , void const   *kbuf , int ksiz ) 
{ TCTREEREC *rec ;
  char *dbuf ;
  int cv ;
  int tmp ;

  {
  rec = tree->root;
  while (rec) {
    dbuf = (char *)rec + (int )sizeof(*rec);
    tmp = (*(tree->cmp))((char const   *)kbuf, ksiz, (char const   *)dbuf, rec->ksiz,
                         tree->cmpop);
    cv = tmp;
    if (cv < 0) {
      tree->cur = rec;
      rec = rec->left;
    } else {
      if (cv > 0) {
        rec = rec->right;
      } else {
        tree->cur = rec;
        return;
      }
    }
  }
  return;
}
}
void tctreeiterinit3(TCTREE *tree , char const   *kstr ) 
{ size_t tmp ;

  {
  tmp = strlen(kstr);
  tctreeiterinit2(tree, (void const   *)kstr, (int )tmp);
  return;
}
}
void const   *tctreeiterval(void const   *kbuf , int *sp ) 
{ TCTREEREC *rec ;

  {
  rec = (TCTREEREC *)((char *)kbuf - (int )sizeof(*rec));
  *sp = rec->vsiz;
  return ((void const   *)(((char *)kbuf + rec->ksiz) + (((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz)));
}
}
char const   *tctreeiterval2(char const   *kstr ) 
{ TCTREEREC *rec ;

  {
  rec = (TCTREEREC *)(kstr - (int )sizeof(*rec));
  return ((kstr + rec->ksiz) + (((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz));
}
}
char const   **tctreekeys2(TCTREE const   *tree , int *np ) 
{ char const   **ary ;
  void *tmp ;
  int anum ;
  TCTREEREC **history ;
  void *tmp___0 ;
  TCTREEREC **result ;
  void *tmp___1 ;
  int hnum ;
  int tmp___2 ;
  TCTREEREC *rec ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*ary)) * tree->rnum + 1ULL));
    ary = (char const   **)tmp;
    if (! ary) {
      tcmyfatal("out of memory");
    }
    break;
  }
  anum = 0;
  if (tree->root) {
    while (1) {
      tmp___0 = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*history)) * tree->rnum));
      history = (TCTREEREC **)tmp___0;
      if (! history) {
        tcmyfatal("out of memory");
      }
      break;
    }
    while (1) {
      tmp___1 = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*history)) * tree->rnum));
      result = (TCTREEREC **)tmp___1;
      if (! result) {
        tcmyfatal("out of memory");
      }
      break;
    }
    hnum = 0;
    tmp___2 = hnum;
    hnum ++;
    *(history + tmp___2) = (TCTREEREC *)tree->root;
    while (hnum > 0) {
      hnum --;
      rec = *(history + hnum);
      if (! rec) {
        rec = *(result + hnum);
        tmp___3 = anum;
        anum ++;
        *(ary + tmp___3) = (char const   *)((char *)rec + (int )sizeof(*rec));
        continue;
      }
      if (rec->right) {
        tmp___4 = hnum;
        hnum ++;
        *(history + tmp___4) = rec->right;
      }
      *(history + hnum) = (TCTREEREC *)((void *)0);
      *(result + hnum) = rec;
      hnum ++;
      if (rec->left) {
        tmp___5 = hnum;
        hnum ++;
        *(history + tmp___5) = rec->left;
      }
    }
    while (1) {
      free((void *)result);
      break;
    }
    while (1) {
      free((void *)history);
      break;
    }
  }
  *np = anum;
  return (ary);
}
}
char const   **tctreevals2(TCTREE const   *tree , int *np ) 
{ char const   **ary ;
  void *tmp ;
  int anum ;
  TCTREEREC **history ;
  void *tmp___0 ;
  TCTREEREC **result ;
  void *tmp___1 ;
  int hnum ;
  int tmp___2 ;
  TCTREEREC *rec ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*ary)) * tree->rnum + 1ULL));
    ary = (char const   **)tmp;
    if (! ary) {
      tcmyfatal("out of memory");
    }
    break;
  }
  anum = 0;
  if (tree->root) {
    while (1) {
      tmp___0 = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*history)) * tree->rnum));
      history = (TCTREEREC **)tmp___0;
      if (! history) {
        tcmyfatal("out of memory");
      }
      break;
    }
    while (1) {
      tmp___1 = malloc((unsigned int )((unsigned long long const   )((int )sizeof(*history)) * tree->rnum));
      result = (TCTREEREC **)tmp___1;
      if (! result) {
        tcmyfatal("out of memory");
      }
      break;
    }
    hnum = 0;
    tmp___2 = hnum;
    hnum ++;
    *(history + tmp___2) = (TCTREEREC *)tree->root;
    while (hnum > 0) {
      hnum --;
      rec = *(history + hnum);
      if (! rec) {
        rec = *(result + hnum);
        tmp___3 = anum;
        anum ++;
        *(ary + tmp___3) = (char const   *)((char *)rec + (int )sizeof(*rec));
        continue;
      }
      if (rec->right) {
        tmp___4 = hnum;
        hnum ++;
        *(history + tmp___4) = rec->right;
      }
      *(history + hnum) = (TCTREEREC *)((void *)0);
      *(result + hnum) = rec;
      hnum ++;
      if (rec->left) {
        tmp___5 = hnum;
        hnum ++;
        *(history + tmp___5) = rec->left;
      }
    }
    while (1) {
      free((void *)result);
      break;
    }
    while (1) {
      free((void *)history);
      break;
    }
  }
  *np = anum;
  return (ary);
}
}
void *tctreeloadone(void const   *ptr , int size , void const   *kbuf , int ksiz ,
                    int *sp ) 
{ char const   *rp ;
  char const   *ep ;
  int step ;
  int rsiz ;
  int _TC_base ;
  int _TC_i ;
  int _TC_base___0 ;
  int _TC_i___0 ;
  char *rv ;
  void *tmp ;
  int tmp___0 ;
  int _TC_base___1 ;
  int _TC_i___1 ;

  {
  rp = (char const   *)ptr;
  ep = (char const   *)((char *)ptr + size);
  while ((unsigned int )rp < (unsigned int )ep) {
    while (1) {
      rsiz = 0;
      _TC_base = 1;
      _TC_i = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i) >= 0) {
          rsiz += (int )*((signed char *)rp + _TC_i) * _TC_base;
          break;
        }
        rsiz += (_TC_base * ((int )*((signed char *)rp + _TC_i) + 1)) * -1;
        _TC_base <<= 7;
        _TC_i ++;
      }
      step = _TC_i + 1;
      break;
    }
    rp += step;
    if (rsiz == ksiz) {
      tmp___0 = memcmp(kbuf, (void const   *)rp, (unsigned int )rsiz);
      if (! tmp___0) {
        rp += rsiz;
        while (1) {
          rsiz = 0;
          _TC_base___0 = 1;
          _TC_i___0 = 0;
          while (1) {
            if ((int )*((signed char *)rp + _TC_i___0) >= 0) {
              rsiz += (int )*((signed char *)rp + _TC_i___0) * _TC_base___0;
              break;
            }
            rsiz += (_TC_base___0 * ((int )*((signed char *)rp + _TC_i___0) + 1)) * -1;
            _TC_base___0 <<= 7;
            _TC_i___0 ++;
          }
          step = _TC_i___0 + 1;
          break;
        }
        rp += step;
        *sp = rsiz;
        while (1) {
          while (1) {
            tmp = malloc((unsigned int )(rsiz + 1));
            rv = (char *)tmp;
            if (! rv) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )rv, (void const   * __restrict  )rp, (unsigned int )rsiz);
          *(rv + rsiz) = (char )'\000';
          break;
        }
        return ((void *)rv);
      }
    }
    rp += rsiz;
    while (1) {
      rsiz = 0;
      _TC_base___1 = 1;
      _TC_i___1 = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i___1) >= 0) {
          rsiz += (int )*((signed char *)rp + _TC_i___1) * _TC_base___1;
          break;
        }
        rsiz += (_TC_base___1 * ((int )*((signed char *)rp + _TC_i___1) + 1)) * -1;
        _TC_base___1 <<= 7;
        _TC_i___1 ++;
      }
      step = _TC_i___1 + 1;
      break;
    }
    rp += step;
    rp += rsiz;
  }
  return ((void *)0);
}
}
void tctreeprintf(TCTREE *tree , char const   *kstr , char const   *format  , ...) 
{ TCXSTR *xstr ;
  TCXSTR *tmp ;
  va_list ap ;
  size_t tmp___0 ;

  {
  tmp = tcxstrnew();
  xstr = tmp;
  __builtin_va_start(ap, format);
  tcvxstrprintf(xstr, format, ap);
  __builtin_va_end(ap);
  tmp___0 = strlen(kstr);
  tctreeput(tree, (void const   *)kstr, (int )tmp___0, (void const   *)xstr->ptr,
            xstr->size);
  tcxstrdel(xstr);
  return;
}
}
TCMDB *tcmdbnew(void) 
{ TCMDB *tmp ;

  {
  tmp = tcmdbnew2(65536U);
  return (tmp);
}
}
TCMDB *tcmdbnew2(uint32_t bnum ) 
{ TCMDB *mdb ;
  void *tmp ;
  void **tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  TCMAP **tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int i ;
  int tmp___6 ;

  {
  if (bnum < 1U) {
    bnum = 65536U;
  }
  bnum = bnum / 8U + 17U;
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*mdb)));
    mdb = (TCMDB *)tmp;
    if (! mdb) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(pthread_rwlock_t ) * 8));
    tmp___0 = (void **)tmp___1;
    mdb->mmtxs = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___2 = malloc((unsigned int )((int )sizeof(pthread_mutex_t )));
    mdb->imtx = tmp___2;
    if (! tmp___2) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___4 = malloc((unsigned int )((int )sizeof(TCMAP *) * 8));
    tmp___3 = (TCMAP **)tmp___4;
    mdb->maps = tmp___3;
    if (! tmp___3) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tmp___5 = pthread_mutex_init((pthread_mutex_t *)mdb->imtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___5 != 0) {
    tcmyfatal("mutex error");
  }
  i = 0;
  while (i < 8) {
    tmp___6 = pthread_rwlock_init((pthread_rwlock_t * __restrict  )((pthread_rwlock_t *)mdb->mmtxs + i),
                                  (pthread_rwlockattr_t const   * __restrict  )((void *)0));
    if (tmp___6 != 0) {
      tcmyfatal("rwlock error");
    }
    *(mdb->maps + i) = tcmapnew2(bnum);
    i ++;
  }
  mdb->iter = -1;
  return (mdb);
}
}
void tcmdbdel(TCMDB *mdb ) 
{ int i ;

  {
  i = 7;
  while (i >= 0) {
    tcmapdel(*(mdb->maps + i));
    pthread_rwlock_destroy((pthread_rwlock_t *)mdb->mmtxs + i);
    i --;
  }
  pthread_mutex_destroy((pthread_mutex_t *)mdb->imtx);
  while (1) {
    free((void *)mdb->maps);
    break;
  }
  while (1) {
    free(mdb->imtx);
    break;
  }
  while (1) {
    free((void *)mdb->mmtxs);
    break;
  }
  while (1) {
    free((void *)mdb);
    break;
  }
  return;
}
}
void tcmdbput(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return;
  }
  tcmapput(*(mdb->maps + mi), kbuf, ksiz, vbuf, vsiz);
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return;
}
}
void tcmdbput2(TCMDB *mdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tcmdbput(mdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr, (int )tmp);
  return;
}
}
_Bool tcmdbputkeep(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return ((_Bool)0);
  }
  tmp___2 = tcmapputkeep(*(mdb->maps + mi), kbuf, ksiz, vbuf, vsiz);
  rv = tmp___2;
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return (rv);
}
}
_Bool tcmdbputkeep2(TCMDB *mdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcmdbputkeep(mdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                         (int )tmp);
  return (tmp___1);
}
}
void tcmdbputcat(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                 int vsiz ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return;
  }
  tcmapputcat(*(mdb->maps + mi), kbuf, ksiz, vbuf, vsiz);
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return;
}
}
void tcmdbputcat2(TCMDB *mdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tcmdbputcat(mdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr, (int )tmp);
  return;
}
}
_Bool tcmdbout(TCMDB *mdb , void const   *kbuf , int ksiz ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return ((_Bool)0);
  }
  tmp___2 = tcmapout(*(mdb->maps + mi), kbuf, ksiz);
  rv = tmp___2;
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return (rv);
}
}
_Bool tcmdbout2(TCMDB *mdb , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcmdbout(mdb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
void *tcmdbget(TCMDB *mdb , void const   *kbuf , int ksiz , int *sp ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___2 ;
  char *rv ;
  void *tmp___3 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_rdlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return ((void *)0);
  }
  tmp___2 = tcmapget((TCMAP const   *)*(mdb->maps + mi), kbuf, ksiz, & vsiz);
  vbuf = (char const   *)tmp___2;
  if (vbuf) {
    while (1) {
      while (1) {
        tmp___3 = malloc((unsigned int )(vsiz + 1));
        rv = (char *)tmp___3;
        if (! rv) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )rv, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      *(rv + vsiz) = (char )'\000';
      break;
    }
    *sp = vsiz;
  } else {
    rv = (char *)((void *)0);
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return ((void *)rv);
}
}
char *tcmdbget2(TCMDB *mdb , char const   *kstr ) 
{ int vsiz ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcmdbget(mdb, (void const   *)kstr, (int )tmp, & vsiz);
  return ((char *)tmp___0);
}
}
int tcmdbvsiz(TCMDB *mdb , void const   *kbuf , int ksiz ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___2 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_rdlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return (-1);
  }
  tmp___2 = tcmapget((TCMAP const   *)*(mdb->maps + mi), kbuf, ksiz, & vsiz);
  vbuf = (char const   *)tmp___2;
  if (! vbuf) {
    vsiz = -1;
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return (vsiz);
}
}
int tcmdbvsiz2(TCMDB *mdb , char const   *kstr ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcmdbvsiz(mdb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
void tcmdbiterinit(TCMDB *mdb ) 
{ int tmp ;
  int i ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)mdb->imtx);
  if (tmp != 0) {
    return;
  }
  i = 0;
  while (i < 8) {
    tcmapiterinit(*(mdb->maps + i));
    i ++;
  }
  mdb->iter = 0;
  pthread_mutex_unlock((pthread_mutex_t *)mdb->imtx);
  return;
}
}
void *tcmdbiternext(TCMDB *mdb , int *sp ) 
{ int tmp ;
  int mi ;
  int tmp___0 ;
  int ksiz ;
  char const   *kbuf ;
  int tmp___1 ;
  void const   *tmp___2 ;
  char *rv ;
  void *tmp___3 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)mdb->imtx);
  if (tmp != 0) {
    return ((void *)0);
  }
  if (mdb->iter < 0) {
    pthread_mutex_unlock((pthread_mutex_t *)mdb->imtx);
    return ((void *)0);
  } else {
    if (mdb->iter >= 8) {
      pthread_mutex_unlock((pthread_mutex_t *)mdb->imtx);
      return ((void *)0);
    }
  }
  mi = mdb->iter;
  tmp___0 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___0 != 0) {
    pthread_mutex_unlock((pthread_mutex_t *)mdb->imtx);
    return ((void *)0);
  }
  while (1) {
    tmp___2 = tcmapiternext(*(mdb->maps + mi), & ksiz);
    kbuf = (char const   *)tmp___2;
    if (kbuf) {
      break;
    } else {
      if (! (mi < 7)) {
        break;
      }
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
    (mdb->iter) ++;
    mi = mdb->iter;
    tmp___1 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
    if (tmp___1 != 0) {
      pthread_mutex_unlock((pthread_mutex_t *)mdb->imtx);
      return ((void *)0);
    }
  }
  if (kbuf) {
    while (1) {
      while (1) {
        tmp___3 = malloc((unsigned int )(ksiz + 1));
        rv = (char *)tmp___3;
        if (! rv) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )rv, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      *(rv + ksiz) = (char )'\000';
      break;
    }
    *sp = ksiz;
  } else {
    rv = (char *)((void *)0);
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  pthread_mutex_unlock((pthread_mutex_t *)mdb->imtx);
  return ((void *)rv);
}
}
char *tcmdbiternext2(TCMDB *mdb ) 
{ int ksiz ;
  void *tmp ;

  {
  tmp = tcmdbiternext(mdb, & ksiz);
  return ((char *)tmp);
}
}
TCLIST *tcmdbfwmkeys(TCMDB *mdb , void const   *pbuf , int psiz , int max ) 
{ TCLIST *keys ;
  TCLIST *tmp ;
  int tmp___0 ;
  int i ;
  TCMAP *map ;
  TCMAPREC *cur ;
  char const   *kbuf ;
  int ksiz ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___1 ;
  void *tmp___2 ;
  TCLISTDATUM *array ;
  char *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void const   *tmp___6 ;
  int tmp___7 ;

  {
  tmp = tclistnew();
  keys = tmp;
  tmp___0 = pthread_mutex_lock((pthread_mutex_t *)mdb->imtx);
  if (tmp___0 != 0) {
    return (keys);
  }
  if (max < 0) {
    max = 2147483647;
  }
  i = 0;
  while (1) {
    if (i < 8) {
      if (! (keys->num < max)) {
        break;
      }
    } else {
      break;
    }
    tmp___7 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + i);
    if (tmp___7 == 0) {
      map = *(mdb->maps + i);
      cur = map->cur;
      tcmapiterinit(map);
      while (1) {
        if (keys->num < max) {
          tmp___6 = tcmapiternext(map, & ksiz);
          kbuf = (char const   *)tmp___6;
          if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
            break;
          }
        } else {
          break;
        }
        if (ksiz >= psiz) {
          tmp___5 = memcmp((void const   *)kbuf, pbuf, (unsigned int )psiz);
          if (! tmp___5) {
            while (1) {
              TC_mysize = ksiz;
              TC_index = keys->start + keys->num;
              if (TC_index >= keys->anum) {
                keys->anum += keys->num + 1;
                while (1) {
                  tmp___2 = realloc((void *)keys->array, (unsigned int )(keys->anum * (int )sizeof(*(keys->array + 0))));
                  tmp___1 = (TCLISTDATUM *)tmp___2;
                  keys->array = tmp___1;
                  if (! tmp___1) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              array = keys->array;
              while (1) {
                tmp___4 = malloc((unsigned int )(TC_mysize + 1));
                tmp___3 = (char *)tmp___4;
                (array + TC_index)->ptr = tmp___3;
                if (! tmp___3) {
                  tcmyfatal("out of memory");
                }
                break;
              }
              memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )kbuf,
                     (unsigned int )TC_mysize);
              *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
              (array + TC_index)->size = TC_mysize;
              (keys->num) ++;
              break;
            }
          }
        }
      }
      map->cur = cur;
      pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + i);
    }
    i ++;
  }
  pthread_mutex_unlock((pthread_mutex_t *)mdb->imtx);
  return (keys);
}
}
TCLIST *tcmdbfwmkeys2(TCMDB *mdb , char const   *pstr , int max ) 
{ size_t tmp ;
  TCLIST *tmp___0 ;

  {
  tmp = strlen(pstr);
  tmp___0 = tcmdbfwmkeys(mdb, (void const   *)pstr, (int )tmp, max);
  return (tmp___0);
}
}
uint64_t tcmdbrnum(TCMDB *mdb ) 
{ uint64_t rnum ;
  int i ;
  uint64_t tmp ;

  {
  rnum = 0ULL;
  i = 0;
  while (i < 8) {
    tmp = tcmaprnum((TCMAP const   *)*(mdb->maps + i));
    rnum += tmp;
    i ++;
  }
  return (rnum);
}
}
uint64_t tcmdbmsiz(TCMDB *mdb ) 
{ uint64_t msiz ;
  int i ;
  uint64_t tmp ;

  {
  msiz = 0ULL;
  i = 0;
  while (i < 8) {
    tmp = tcmapmsiz((TCMAP const   *)*(mdb->maps + i));
    msiz += tmp;
    i ++;
  }
  return (msiz);
}
}
int tcmdbaddint(TCMDB *mdb , void const   *kbuf , int ksiz , int num ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int rv ;
  int tmp___2 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return ((-0x7FFFFFFF-1));
  }
  tmp___2 = tcmapaddint(*(mdb->maps + mi), kbuf, ksiz, num);
  rv = tmp___2;
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return (rv);
}
}
double tcmdbadddouble(TCMDB *mdb , void const   *kbuf , int ksiz , double num ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  double tmp___1 ;
  int tmp___2 ;
  double rv ;
  double tmp___3 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___2 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___2 != 0) {
    tmp___1 = nan("");
    return (tmp___1);
  }
  tmp___3 = tcmapadddouble(*(mdb->maps + mi), kbuf, ksiz, num);
  rv = tmp___3;
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return (rv);
}
}
void tcmdbvanish(TCMDB *mdb ) 
{ int i ;
  int tmp ;

  {
  i = 0;
  while (i < 8) {
    tmp = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + i);
    if (tmp == 0) {
      tcmapclear(*(mdb->maps + i));
      pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + i);
    }
    i ++;
  }
  return;
}
}
void tcmdbcutfront(TCMDB *mdb , int num ) 
{ int i ;
  int tmp ;

  {
  num = num / 8 + 1;
  i = 0;
  while (i < 8) {
    tmp = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + i);
    if (tmp == 0) {
      tcmapcutfront(*(mdb->maps + i), num);
      pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + i);
    }
    i ++;
  }
  return;
}
}
void tcmdbput3(TCMDB *mdb , void const   *kbuf , int ksiz , char const   *vbuf , int vsiz ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return;
  }
  tcmapput3(*(mdb->maps + mi), kbuf, ksiz, vbuf, vsiz);
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return;
}
}
void tcmdbput4(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *fvbuf ,
               int fvsiz , void const   *lvbuf , int lvsiz ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return;
  }
  tcmapput4(*(mdb->maps + mi), kbuf, ksiz, fvbuf, fvsiz, lvbuf, lvsiz);
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return;
}
}
void tcmdbputcat3(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return;
  }
  tcmapputcat3(*(mdb->maps + mi), kbuf, ksiz, vbuf, vsiz);
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return;
}
}
_Bool tcmdbputproc(TCMDB *mdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return ((_Bool)0);
  }
  tmp___2 = tcmapputproc(*(mdb->maps + mi), kbuf, ksiz, vbuf, vsiz, proc___0, op);
  rv = tmp___2;
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return (rv);
}
}
void *tcmdbget3(TCMDB *mdb , void const   *kbuf , int ksiz , int *sp ) 
{ unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___2 ;
  char *rv ;
  void *tmp___3 ;

  {
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___0 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___0) {
        break;
      }
      tmp = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp;
    }
    mi &= 7U;
    break;
  }
  tmp___1 = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___1 != 0) {
    return ((void *)0);
  }
  tmp___2 = tcmapget3(*(mdb->maps + mi), kbuf, ksiz, & vsiz);
  vbuf = (char const   *)tmp___2;
  if (vbuf) {
    while (1) {
      while (1) {
        tmp___3 = malloc((unsigned int )(vsiz + 1));
        rv = (char *)tmp___3;
        if (! rv) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )rv, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      *(rv + vsiz) = (char )'\000';
      break;
    }
    *sp = vsiz;
  } else {
    rv = (char *)((void *)0);
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  return ((void *)rv);
}
}
void tcmdbiterinit2(TCMDB *mdb , void const   *kbuf , int ksiz ) 
{ int tmp ;
  unsigned int mi ;
  unsigned char const   *_TC_p ;
  int _TC_ksiz ;
  unsigned char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int vsiz ;
  int i ;
  void const   *tmp___3 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)mdb->imtx);
  if (tmp != 0) {
    return;
  }
  while (1) {
    _TC_p = ((unsigned char const   *)kbuf + ksiz) - 1;
    _TC_ksiz = ksiz;
    mi = 537334051U;
    while (1) {
      tmp___1 = _TC_ksiz;
      _TC_ksiz --;
      if (! tmp___1) {
        break;
      }
      tmp___0 = _TC_p;
      _TC_p --;
      mi = mi * 33U + (unsigned int )*tmp___0;
    }
    mi &= 7U;
    break;
  }
  tmp___2 = pthread_rwlock_rdlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  if (tmp___2 != 0) {
    pthread_mutex_unlock((pthread_mutex_t *)mdb->imtx);
    return;
  }
  tmp___3 = tcmapget((TCMAP const   *)*(mdb->maps + mi), kbuf, ksiz, & vsiz);
  if (tmp___3) {
    i = 0;
    while (i < 8) {
      tcmapiterinit(*(mdb->maps + i));
      i ++;
    }
    tcmapiterinit2(*(mdb->maps + mi), kbuf, ksiz);
    mdb->iter = (int )mi;
  }
  pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + mi);
  pthread_mutex_unlock((pthread_mutex_t *)mdb->imtx);
  return;
}
}
void tcmdbiterinit3(TCMDB *mdb , char const   *kstr ) 
{ size_t tmp ;

  {
  tmp = strlen(kstr);
  tcmdbiterinit2(mdb, (void const   *)kstr, (int )tmp);
  return;
}
}
void tcmdbforeach(TCMDB *mdb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                             int vsiz , void *op ) , void *op ) 
{ int i ;
  int tmp ;
  _Bool cont ;
  int i___0 ;
  TCMAP *map ;
  TCMAPREC *cur ;
  int ksiz ;
  char const   *kbuf ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___0 ;
  _Bool tmp___1 ;
  void const   *tmp___2 ;
  int i___1 ;

  {
  i = 0;
  while (i < 8) {
    tmp = pthread_rwlock_wrlock((pthread_rwlock_t *)mdb->mmtxs + i);
    if (tmp != 0) {
      while (i >= 0) {
        pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + i);
        i --;
      }
      return;
    }
    i ++;
  }
  cont = (_Bool)1;
  i___0 = 0;
  while (1) {
    if (cont) {
      if (! (i___0 < 8)) {
        break;
      }
    } else {
      break;
    }
    map = *(mdb->maps + i___0);
    cur = map->cur;
    tcmapiterinit(map);
    while (1) {
      if (cont) {
        tmp___2 = tcmapiternext(map, & ksiz);
        kbuf = (char const   *)tmp___2;
        if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
          break;
        }
      } else {
        break;
      }
      tmp___0 = tcmapiterval((void const   *)kbuf, & vsiz);
      vbuf = (char const   *)tmp___0;
      tmp___1 = (*iter)((void const   *)kbuf, ksiz, (void const   *)vbuf, vsiz, op);
      if (! tmp___1) {
        cont = (_Bool)0;
      }
    }
    map->cur = cur;
    i___0 ++;
  }
  i___1 = 7;
  while (i___1 >= 0) {
    pthread_rwlock_unlock((pthread_rwlock_t *)mdb->mmtxs + i___1);
    i___1 --;
  }
  return;
}
}
TCNDB *tcndbnew(void) 
{ TCNDB *tmp ;

  {
  tmp = tcndbnew2(& tccmplexical, (void *)0);
  return (tmp);
}
}
TCNDB *tcndbnew2(int (*cmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz ,
                            void *op ) , void *cmpop ) 
{ TCNDB *ndb ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*ndb)));
    ndb = (TCNDB *)tmp;
    if (! ndb) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___0 = malloc((unsigned int )((int )sizeof(pthread_mutex_t )));
    ndb->mmtx = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tmp___1 = pthread_mutex_init((pthread_mutex_t *)ndb->mmtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___1 != 0) {
    tcmyfatal("mutex error");
  }
  ndb->tree = tctreenew2(cmp, cmpop);
  return (ndb);
}
}
void tcndbdel(TCNDB *ndb ) 
{ 

  {
  tctreedel(ndb->tree);
  pthread_mutex_destroy((pthread_mutex_t *)ndb->mmtx);
  while (1) {
    free(ndb->mmtx);
    break;
  }
  while (1) {
    free((void *)ndb);
    break;
  }
  return;
}
}
void tcndbput(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return;
  }
  tctreeput(ndb->tree, kbuf, ksiz, vbuf, vsiz);
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return;
}
}
void tcndbput2(TCNDB *ndb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tcndbput(ndb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr, (int )tmp);
  return;
}
}
_Bool tcndbputkeep(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) 
{ int tmp ;
  _Bool rv ;
  _Bool tmp___0 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return ((_Bool)0);
  }
  tmp___0 = tctreeputkeep(ndb->tree, kbuf, ksiz, vbuf, vsiz);
  rv = tmp___0;
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return (rv);
}
}
_Bool tcndbputkeep2(TCNDB *ndb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcndbputkeep(ndb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                         (int )tmp);
  return (tmp___1);
}
}
void tcndbputcat(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf ,
                 int vsiz ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return;
  }
  tctreeputcat(ndb->tree, kbuf, ksiz, vbuf, vsiz);
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return;
}
}
void tcndbputcat2(TCNDB *ndb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tcndbputcat(ndb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr, (int )tmp);
  return;
}
}
_Bool tcndbout(TCNDB *ndb , void const   *kbuf , int ksiz ) 
{ int tmp ;
  _Bool rv ;
  _Bool tmp___0 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return ((_Bool)0);
  }
  tmp___0 = tctreeout(ndb->tree, kbuf, ksiz);
  rv = tmp___0;
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return (rv);
}
}
_Bool tcndbout2(TCNDB *ndb , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcndbout(ndb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
void *tcndbget(TCNDB *ndb , void const   *kbuf , int ksiz , int *sp ) 
{ int tmp ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___0 ;
  char *rv ;
  void *tmp___1 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return ((void *)0);
  }
  tmp___0 = tctreeget(ndb->tree, kbuf, ksiz, & vsiz);
  vbuf = (char const   *)tmp___0;
  if (vbuf) {
    while (1) {
      while (1) {
        tmp___1 = malloc((unsigned int )(vsiz + 1));
        rv = (char *)tmp___1;
        if (! rv) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )rv, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      *(rv + vsiz) = (char )'\000';
      break;
    }
    *sp = vsiz;
  } else {
    rv = (char *)((void *)0);
  }
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return ((void *)rv);
}
}
char *tcndbget2(TCNDB *ndb , char const   *kstr ) 
{ int vsiz ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcndbget(ndb, (void const   *)kstr, (int )tmp, & vsiz);
  return ((char *)tmp___0);
}
}
int tcndbvsiz(TCNDB *ndb , void const   *kbuf , int ksiz ) 
{ int tmp ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___0 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return (-1);
  }
  tmp___0 = tctreeget(ndb->tree, kbuf, ksiz, & vsiz);
  vbuf = (char const   *)tmp___0;
  if (! vbuf) {
    vsiz = -1;
  }
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return (vsiz);
}
}
int tcndbvsiz2(TCNDB *ndb , char const   *kstr ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcndbvsiz(ndb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
void tcndbiterinit(TCNDB *ndb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return;
  }
  tctreeiterinit(ndb->tree);
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return;
}
}
void *tcndbiternext(TCNDB *ndb , int *sp ) 
{ int tmp ;
  int ksiz ;
  char const   *kbuf ;
  void const   *tmp___0 ;
  char *rv ;
  void *tmp___1 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return ((void *)0);
  }
  tmp___0 = tctreeiternext(ndb->tree, & ksiz);
  kbuf = (char const   *)tmp___0;
  if (kbuf) {
    while (1) {
      while (1) {
        tmp___1 = malloc((unsigned int )(ksiz + 1));
        rv = (char *)tmp___1;
        if (! rv) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )rv, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      *(rv + ksiz) = (char )'\000';
      break;
    }
    *sp = ksiz;
  } else {
    rv = (char *)((void *)0);
  }
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return ((void *)rv);
}
}
char *tcndbiternext2(TCNDB *ndb ) 
{ int ksiz ;
  void *tmp ;

  {
  tmp = tcndbiternext(ndb, & ksiz);
  return ((char *)tmp);
}
}
TCLIST *tcndbfwmkeys(TCNDB *ndb , void const   *pbuf , int psiz , int max ) 
{ TCLIST *keys ;
  TCLIST *tmp ;
  int tmp___0 ;
  TCTREE *tree ;
  TCTREEREC *cur ;
  char const   *lbuf ;
  int lsiz ;
  char const   *kbuf ;
  int ksiz ;
  int tmp___1 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___2 ;
  void *tmp___3 ;
  TCLISTDATUM *array ;
  char *tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  void const   *tmp___7 ;

  {
  tmp = tclistnew();
  keys = tmp;
  tmp___0 = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp___0 != 0) {
    return (keys);
  }
  if (max < 0) {
    max = 2147483647;
  }
  tree = ndb->tree;
  cur = tree->cur;
  tctreeiterinit2(tree, pbuf, psiz);
  lbuf = (char const   *)((void *)0);
  lsiz = 0;
  while (1) {
    if (keys->num < max) {
      tmp___7 = tctreeiternext(tree, & ksiz);
      kbuf = (char const   *)tmp___7;
      if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    if (ksiz < psiz) {
      break;
    } else {
      tmp___1 = memcmp((void const   *)kbuf, pbuf, (unsigned int )psiz);
      if (tmp___1) {
        break;
      }
    }
    if (! lbuf) {
      goto _L;
    } else {
      if (lsiz != ksiz) {
        goto _L;
      } else {
        tmp___6 = memcmp((void const   *)kbuf, (void const   *)lbuf, (unsigned int )ksiz);
        if (tmp___6) {
          _L: 
          while (1) {
            TC_mysize = ksiz;
            TC_index = keys->start + keys->num;
            if (TC_index >= keys->anum) {
              keys->anum += keys->num + 1;
              while (1) {
                tmp___3 = realloc((void *)keys->array, (unsigned int )(keys->anum * (int )sizeof(*(keys->array + 0))));
                tmp___2 = (TCLISTDATUM *)tmp___3;
                keys->array = tmp___2;
                if (! tmp___2) {
                  tcmyfatal("out of memory");
                }
                break;
              }
            }
            array = keys->array;
            while (1) {
              tmp___5 = malloc((unsigned int )(TC_mysize + 1));
              tmp___4 = (char *)tmp___5;
              (array + TC_index)->ptr = tmp___4;
              if (! tmp___4) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )kbuf,
                   (unsigned int )TC_mysize);
            *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
            (array + TC_index)->size = TC_mysize;
            (keys->num) ++;
            break;
          }
          if (keys->num >= max) {
            break;
          }
          lbuf = kbuf;
          lsiz = ksiz;
        }
      }
    }
  }
  tree->cur = cur;
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return (keys);
}
}
TCLIST *tcndbfwmkeys2(TCNDB *ndb , char const   *pstr , int max ) 
{ size_t tmp ;
  TCLIST *tmp___0 ;

  {
  tmp = strlen(pstr);
  tmp___0 = tcndbfwmkeys(ndb, (void const   *)pstr, (int )tmp, max);
  return (tmp___0);
}
}
uint64_t tcndbrnum(TCNDB *ndb ) 
{ uint64_t tmp ;

  {
  tmp = tctreernum((TCTREE const   *)ndb->tree);
  return (tmp);
}
}
uint64_t tcndbmsiz(TCNDB *ndb ) 
{ uint64_t tmp ;

  {
  tmp = tctreemsiz((TCTREE const   *)ndb->tree);
  return (tmp);
}
}
int tcndbaddint(TCNDB *ndb , void const   *kbuf , int ksiz , int num ) 
{ int tmp ;
  int rv ;
  int tmp___0 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return ((-0x7FFFFFFF-1));
  }
  tmp___0 = tctreeaddint(ndb->tree, kbuf, ksiz, num);
  rv = tmp___0;
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return (rv);
}
}
double tcndbadddouble(TCNDB *ndb , void const   *kbuf , int ksiz , double num ) 
{ double tmp ;
  int tmp___0 ;
  double rv ;
  double tmp___1 ;

  {
  tmp___0 = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp___0 != 0) {
    tmp = nan("");
    return (tmp);
  }
  tmp___1 = tctreeadddouble(ndb->tree, kbuf, ksiz, num);
  rv = tmp___1;
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return (rv);
}
}
void tcndbvanish(TCNDB *ndb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {

  }
  tctreeclear(ndb->tree);
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return;
}
}
void tcndbcutfringe(TCNDB *ndb , int num ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {

  }
  tctreecutfringe(ndb->tree, num);
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return;
}
}
void tcndbput3(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return;
  }
  tctreeput3(ndb->tree, kbuf, ksiz, vbuf, vsiz);
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return;
}
}
_Bool tcndbputkeep3(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf ,
                    int vsiz ) 
{ int tmp ;
  _Bool rv ;
  _Bool tmp___0 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return ((_Bool)0);
  }
  tmp___0 = tctreeputkeep3(ndb->tree, kbuf, ksiz, vbuf, vsiz);
  rv = tmp___0;
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return (rv);
}
}
void tcndbputcat3(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return;
  }
  tctreeputcat3(ndb->tree, kbuf, ksiz, vbuf, vsiz);
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return;
}
}
_Bool tcndbputproc(TCNDB *ndb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) 
{ int tmp ;
  _Bool rv ;
  _Bool tmp___0 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return ((_Bool)0);
  }
  tmp___0 = tctreeputproc(ndb->tree, kbuf, ksiz, vbuf, vsiz, proc___0, op);
  rv = tmp___0;
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return (rv);
}
}
void *tcndbget3(TCNDB *ndb , void const   *kbuf , int ksiz , int *sp ) 
{ int tmp ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___0 ;
  char *rv ;
  void *tmp___1 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return ((void *)0);
  }
  tmp___0 = tctreeget3((TCTREE const   *)ndb->tree, kbuf, ksiz, & vsiz);
  vbuf = (char const   *)tmp___0;
  if (vbuf) {
    while (1) {
      while (1) {
        tmp___1 = malloc((unsigned int )(vsiz + 1));
        rv = (char *)tmp___1;
        if (! rv) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )rv, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      *(rv + vsiz) = (char )'\000';
      break;
    }
    *sp = vsiz;
  } else {
    rv = (char *)((void *)0);
  }
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return ((void *)rv);
}
}
void tcndbiterinit2(TCNDB *ndb , void const   *kbuf , int ksiz ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return;
  }
  tctreeiterinit2(ndb->tree, kbuf, ksiz);
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return;
}
}
void tcndbiterinit3(TCNDB *ndb , char const   *kstr ) 
{ size_t tmp ;

  {
  tmp = strlen(kstr);
  tcndbiterinit2(ndb, (void const   *)kstr, (int )tmp);
  return;
}
}
void tcndbforeach(TCNDB *ndb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                             int vsiz , void *op ) , void *op ) 
{ int tmp ;
  TCTREE *tree ;
  TCTREEREC *cur ;
  int ksiz ;
  char const   *kbuf ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___0 ;
  _Bool tmp___1 ;
  void const   *tmp___2 ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)ndb->mmtx);
  if (tmp != 0) {
    return;
  }
  tree = ndb->tree;
  cur = tree->cur;
  tctreeiterinit(tree);
  while (1) {
    tmp___2 = tctreeiternext(tree, & ksiz);
    kbuf = (char const   *)tmp___2;
    if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
      break;
    }
    tmp___0 = tctreeiterval((void const   *)kbuf, & vsiz);
    vbuf = (char const   *)tmp___0;
    tmp___1 = (*iter)((void const   *)kbuf, ksiz, (void const   *)vbuf, vsiz, op);
    if (! tmp___1) {
      break;
    }
  }
  tree->cur = cur;
  pthread_mutex_unlock((pthread_mutex_t *)ndb->mmtx);
  return;
}
}
TCMPOOL *tcglobalmemorypool  =    (TCMPOOL *)((void *)0);
static void tcmpooldelglobal(void) ;
TCMPOOL *tcmpoolnew(void) 
{ TCMPOOL *mpool ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  TCMPELEM *tmp___2 ;
  void *tmp___3 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*mpool)));
    mpool = (TCMPOOL *)tmp;
    if (! mpool) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___0 = malloc((unsigned int )((int )sizeof(pthread_mutex_t )));
    mpool->mutex = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tmp___1 = pthread_mutex_init((pthread_mutex_t *)mpool->mutex, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___1 != 0) {
    tcmyfatal("locking failed");
  }
  mpool->anum = 128;
  while (1) {
    tmp___3 = malloc((unsigned int )((int )sizeof(*(mpool->elems + 0)) * mpool->anum));
    tmp___2 = (TCMPELEM *)tmp___3;
    mpool->elems = tmp___2;
    if (! tmp___2) {
      tcmyfatal("out of memory");
    }
    break;
  }
  mpool->num = 0;
  return (mpool);
}
}
void tcmpooldel(TCMPOOL *mpool ) 
{ TCMPELEM *elems ;
  int i ;

  {
  elems = mpool->elems;
  i = mpool->num - 1;
  while (i >= 0) {
    (*((elems + i)->del))((elems + i)->ptr);
    i --;
  }
  while (1) {
    free((void *)elems);
    break;
  }
  pthread_mutex_destroy((pthread_mutex_t *)mpool->mutex);
  while (1) {
    free(mpool->mutex);
    break;
  }
  while (1) {
    free((void *)mpool);
    break;
  }
  return;
}
}
void *tcmpoolpush(TCMPOOL *mpool , void *ptr , void (*del)(void * ) ) 
{ int tmp ;
  int num ;
  TCMPELEM *tmp___0 ;
  void *tmp___1 ;

  {
  if (! ptr) {
    return ((void *)0);
  }
  tmp = pthread_mutex_lock((pthread_mutex_t *)mpool->mutex);
  if (tmp != 0) {
    tcmyfatal("locking failed");
  }
  num = mpool->num;
  if (num >= mpool->anum) {
    mpool->anum *= 2;
    while (1) {
      tmp___1 = realloc((void *)mpool->elems, (unsigned int )(mpool->anum * (int )sizeof(*(mpool->elems + 0))));
      tmp___0 = (TCMPELEM *)tmp___1;
      mpool->elems = tmp___0;
      if (! tmp___0) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  (mpool->elems + num)->ptr = ptr;
  (mpool->elems + num)->del = del;
  (mpool->num) ++;
  pthread_mutex_unlock((pthread_mutex_t *)mpool->mutex);
  return (ptr);
}
}
void *tcmpoolpushptr(TCMPOOL *mpool , void *ptr ) 
{ void *tmp ;

  {
  tmp = tcmpoolpush(mpool, ptr, & free);
  return (tmp);
}
}
TCXSTR *tcmpoolpushxstr(TCMPOOL *mpool , TCXSTR *xstr ) 
{ void *tmp ;

  {
  tmp = tcmpoolpush(mpool, (void *)xstr, (void (*)(void * ))(& tcxstrdel));
  return ((TCXSTR *)tmp);
}
}
TCLIST *tcmpoolpushlist(TCMPOOL *mpool , TCLIST *list ) 
{ void *tmp ;

  {
  tmp = tcmpoolpush(mpool, (void *)list, (void (*)(void * ))(& tclistdel));
  return ((TCLIST *)tmp);
}
}
TCMAP *tcmpoolpushmap(TCMPOOL *mpool , TCMAP *map ) 
{ void *tmp ;

  {
  tmp = tcmpoolpush(mpool, (void *)map, (void (*)(void * ))(& tcmapdel));
  return ((TCMAP *)tmp);
}
}
TCTREE *tcmpoolpushtree(TCMPOOL *mpool , TCTREE *tree ) 
{ void *tmp ;

  {
  tmp = tcmpoolpush(mpool, (void *)tree, (void (*)(void * ))(& tctreedel));
  return ((TCTREE *)tmp);
}
}
void *tcmpoolmalloc(TCMPOOL *mpool , size_t size ) 
{ void *ptr ;

  {
  while (1) {
    ptr = malloc(size);
    if (! ptr) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tcmpoolpush(mpool, ptr, & free);
  return (ptr);
}
}
TCXSTR *tcmpoolxstrnew(TCMPOOL *mpool ) 
{ TCXSTR *xstr ;
  TCXSTR *tmp ;

  {
  tmp = tcxstrnew();
  xstr = tmp;
  tcmpoolpush(mpool, (void *)xstr, (void (*)(void * ))(& tcxstrdel));
  return (xstr);
}
}
TCLIST *tcmpoollistnew(TCMPOOL *mpool ) 
{ TCLIST *list ;
  TCLIST *tmp ;

  {
  tmp = tclistnew();
  list = tmp;
  tcmpoolpush(mpool, (void *)list, (void (*)(void * ))(& tclistdel));
  return (list);
}
}
TCMAP *tcmpoolmapnew(TCMPOOL *mpool ) 
{ TCMAP *map ;
  TCMAP *tmp ;

  {
  tmp = tcmapnew();
  map = tmp;
  tcmpoolpush(mpool, (void *)map, (void (*)(void * ))(& tcmapdel));
  return (map);
}
}
TCTREE *tcmpooltreenew(TCMPOOL *mpool ) 
{ TCTREE *tree ;
  TCTREE *tmp ;

  {
  tmp = tctreenew();
  tree = tmp;
  tcmpoolpush(mpool, (void *)tree, (void (*)(void * ))(& tctreedel));
  return (tree);
}
}
void tcmpoolpop(TCMPOOL *mpool , _Bool exe ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)mpool->mutex);
  if (tmp != 0) {
    tcmyfatal("locking failed");
  }
  if (mpool->num > 0) {
    (mpool->num) --;
    if (exe) {
      (*((mpool->elems + mpool->num)->del))((mpool->elems + mpool->num)->ptr);
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)mpool->mutex);
  return;
}
}
TCMPOOL *tcmpoolglobal(void) 
{ 

  {
  if (tcglobalmemorypool) {
    return (tcglobalmemorypool);
  }
  tcglobalmemorypool = tcmpoolnew();
  atexit(& tcmpooldelglobal);
  return (tcglobalmemorypool);
}
}
static void tcmpooldelglobal(void) 
{ 

  {
  if (tcglobalmemorypool) {
    tcmpooldel(tcglobalmemorypool);
  }
  return;
}
}
int tcrandomdevfd  =    -1;
static void tcrandomfdclose(void) ;
static time_t tcmkgmtime(struct tm *tm ) ;
long tclmax(long a , long b ) 
{ long tmp ;

  {
  if (a > b) {
    tmp = a;
  } else {
    tmp = b;
  }
  return (tmp);
}
}
long tclmin(long a , long b ) 
{ long tmp ;

  {
  if (a < b) {
    tmp = a;
  } else {
    tmp = b;
  }
  return (tmp);
}
}
static uint32_t cnt  =    0U;
static uint64_t seed  =    0ULL;
static uint64_t mask  =    0ULL;
static pthread_mutex_t mutex  =    {{0, 0U, 0, 0, 0U, {0}}};
unsigned long tclrand(void) 
{ time_t tmp ;
  double t ;
  double tmp___0 ;
  uint64_t tmask ;
  long tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  uint64_t num ;
  uint32_t tmp___4 ;

  {
  if ((cnt & 255U) == 0U) {
    tmp___3 = pthread_mutex_lock(& mutex);
    if (tmp___3 == 0) {
      if (cnt == 0U) {
        tmp = time((time_t *)((void *)0));
        seed += (unsigned long long )tmp;
      }
      if (tcrandomdevfd == -1) {
        tcrandomdevfd = open("/dev/urandom", 0, 420);
        if (tcrandomdevfd != -1) {
          atexit(& tcrandomfdclose);
        }
      }
      if (tcrandomdevfd == -1) {
        tmp___0 = tctime();
        t = tmp___0;
        tmp___1 = tclmin((long )((int )sizeof(t)), (long )((int )sizeof(tmask)));
        memcpy((void * __restrict  )(& tmask), (void const   * __restrict  )(& t),
               (unsigned int )tmp___1);
        mask = (mask << 8) ^ tmask;
      } else {
        tmp___2 = read(tcrandomdevfd, (void *)(& mask), (unsigned int )((int )sizeof(mask)));
        if (tmp___2 != (int )sizeof(mask)) {
          tmp___0 = tctime();
          t = tmp___0;
          tmp___1 = tclmin((long )((int )sizeof(t)), (long )((int )sizeof(tmask)));
          memcpy((void * __restrict  )(& tmask), (void const   * __restrict  )(& t),
                 (unsigned int )tmp___1);
          mask = (mask << 8) ^ tmask;
        }
      }
      pthread_mutex_unlock(& mutex);
    }
  }
  seed = seed * 123456789012301ULL + 211ULL;
  tmp___4 = cnt;
  cnt ++;
  num = (mask ^ (unsigned long long )tmp___4) ^ seed;
  return ((unsigned long )(((((((((num & 255ULL) << 56) | ((num & 65280ULL) << 40)) | ((num & 16711680ULL) << 24)) | ((num & 4278190080ULL) << 8)) | ((num & 1095216660480ULL) >> 8)) | ((num & 280375465082880ULL) >> 24)) | ((num & 71776119061217280ULL) >> 40)) | ((num & 0xff00000000000000ULL) >> 56)));
}
}
double tcdrand(void) 
{ double val ;
  unsigned long tmp ;
  double tmp___0 ;

  {
  tmp = tclrand();
  val = (double )tmp / (double )4294967295UL;
  if (val < 1.0) {
    tmp___0 = val;
  } else {
    tmp___0 = 0.0;
  }
  return (tmp___0);
}
}
double tcdrandnd(double avg , double sd ) 
{ double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
  tmp = tcdrand();
  tmp___0 = log(tmp);
  tmp___1 = sqrt(- 2.0 * tmp___0);
  tmp___2 = tcdrand();
  tmp___3 = cos(((double )2 * 3.141592653589793) * tmp___2);
  return ((tmp___1 * tmp___3) * sd + avg);
}
}
int tcstricmp(char const   *astr , char const   *bstr ) 
{ int ac ;
  int tmp ;
  int bc ;
  int tmp___0 ;
  int tmp___1 ;

  {
  while ((int const   )*astr != 0) {
    if ((int const   )*bstr == 0) {
      return (1);
    }
    if ((int const   )*astr >= 65) {
      if ((int const   )*astr <= 90) {
        tmp = (int )((int const   )*astr + 32);
      } else {
        tmp = (int )((int const   )*((unsigned char *)astr));
      }
    } else {
      tmp = (int )((int const   )*((unsigned char *)astr));
    }
    ac = tmp;
    if ((int const   )*bstr >= 65) {
      if ((int const   )*bstr <= 90) {
        tmp___0 = (int )((int const   )*bstr + 32);
      } else {
        tmp___0 = (int )((int const   )*((unsigned char *)bstr));
      }
    } else {
      tmp___0 = (int )((int const   )*((unsigned char *)bstr));
    }
    bc = tmp___0;
    if (ac != bc) {
      return (ac - bc);
    }
    astr ++;
    bstr ++;
  }
  if ((int const   )*bstr == 0) {
    tmp___1 = 0;
  } else {
    tmp___1 = -1;
  }
  return (tmp___1);
}
}
_Bool tcstrfwm(char const   *str , char const   *key ) 
{ 

  {
  while ((int const   )*key != 0) {
    if ((int const   )*str != (int const   )*key) {
      return ((_Bool)0);
    } else {
      if ((int const   )*str == 0) {
        return ((_Bool)0);
      }
    }
    key ++;
    str ++;
  }
  return ((_Bool)1);
}
}
_Bool tcstrifwm(char const   *str , char const   *key ) 
{ int sc ;
  int kc ;

  {
  while ((int const   )*key != 0) {
    if ((int const   )*str == 0) {
      return ((_Bool)0);
    }
    sc = (int )*str;
    if (sc >= 65) {
      if (sc <= 90) {
        sc += 32;
      }
    }
    kc = (int )*key;
    if (kc >= 65) {
      if (kc <= 90) {
        kc += 32;
      }
    }
    if (sc != kc) {
      return ((_Bool)0);
    }
    key ++;
    str ++;
  }
  return ((_Bool)1);
}
}
_Bool tcstrbwm(char const   *str , char const   *key ) 
{ int slen ;
  size_t tmp ;
  int klen ;
  size_t tmp___0 ;
  int i ;

  {
  tmp = strlen(str);
  slen = (int )tmp;
  tmp___0 = strlen(key);
  klen = (int )tmp___0;
  i = 1;
  while (i <= klen) {
    if (i > slen) {
      return ((_Bool)0);
    } else {
      if ((int const   )*(str + (slen - i)) != (int const   )*(key + (klen - i))) {
        return ((_Bool)0);
      }
    }
    i ++;
  }
  return ((_Bool)1);
}
}
_Bool tcstribwm(char const   *str , char const   *key ) 
{ int slen ;
  size_t tmp ;
  int klen ;
  size_t tmp___0 ;
  int i ;
  int sc ;
  int kc ;

  {
  tmp = strlen(str);
  slen = (int )tmp;
  tmp___0 = strlen(key);
  klen = (int )tmp___0;
  i = 1;
  while (i <= klen) {
    if (i > slen) {
      return ((_Bool)0);
    }
    sc = (int )*(str + (slen - i));
    if (sc >= 65) {
      if (sc <= 90) {
        sc += 32;
      }
    }
    kc = (int )*(key + (klen - i));
    if (kc >= 65) {
      if (kc <= 90) {
        kc += 32;
      }
    }
    if (sc != kc) {
      return ((_Bool)0);
    }
    i ++;
  }
  return ((_Bool)1);
}
}
int tcstrdist(char const   *astr , char const   *bstr ) 
{ int alen ;
  size_t tmp ;
  long tmp___0 ;
  int blen ;
  size_t tmp___1 ;
  long tmp___2 ;
  int dsiz ;
  int tbuf[16384] ;
  int *tbl ;
  void *tmp___3 ;
  int i ;
  int i___0 ;
  int i___1 ;
  int j ;
  int ac ;
  int bc ;
  int cc ;
  int rv ;

  {
  tmp = strlen(astr);
  tmp___0 = tclmin((long )tmp, 4096L);
  alen = (int )tmp___0;
  tmp___1 = strlen(bstr);
  tmp___2 = tclmin((long )tmp___1, 4096L);
  blen = (int )tmp___2;
  dsiz = blen + 1;
  if ((alen + 1) * dsiz < 16384) {
    tbl = tbuf;
  } else {
    while (1) {
      tmp___3 = malloc((unsigned int )(((alen + 1) * dsiz) * (int )sizeof(*tbl)));
      tbl = (int *)tmp___3;
      if (! tbl) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  i = 0;
  while (i <= alen) {
    *(tbl + i * dsiz) = i;
    i ++;
  }
  i___0 = 1;
  while (i___0 <= blen) {
    *(tbl + i___0) = i___0;
    i___0 ++;
  }
  astr --;
  bstr --;
  i___1 = 1;
  while (i___1 <= alen) {
    j = 1;
    while (j <= blen) {
      ac = *(tbl + ((i___1 - 1) * dsiz + j)) + 1;
      bc = *(tbl + ((i___1 * dsiz + j) - 1)) + 1;
      cc = *(tbl + (((i___1 - 1) * dsiz + j) - 1)) + ((int const   )*(astr + i___1) != (int const   )*(bstr + j));
      if (ac < bc) {
        ac = ac;
      } else {
        ac = bc;
      }
      if (ac < cc) {
        *(tbl + (i___1 * dsiz + j)) = ac;
      } else {
        *(tbl + (i___1 * dsiz + j)) = cc;
      }
      j ++;
    }
    i___1 ++;
  }
  rv = *(tbl + (alen * dsiz + blen));
  if ((unsigned int )tbl != (unsigned int )(tbuf)) {
    while (1) {
      free((void *)tbl);
      break;
    }
  }
  return (rv);
}
}
int tcstrdistutf(char const   *astr , char const   *bstr ) 
{ int alen ;
  size_t tmp ;
  uint16_t abuf[16384] ;
  uint16_t *aary ;
  void *tmp___0 ;
  int blen ;
  size_t tmp___1 ;
  uint16_t bbuf[16384] ;
  uint16_t *bary ;
  void *tmp___2 ;
  int dsiz ;
  int tbuf[16384] ;
  int *tbl ;
  void *tmp___3 ;
  int i ;
  int i___0 ;
  int i___1 ;
  int j ;
  int ac ;
  int bc ;
  int cc ;
  int rv ;

  {
  tmp = strlen(astr);
  alen = (int )tmp;
  if (alen < 16384) {
    aary = abuf;
  } else {
    while (1) {
      tmp___0 = malloc((unsigned int )(alen * (int )sizeof(*aary)));
      aary = (uint16_t *)tmp___0;
      if (! aary) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  tcstrutftoucs(astr, aary, & alen);
  tmp___1 = strlen(bstr);
  blen = (int )tmp___1;
  if (blen < 16384) {
    bary = bbuf;
  } else {
    while (1) {
      tmp___2 = malloc((unsigned int )(blen * (int )sizeof(*bary)));
      bary = (uint16_t *)tmp___2;
      if (! bary) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  tcstrutftoucs(bstr, bary, & blen);
  if (alen > 4096) {
    alen = 4096;
  }
  if (blen > 4096) {
    blen = 4096;
  }
  dsiz = blen + 1;
  if ((alen + 1) * dsiz < 16384) {
    tbl = tbuf;
  } else {
    while (1) {
      tmp___3 = malloc((unsigned int )(((alen + 1) * dsiz) * (int )sizeof(*tbl)));
      tbl = (int *)tmp___3;
      if (! tbl) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  i = 0;
  while (i <= alen) {
    *(tbl + i * dsiz) = i;
    i ++;
  }
  i___0 = 1;
  while (i___0 <= blen) {
    *(tbl + i___0) = i___0;
    i___0 ++;
  }
  aary --;
  bary --;
  i___1 = 1;
  while (i___1 <= alen) {
    j = 1;
    while (j <= blen) {
      ac = *(tbl + ((i___1 - 1) * dsiz + j)) + 1;
      bc = *(tbl + ((i___1 * dsiz + j) - 1)) + 1;
      cc = *(tbl + (((i___1 - 1) * dsiz + j) - 1)) + ((int )*(aary + i___1) != (int )*(bary + j));
      if (ac < bc) {
        ac = ac;
      } else {
        ac = bc;
      }
      if (ac < cc) {
        *(tbl + (i___1 * dsiz + j)) = ac;
      } else {
        *(tbl + (i___1 * dsiz + j)) = cc;
      }
      j ++;
    }
    i___1 ++;
  }
  aary ++;
  bary ++;
  rv = *(tbl + (alen * dsiz + blen));
  if ((unsigned int )tbl != (unsigned int )(tbuf)) {
    while (1) {
      free((void *)tbl);
      break;
    }
  }
  if ((unsigned int )bary != (unsigned int )(bbuf)) {
    while (1) {
      free((void *)bary);
      break;
    }
  }
  if ((unsigned int )aary != (unsigned int )(abuf)) {
    while (1) {
      free((void *)aary);
      break;
    }
  }
  return (rv);
}
}
char *tcstrtoupper(char *str ) 
{ char *wp ;

  {
  wp = str;
  while ((int )*wp != 0) {
    if ((int )*wp >= 97) {
      if ((int )*wp <= 122) {
        *wp = (char )((int )*wp - 32);
      }
    }
    wp ++;
  }
  return (str);
}
}
char *tcstrtolower(char *str ) 
{ char *wp ;

  {
  wp = str;
  while ((int )*wp != 0) {
    if ((int )*wp >= 65) {
      if ((int )*wp <= 90) {
        *wp = (char )((int )*wp + 32);
      }
    }
    wp ++;
  }
  return (str);
}
}
char *tcstrtrim(char *str ) 
{ char const   *rp ;
  char *wp ;
  _Bool head ;
  char *tmp ;
  char *tmp___0 ;

  {
  rp = (char const   *)str;
  wp = str;
  head = (_Bool)1;
  while ((int const   )*rp != 0) {
    if ((int const   )*rp > 0) {
      if ((int const   )*rp <= 32) {
        if (! head) {
          tmp = wp;
          wp ++;
          *tmp = (char )*rp;
        }
      } else {
        tmp___0 = wp;
        wp ++;
        *tmp___0 = (char )*rp;
        head = (_Bool)0;
      }
    } else {
      tmp___0 = wp;
      wp ++;
      *tmp___0 = (char )*rp;
      head = (_Bool)0;
    }
    rp ++;
  }
  *wp = (char )'\000';
  while (1) {
    if ((unsigned int )wp > (unsigned int )str) {
      if ((int )*(wp + -1) > 0) {
        if (! ((int )*(wp + -1) <= 32)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    wp --;
    *wp = (char )'\000';
  }
  return (str);
}
}
char *tcstrsqzspc(char *str ) 
{ char *rp ;
  char *wp ;
  _Bool spc ;
  char *tmp ;
  char *tmp___0 ;

  {
  rp = str;
  wp = str;
  spc = (_Bool)1;
  while ((int )*rp != 0) {
    if ((int )*rp > 0) {
      if ((int )*rp <= 32) {
        if (! spc) {
          tmp = wp;
          wp ++;
          *tmp = *rp;
        }
        spc = (_Bool)1;
      } else {
        tmp___0 = wp;
        wp ++;
        *tmp___0 = *rp;
        spc = (_Bool)0;
      }
    } else {
      tmp___0 = wp;
      wp ++;
      *tmp___0 = *rp;
      spc = (_Bool)0;
    }
    rp ++;
  }
  *wp = (char )'\000';
  wp --;
  while ((unsigned int )wp >= (unsigned int )str) {
    if ((int )*wp > 0) {
      if ((int )*wp <= 32) {
        *wp = (char )'\000';
      } else {
        break;
      }
    } else {
      break;
    }
    wp --;
  }
  return (str);
}
}
char *tcstrsubchr(char *str , char const   *rstr , char const   *sstr ) 
{ int slen ;
  size_t tmp ;
  char *wp ;
  int i ;
  char const   *p ;
  char *tmp___1 ;
  int idx ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  tmp = strlen(sstr);
  slen = (int )tmp;
  wp = str;
  i = 0;
  while ((int )*(str + i) != 0) {
    tmp___1 = __builtin_strchr((char *)rstr, (int )*(str + i));
    p = (char const   *)tmp___1;
    if (p) {
      idx = p - rstr;
      if (idx < slen) {
        tmp___2 = wp;
        wp ++;
        *tmp___2 = (char )*(sstr + idx);
      }
    } else {
      tmp___3 = wp;
      wp ++;
      *tmp___3 = *(str + i);
    }
    i ++;
  }
  *wp = (char )'\000';
  return (str);
}
}
int tcstrcntutf(char const   *str ) 
{ unsigned char const   *rp ;
  int cnt___0 ;

  {
  rp = (unsigned char const   *)((unsigned char *)str);
  cnt___0 = 0;
  while ((int const   )*rp != 0) {
    if (((int const   )*rp & 128) == 0) {
      cnt___0 ++;
    } else {
      if (((int const   )*rp & 224) == 192) {
        cnt___0 ++;
      } else {
        if (((int const   )*rp & 240) == 224) {
          cnt___0 ++;
        } else {
          if (((int const   )*rp & 248) == 240) {
            cnt___0 ++;
          }
        }
      }
    }
    rp ++;
  }
  return (cnt___0);
}
}
char *tcstrcututf(char *str , int num ) 
{ unsigned char *wp ;
  int cnt___0 ;

  {
  wp = (unsigned char *)str;
  cnt___0 = 0;
  while ((int )*wp != 0) {
    if (((int )*wp & 128) == 0) {
      goto _L;
    } else {
      if (((int )*wp & 224) == 192) {
        goto _L;
      } else {
        if (((int )*wp & 240) == 224) {
          goto _L;
        } else {
          if (((int )*wp & 248) == 240) {
            _L: 
            cnt___0 ++;
            if (cnt___0 > num) {
              *wp = (unsigned char )'\000';
              break;
            }
          }
        }
      }
    }
    wp ++;
  }
  return (str);
}
}
void tcstrutftoucs(char const   *str , uint16_t *ary , int *np ) 
{ unsigned char const   *rp ;
  unsigned int wi ;
  int c ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
  rp = (unsigned char const   *)((unsigned char *)str);
  wi = 0U;
  while ((int const   )*rp != 0) {
    c = (int )*((unsigned char *)rp);
    if (c < 128) {
      tmp = wi;
      wi ++;
      *(ary + tmp) = (unsigned short )c;
    } else {
      if (c < 224) {
        if ((int const   )*(rp + 1) >= 128) {
          tmp___0 = wi;
          wi ++;
          *(ary + tmp___0) = (unsigned short )((((int const   )*(rp + 0) & 31) << 6) | ((int const   )*(rp + 1) & 63));
          rp ++;
        }
      } else {
        if (c < 240) {
          if ((int const   )*(rp + 1) >= 128) {
            if ((int const   )*(rp + 2) >= 128) {
              tmp___1 = wi;
              wi ++;
              *(ary + tmp___1) = (unsigned short )(((((int const   )*(rp + 0) & 15) << 12) | (((int const   )*(rp + 1) & 63) << 6)) | ((int const   )*(rp + 2) & 63));
              rp += 2;
            }
          }
        }
      }
    }
    rp ++;
  }
  *np = (int )wi;
  return;
}
}
int tcstrucstoutf(uint16_t const   *ary , int num , char *str ) 
{ unsigned char *wp ;
  int i ;
  unsigned int c ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;

  {
  wp = (unsigned char *)str;
  i = 0;
  while (i < num) {
    c = (unsigned int )*(ary + i);
    if (c < 128U) {
      tmp = wp;
      wp ++;
      *tmp = (unsigned char )c;
    } else {
      if (c < 2048U) {
        tmp___0 = wp;
        wp ++;
        *tmp___0 = (unsigned char )(192U | (c >> 6));
        tmp___1 = wp;
        wp ++;
        *tmp___1 = (unsigned char )(128U | (c & 63U));
      } else {
        tmp___2 = wp;
        wp ++;
        *tmp___2 = (unsigned char )(224U | (c >> 12));
        tmp___3 = wp;
        wp ++;
        *tmp___3 = (unsigned char )(128U | ((c & 4095U) >> 6));
        tmp___4 = wp;
        wp ++;
        *tmp___4 = (unsigned char )(128U | (c & 63U));
      }
    }
    i ++;
  }
  *wp = (unsigned char )'\000';
  return ((char *)wp - str);
}
}
TCLIST *tcstrsplit(char const   *str , char const   *delims ) 
{ TCLIST *list ;
  TCLIST *tmp ;
  char const   *sp ;
  char *tmp___1 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___2 ;
  void *tmp___3 ;
  TCLISTDATUM *array ;
  char *tmp___4 ;
  void *tmp___5 ;

  {
  tmp = tclistnew();
  list = tmp;
  while (1) {
    sp = str;
    while (1) {
      if ((int const   )*str != 0) {
        tmp___1 = __builtin_strchr((char *)delims, (int )*str);
        if (tmp___1) {
          break;
        }
      } else {
        break;
      }
      str ++;
    }
    while (1) {
      TC_mysize = str - sp;
      TC_index = list->start + list->num;
      if (TC_index >= list->anum) {
        list->anum += list->num + 1;
        while (1) {
          tmp___3 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
          tmp___2 = (TCLISTDATUM *)tmp___3;
          list->array = tmp___2;
          if (! tmp___2) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array = list->array;
      while (1) {
        tmp___5 = malloc((unsigned int )(TC_mysize + 1));
        tmp___4 = (char *)tmp___5;
        (array + TC_index)->ptr = tmp___4;
        if (! tmp___4) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )sp,
             (unsigned int )TC_mysize);
      *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
      (array + TC_index)->size = TC_mysize;
      (list->num) ++;
      break;
    }
    if ((int const   )*str == 0) {
      break;
    }
    str ++;
  }
  return (list);
}
}
char *tcstrjoin(TCLIST const   *list , char delim ) 
{ int num ;
  int size ;
  int i ;
  char *buf ;
  void *tmp ;
  char *wp ;
  int i___0 ;
  char *tmp___0 ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___1 ;

  {
  num = (int )list->num;
  size = num + 1;
  i = 0;
  while (i < num) {
    size += (list->array + (i + (int )list->start))->size;
    i ++;
  }
  while (1) {
    tmp = malloc((unsigned int )size);
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  i___0 = 0;
  while (i___0 < num) {
    if (i___0 > 0) {
      tmp___0 = wp;
      wp ++;
      *tmp___0 = delim;
    }
    tmp___1 = tclistval(list, i___0, & vsiz);
    vbuf = (char const   *)tmp___1;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
    wp += vsiz;
    i___0 ++;
  }
  *wp = (char )'\000';
  return (buf);
}
}
int64_t tcatoi(char const   *str ) 
{ int sign ;
  int64_t num ;

  {
  while (1) {
    if ((int const   )*str > 0) {
      if (! ((int const   )*str <= 32)) {
        break;
      }
    } else {
      break;
    }
    str ++;
  }
  sign = 1;
  num = 0LL;
  if ((int const   )*str == 45) {
    str ++;
    sign = -1;
  } else {
    if ((int const   )*str == 43) {
      str ++;
    }
  }
  while ((int const   )*str != 0) {
    if ((int const   )*str < 48) {
      break;
    } else {
      if ((int const   )*str > 57) {
        break;
      }
    }
    num = (num * 10LL + (long long )*str) - 48LL;
    str ++;
  }
  return (num * (long long )sign);
}
}
int64_t tcatoix(char const   *str ) 
{ int sign ;
  long double num ;
  long double base ;

  {
  while (1) {
    if ((int const   )*str > 0) {
      if (! ((int const   )*str <= 32)) {
        break;
      }
    } else {
      break;
    }
    str ++;
  }
  sign = 1;
  if ((int const   )*str == 45) {
    str ++;
    sign = -1;
  } else {
    if ((int const   )*str == 43) {
      str ++;
    }
  }
  num = (long double )0;
  while ((int const   )*str != 0) {
    if ((int const   )*str < 48) {
      break;
    } else {
      if ((int const   )*str > 57) {
        break;
      }
    }
    num = (num * (long double )10 + (long double )*str) - (long double )48;
    str ++;
  }
  if ((int const   )*str == 46) {
    str ++;
    base = (long double )10;
    while ((int const   )*str != 0) {
      if ((int const   )*str < 48) {
        break;
      } else {
        if ((int const   )*str > 57) {
          break;
        }
      }
      num += (long double )((int const   )*str - 48) / base;
      str ++;
      base *= (long double )10;
    }
  }
  num *= (long double )sign;
  while (1) {
    if ((int const   )*str > 0) {
      if (! ((int const   )*str <= 32)) {
        break;
      }
    } else {
      break;
    }
    str ++;
  }
  if ((int const   )*str == 107) {
    num *= (long double )(1LL << 10);
  } else {
    if ((int const   )*str == 75) {
      num *= (long double )(1LL << 10);
    } else {
      if ((int const   )*str == 109) {
        num *= (long double )(1LL << 20);
      } else {
        if ((int const   )*str == 77) {
          num *= (long double )(1LL << 20);
        } else {
          if ((int const   )*str == 103) {
            num *= (long double )(1LL << 30);
          } else {
            if ((int const   )*str == 71) {
              num *= (long double )(1LL << 30);
            } else {
              if ((int const   )*str == 116) {
                num *= (long double )(1LL << 40);
              } else {
                if ((int const   )*str == 84) {
                  num *= (long double )(1LL << 40);
                } else {
                  if ((int const   )*str == 112) {
                    num *= (long double )(1LL << 50);
                  } else {
                    if ((int const   )*str == 80) {
                      num *= (long double )(1LL << 50);
                    } else {
                      if ((int const   )*str == 101) {
                        num *= (long double )(1LL << 60);
                      } else {
                        if ((int const   )*str == 69) {
                          num *= (long double )(1LL << 60);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (num > (long double )9223372036854775807LL) {
    return (9223372036854775807LL);
  }
  if (num < (long double )(-0x7FFFFFFFFFFFFFFF-1)) {
    return ((-0x7FFFFFFFFFFFFFFF-1));
  }
  return ((long long )num);
}
}
double tcatof(char const   *str ) 
{ int sign ;
  double tmp ;
  _Bool tmp___0 ;
  double tmp___1 ;
  _Bool tmp___2 ;
  long double num ;
  int col ;
  long double fract ;
  long double base ;
  int64_t tmp___3 ;
  double tmp___4 ;

  {
  while (1) {
    if ((int const   )*str > 0) {
      if (! ((int const   )*str <= 32)) {
        break;
      }
    } else {
      break;
    }
    str ++;
  }
  sign = 1;
  if ((int const   )*str == 45) {
    str ++;
    sign = -1;
  } else {
    if ((int const   )*str == 43) {
      str ++;
    }
  }
  tmp___0 = tcstrifwm(str, "inf");
  if (tmp___0) {
    tmp = __builtin_huge_val();
    return (tmp * (double )sign);
  }
  tmp___2 = tcstrifwm(str, "nan");
  if (tmp___2) {
    tmp___1 = nan("");
    return (tmp___1);
  }
  num = (long double )0;
  col = 0;
  while ((int const   )*str != 0) {
    if ((int const   )*str < 48) {
      break;
    } else {
      if ((int const   )*str > 57) {
        break;
      }
    }
    num = (num * (long double )10 + (long double )*str) - (long double )48;
    str ++;
    if (num > (long double )0) {
      col ++;
    }
  }
  if ((int const   )*str == 46) {
    str ++;
    fract = (long double )0.0;
    base = (long double )10;
    while (1) {
      if (col < 16) {
        if (! ((int const   )*str != 0)) {
          break;
        }
      } else {
        break;
      }
      if ((int const   )*str < 48) {
        break;
      } else {
        if ((int const   )*str > 57) {
          break;
        }
      }
      fract += (long double )((int const   )*str - 48) / base;
      str ++;
      col ++;
      base *= (long double )10;
    }
    num += fract;
  }
  if ((int const   )*str == 101) {
    str ++;
    tmp___3 = tcatoi(str);
    tmp___4 = pow((double )10, (double )tmp___3);
    num *= (long double )tmp___4;
  } else {
    if ((int const   )*str == 69) {
      str ++;
      tmp___3 = tcatoi(str);
      tmp___4 = pow((double )10, (double )tmp___3);
      num *= (long double )tmp___4;
    }
  }
  return ((double )(num * (long double )sign));
}
}
_Bool tcregexmatch(char const   *str , char const   *regex ) 
{ int options ;
  regex_t rbuf ;
  int tmp ;
  _Bool rv ;
  int tmp___0 ;

  {
  options = 1 | (((1 << 1) << 1) << 1);
  if ((int const   )*regex == 42) {
    options |= 1 << 1;
    regex ++;
  }
  tmp = regcomp((regex_t * __restrict  )(& rbuf), (char const   * __restrict  )regex,
                options);
  if (tmp != 0) {
    return ((_Bool)0);
  }
  tmp___0 = regexec((regex_t const   * __restrict  )(& rbuf), (char const   * __restrict  )str,
                    0U, (regmatch_t * __restrict  )((void *)0), 0);
  rv = (_Bool )(tmp___0 == 0);
  regfree(& rbuf);
  return (rv);
}
}
char *tcregexreplace(char const   *str , char const   *regex , char const   *alt ) 
{ int options ;
  regex_t rbuf ;
  char *tmp ;
  int tmp___0 ;
  regmatch_t subs[256] ;
  char *tmp___1 ;
  int tmp___2 ;
  char const   *sp ;
  TCXSTR *xstr ;
  TCXSTR *tmp___3 ;
  _Bool first ;
  char const   *rp ;
  int num ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;

  {
  options = 1;
  if ((int const   )*regex == 42) {
    options |= 1 << 1;
    regex ++;
  }
  if ((int const   )*(regex + 0) == 0) {
    tmp = tcstrdup((void const   *)str);
    return (tmp);
  } else {
    tmp___0 = regcomp((regex_t * __restrict  )(& rbuf), (char const   * __restrict  )regex,
                      options);
    if (tmp___0 != 0) {
      tmp = tcstrdup((void const   *)str);
      return (tmp);
    }
  }
  tmp___2 = regexec((regex_t const   * __restrict  )(& rbuf), (char const   * __restrict  )str,
                    32U, (regmatch_t * __restrict  )(subs), 0);
  if (tmp___2 != 0) {
    regfree(& rbuf);
    tmp___1 = tcstrdup((void const   *)str);
    return (tmp___1);
  }
  sp = str;
  tmp___3 = tcxstrnew();
  xstr = tmp___3;
  first = (_Bool)1;
  while (1) {
    if ((int const   )*(sp + 0) != 0) {
      if (first) {
        tmp___4 = 0;
      } else {
        tmp___4 = 1;
      }
      tmp___5 = regexec((regex_t const   * __restrict  )(& rbuf), (char const   * __restrict  )sp,
                        10U, (regmatch_t * __restrict  )(subs), tmp___4);
      if (! (tmp___5 == 0)) {
        break;
      }
    } else {
      break;
    }
    first = (_Bool)0;
    if (subs[0].rm_so == -1) {
      break;
    }
    tcxstrcat(xstr, (void const   *)sp, subs[0].rm_so);
    rp = alt;
    while ((int const   )*rp != 0) {
      if ((int const   )*rp == 92) {
        if ((int const   )*(rp + 1) >= 48) {
          if ((int const   )*(rp + 1) <= 57) {
            num = (int )((int const   )*(rp + 1) - 48);
            if (subs[num].rm_so != -1) {
              if (subs[num].rm_eo != -1) {
                tcxstrcat(xstr, (void const   *)(sp + subs[num].rm_so), subs[num].rm_eo - subs[num].rm_so);
              }
            }
            rp ++;
          } else {
            goto _L;
          }
        } else {
          _L: 
          if ((int const   )*(rp + 1) != 0) {
            rp ++;
            tcxstrcat(xstr, (void const   *)rp, 1);
          }
        }
      } else {
        if ((int const   )*rp == 38) {
          tcxstrcat(xstr, (void const   *)(sp + subs[0].rm_so), subs[0].rm_eo - subs[0].rm_so);
        } else {
          tcxstrcat(xstr, (void const   *)rp, 1);
        }
      }
      rp ++;
    }
    sp += subs[0].rm_eo;
    if (subs[0].rm_eo < 1) {
      break;
    }
  }
  tcxstrcat2(xstr, sp);
  regfree(& rbuf);
  tmp___6 = tcxstrtomalloc(xstr);
  return ((char *)tmp___6);
}
}
void tcmd5hash(void const   *ptr , int size , char *buf ) 
{ int i ;
  md5_state_t ms ;
  unsigned char digest[16] ;
  char *wp ;
  int tmp ;

  {
  _tc_md5_init(& ms);
  _tc_md5_append(& ms, (md5_byte_t const   *)((md5_byte_t *)ptr), size);
  _tc_md5_finish(& ms, digest);
  wp = buf;
  i = 0;
  while (i < 16) {
    tmp = sprintf((char * __restrict  )wp, (char const   * __restrict  )"%02x", digest[i]);
    wp += tmp;
    i ++;
  }
  *wp = (char )'\000';
  return;
}
}
void tcarccipher(void const   *ptr , int size , void const   *kbuf , int ksiz , void *obuf ) 
{ uint32_t sbox[256] ;
  uint32_t kbox[256] ;
  int i ;
  int sidx ;
  int i___0 ;
  uint32_t swap ;
  int x ;
  int y ;
  int i___1 ;
  int32_t swap___0 ;

  {
  if (ksiz < 1) {
    kbuf = (void const   *)"";
    ksiz = 1;
  }
  i = 0;
  while (i < 256) {
    sbox[i] = (unsigned int )i;
    kbox[i] = (unsigned int )*((uint8_t *)kbuf + i % ksiz);
    i ++;
  }
  sidx = 0;
  i___0 = 0;
  while (i___0 < 256) {
    sidx = (int )((((unsigned int )sidx + sbox[i___0]) + kbox[i___0]) & 255U);
    swap = sbox[i___0];
    sbox[i___0] = sbox[sidx];
    sbox[sidx] = swap;
    i___0 ++;
  }
  x = 0;
  y = 0;
  i___1 = 0;
  while (i___1 < size) {
    x = (x + 1) & 255;
    y = (int )(((unsigned int )y + sbox[x]) & 255U);
    swap___0 = (int )sbox[x];
    sbox[x] = sbox[y];
    sbox[y] = (unsigned int )swap___0;
    *((uint8_t *)obuf + i___1) = (unsigned char )((unsigned int )*((uint8_t *)ptr + i___1) ^ sbox[(sbox[x] + sbox[y]) & 255U]);
    i___1 ++;
  }
  return;
}
}
double tctime(void) 
{ struct timeval tv ;
  int tmp ;

  {
  tmp = gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
  if (tmp == -1) {
    return (0.0);
  }
  return ((double )tv.tv_sec + (double )tv.tv_usec / 1000000.0);
}
}
void tccalendar(int64_t t , int jl , int *yearp , int *monp , int *dayp , int *hourp ,
                int *minp , int *secp ) 
{ time_t tmp ;
  time_t tt ;
  struct tm ts ;
  struct tm *tmp___0 ;

  {
  if (t == 9223372036854775807LL) {
    tmp = time((time_t *)((void *)0));
    t = (long long )tmp;
  }
  if (jl == 2147483647) {
    jl = tcjetlag();
  }
  tt = (long )t + (long )jl;
  tmp___0 = gmtime_r((time_t const   * __restrict  )(& tt), (struct tm * __restrict  )(& ts));
  if (! tmp___0) {
    if (yearp) {
      *yearp = 0;
    }
    if (monp) {
      *monp = 0;
    }
    if (dayp) {
      *dayp = 0;
    }
    if (hourp) {
      *hourp = 0;
    }
    if (minp) {
      *minp = 0;
    }
    if (secp) {
      *secp = 0;
    }
  }
  if (yearp) {
    *yearp = ts.tm_year + 1900;
  }
  if (monp) {
    *monp = ts.tm_mon + 1;
  }
  if (dayp) {
    *dayp = ts.tm_mday;
  }
  if (hourp) {
    *hourp = ts.tm_hour;
  }
  if (minp) {
    *minp = ts.tm_min;
  }
  if (secp) {
    *secp = ts.tm_sec;
  }
  return;
}
}
void tcdatestrwww(int64_t t , int jl , char *buf ) 
{ time_t tmp ;
  time_t tt ;
  struct tm ts ;
  struct tm *tmp___0 ;
  char tzone[16] ;

  {
  if (t == 9223372036854775807LL) {
    tmp = time((time_t *)((void *)0));
    t = (long long )tmp;
  }
  if (jl == 2147483647) {
    jl = tcjetlag();
  }
  tt = (long )t + (long )jl;
  tmp___0 = gmtime_r((time_t const   * __restrict  )(& tt), (struct tm * __restrict  )(& ts));
  if (! tmp___0) {
    memset((void *)(& ts), 0, (unsigned int )((int )sizeof(ts)));
  }
  ts.tm_year += 1900;
  (ts.tm_mon) ++;
  jl /= 60;
  if (jl == 0) {
    sprintf((char * __restrict  )(tzone), (char const   * __restrict  )"Z");
  } else {
    if (jl < 0) {
      jl *= -1;
      sprintf((char * __restrict  )(tzone), (char const   * __restrict  )"-%02d:%02d",
              jl / 60, jl % 60);
    } else {
      sprintf((char * __restrict  )(tzone), (char const   * __restrict  )"+%02d:%02d",
              jl / 60, jl % 60);
    }
  }
  sprintf((char * __restrict  )buf, (char const   * __restrict  )"%04d-%02d-%02dT%02d:%02d:%02d%s",
          ts.tm_year, ts.tm_mon, ts.tm_mday, ts.tm_hour, ts.tm_min, ts.tm_sec, tzone);
  return;
}
}
void tcdatestrhttp(int64_t t , int jl , char *buf ) 
{ time_t tmp ;
  time_t tt ;
  struct tm ts ;
  struct tm *tmp___0 ;
  char *wp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  if (t == 9223372036854775807LL) {
    tmp = time((time_t *)((void *)0));
    t = (long long )tmp;
  }
  if (jl == 2147483647) {
    jl = tcjetlag();
  }
  tt = (long )t + (long )jl;
  tmp___0 = gmtime_r((time_t const   * __restrict  )(& tt), (struct tm * __restrict  )(& ts));
  if (! tmp___0) {
    memset((void *)(& ts), 0, (unsigned int )((int )sizeof(ts)));
  }
  ts.tm_year += 1900;
  (ts.tm_mon) ++;
  jl /= 60;
  wp = buf;
  tmp___1 = tcdayofweek(ts.tm_year, ts.tm_mon, ts.tm_mday);
  switch (tmp___1) {
  case 0: 
  tmp___2 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Sun, ");
  wp += tmp___2;
  break;
  case 1: 
  tmp___3 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Mon, ");
  wp += tmp___3;
  break;
  case 2: 
  tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Tue, ");
  wp += tmp___4;
  break;
  case 3: 
  tmp___5 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Wed, ");
  wp += tmp___5;
  break;
  case 4: 
  tmp___6 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Thu, ");
  wp += tmp___6;
  break;
  case 5: 
  tmp___7 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Fri, ");
  wp += tmp___7;
  break;
  case 6: 
  tmp___8 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Sat, ");
  wp += tmp___8;
  break;
  }
  tmp___9 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"%02d ",
                    ts.tm_mday);
  wp += tmp___9;
  switch (ts.tm_mon) {
  case 1: 
  tmp___10 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Jan ");
  wp += tmp___10;
  break;
  case 2: 
  tmp___11 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Feb ");
  wp += tmp___11;
  break;
  case 3: 
  tmp___12 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Mar ");
  wp += tmp___12;
  break;
  case 4: 
  tmp___13 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Apr ");
  wp += tmp___13;
  break;
  case 5: 
  tmp___14 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"May ");
  wp += tmp___14;
  break;
  case 6: 
  tmp___15 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Jun ");
  wp += tmp___15;
  break;
  case 7: 
  tmp___16 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Jul ");
  wp += tmp___16;
  break;
  case 8: 
  tmp___17 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Aug ");
  wp += tmp___17;
  break;
  case 9: 
  tmp___18 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Sep ");
  wp += tmp___18;
  break;
  case 10: 
  tmp___19 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Oct ");
  wp += tmp___19;
  break;
  case 11: 
  tmp___20 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Nov ");
  wp += tmp___20;
  break;
  case 12: 
  tmp___21 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"Dec ");
  wp += tmp___21;
  break;
  }
  tmp___22 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"%04d %02d:%02d:%02d ",
                     ts.tm_year, ts.tm_hour, ts.tm_min, ts.tm_sec);
  wp += tmp___22;
  if (jl == 0) {
    sprintf((char * __restrict  )wp, (char const   * __restrict  )"GMT");
  } else {
    if (jl < 0) {
      jl *= -1;
      sprintf((char * __restrict  )wp, (char const   * __restrict  )"-%02d%02d", jl / 60,
              jl % 60);
    } else {
      sprintf((char * __restrict  )wp, (char const   * __restrict  )"+%02d%02d", jl / 60,
              jl % 60);
    }
  }
  return;
}
}
int64_t tcstrmktime(char const   *str ) 
{ int64_t tmp ;
  struct tm ts ;
  int len ;
  size_t tmp___0 ;
  time_t t ;
  int64_t tmp___1 ;
  char const   *pv ;
  int64_t tmp___2 ;
  char const   *rp ;
  int64_t tmp___3 ;
  int64_t tmp___4 ;
  int64_t tmp___5 ;
  int64_t tmp___6 ;
  char *tmp___8 ;
  int64_t tmp___9 ;
  char *tmp___11 ;
  char *tmp___13 ;
  int64_t tmp___14 ;
  int64_t tmp___15 ;
  int tmp___16 ;
  size_t tmp___17 ;
  char *tmp___19 ;
  char *tmp___21 ;
  char *tmp___23 ;
  time_t tmp___24 ;
  int64_t tmp___25 ;
  char const   *rp___0 ;
  int64_t tmp___26 ;
  int64_t tmp___27 ;
  int64_t tmp___28 ;
  int64_t tmp___29 ;
  char *tmp___31 ;
  int64_t tmp___32 ;
  char *tmp___34 ;
  char *tmp___36 ;
  int64_t tmp___37 ;
  int64_t tmp___38 ;
  int tmp___39 ;
  size_t tmp___40 ;
  char *tmp___42 ;
  char *tmp___44 ;
  char *tmp___46 ;
  time_t tmp___47 ;
  char const   *crp ;
  int64_t tmp___48 ;
  _Bool tmp___49 ;
  _Bool tmp___50 ;
  _Bool tmp___51 ;
  _Bool tmp___52 ;
  _Bool tmp___53 ;
  _Bool tmp___54 ;
  _Bool tmp___55 ;
  _Bool tmp___56 ;
  _Bool tmp___57 ;
  _Bool tmp___58 ;
  _Bool tmp___59 ;
  _Bool tmp___60 ;
  int64_t tmp___61 ;
  int clen ;
  size_t tmp___62 ;
  int64_t tmp___63 ;
  int64_t tmp___64 ;
  int64_t tmp___65 ;
  int tmp___66 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___68 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___75 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___82 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___89 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___96 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___103 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___110 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___117 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___124 ;
  int tmp___127 ;
  int tmp___128 ;
  int tmp___129 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___131 ;
  int tmp___134 ;
  int tmp___135 ;
  int tmp___136 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___138 ;
  int tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___145 ;
  int tmp___148 ;
  int tmp___149 ;
  int tmp___150 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___152 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  time_t tmp___158 ;

  {
  while (1) {
    if ((int const   )*str > 0) {
      if (! ((int const   )*str <= 32)) {
        break;
      }
    } else {
      break;
    }
    str ++;
  }
  if ((int const   )*str == 0) {
    return ((-0x7FFFFFFFFFFFFFFF-1));
  }
  if ((int const   )*(str + 0) == 48) {
    if ((int const   )*(str + 1) == 120) {
      tmp = tcatoih(str + 2);
      return (tmp);
    } else {
      if ((int const   )*(str + 1) == 88) {
        tmp = tcatoih(str + 2);
        return (tmp);
      }
    }
  }
  memset((void *)(& ts), 0, (unsigned int )((int )sizeof(ts)));
  ts.tm_year = 70;
  ts.tm_mon = 0;
  ts.tm_mday = 1;
  ts.tm_hour = 0;
  ts.tm_min = 0;
  ts.tm_sec = 0;
  ts.tm_isdst = 0;
  tmp___0 = strlen(str);
  len = (int )tmp___0;
  tmp___1 = tcatoi(str);
  t = (long )tmp___1;
  pv = str;
  while (1) {
    if ((int const   )*pv >= 48) {
      if (! ((int const   )*pv <= 57)) {
        break;
      }
    } else {
      break;
    }
    pv ++;
  }
  while (1) {
    if ((int const   )*pv > 0) {
      if (! ((int const   )*pv <= 32)) {
        break;
      }
    } else {
      break;
    }
    pv ++;
  }
  if ((int const   )*pv == 0) {
    return ((long long )t);
  }
  if ((int const   )*(pv + 0) == 115) {
    goto _L;
  } else {
    if ((int const   )*(pv + 0) == 83) {
      _L: 
      if ((int const   )*(pv + 1) >= 0) {
        if ((int const   )*(pv + 1) <= 32) {
          return ((long long )t);
        }
      }
    }
  }
  if ((int const   )*(pv + 0) == 109) {
    goto _L___0;
  } else {
    if ((int const   )*(pv + 0) == 77) {
      _L___0: 
      if ((int const   )*(pv + 1) >= 0) {
        if ((int const   )*(pv + 1) <= 32) {
          return ((long long )t * 60LL);
        }
      }
    }
  }
  if ((int const   )*(pv + 0) == 104) {
    goto _L___1;
  } else {
    if ((int const   )*(pv + 0) == 72) {
      _L___1: 
      if ((int const   )*(pv + 1) >= 0) {
        if ((int const   )*(pv + 1) <= 32) {
          return (((long long )t * 60LL) * 60LL);
        }
      }
    }
  }
  if ((int const   )*(pv + 0) == 100) {
    goto _L___2;
  } else {
    if ((int const   )*(pv + 0) == 68) {
      _L___2: 
      if ((int const   )*(pv + 1) >= 0) {
        if ((int const   )*(pv + 1) <= 32) {
          return ((((long long )t * 60LL) * 60LL) * 24LL);
        }
      }
    }
  }
  if (len > 4) {
    if ((int const   )*(str + 4) == 45) {
      tmp___2 = tcatoi(str);
      ts.tm_year = (int )(tmp___2 - 1900LL);
      tmp___23 = __builtin_strchr((char *)str, '-');
      pv = (char const   *)tmp___23;
      if ((unsigned int )pv != (unsigned int )((void *)0)) {
        if (pv - str == 4) {
          rp = pv + 1;
          tmp___3 = tcatoi(rp);
          ts.tm_mon = (int )(tmp___3 - 1LL);
          tmp___21 = __builtin_strchr((char *)rp, '-');
          pv = (char const   *)tmp___21;
          if ((unsigned int )pv != (unsigned int )((void *)0)) {
            if (pv - str == 7) {
              rp = pv + 1;
              tmp___4 = tcatoi(rp);
              ts.tm_mday = (int )tmp___4;
              tmp___19 = __builtin_strchr((char *)rp, 'T');
              pv = (char const   *)tmp___19;
              if ((unsigned int )pv != (unsigned int )((void *)0)) {
                if (pv - str == 10) {
                  rp = pv + 1;
                  tmp___5 = tcatoi(rp);
                  ts.tm_hour = (int )tmp___5;
                  tmp___8 = __builtin_strchr((char *)rp, ':');
                  pv = (char const   *)tmp___8;
                  if ((unsigned int )pv != (unsigned int )((void *)0)) {
                    if (pv - str == 13) {
                      rp = pv + 1;
                      tmp___6 = tcatoi(rp);
                      ts.tm_min = (int )tmp___6;
                    }
                  }
                  tmp___11 = __builtin_strchr((char *)rp, ':');
                  pv = (char const   *)tmp___11;
                  if ((unsigned int )pv != (unsigned int )((void *)0)) {
                    if (pv - str == 16) {
                      rp = pv + 1;
                      tmp___9 = tcatoi(rp);
                      ts.tm_sec = (int )tmp___9;
                    }
                  }
                  tmp___13 = __builtin_strchr((char *)rp, '.');
                  pv = (char const   *)tmp___13;
                  if ((unsigned int )pv != (unsigned int )((void *)0)) {
                    if (pv - str >= 19) {
                      rp = pv + 1;
                    }
                  }
                  pv = rp;
                  while (1) {
                    if ((int const   )*pv >= 48) {
                      if (! ((int const   )*pv <= 57)) {
                        break;
                      }
                    } else {
                      break;
                    }
                    pv ++;
                  }
                  if ((int const   )*pv == 43) {
                    goto _L___3;
                  } else {
                    if ((int const   )*pv == 45) {
                      _L___3: 
                      tmp___17 = strlen(pv);
                      if (tmp___17 >= 6U) {
                        if ((int const   )*(pv + 3) == 58) {
                          tmp___14 = tcatoi(pv + 1);
                          tmp___15 = tcatoi(pv + 4);
                          if ((int const   )*(pv + 0) == 43) {
                            tmp___16 = 1;
                          } else {
                            tmp___16 = -1;
                          }
                          ts.tm_sec = (int )((long long )ts.tm_sec - (tmp___14 * 3600LL + tmp___15 * 60LL) * (long long )tmp___16);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      tmp___24 = tcmkgmtime(& ts);
      return ((long long )tmp___24);
    }
  }
  if (len > 4) {
    if ((int const   )*(str + 4) == 47) {
      tmp___25 = tcatoi(str);
      ts.tm_year = (int )(tmp___25 - 1900LL);
      tmp___46 = __builtin_strchr((char *)str, '/');
      pv = (char const   *)tmp___46;
      if ((unsigned int )pv != (unsigned int )((void *)0)) {
        if (pv - str == 4) {
          rp___0 = pv + 1;
          tmp___26 = tcatoi(rp___0);
          ts.tm_mon = (int )(tmp___26 - 1LL);
          tmp___44 = __builtin_strchr((char *)rp___0, '/');
          pv = (char const   *)tmp___44;
          if ((unsigned int )pv != (unsigned int )((void *)0)) {
            if (pv - str == 7) {
              rp___0 = pv + 1;
              tmp___27 = tcatoi(rp___0);
              ts.tm_mday = (int )tmp___27;
              tmp___42 = __builtin_strchr((char *)rp___0, ' ');
              pv = (char const   *)tmp___42;
              if ((unsigned int )pv != (unsigned int )((void *)0)) {
                if (pv - str == 10) {
                  rp___0 = pv + 1;
                  tmp___28 = tcatoi(rp___0);
                  ts.tm_hour = (int )tmp___28;
                  tmp___31 = __builtin_strchr((char *)rp___0, ':');
                  pv = (char const   *)tmp___31;
                  if ((unsigned int )pv != (unsigned int )((void *)0)) {
                    if (pv - str == 13) {
                      rp___0 = pv + 1;
                      tmp___29 = tcatoi(rp___0);
                      ts.tm_min = (int )tmp___29;
                    }
                  }
                  tmp___34 = __builtin_strchr((char *)rp___0, ':');
                  pv = (char const   *)tmp___34;
                  if ((unsigned int )pv != (unsigned int )((void *)0)) {
                    if (pv - str == 16) {
                      rp___0 = pv + 1;
                      tmp___32 = tcatoi(rp___0);
                      ts.tm_sec = (int )tmp___32;
                    }
                  }
                  tmp___36 = __builtin_strchr((char *)rp___0, '.');
                  pv = (char const   *)tmp___36;
                  if ((unsigned int )pv != (unsigned int )((void *)0)) {
                    if (pv - str >= 19) {
                      rp___0 = pv + 1;
                    }
                  }
                  pv = rp___0;
                  while (1) {
                    if ((int const   )*pv >= 48) {
                      if (! ((int const   )*pv <= 57)) {
                        break;
                      }
                    } else {
                      break;
                    }
                    pv ++;
                  }
                  if ((int const   )*pv == 43) {
                    goto _L___4;
                  } else {
                    if ((int const   )*pv == 45) {
                      _L___4: 
                      tmp___40 = strlen(pv);
                      if (tmp___40 >= 6U) {
                        if ((int const   )*(pv + 3) == 58) {
                          tmp___37 = tcatoi(pv + 1);
                          tmp___38 = tcatoi(pv + 4);
                          if ((int const   )*(pv + 0) == 43) {
                            tmp___39 = 1;
                          } else {
                            tmp___39 = -1;
                          }
                          ts.tm_sec = (int )((long long )ts.tm_sec - (tmp___37 * 3600LL + tmp___38 * 60LL) * (long long )tmp___39);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      tmp___47 = tcmkgmtime(& ts);
      return ((long long )tmp___47);
    }
  }
  crp = str;
  if (len >= 4) {
    if ((int const   )*(str + 3) == 44) {
      crp = str + 4;
    }
  }
  while ((int const   )*crp == 32) {
    crp ++;
  }
  tmp___48 = tcatoi(crp);
  ts.tm_mday = (int )tmp___48;
  while (1) {
    if ((int const   )*crp >= 48) {
      if (! ((int const   )*crp <= 57)) {
        goto _L___5;
      }
    } else {
      _L___5: 
      if (! ((int const   )*crp == 32)) {
        break;
      }
    }
    crp ++;
  }
  tmp___60 = tcstrifwm(crp, "Jan");
  if (tmp___60) {
    ts.tm_mon = 0;
  } else {
    tmp___59 = tcstrifwm(crp, "Feb");
    if (tmp___59) {
      ts.tm_mon = 1;
    } else {
      tmp___58 = tcstrifwm(crp, "Mar");
      if (tmp___58) {
        ts.tm_mon = 2;
      } else {
        tmp___57 = tcstrifwm(crp, "Apr");
        if (tmp___57) {
          ts.tm_mon = 3;
        } else {
          tmp___56 = tcstrifwm(crp, "May");
          if (tmp___56) {
            ts.tm_mon = 4;
          } else {
            tmp___55 = tcstrifwm(crp, "Jun");
            if (tmp___55) {
              ts.tm_mon = 5;
            } else {
              tmp___54 = tcstrifwm(crp, "Jul");
              if (tmp___54) {
                ts.tm_mon = 6;
              } else {
                tmp___53 = tcstrifwm(crp, "Aug");
                if (tmp___53) {
                  ts.tm_mon = 7;
                } else {
                  tmp___52 = tcstrifwm(crp, "Sep");
                  if (tmp___52) {
                    ts.tm_mon = 8;
                  } else {
                    tmp___51 = tcstrifwm(crp, "Oct");
                    if (tmp___51) {
                      ts.tm_mon = 9;
                    } else {
                      tmp___50 = tcstrifwm(crp, "Nov");
                      if (tmp___50) {
                        ts.tm_mon = 10;
                      } else {
                        tmp___49 = tcstrifwm(crp, "Dec");
                        if (tmp___49) {
                          ts.tm_mon = 11;
                        } else {
                          ts.tm_mon = -1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (ts.tm_mon >= 0) {
    crp += 3;
  }
  while ((int const   )*crp == 32) {
    crp ++;
  }
  tmp___61 = tcatoi(crp);
  ts.tm_year = (int )tmp___61;
  if (ts.tm_year >= 1969) {
    ts.tm_year -= 1900;
  }
  while (1) {
    if ((int const   )*crp >= 48) {
      if (! ((int const   )*crp <= 57)) {
        break;
      }
    } else {
      break;
    }
    crp ++;
  }
  while ((int const   )*crp == 32) {
    crp ++;
  }
  if (ts.tm_mday > 0) {
    if (ts.tm_mon >= 0) {
      if (ts.tm_year >= 0) {
        tmp___62 = strlen(crp);
        clen = (int )tmp___62;
        if (clen >= 8) {
          if ((int const   )*(crp + 2) == 58) {
            if ((int const   )*(crp + 5) == 58) {
              tmp___63 = tcatoi(crp + 0);
              ts.tm_hour = (int )tmp___63;
              tmp___64 = tcatoi(crp + 3);
              ts.tm_min = (int )tmp___64;
              tmp___65 = tcatoi(crp + 6);
              ts.tm_sec = (int )tmp___65;
              if (clen >= 14) {
                if ((int const   )*(crp + 8) == 32) {
                  if ((int const   )*(crp + 9) == 43) {
                    goto _L___33;
                  } else {
                    if ((int const   )*(crp + 9) == 45) {
                      _L___33: 
                      if ((int const   )*(crp + 9) == 43) {
                        tmp___66 = 1;
                      } else {
                        tmp___66 = -1;
                      }
                      ts.tm_sec -= (int )((((((int const   )*(crp + 10) - 48) * 36000 + ((int const   )*(crp + 11) - 48) * 3600) + ((int const   )*(crp + 12) - 48) * 600) + ((int const   )*(crp + 13) - 48) * 60) * (int const   )tmp___66);
                    } else {
                      goto _L___34;
                    }
                  }
                } else {
                  goto _L___34;
                }
              } else {
                _L___34: 
                if (clen > 9) {
                  if (0) {
                    __s1_len___11 = strlen(crp + 9);
                    __s2_len___11 = strlen("JST");
                    if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                      goto _L___31;
                    } else {
                      if (__s1_len___11 >= 4U) {
                        _L___31: 
                        if (! ((unsigned int )((void const   *)("JST" + 1)) - (unsigned int )((void const   *)"JST") == 1U)) {
                          tmp___157 = 1;
                        } else {
                          if (__s2_len___11 >= 4U) {
                            tmp___157 = 1;
                          } else {
                            tmp___157 = 0;
                          }
                        }
                      } else {
                        tmp___157 = 0;
                      }
                    }
                    if (tmp___157) {
                      tmp___152 = __builtin_strcmp(crp + 9, "JST");
                      tmp___156 = tmp___152;
                    } else {
                      tmp___155 = __builtin_strcmp(crp + 9, "JST");
                      tmp___156 = tmp___155;
                    }
                  } else {
                    tmp___155 = __builtin_strcmp(crp + 9, "JST");
                    tmp___156 = tmp___155;
                  }
                  if (tmp___156) {
                    if (0) {
                      __s1_len___10 = strlen(crp + 9);
                      __s2_len___10 = strlen("CCT");
                      if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                        goto _L___29;
                      } else {
                        if (__s1_len___10 >= 4U) {
                          _L___29: 
                          if (! ((unsigned int )((void const   *)("CCT" + 1)) - (unsigned int )((void const   *)"CCT") == 1U)) {
                            tmp___150 = 1;
                          } else {
                            if (__s2_len___10 >= 4U) {
                              tmp___150 = 1;
                            } else {
                              tmp___150 = 0;
                            }
                          }
                        } else {
                          tmp___150 = 0;
                        }
                      }
                      if (tmp___150) {
                        tmp___145 = __builtin_strcmp(crp + 9, "CCT");
                        tmp___149 = tmp___145;
                      } else {
                        tmp___148 = __builtin_strcmp(crp + 9, "CCT");
                        tmp___149 = tmp___148;
                      }
                    } else {
                      tmp___148 = __builtin_strcmp(crp + 9, "CCT");
                      tmp___149 = tmp___148;
                    }
                    if (tmp___149) {
                      if (0) {
                        __s1_len___9 = strlen(crp + 9);
                        __s2_len___9 = strlen("KST");
                        if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                          goto _L___27;
                        } else {
                          if (__s1_len___9 >= 4U) {
                            _L___27: 
                            if (! ((unsigned int )((void const   *)("KST" + 1)) - (unsigned int )((void const   *)"KST") == 1U)) {
                              tmp___143 = 1;
                            } else {
                              if (__s2_len___9 >= 4U) {
                                tmp___143 = 1;
                              } else {
                                tmp___143 = 0;
                              }
                            }
                          } else {
                            tmp___143 = 0;
                          }
                        }
                        if (tmp___143) {
                          tmp___138 = __builtin_strcmp(crp + 9, "KST");
                          tmp___142 = tmp___138;
                        } else {
                          tmp___141 = __builtin_strcmp(crp + 9, "KST");
                          tmp___142 = tmp___141;
                        }
                      } else {
                        tmp___141 = __builtin_strcmp(crp + 9, "KST");
                        tmp___142 = tmp___141;
                      }
                      if (tmp___142) {
                        if (0) {
                          __s1_len___8 = strlen(crp + 9);
                          __s2_len___8 = strlen("EDT");
                          if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                            goto _L___25;
                          } else {
                            if (__s1_len___8 >= 4U) {
                              _L___25: 
                              if (! ((unsigned int )((void const   *)("EDT" + 1)) - (unsigned int )((void const   *)"EDT") == 1U)) {
                                tmp___136 = 1;
                              } else {
                                if (__s2_len___8 >= 4U) {
                                  tmp___136 = 1;
                                } else {
                                  tmp___136 = 0;
                                }
                              }
                            } else {
                              tmp___136 = 0;
                            }
                          }
                          if (tmp___136) {
                            tmp___131 = __builtin_strcmp(crp + 9, "EDT");
                            tmp___135 = tmp___131;
                          } else {
                            tmp___134 = __builtin_strcmp(crp + 9, "EDT");
                            tmp___135 = tmp___134;
                          }
                        } else {
                          tmp___134 = __builtin_strcmp(crp + 9, "EDT");
                          tmp___135 = tmp___134;
                        }
                        if (tmp___135) {
                          if (0) {
                            __s1_len___7 = strlen(crp + 9);
                            __s2_len___7 = strlen("EST");
                            if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                              goto _L___23;
                            } else {
                              if (__s1_len___7 >= 4U) {
                                _L___23: 
                                if (! ((unsigned int )((void const   *)("EST" + 1)) - (unsigned int )((void const   *)"EST") == 1U)) {
                                  tmp___129 = 1;
                                } else {
                                  if (__s2_len___7 >= 4U) {
                                    tmp___129 = 1;
                                  } else {
                                    tmp___129 = 0;
                                  }
                                }
                              } else {
                                tmp___129 = 0;
                              }
                            }
                            if (tmp___129) {
                              tmp___124 = __builtin_strcmp(crp + 9, "EST");
                              tmp___128 = tmp___124;
                            } else {
                              tmp___127 = __builtin_strcmp(crp + 9, "EST");
                              tmp___128 = tmp___127;
                            }
                          } else {
                            tmp___127 = __builtin_strcmp(crp + 9, "EST");
                            tmp___128 = tmp___127;
                          }
                          if (tmp___128) {
                            if (0) {
                              __s1_len___6 = strlen(crp + 9);
                              __s2_len___6 = strlen("CDT");
                              if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                                goto _L___21;
                              } else {
                                if (__s1_len___6 >= 4U) {
                                  _L___21: 
                                  if (! ((unsigned int )((void const   *)("CDT" + 1)) - (unsigned int )((void const   *)"CDT") == 1U)) {
                                    tmp___122 = 1;
                                  } else {
                                    if (__s2_len___6 >= 4U) {
                                      tmp___122 = 1;
                                    } else {
                                      tmp___122 = 0;
                                    }
                                  }
                                } else {
                                  tmp___122 = 0;
                                }
                              }
                              if (tmp___122) {
                                tmp___117 = __builtin_strcmp(crp + 9, "CDT");
                                tmp___121 = tmp___117;
                              } else {
                                tmp___120 = __builtin_strcmp(crp + 9, "CDT");
                                tmp___121 = tmp___120;
                              }
                            } else {
                              tmp___120 = __builtin_strcmp(crp + 9, "CDT");
                              tmp___121 = tmp___120;
                            }
                            if (tmp___121) {
                              if (0) {
                                __s1_len___5 = strlen(crp + 9);
                                __s2_len___5 = strlen("CST");
                                if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                                  goto _L___19;
                                } else {
                                  if (__s1_len___5 >= 4U) {
                                    _L___19: 
                                    if (! ((unsigned int )((void const   *)("CST" + 1)) - (unsigned int )((void const   *)"CST") == 1U)) {
                                      tmp___115 = 1;
                                    } else {
                                      if (__s2_len___5 >= 4U) {
                                        tmp___115 = 1;
                                      } else {
                                        tmp___115 = 0;
                                      }
                                    }
                                  } else {
                                    tmp___115 = 0;
                                  }
                                }
                                if (tmp___115) {
                                  tmp___110 = __builtin_strcmp(crp + 9, "CST");
                                  tmp___114 = tmp___110;
                                } else {
                                  tmp___113 = __builtin_strcmp(crp + 9, "CST");
                                  tmp___114 = tmp___113;
                                }
                              } else {
                                tmp___113 = __builtin_strcmp(crp + 9, "CST");
                                tmp___114 = tmp___113;
                              }
                              if (tmp___114) {
                                if (0) {
                                  __s1_len___4 = strlen(crp + 9);
                                  __s2_len___4 = strlen("MDT");
                                  if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                                    goto _L___17;
                                  } else {
                                    if (__s1_len___4 >= 4U) {
                                      _L___17: 
                                      if (! ((unsigned int )((void const   *)("MDT" + 1)) - (unsigned int )((void const   *)"MDT") == 1U)) {
                                        tmp___108 = 1;
                                      } else {
                                        if (__s2_len___4 >= 4U) {
                                          tmp___108 = 1;
                                        } else {
                                          tmp___108 = 0;
                                        }
                                      }
                                    } else {
                                      tmp___108 = 0;
                                    }
                                  }
                                  if (tmp___108) {
                                    tmp___103 = __builtin_strcmp(crp + 9, "MDT");
                                    tmp___107 = tmp___103;
                                  } else {
                                    tmp___106 = __builtin_strcmp(crp + 9, "MDT");
                                    tmp___107 = tmp___106;
                                  }
                                } else {
                                  tmp___106 = __builtin_strcmp(crp + 9, "MDT");
                                  tmp___107 = tmp___106;
                                }
                                if (tmp___107) {
                                  if (0) {
                                    __s1_len___3 = strlen(crp + 9);
                                    __s2_len___3 = strlen("MST");
                                    if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                                      goto _L___15;
                                    } else {
                                      if (__s1_len___3 >= 4U) {
                                        _L___15: 
                                        if (! ((unsigned int )((void const   *)("MST" + 1)) - (unsigned int )((void const   *)"MST") == 1U)) {
                                          tmp___101 = 1;
                                        } else {
                                          if (__s2_len___3 >= 4U) {
                                            tmp___101 = 1;
                                          } else {
                                            tmp___101 = 0;
                                          }
                                        }
                                      } else {
                                        tmp___101 = 0;
                                      }
                                    }
                                    if (tmp___101) {
                                      tmp___96 = __builtin_strcmp(crp + 9, "MST");
                                      tmp___100 = tmp___96;
                                    } else {
                                      tmp___99 = __builtin_strcmp(crp + 9, "MST");
                                      tmp___100 = tmp___99;
                                    }
                                  } else {
                                    tmp___99 = __builtin_strcmp(crp + 9, "MST");
                                    tmp___100 = tmp___99;
                                  }
                                  if (tmp___100) {
                                    if (0) {
                                      __s1_len___2 = strlen(crp + 9);
                                      __s2_len___2 = strlen("PDT");
                                      if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                                        goto _L___13;
                                      } else {
                                        if (__s1_len___2 >= 4U) {
                                          _L___13: 
                                          if (! ((unsigned int )((void const   *)("PDT" + 1)) - (unsigned int )((void const   *)"PDT") == 1U)) {
                                            tmp___94 = 1;
                                          } else {
                                            if (__s2_len___2 >= 4U) {
                                              tmp___94 = 1;
                                            } else {
                                              tmp___94 = 0;
                                            }
                                          }
                                        } else {
                                          tmp___94 = 0;
                                        }
                                      }
                                      if (tmp___94) {
                                        tmp___89 = __builtin_strcmp(crp + 9, "PDT");
                                        tmp___93 = tmp___89;
                                      } else {
                                        tmp___92 = __builtin_strcmp(crp + 9, "PDT");
                                        tmp___93 = tmp___92;
                                      }
                                    } else {
                                      tmp___92 = __builtin_strcmp(crp + 9, "PDT");
                                      tmp___93 = tmp___92;
                                    }
                                    if (tmp___93) {
                                      if (0) {
                                        __s1_len___1 = strlen(crp + 9);
                                        __s2_len___1 = strlen("PST");
                                        if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                                          goto _L___11;
                                        } else {
                                          if (__s1_len___1 >= 4U) {
                                            _L___11: 
                                            if (! ((unsigned int )((void const   *)("PST" + 1)) - (unsigned int )((void const   *)"PST") == 1U)) {
                                              tmp___87 = 1;
                                            } else {
                                              if (__s2_len___1 >= 4U) {
                                                tmp___87 = 1;
                                              } else {
                                                tmp___87 = 0;
                                              }
                                            }
                                          } else {
                                            tmp___87 = 0;
                                          }
                                        }
                                        if (tmp___87) {
                                          tmp___82 = __builtin_strcmp(crp + 9, "PST");
                                          tmp___86 = tmp___82;
                                        } else {
                                          tmp___85 = __builtin_strcmp(crp + 9, "PST");
                                          tmp___86 = tmp___85;
                                        }
                                      } else {
                                        tmp___85 = __builtin_strcmp(crp + 9, "PST");
                                        tmp___86 = tmp___85;
                                      }
                                      if (tmp___86) {
                                        if (0) {
                                          __s1_len___0 = strlen(crp + 9);
                                          __s2_len___0 = strlen("HDT");
                                          if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                                            goto _L___9;
                                          } else {
                                            if (__s1_len___0 >= 4U) {
                                              _L___9: 
                                              if (! ((unsigned int )((void const   *)("HDT" + 1)) - (unsigned int )((void const   *)"HDT") == 1U)) {
                                                tmp___80 = 1;
                                              } else {
                                                if (__s2_len___0 >= 4U) {
                                                  tmp___80 = 1;
                                                } else {
                                                  tmp___80 = 0;
                                                }
                                              }
                                            } else {
                                              tmp___80 = 0;
                                            }
                                          }
                                          if (tmp___80) {
                                            tmp___75 = __builtin_strcmp(crp + 9, "HDT");
                                            tmp___79 = tmp___75;
                                          } else {
                                            tmp___78 = __builtin_strcmp(crp + 9, "HDT");
                                            tmp___79 = tmp___78;
                                          }
                                        } else {
                                          tmp___78 = __builtin_strcmp(crp + 9, "HDT");
                                          tmp___79 = tmp___78;
                                        }
                                        if (tmp___79) {
                                          if (0) {
                                            __s1_len = strlen(crp + 9);
                                            __s2_len = strlen("HST");
                                            if (! ((unsigned int )((void const   *)((crp + 9) + 1)) - (unsigned int )((void const   *)(crp + 9)) == 1U)) {
                                              goto _L___7;
                                            } else {
                                              if (__s1_len >= 4U) {
                                                _L___7: 
                                                if (! ((unsigned int )((void const   *)("HST" + 1)) - (unsigned int )((void const   *)"HST") == 1U)) {
                                                  tmp___73 = 1;
                                                } else {
                                                  if (__s2_len >= 4U) {
                                                    tmp___73 = 1;
                                                  } else {
                                                    tmp___73 = 0;
                                                  }
                                                }
                                              } else {
                                                tmp___73 = 0;
                                              }
                                            }
                                            if (tmp___73) {
                                              tmp___68 = __builtin_strcmp(crp + 9,
                                                                          "HST");
                                              tmp___72 = tmp___68;
                                            } else {
                                              tmp___71 = __builtin_strcmp(crp + 9,
                                                                          "HST");
                                              tmp___72 = tmp___71;
                                            }
                                          } else {
                                            tmp___71 = __builtin_strcmp(crp + 9, "HST");
                                            tmp___72 = tmp___71;
                                          }
                                          if (! tmp___72) {
                                            ts.tm_sec -= -36000;
                                          }
                                        } else {
                                          ts.tm_sec -= -32400;
                                        }
                                      } else {
                                        ts.tm_sec -= -28800;
                                      }
                                    } else {
                                      ts.tm_sec -= -25200;
                                    }
                                  } else {
                                    ts.tm_sec -= -25200;
                                  }
                                } else {
                                  ts.tm_sec -= -21600;
                                }
                              } else {
                                ts.tm_sec -= -21600;
                              }
                            } else {
                              ts.tm_sec -= -18000;
                            }
                          } else {
                            ts.tm_sec -= -18000;
                          }
                        } else {
                          ts.tm_sec -= -14400;
                        }
                      } else {
                        ts.tm_sec -= 32400;
                      }
                    } else {
                      ts.tm_sec -= 28800;
                    }
                  } else {
                    ts.tm_sec -= 32400;
                  }
                }
              }
            }
          }
        }
        tmp___158 = tcmkgmtime(& ts);
        return ((long long )tmp___158);
      }
    }
  }
  return ((-0x7FFFFFFFFFFFFFFF-1));
}
}
int tcjetlag(void) 
{ 

  {
  tzset();
  return ((int )(- timezone));
}
}
int tcdayofweek(int year , int mon , int day ) 
{ 

  {
  if (mon < 3) {
    year --;
    mon += 12;
  }
  return (((day + (8 + 13 * mon) / 5) + (((year + year / 4) - year / 100) + year / 400)) % 7);
}
}
static void tcrandomfdclose(void) 
{ 

  {
  close(tcrandomdevfd);
  return;
}
}
static time_t tcmkgmtime(struct tm *tm ) 
{ time_t tmp ;

  {
  tmp = timegm(tm);
  return (tmp);
}
}
static int tcstrutfkwicputtext(uint16_t const   *oary , uint16_t const   *nary , int si ,
                               int ti , int end , char *buf , TCLIST const   *uwords ,
                               int opts ) ;
static int tcchidxcmp(void const   *a , void const   *b ) ;
_Bool tcstrisnum(char const   *str ) 
{ _Bool isnum ;
  int tmp ;

  {
  isnum = (_Bool)0;
  while (1) {
    if ((int const   )*str > 0) {
      if (! ((int const   )*str <= 32)) {
        break;
      }
    } else {
      break;
    }
    str ++;
  }
  if ((int const   )*str == 45) {
    str ++;
  }
  while (1) {
    if ((int const   )*str >= 48) {
      if (! ((int const   )*str <= 57)) {
        break;
      }
    } else {
      break;
    }
    isnum = (_Bool)1;
    str ++;
  }
  if ((int const   )*str == 46) {
    str ++;
  }
  while (1) {
    if ((int const   )*str >= 48) {
      if (! ((int const   )*str <= 57)) {
        break;
      }
    } else {
      break;
    }
    isnum = (_Bool)1;
    str ++;
  }
  while (1) {
    if ((int const   )*str > 0) {
      if (! ((int const   )*str <= 32)) {
        break;
      }
    } else {
      break;
    }
    str ++;
  }
  if (isnum) {
    if ((int const   )*str == 0) {
      tmp = 1;
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  return ((_Bool )tmp);
}
}
int64_t tcatoih(char const   *str ) 
{ int64_t num ;

  {
  while (1) {
    if ((int const   )*str > 0) {
      if (! ((int const   )*str <= 32)) {
        break;
      }
    } else {
      break;
    }
    str ++;
  }
  if ((int const   )*(str + 0) == 48) {
    if ((int const   )*(str + 1) == 120) {
      str += 2;
    } else {
      if ((int const   )*(str + 1) == 88) {
        str += 2;
      }
    }
  }
  num = 0LL;
  while (1) {
    if ((int const   )*str >= 48) {
      if ((int const   )*str <= 57) {
        num = (num * 16LL + (long long )*str) - 48LL;
      } else {
        goto _L___0;
      }
    } else {
      _L___0: 
      if ((int const   )*str >= 97) {
        if ((int const   )*str <= 102) {
          num = ((num * 16LL + (long long )*str) - 97LL) + 10LL;
        } else {
          goto _L;
        }
      } else {
        _L: 
        if ((int const   )*str >= 65) {
          if ((int const   )*str <= 70) {
            num = ((num * 16LL + (long long )*str) - 65LL) + 10LL;
          } else {
            break;
          }
        } else {
          break;
        }
      }
    }
    str ++;
  }
  return (num);
}
}
char const   *tcstrskipspc(char const   *str ) 
{ 

  {
  while (1) {
    if ((int const   )*str > 0) {
      if (! ((int const   )*str <= 32)) {
        break;
      }
    } else {
      break;
    }
    str ++;
  }
  return (str);
}
}
char *tcstrutfnorm(char *str , int opts ) 
{ uint16_t buf[16384] ;
  uint16_t *ary ;
  int len ;
  size_t tmp ;
  void *tmp___0 ;
  int num ;

  {
  tmp = strlen((char const   *)str);
  len = (int )tmp;
  if (len < 16384) {
    ary = buf;
  } else {
    while (1) {
      tmp___0 = malloc((unsigned int )(len * (int )sizeof(*ary)));
      ary = (uint16_t *)tmp___0;
      if (! ary) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  tcstrutftoucs((char const   *)str, ary, & num);
  num = tcstrucsnorm(ary, num, opts);
  tcstrucstoutf((uint16_t const   *)ary, num, str);
  if ((unsigned int )ary != (unsigned int )(buf)) {
    while (1) {
      free((void *)ary);
      break;
    }
  }
  return (str);
}
}
int tcstrucsnorm(uint16_t *ary , int num , int opts ) 
{ _Bool spcmode ;
  _Bool lowmode ;
  _Bool nacmode ;
  _Bool widmode ;
  int wi ;
  int i ;
  int c ;
  int high ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;

  {
  spcmode = (_Bool )(opts & 1);
  lowmode = (_Bool )(opts & 2);
  nacmode = (_Bool )(opts & 4);
  widmode = (_Bool )(opts & 8);
  wi = 0;
  i = 0;
  while (i < num) {
    c = (int )*(ary + i);
    high = c >> 8;
    if (high == 0) {
      if (c <= 32) {
        goto _L___5;
      } else {
        if (c == 127) {
          _L___5: 
          if (spcmode) {
            tmp = wi;
            wi ++;
            *(ary + tmp) = (unsigned short)32;
            if (wi < 2) {
              wi --;
            } else {
              if ((int )*(ary + (wi - 2)) == 32) {
                wi --;
              }
            }
          } else {
            if (c == 9) {
              tmp___0 = wi;
              wi ++;
              *(ary + tmp___0) = (unsigned short )c;
            } else {
              if (c == 10) {
                tmp___0 = wi;
                wi ++;
                *(ary + tmp___0) = (unsigned short )c;
              } else {
                if (c == 13) {
                  tmp___0 = wi;
                  wi ++;
                  *(ary + tmp___0) = (unsigned short )c;
                } else {
                  tmp___1 = wi;
                  wi ++;
                  *(ary + tmp___1) = (unsigned short)32;
                }
              }
            }
          }
        } else {
          if (c == 160) {
            if (spcmode) {
              tmp___2 = wi;
              wi ++;
              *(ary + tmp___2) = (unsigned short)32;
              if (wi < 2) {
                wi --;
              } else {
                if ((int )*(ary + (wi - 2)) == 32) {
                  wi --;
                }
              }
            } else {
              tmp___3 = wi;
              wi ++;
              *(ary + tmp___3) = (unsigned short )c;
            }
          } else {
            if (lowmode) {
              if (c < 127) {
                if (c >= 65) {
                  if (c <= 90) {
                    c += 32;
                  }
                }
              } else {
                if (c >= 192) {
                  if (c <= 222) {
                    if (c != 215) {
                      c += 32;
                    }
                  }
                }
              }
            }
            if (nacmode) {
              if (c >= 192) {
                if (c <= 197) {
                  c = 'A';
                } else {
                  goto _L;
                }
              } else {
                _L: 
                if (c == 199) {
                  c = 'C';
                }
              }
              if (c >= 199) {
                if (c <= 203) {
                  c = 'E';
                }
              }
              if (c >= 204) {
                if (c <= 207) {
                  c = 'I';
                } else {
                  goto _L___0;
                }
              } else {
                _L___0: 
                if (c == 208) {
                  c = 'D';
                } else {
                  if (c == 209) {
                    c = 'N';
                  }
                }
              }
              if (c >= 210) {
                if (c <= 214) {
                  c = 'O';
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: 
                if (c == 216) {
                  c = 'O';
                }
              }
              if (c >= 217) {
                if (c <= 220) {
                  c = 'U';
                }
              }
              if (c == 221) {
                c = 'Y';
              } else {
                if (c == 222) {
                  c = 'Y';
                } else {
                  if (c == 223) {
                    c = 's';
                  } else {
                    if (c >= 224) {
                      if (c <= 229) {
                        c = 'a';
                      } else {
                        goto _L___2;
                      }
                    } else {
                      _L___2: 
                      if (c == 231) {
                        c = 'c';
                      }
                    }
                  }
                }
              }
              if (c >= 231) {
                if (c <= 235) {
                  c = 'e';
                }
              }
              if (c >= 236) {
                if (c <= 239) {
                  c = 'i';
                } else {
                  goto _L___3;
                }
              } else {
                _L___3: 
                if (c == 240) {
                  c = 'd';
                } else {
                  if (c == 241) {
                    c = 'n';
                  }
                }
              }
              if (c >= 242) {
                if (c <= 246) {
                  c = 'o';
                } else {
                  goto _L___4;
                }
              } else {
                _L___4: 
                if (c == 248) {
                  c = 'o';
                }
              }
              if (c >= 249) {
                if (c <= 252) {
                  c = 'u';
                }
              }
              if (c >= 253) {
                if (c <= 255) {
                  c = 'y';
                }
              }
            }
            tmp___4 = wi;
            wi ++;
            *(ary + tmp___4) = (unsigned short )c;
          }
        }
      }
    } else {
      if (high == 1) {
        if (lowmode) {
          if (c <= 311) {
            if ((c & 1) == 0) {
              c ++;
            }
          } else {
            if (c == 312) {
              c = c;
            } else {
              if (c <= 328) {
                if ((c & 1) == 1) {
                  c ++;
                }
              } else {
                if (c == 329) {
                  c = c;
                } else {
                  if (c <= 375) {
                    if ((c & 1) == 0) {
                      c ++;
                    }
                  } else {
                    if (c == 376) {
                      c = 255;
                    } else {
                      if (c <= 382) {
                        if ((c & 1) == 1) {
                          c ++;
                        }
                      } else {
                        if (c == 383) {
                          c = c;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (nacmode) {
          if (c == 255) {
            c = 'y';
          } else {
            if (c <= 261) {
              if ((c & 1) == 0) {
                c = 'A';
              } else {
                c = 'a';
              }
            } else {
              if (c <= 269) {
                if ((c & 1) == 0) {
                  c = 'C';
                } else {
                  c = 'c';
                }
              } else {
                if (c <= 273) {
                  if ((c & 1) == 0) {
                    c = 'D';
                  } else {
                    c = 'd';
                  }
                } else {
                  if (c <= 283) {
                    if ((c & 1) == 0) {
                      c = 'E';
                    } else {
                      c = 'e';
                    }
                  } else {
                    if (c <= 291) {
                      if ((c & 1) == 0) {
                        c = 'G';
                      } else {
                        c = 'g';
                      }
                    } else {
                      if (c <= 295) {
                        if ((c & 1) == 0) {
                          c = 'H';
                        } else {
                          c = 'h';
                        }
                      } else {
                        if (c <= 305) {
                          if ((c & 1) == 0) {
                            c = 'I';
                          } else {
                            c = 'i';
                          }
                        } else {
                          if (c == 308) {
                            c = 'J';
                          } else {
                            if (c == 309) {
                              c = 'j';
                            } else {
                              if (c == 310) {
                                c = 'K';
                              } else {
                                if (c == 311) {
                                  c = 'k';
                                } else {
                                  if (c == 312) {
                                    c = 'k';
                                  } else {
                                    if (c >= 313) {
                                      if (c <= 322) {
                                        if ((c & 1) == 1) {
                                          c = 'L';
                                        } else {
                                          c = 'l';
                                        }
                                      } else {
                                        goto _L___14;
                                      }
                                    } else {
                                      _L___14: 
                                      if (c >= 323) {
                                        if (c <= 328) {
                                          if ((c & 1) == 1) {
                                            c = 'N';
                                          } else {
                                            c = 'n';
                                          }
                                        } else {
                                          goto _L___13;
                                        }
                                      } else {
                                        _L___13: 
                                        if (c >= 329) {
                                          if (c <= 331) {
                                            if ((c & 1) == 0) {
                                              c = 'N';
                                            } else {
                                              c = 'n';
                                            }
                                          } else {
                                            goto _L___12;
                                          }
                                        } else {
                                          _L___12: 
                                          if (c >= 332) {
                                            if (c <= 337) {
                                              if ((c & 1) == 0) {
                                                c = 'O';
                                              } else {
                                                c = 'o';
                                              }
                                            } else {
                                              goto _L___11;
                                            }
                                          } else {
                                            _L___11: 
                                            if (c >= 340) {
                                              if (c <= 345) {
                                                if ((c & 1) == 0) {
                                                  c = 'R';
                                                } else {
                                                  c = 'r';
                                                }
                                              } else {
                                                goto _L___10;
                                              }
                                            } else {
                                              _L___10: 
                                              if (c >= 346) {
                                                if (c <= 353) {
                                                  if ((c & 1) == 0) {
                                                    c = 'S';
                                                  } else {
                                                    c = 's';
                                                  }
                                                } else {
                                                  goto _L___9;
                                                }
                                              } else {
                                                _L___9: 
                                                if (c >= 354) {
                                                  if (c <= 359) {
                                                    if ((c & 1) == 0) {
                                                      c = 'T';
                                                    } else {
                                                      c = 't';
                                                    }
                                                  } else {
                                                    goto _L___8;
                                                  }
                                                } else {
                                                  _L___8: 
                                                  if (c >= 360) {
                                                    if (c <= 371) {
                                                      if ((c & 1) == 0) {
                                                        c = 'U';
                                                      } else {
                                                        c = 'u';
                                                      }
                                                    } else {
                                                      goto _L___7;
                                                    }
                                                  } else {
                                                    _L___7: 
                                                    if (c == 372) {
                                                      c = 'W';
                                                    } else {
                                                      if (c == 373) {
                                                        c = 'w';
                                                      } else {
                                                        if (c == 374) {
                                                          c = 'Y';
                                                        } else {
                                                          if (c == 375) {
                                                            c = 'y';
                                                          } else {
                                                            if (c == 376) {
                                                              c = 'Y';
                                                            } else {
                                                              if (c >= 377) {
                                                                if (c <= 382) {
                                                                  if ((c & 1) == 1) {
                                                                    c = 'Z';
                                                                  } else {
                                                                    c = 'z';
                                                                  }
                                                                } else {
                                                                  goto _L___6;
                                                                }
                                                              } else {
                                                                _L___6: 
                                                                if (c == 383) {
                                                                  c = 's';
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        tmp___5 = wi;
        wi ++;
        *(ary + tmp___5) = (unsigned short )c;
      } else {
        if (high == 3) {
          if (lowmode) {
            if (c >= 913) {
              if (c <= 937) {
                c += 32;
              } else {
                goto _L___16;
              }
            } else {
              _L___16: 
              if (c >= 984) {
                if (c <= 1007) {
                  if ((c & 1) == 0) {
                    c ++;
                  }
                } else {
                  goto _L___15;
                }
              } else {
                _L___15: 
                if (c == 884) {
                  c ++;
                } else {
                  if (c == 1015) {
                    c ++;
                  } else {
                    if (c == 1018) {
                      c ++;
                    }
                  }
                }
              }
            }
          }
          tmp___6 = wi;
          wi ++;
          *(ary + tmp___6) = (unsigned short )c;
        } else {
          if (high == 4) {
            if (lowmode) {
              if (c <= 1039) {
                c += 80;
              } else {
                if (c <= 1071) {
                  c += 32;
                } else {
                  if (c >= 1120) {
                    if (c <= 1153) {
                      if ((c & 1) == 0) {
                        c ++;
                      }
                    } else {
                      goto _L___19;
                    }
                  } else {
                    _L___19: 
                    if (c >= 1162) {
                      if (c <= 1215) {
                        if ((c & 1) == 0) {
                          c ++;
                        }
                      } else {
                        goto _L___18;
                      }
                    } else {
                      _L___18: 
                      if (c == 1216) {
                        c = 1231;
                      } else {
                        if (c >= 1217) {
                          if (c <= 1230) {
                            if ((c & 1) == 1) {
                              c ++;
                            }
                          } else {
                            goto _L___17;
                          }
                        } else {
                          _L___17: 
                          if (c >= 1232) {
                            if ((c & 1) == 0) {
                              c ++;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            tmp___7 = wi;
            wi ++;
            *(ary + tmp___7) = (unsigned short )c;
          } else {
            if (high == 32) {
              if (c == 8194) {
                goto _L___20;
              } else {
                if (c == 8195) {
                  goto _L___20;
                } else {
                  if (c == 8201) {
                    _L___20: 
                    if (spcmode) {
                      tmp___8 = wi;
                      wi ++;
                      *(ary + tmp___8) = (unsigned short)32;
                      if (wi < 2) {
                        wi --;
                      } else {
                        if ((int )*(ary + (wi - 2)) == 32) {
                          wi --;
                        }
                      }
                    } else {
                      tmp___9 = wi;
                      wi ++;
                      *(ary + tmp___9) = (unsigned short )c;
                    }
                  } else {
                    if (c == 8208) {
                      tmp___10 = wi;
                      wi ++;
                      if (widmode) {
                        *(ary + tmp___10) = (unsigned short)45;
                      } else {
                        *(ary + tmp___10) = (unsigned short )c;
                      }
                    } else {
                      if (c == 8213) {
                        tmp___11 = wi;
                        wi ++;
                        if (widmode) {
                          *(ary + tmp___11) = (unsigned short)45;
                        } else {
                          *(ary + tmp___11) = (unsigned short )c;
                        }
                      } else {
                        if (c == 8217) {
                          tmp___12 = wi;
                          wi ++;
                          if (widmode) {
                            *(ary + tmp___12) = (unsigned short)39;
                          } else {
                            *(ary + tmp___12) = (unsigned short )c;
                          }
                        } else {
                          if (c == 8243) {
                            tmp___13 = wi;
                            wi ++;
                            if (widmode) {
                              *(ary + tmp___13) = (unsigned short)34;
                            } else {
                              *(ary + tmp___13) = (unsigned short )c;
                            }
                          } else {
                            tmp___14 = wi;
                            wi ++;
                            *(ary + tmp___14) = (unsigned short )c;
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              if (high == 34) {
                if (c == 8722) {
                  tmp___15 = wi;
                  wi ++;
                  if (widmode) {
                    *(ary + tmp___15) = (unsigned short)45;
                  } else {
                    *(ary + tmp___15) = (unsigned short )c;
                  }
                } else {
                  tmp___16 = wi;
                  wi ++;
                  *(ary + tmp___16) = (unsigned short )c;
                }
              } else {
                if (high == 48) {
                  if (c == 12288) {
                    if (spcmode) {
                      tmp___17 = wi;
                      wi ++;
                      *(ary + tmp___17) = (unsigned short)32;
                      if (wi < 2) {
                        wi --;
                      } else {
                        if ((int )*(ary + (wi - 2)) == 32) {
                          wi --;
                        }
                      }
                    } else {
                      if (widmode) {
                        tmp___18 = wi;
                        wi ++;
                        *(ary + tmp___18) = (unsigned short)32;
                      } else {
                        tmp___19 = wi;
                        wi ++;
                        *(ary + tmp___19) = (unsigned short )c;
                      }
                    }
                  } else {
                    tmp___20 = wi;
                    wi ++;
                    *(ary + tmp___20) = (unsigned short )c;
                  }
                } else {
                  if (high == 255) {
                    if (c == 65281) {
                      tmp___21 = wi;
                      wi ++;
                      if (widmode) {
                        *(ary + tmp___21) = (unsigned short)33;
                      } else {
                        *(ary + tmp___21) = (unsigned short )c;
                      }
                    } else {
                      if (c == 65283) {
                        tmp___22 = wi;
                        wi ++;
                        if (widmode) {
                          *(ary + tmp___22) = (unsigned short)35;
                        } else {
                          *(ary + tmp___22) = (unsigned short )c;
                        }
                      } else {
                        if (c == 65284) {
                          tmp___23 = wi;
                          wi ++;
                          if (widmode) {
                            *(ary + tmp___23) = (unsigned short)36;
                          } else {
                            *(ary + tmp___23) = (unsigned short )c;
                          }
                        } else {
                          if (c == 65285) {
                            tmp___24 = wi;
                            wi ++;
                            if (widmode) {
                              *(ary + tmp___24) = (unsigned short)37;
                            } else {
                              *(ary + tmp___24) = (unsigned short )c;
                            }
                          } else {
                            if (c == 65286) {
                              tmp___25 = wi;
                              wi ++;
                              if (widmode) {
                                *(ary + tmp___25) = (unsigned short)38;
                              } else {
                                *(ary + tmp___25) = (unsigned short )c;
                              }
                            } else {
                              if (c == 65290) {
                                tmp___26 = wi;
                                wi ++;
                                if (widmode) {
                                  *(ary + tmp___26) = (unsigned short)42;
                                } else {
                                  *(ary + tmp___26) = (unsigned short )c;
                                }
                              } else {
                                if (c == 65291) {
                                  tmp___27 = wi;
                                  wi ++;
                                  if (widmode) {
                                    *(ary + tmp___27) = (unsigned short)43;
                                  } else {
                                    *(ary + tmp___27) = (unsigned short )c;
                                  }
                                } else {
                                  if (c == 65292) {
                                    tmp___28 = wi;
                                    wi ++;
                                    if (widmode) {
                                      *(ary + tmp___28) = (unsigned short)44;
                                    } else {
                                      *(ary + tmp___28) = (unsigned short )c;
                                    }
                                  } else {
                                    if (c == 65294) {
                                      tmp___29 = wi;
                                      wi ++;
                                      if (widmode) {
                                        *(ary + tmp___29) = (unsigned short)46;
                                      } else {
                                        *(ary + tmp___29) = (unsigned short )c;
                                      }
                                    } else {
                                      if (c == 65295) {
                                        tmp___30 = wi;
                                        wi ++;
                                        if (widmode) {
                                          *(ary + tmp___30) = (unsigned short)47;
                                        } else {
                                          *(ary + tmp___30) = (unsigned short )c;
                                        }
                                      } else {
                                        if (c == 65306) {
                                          tmp___31 = wi;
                                          wi ++;
                                          if (widmode) {
                                            *(ary + tmp___31) = (unsigned short)58;
                                          } else {
                                            *(ary + tmp___31) = (unsigned short )c;
                                          }
                                        } else {
                                          if (c == 65307) {
                                            tmp___32 = wi;
                                            wi ++;
                                            if (widmode) {
                                              *(ary + tmp___32) = (unsigned short)59;
                                            } else {
                                              *(ary + tmp___32) = (unsigned short )c;
                                            }
                                          } else {
                                            if (c == 65309) {
                                              tmp___33 = wi;
                                              wi ++;
                                              if (widmode) {
                                                *(ary + tmp___33) = (unsigned short)61;
                                              } else {
                                                *(ary + tmp___33) = (unsigned short )c;
                                              }
                                            } else {
                                              if (c == 65311) {
                                                tmp___34 = wi;
                                                wi ++;
                                                if (widmode) {
                                                  *(ary + tmp___34) = (unsigned short)63;
                                                } else {
                                                  *(ary + tmp___34) = (unsigned short )c;
                                                }
                                              } else {
                                                if (c == 65312) {
                                                  tmp___35 = wi;
                                                  wi ++;
                                                  if (widmode) {
                                                    *(ary + tmp___35) = (unsigned short)64;
                                                  } else {
                                                    *(ary + tmp___35) = (unsigned short )c;
                                                  }
                                                } else {
                                                  if (c == 65340) {
                                                    tmp___36 = wi;
                                                    wi ++;
                                                    if (widmode) {
                                                      *(ary + tmp___36) = (unsigned short)92;
                                                    } else {
                                                      *(ary + tmp___36) = (unsigned short )c;
                                                    }
                                                  } else {
                                                    if (c == 65342) {
                                                      tmp___37 = wi;
                                                      wi ++;
                                                      if (widmode) {
                                                        *(ary + tmp___37) = (unsigned short)94;
                                                      } else {
                                                        *(ary + tmp___37) = (unsigned short )c;
                                                      }
                                                    } else {
                                                      if (c == 65343) {
                                                        tmp___38 = wi;
                                                        wi ++;
                                                        if (widmode) {
                                                          *(ary + tmp___38) = (unsigned short)95;
                                                        } else {
                                                          *(ary + tmp___38) = (unsigned short )c;
                                                        }
                                                      } else {
                                                        if (c == 65372) {
                                                          tmp___39 = wi;
                                                          wi ++;
                                                          if (widmode) {
                                                            *(ary + tmp___39) = (unsigned short)124;
                                                          } else {
                                                            *(ary + tmp___39) = (unsigned short )c;
                                                          }
                                                        } else {
                                                          if (c >= 65313) {
                                                            if (c <= 65338) {
                                                              if (widmode) {
                                                                if (lowmode) {
                                                                  tmp___40 = wi;
                                                                  wi ++;
                                                                  *(ary + tmp___40) = (unsigned short )((c - 65248) + 32);
                                                                } else {
                                                                  tmp___41 = wi;
                                                                  wi ++;
                                                                  *(ary + tmp___41) = (unsigned short )(c - 65248);
                                                                }
                                                              } else {
                                                                if (lowmode) {
                                                                  tmp___42 = wi;
                                                                  wi ++;
                                                                  *(ary + tmp___42) = (unsigned short )(c + 32);
                                                                } else {
                                                                  tmp___43 = wi;
                                                                  wi ++;
                                                                  *(ary + tmp___43) = (unsigned short )c;
                                                                }
                                                              }
                                                            } else {
                                                              goto _L___35;
                                                            }
                                                          } else {
                                                            _L___35: 
                                                            if (c >= 65345) {
                                                              if (c <= 65370) {
                                                                tmp___44 = wi;
                                                                wi ++;
                                                                if (widmode) {
                                                                  *(ary + tmp___44) = (unsigned short )(c - 65248);
                                                                } else {
                                                                  *(ary + tmp___44) = (unsigned short )c;
                                                                }
                                                              } else {
                                                                goto _L___34;
                                                              }
                                                            } else {
                                                              _L___34: 
                                                              if (c >= 65296) {
                                                                if (c <= 65305) {
                                                                  tmp___45 = wi;
                                                                  wi ++;
                                                                  if (widmode) {
                                                                    *(ary + tmp___45) = (unsigned short )(c - 65248);
                                                                  } else {
                                                                    *(ary + tmp___45) = (unsigned short )c;
                                                                  }
                                                                } else {
                                                                  goto _L___33;
                                                                }
                                                              } else {
                                                                _L___33: 
                                                                if (c == 65377) {
                                                                  tmp___46 = wi;
                                                                  wi ++;
                                                                  if (widmode) {
                                                                    *(ary + tmp___46) = (unsigned short)12290;
                                                                  } else {
                                                                    *(ary + tmp___46) = (unsigned short )c;
                                                                  }
                                                                } else {
                                                                  if (c == 65378) {
                                                                    tmp___47 = wi;
                                                                    wi ++;
                                                                    if (widmode) {
                                                                      *(ary + tmp___47) = (unsigned short)12300;
                                                                    } else {
                                                                      *(ary + tmp___47) = (unsigned short )c;
                                                                    }
                                                                  } else {
                                                                    if (c == 65379) {
                                                                      tmp___48 = wi;
                                                                      wi ++;
                                                                      if (widmode) {
                                                                        *(ary + tmp___48) = (unsigned short)12301;
                                                                      } else {
                                                                        *(ary + tmp___48) = (unsigned short )c;
                                                                      }
                                                                    } else {
                                                                      if (c == 65380) {
                                                                        tmp___49 = wi;
                                                                        wi ++;
                                                                        if (widmode) {
                                                                          *(ary + tmp___49) = (unsigned short)12289;
                                                                        } else {
                                                                          *(ary + tmp___49) = (unsigned short )c;
                                                                        }
                                                                      } else {
                                                                        if (c == 65381) {
                                                                          tmp___50 = wi;
                                                                          wi ++;
                                                                          if (widmode) {
                                                                            *(ary + tmp___50) = (unsigned short)12539;
                                                                          } else {
                                                                            *(ary + tmp___50) = (unsigned short )c;
                                                                          }
                                                                        } else {
                                                                          if (c == 65382) {
                                                                            tmp___51 = wi;
                                                                            wi ++;
                                                                            if (widmode) {
                                                                              *(ary + tmp___51) = (unsigned short)12530;
                                                                            } else {
                                                                              *(ary + tmp___51) = (unsigned short )c;
                                                                            }
                                                                          } else {
                                                                            if (c >= 65383) {
                                                                              if (c <= 65387) {
                                                                                tmp___52 = wi;
                                                                                wi ++;
                                                                                if (widmode) {
                                                                                  *(ary + tmp___52) = (unsigned short )((c - 65383) * 2 + 12449);
                                                                                } else {
                                                                                  *(ary + tmp___52) = (unsigned short )c;
                                                                                }
                                                                              } else {
                                                                                goto _L___32;
                                                                              }
                                                                            } else {
                                                                              _L___32: 
                                                                              if (c >= 65388) {
                                                                                if (c <= 65390) {
                                                                                  tmp___53 = wi;
                                                                                  wi ++;
                                                                                  if (widmode) {
                                                                                    *(ary + tmp___53) = (unsigned short )((c - 65388) * 2 + 12515);
                                                                                  } else {
                                                                                    *(ary + tmp___53) = (unsigned short )c;
                                                                                  }
                                                                                } else {
                                                                                  goto _L___31;
                                                                                }
                                                                              } else {
                                                                                _L___31: 
                                                                                if (c == 65391) {
                                                                                  tmp___54 = wi;
                                                                                  wi ++;
                                                                                  if (widmode) {
                                                                                    *(ary + tmp___54) = (unsigned short)12483;
                                                                                  } else {
                                                                                    *(ary + tmp___54) = (unsigned short )c;
                                                                                  }
                                                                                } else {
                                                                                  if (c == 65392) {
                                                                                    tmp___55 = wi;
                                                                                    wi ++;
                                                                                    if (widmode) {
                                                                                      *(ary + tmp___55) = (unsigned short)12540;
                                                                                    } else {
                                                                                      *(ary + tmp___55) = (unsigned short )c;
                                                                                    }
                                                                                  } else {
                                                                                    if (c >= 65393) {
                                                                                      if (c <= 65397) {
                                                                                        if (widmode) {
                                                                                          *(ary + wi) = (unsigned short )((c - 65393) * 2 + 12450);
                                                                                          if (c == 65395) {
                                                                                            if (i < num - 1) {
                                                                                              if ((int )*(ary + (i + 1)) == 65438) {
                                                                                                *(ary + wi) = (unsigned short)12532;
                                                                                                i ++;
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                          wi ++;
                                                                                        } else {
                                                                                          tmp___56 = wi;
                                                                                          wi ++;
                                                                                          *(ary + tmp___56) = (unsigned short )c;
                                                                                        }
                                                                                      } else {
                                                                                        goto _L___30;
                                                                                      }
                                                                                    } else {
                                                                                      _L___30: 
                                                                                      if (c >= 65398) {
                                                                                        if (c <= 65402) {
                                                                                          if (widmode) {
                                                                                            *(ary + wi) = (unsigned short )((c - 65398) * 2 + 12459);
                                                                                            if (i < num - 1) {
                                                                                              if ((int )*(ary + (i + 1)) == 65438) {
                                                                                                *(ary + wi) = (unsigned short )((int )*(ary + wi) + 1);
                                                                                                i ++;
                                                                                              }
                                                                                            }
                                                                                            wi ++;
                                                                                          } else {
                                                                                            tmp___57 = wi;
                                                                                            wi ++;
                                                                                            *(ary + tmp___57) = (unsigned short )c;
                                                                                          }
                                                                                        } else {
                                                                                          goto _L___29;
                                                                                        }
                                                                                      } else {
                                                                                        _L___29: 
                                                                                        if (c >= 65403) {
                                                                                          if (c <= 65407) {
                                                                                            if (widmode) {
                                                                                              *(ary + wi) = (unsigned short )((c - 65403) * 2 + 12469);
                                                                                              if (i < num - 1) {
                                                                                                if ((int )*(ary + (i + 1)) == 65438) {
                                                                                                  *(ary + wi) = (unsigned short )((int )*(ary + wi) + 1);
                                                                                                  i ++;
                                                                                                }
                                                                                              }
                                                                                              wi ++;
                                                                                            } else {
                                                                                              tmp___58 = wi;
                                                                                              wi ++;
                                                                                              *(ary + tmp___58) = (unsigned short )c;
                                                                                            }
                                                                                          } else {
                                                                                            goto _L___28;
                                                                                          }
                                                                                        } else {
                                                                                          _L___28: 
                                                                                          if (c >= 65408) {
                                                                                            if (c <= 65412) {
                                                                                              if (widmode) {
                                                                                                if (c >= 65410) {
                                                                                                  tmp___59 = 1;
                                                                                                } else {
                                                                                                  tmp___59 = 0;
                                                                                                }
                                                                                                *(ary + wi) = (unsigned short )(((c - 65408) * 2 + 12479) + tmp___59);
                                                                                                if (i < num - 1) {
                                                                                                  if ((int )*(ary + (i + 1)) == 65438) {
                                                                                                    *(ary + wi) = (unsigned short )((int )*(ary + wi) + 1);
                                                                                                    i ++;
                                                                                                  }
                                                                                                }
                                                                                                wi ++;
                                                                                              } else {
                                                                                                tmp___60 = wi;
                                                                                                wi ++;
                                                                                                *(ary + tmp___60) = (unsigned short )c;
                                                                                              }
                                                                                            } else {
                                                                                              goto _L___27;
                                                                                            }
                                                                                          } else {
                                                                                            _L___27: 
                                                                                            if (c >= 65413) {
                                                                                              if (c <= 65417) {
                                                                                                tmp___61 = wi;
                                                                                                wi ++;
                                                                                                if (widmode) {
                                                                                                  *(ary + tmp___61) = (unsigned short )(c - 52923);
                                                                                                } else {
                                                                                                  *(ary + tmp___61) = (unsigned short )c;
                                                                                                }
                                                                                              } else {
                                                                                                goto _L___26;
                                                                                              }
                                                                                            } else {
                                                                                              _L___26: 
                                                                                              if (c >= 65418) {
                                                                                                if (c <= 65422) {
                                                                                                  if (widmode) {
                                                                                                    *(ary + wi) = (unsigned short )((c - 65418) * 3 + 12495);
                                                                                                    if (i < num - 1) {
                                                                                                      if ((int )*(ary + (i + 1)) == 65438) {
                                                                                                        *(ary + wi) = (unsigned short )((int )*(ary + wi) + 1);
                                                                                                        i ++;
                                                                                                      } else {
                                                                                                        goto _L___21;
                                                                                                      }
                                                                                                    } else {
                                                                                                      _L___21: 
                                                                                                      if (i < num - 1) {
                                                                                                        if ((int )*(ary + (i + 1)) == 65439) {
                                                                                                          *(ary + wi) = (unsigned short )((int )*(ary + wi) + 2);
                                                                                                          i ++;
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                    wi ++;
                                                                                                  } else {
                                                                                                    tmp___62 = wi;
                                                                                                    wi ++;
                                                                                                    *(ary + tmp___62) = (unsigned short )c;
                                                                                                  }
                                                                                                } else {
                                                                                                  goto _L___25;
                                                                                                }
                                                                                              } else {
                                                                                                _L___25: 
                                                                                                if (c >= 65423) {
                                                                                                  if (c <= 65427) {
                                                                                                    tmp___63 = wi;
                                                                                                    wi ++;
                                                                                                    if (widmode) {
                                                                                                      *(ary + tmp___63) = (unsigned short )(c - 52913);
                                                                                                    } else {
                                                                                                      *(ary + tmp___63) = (unsigned short )c;
                                                                                                    }
                                                                                                  } else {
                                                                                                    goto _L___24;
                                                                                                  }
                                                                                                } else {
                                                                                                  _L___24: 
                                                                                                  if (c >= 65428) {
                                                                                                    if (c <= 65430) {
                                                                                                      tmp___64 = wi;
                                                                                                      wi ++;
                                                                                                      if (widmode) {
                                                                                                        *(ary + tmp___64) = (unsigned short )((c - 65428) * 2 + 12516);
                                                                                                      } else {
                                                                                                        *(ary + tmp___64) = (unsigned short )c;
                                                                                                      }
                                                                                                    } else {
                                                                                                      goto _L___23;
                                                                                                    }
                                                                                                  } else {
                                                                                                    _L___23: 
                                                                                                    if (c >= 65431) {
                                                                                                      if (c <= 65435) {
                                                                                                        tmp___65 = wi;
                                                                                                        wi ++;
                                                                                                        if (widmode) {
                                                                                                          *(ary + tmp___65) = (unsigned short )(c - 52910);
                                                                                                        } else {
                                                                                                          *(ary + tmp___65) = (unsigned short )c;
                                                                                                        }
                                                                                                      } else {
                                                                                                        goto _L___22;
                                                                                                      }
                                                                                                    } else {
                                                                                                      _L___22: 
                                                                                                      if (c == 65436) {
                                                                                                        tmp___66 = wi;
                                                                                                        wi ++;
                                                                                                        if (widmode) {
                                                                                                          *(ary + tmp___66) = (unsigned short)12527;
                                                                                                        } else {
                                                                                                          *(ary + tmp___66) = (unsigned short )c;
                                                                                                        }
                                                                                                      } else {
                                                                                                        if (c == 65437) {
                                                                                                          tmp___67 = wi;
                                                                                                          wi ++;
                                                                                                          if (widmode) {
                                                                                                            *(ary + tmp___67) = (unsigned short)12531;
                                                                                                          } else {
                                                                                                            *(ary + tmp___67) = (unsigned short )c;
                                                                                                          }
                                                                                                        } else {
                                                                                                          tmp___68 = wi;
                                                                                                          wi ++;
                                                                                                          *(ary + tmp___68) = (unsigned short )c;
                                                                                                        }
                                                                                                      }
                                                                                                    }
                                                                                                  }
                                                                                                }
                                                                                              }
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    tmp___69 = wi;
                    wi ++;
                    *(ary + tmp___69) = (unsigned short )c;
                  }
                }
              }
            }
          }
        }
      }
    }
    i ++;
  }
  if (spcmode) {
    while (1) {
      if (wi > 0) {
        if (! ((int )*(ary + (wi - 1)) == 32)) {
          break;
        }
      } else {
        break;
      }
      wi --;
    }
  }
  return (wi);
}
}
TCLIST *tcstrkwic(char const   *str , TCLIST const   *words , int width , int opts ) 
{ TCLIST *texts ;
  TCLIST *tmp ;
  int len ;
  size_t tmp___0 ;
  uint16_t *oary ;
  uint16_t *nary ;
  void *tmp___1 ;
  void *tmp___2 ;
  int oanum ;
  int nanum ;
  int i ;
  int wnum ;
  TCLIST *uwords ;
  TCLIST *tmp___3 ;
  int i___0 ;
  char const   *word ;
  int wsiz ;
  uint16_t *uwary ;
  void *tmp___4 ;
  int uwnum ;
  int ri ;
  int pi ;
  int step ;
  int i___1 ;
  char const   *val ;
  int uwnum___0 ;
  uint16_t *uwary___0 ;
  int ci ;
  int si ;
  long tmp___5 ;
  long tmp___6 ;
  int ti ;
  long tmp___7 ;
  char *tbuf ;
  void *tmp___8 ;
  int wi ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int ti___0 ;
  long tmp___18 ;
  char *tbuf___0 ;
  void *tmp___19 ;
  int wi___0 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  tmp = tclistnew();
  texts = tmp;
  tmp___0 = strlen(str);
  len = (int )tmp___0;
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(*oary) * len + 1));
    oary = (uint16_t *)tmp___1;
    if (! oary) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___2 = malloc((unsigned int )((int )sizeof(*nary) * len + 1));
    nary = (uint16_t *)tmp___2;
    if (! nary) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tcstrutftoucs(str, oary, & oanum);
  tcstrutftoucs(str, nary, & nanum);
  nanum = tcstrucsnorm(nary, nanum, 14);
  if (nanum != oanum) {
    memcpy((void * __restrict  )nary, (void const   * __restrict  )oary, (unsigned int )((int )sizeof(*oary) * oanum));
    i = 0;
    while (i < oanum) {
      if ((int )*(nary + i) >= 65) {
        if ((int )*(nary + i) <= 90) {
          *(nary + i) = (unsigned short )((int )*(nary + i) + 32);
        }
      }
      i ++;
    }
    nanum = oanum;
  }
  wnum = (int )words->num;
  tmp___3 = tclistnew2(wnum);
  uwords = tmp___3;
  i___0 = 0;
  while (i___0 < wnum) {
    while (1) {
      word = (char const   *)(words->array + (i___0 + (int )words->start))->ptr;
      wsiz = (words->array + (i___0 + (int )words->start))->size;
      break;
    }
    while (1) {
      tmp___4 = malloc((unsigned int )((int )sizeof(*uwary) * wsiz + 1));
      uwary = (uint16_t *)tmp___4;
      if (! uwary) {
        tcmyfatal("out of memory");
      }
      break;
    }
    tcstrutftoucs(word, uwary, & uwnum);
    uwnum = tcstrucsnorm(uwary, uwnum, 15);
    if (uwnum > 0) {
      tclistpushmalloc(uwords, (void *)uwary, (int )sizeof(*uwary) * uwnum);
    } else {
      while (1) {
        free((void *)uwary);
        break;
      }
    }
    i___0 ++;
  }
  wnum = uwords->num;
  ri = 0;
  pi = 0;
  while (ri < nanum) {
    step = 0;
    i___1 = 0;
    while (i___1 < wnum) {
      while (1) {
        val = (char const   *)(uwords->array + (i___1 + uwords->start))->ptr;
        uwnum___0 = (uwords->array + (i___1 + uwords->start))->size;
        break;
      }
      uwary___0 = (uint16_t *)val;
      uwnum___0 /= (int )sizeof(*uwary___0);
      if (ri + uwnum___0 <= nanum) {
        ci = 0;
        while (1) {
          if (ci < uwnum___0) {
            if (! ((int )*(nary + (ri + ci)) == (int )*(uwary___0 + ci))) {
              break;
            }
          } else {
            break;
          }
          ci ++;
        }
        if (ci == uwnum___0) {
          tmp___5 = tclmax((long )(ri - width), 0L);
          si = (int )tmp___5;
          if (opts & 16777216) {
            tmp___6 = tclmax((long )si, (long )pi);
            si = (int )tmp___6;
          }
          tmp___7 = tclmin((long )((ri + uwnum___0) + width), (long )nanum);
          ti = (int )tmp___7;
          while (1) {
            tmp___8 = malloc((unsigned int )((ti - si) * 5 + 1));
            tbuf = (char *)tmp___8;
            if (! tbuf) {
              tcmyfatal("out of memory");
            }
            break;
          }
          wi = 0;
          if (ri > si) {
            tmp___9 = tcstrutfkwicputtext((uint16_t const   *)oary, (uint16_t const   *)nary,
                                          si, ri, ri, tbuf + wi, (TCLIST const   *)uwords,
                                          opts);
            wi += tmp___9;
          }
          if (opts & 1) {
            tmp___10 = wi;
            wi ++;
            *(tbuf + tmp___10) = (char )'\t';
          } else {
            if (opts & 2) {
              tmp___11 = wi;
              wi ++;
              *(tbuf + tmp___11) = (char)2;
            } else {
              if (opts & 4) {
                tmp___12 = wi;
                wi ++;
                *(tbuf + tmp___12) = (char )'[';
              }
            }
          }
          tmp___13 = tcstrucstoutf((uint16_t const   *)(oary + ri), ci, tbuf + wi);
          wi += tmp___13;
          if (opts & 1) {
            tmp___14 = wi;
            wi ++;
            *(tbuf + tmp___14) = (char )'\t';
          } else {
            if (opts & 2) {
              tmp___15 = wi;
              wi ++;
              *(tbuf + tmp___15) = (char)3;
            } else {
              if (opts & 4) {
                tmp___16 = wi;
                wi ++;
                *(tbuf + tmp___16) = (char )']';
              }
            }
          }
          if (ti > ri + ci) {
            tmp___17 = tcstrutfkwicputtext((uint16_t const   *)oary, (uint16_t const   *)nary,
                                           ri + ci, ti, nanum, tbuf + wi, (TCLIST const   *)uwords,
                                           opts);
            wi += tmp___17;
          }
          if (wi > 0) {
            tclistpushmalloc(texts, (void *)tbuf, wi);
          } else {
            while (1) {
              free((void *)tbuf);
              break;
            }
          }
          if (ti > step) {
            step = ti;
          }
          if (step > pi) {
            pi = step;
          }
          if (opts & 16777216) {
            break;
          }
        }
      }
      i___1 ++;
    }
    if (ri == 0) {
      if (step < 1) {
        if (opts & 33554432) {
          tmp___18 = tclmin((long )(ri + width * 2), (long )nanum);
          ti___0 = (int )tmp___18;
          if (ti___0 > 0) {
            while (1) {
              tmp___19 = malloc((unsigned int )(ti___0 * 5 + 1));
              tbuf___0 = (char *)tmp___19;
              if (! tbuf___0) {
                tcmyfatal("out of memory");
              }
              break;
            }
            wi___0 = 0;
            tmp___20 = tcstrutfkwicputtext((uint16_t const   *)oary, (uint16_t const   *)nary,
                                           0, ti___0, nanum, tbuf___0 + wi___0, (TCLIST const   *)uwords,
                                           opts);
            wi___0 += tmp___20;
            if (! (opts & 16777216)) {
              if (opts & 1) {
                tmp___21 = wi___0;
                wi___0 ++;
                *(tbuf___0 + tmp___21) = (char )'\t';
                tmp___22 = wi___0;
                wi___0 ++;
                *(tbuf___0 + tmp___22) = (char )'\t';
              }
            }
            tclistpushmalloc(texts, (void *)tbuf___0, wi___0);
          }
          step = ti___0;
        }
      }
    }
    if (opts & 16777216) {
      if (step > 0) {
        ri = step;
      } else {
        ri ++;
      }
    } else {
      ri ++;
    }
  }
  tclistdel(uwords);
  while (1) {
    free((void *)nary);
    break;
  }
  while (1) {
    free((void *)oary);
    break;
  }
  return (texts);
}
}
TCLIST *tcstrtokenize(char const   *str ) 
{ TCLIST *tokens ;
  TCLIST *tmp ;
  unsigned char const   *rp ;
  TCXSTR *buf ;
  TCXSTR *tmp___0 ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___1 ;
  void *tmp___2 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___3 ;
  void *tmp___4 ;
  int size ;
  void *tmp___5 ;
  unsigned char const   *ep ;
  int TC_mysize___1 ;
  int TC_index ;
  TCLISTDATUM *tmp___6 ;
  void *tmp___7 ;
  TCLISTDATUM *array ;
  char *tmp___8 ;
  void *tmp___9 ;

  {
  tmp = tclistnew();
  tokens = tmp;
  rp = (unsigned char const   *)((unsigned char *)str);
  while ((int const   )*rp != 0) {
    while ((int const   )*rp <= 32) {
      rp ++;
    }
    if ((int const   )*rp == 34) {
      rp ++;
      tmp___0 = tcxstrnew();
      buf = tmp___0;
      while ((int const   )*rp != 0) {
        if ((int const   )*rp == 92) {
          rp ++;
          if ((int const   )*rp != 0) {
            while (1) {
              TC_mysize = 1;
              TC_nsize = (buf->size + TC_mysize) + 1;
              if (buf->asize < TC_nsize) {
                while (buf->asize < TC_nsize) {
                  buf->asize *= 2;
                  if (buf->asize < TC_nsize) {
                    buf->asize = TC_nsize;
                  }
                }
                while (1) {
                  tmp___2 = realloc((void *)buf->ptr, (unsigned int )buf->asize);
                  tmp___1 = (char *)tmp___2;
                  buf->ptr = tmp___1;
                  if (! tmp___1) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              memcpy((void * __restrict  )(buf->ptr + buf->size), (void const   * __restrict  )rp,
                     (unsigned int )TC_mysize);
              buf->size += TC_mysize;
              *(buf->ptr + buf->size) = (char )'\000';
              break;
            }
          }
          rp ++;
        } else {
          if ((int const   )*rp == 34) {
            rp ++;
            break;
          } else {
            while (1) {
              TC_mysize___0 = 1;
              TC_nsize___0 = (buf->size + TC_mysize___0) + 1;
              if (buf->asize < TC_nsize___0) {
                while (buf->asize < TC_nsize___0) {
                  buf->asize *= 2;
                  if (buf->asize < TC_nsize___0) {
                    buf->asize = TC_nsize___0;
                  }
                }
                while (1) {
                  tmp___4 = realloc((void *)buf->ptr, (unsigned int )buf->asize);
                  tmp___3 = (char *)tmp___4;
                  buf->ptr = tmp___3;
                  if (! tmp___3) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              memcpy((void * __restrict  )(buf->ptr + buf->size), (void const   * __restrict  )rp,
                     (unsigned int )TC_mysize___0);
              buf->size += TC_mysize___0;
              *(buf->ptr + buf->size) = (char )'\000';
              break;
            }
            rp ++;
          }
        }
      }
      size = buf->size;
      tmp___5 = tcxstrtomalloc(buf);
      tclistpushmalloc(tokens, tmp___5, size);
    } else {
      ep = rp;
      while ((int const   )*ep > 32) {
        ep ++;
      }
      if ((unsigned int )ep > (unsigned int )rp) {
        while (1) {
          TC_mysize___1 = ep - rp;
          TC_index = tokens->start + tokens->num;
          if (TC_index >= tokens->anum) {
            tokens->anum += tokens->num + 1;
            while (1) {
              tmp___7 = realloc((void *)tokens->array, (unsigned int )(tokens->anum * (int )sizeof(*(tokens->array + 0))));
              tmp___6 = (TCLISTDATUM *)tmp___7;
              tokens->array = tmp___6;
              if (! tmp___6) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          array = tokens->array;
          while (1) {
            tmp___9 = malloc((unsigned int )(TC_mysize___1 + 1));
            tmp___8 = (char *)tmp___9;
            (array + TC_index)->ptr = tmp___8;
            if (! tmp___8) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )rp,
                 (unsigned int )TC_mysize___1);
          *((array + TC_index)->ptr + TC_mysize___1) = (char )'\000';
          (array + TC_index)->size = TC_mysize___1;
          (tokens->num) ++;
          break;
        }
      }
      if ((int const   )*ep != 0) {
        rp = ep + 1;
      } else {
        break;
      }
    }
  }
  return (tokens);
}
}
TCLIST *tcstrsplit2(void const   *ptr , int size ) 
{ TCLIST *list ;
  TCLIST *tmp ;
  char const   *rp ;
  char const   *ep ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___0 ;
  void *tmp___1 ;
  TCLISTDATUM *array ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  tmp = tclistnew();
  list = tmp;
  while (size >= 0) {
    rp = (char const   *)ptr;
    ep = (char const   *)ptr + size;
    while ((unsigned int )rp < (unsigned int )ep) {
      if ((int const   )*rp == 0) {
        break;
      }
      rp ++;
    }
    while (1) {
      TC_mysize = rp - (char const   *)ptr;
      TC_index = list->start + list->num;
      if (TC_index >= list->anum) {
        list->anum += list->num + 1;
        while (1) {
          tmp___1 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
          tmp___0 = (TCLISTDATUM *)tmp___1;
          list->array = tmp___0;
          if (! tmp___0) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array = list->array;
      while (1) {
        tmp___3 = malloc((unsigned int )(TC_mysize + 1));
        tmp___2 = (char *)tmp___3;
        (array + TC_index)->ptr = tmp___2;
        if (! tmp___2) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )ptr,
             (unsigned int )TC_mysize);
      *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
      (array + TC_index)->size = TC_mysize;
      (list->num) ++;
      break;
    }
    rp ++;
    size -= rp - (char const   *)ptr;
    ptr = (void const   *)rp;
  }
  return (list);
}
}
TCMAP *tcstrsplit3(char const   *str , char const   *delims ) 
{ TCMAP *map ;
  TCMAP *tmp ;
  char const   *kbuf ;
  int ksiz ;
  char const   *sp ;
  char *tmp___1 ;

  {
  tmp = tcmapnew2(31U);
  map = tmp;
  kbuf = (char const   *)((void *)0);
  ksiz = 0;
  while (1) {
    sp = str;
    while (1) {
      if ((int const   )*str != 0) {
        tmp___1 = __builtin_strchr((char *)delims, (int )*str);
        if (tmp___1) {
          break;
        }
      } else {
        break;
      }
      str ++;
    }
    if (kbuf) {
      tcmapput(map, (void const   *)kbuf, ksiz, (void const   *)sp, str - sp);
      kbuf = (char const   *)((void *)0);
    } else {
      kbuf = sp;
      ksiz = str - sp;
    }
    if ((int const   )*str == 0) {
      break;
    }
    str ++;
  }
  return (map);
}
}
TCMAP *tcstrsplit4(void const   *ptr , int size ) 
{ TCMAP *map ;
  long tmp ;
  TCMAP *tmp___0 ;
  char const   *kbuf ;
  int ksiz ;
  char const   *rp ;
  char const   *ep ;

  {
  tmp = tclmin((long )(size / 6 + 1), 4093L);
  tmp___0 = tcmapnew2((unsigned int )tmp);
  map = tmp___0;
  kbuf = (char const   *)((void *)0);
  ksiz = 0;
  while (size >= 0) {
    rp = (char const   *)ptr;
    ep = (char const   *)ptr + size;
    while ((unsigned int )rp < (unsigned int )ep) {
      if ((int const   )*rp == 0) {
        break;
      }
      rp ++;
    }
    if (kbuf) {
      tcmapput(map, (void const   *)kbuf, ksiz, ptr, rp - (char const   *)ptr);
      kbuf = (char const   *)((void *)0);
    } else {
      kbuf = (char const   *)ptr;
      ksiz = rp - (char const   *)ptr;
    }
    rp ++;
    size -= rp - (char const   *)ptr;
    ptr = (void const   *)rp;
  }
  return (map);
}
}
void *tcstrjoin2(TCLIST const   *list , int *sp ) 
{ int num ;
  int size ;
  int i ;
  char *buf ;
  void *tmp ;
  char *wp ;
  int i___0 ;
  char *tmp___0 ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___1 ;

  {
  num = (int )list->num;
  size = num + 1;
  i = 0;
  while (i < num) {
    size += (list->array + (i + (int )list->start))->size;
    i ++;
  }
  while (1) {
    tmp = malloc((unsigned int )size);
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  i___0 = 0;
  while (i___0 < num) {
    if (i___0 > 0) {
      tmp___0 = wp;
      wp ++;
      *tmp___0 = (char )'\000';
    }
    tmp___1 = tclistval(list, i___0, & vsiz);
    vbuf = (char const   *)tmp___1;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
    wp += vsiz;
    i___0 ++;
  }
  *wp = (char )'\000';
  *sp = wp - buf;
  return ((void *)buf);
}
}
char *tcstrjoin3(TCMAP const   *map , char delim ) 
{ int num ;
  int size ;
  TCMAPREC *cur ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  void const   *tmp ;
  char *buf ;
  void *tmp___0 ;
  char *wp ;
  _Bool first ;
  char *tmp___1 ;
  int vsiz___0 ;
  char const   *vbuf ;
  void const   *tmp___2 ;
  char *tmp___3 ;
  void const   *tmp___4 ;

  {
  num = (int )map->rnum;
  size = num * 2 + 1;
  cur = (TCMAPREC *)map->cur;
  tcmapiterinit((TCMAP *)map);
  while (1) {
    tmp = tcmapiternext((TCMAP *)map, & ksiz);
    kbuf = (char const   *)tmp;
    if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
      break;
    }
    tcmapiterval((void const   *)kbuf, & vsiz);
    size += ksiz + vsiz;
  }
  while (1) {
    tmp___0 = malloc((unsigned int )size);
    buf = (char *)tmp___0;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  tcmapiterinit((TCMAP *)map);
  first = (_Bool)1;
  while (1) {
    tmp___4 = tcmapiternext((TCMAP *)map, & ksiz);
    kbuf = (char const   *)tmp___4;
    if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
      break;
    }
    if (first) {
      first = (_Bool)0;
    } else {
      tmp___1 = wp;
      wp ++;
      *tmp___1 = delim;
    }
    memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    wp += ksiz;
    tmp___2 = tcmapiterval((void const   *)kbuf, & vsiz___0);
    vbuf = (char const   *)tmp___2;
    tmp___3 = wp;
    wp ++;
    *tmp___3 = delim;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz___0);
    wp += vsiz___0;
  }
  *wp = (char )'\000';
  ((TCMAP *)map)->cur = cur;
  return (buf);
}
}
void *tcstrjoin4(TCMAP const   *map , int *sp ) 
{ int num ;
  int size ;
  TCMAPREC *cur ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  void const   *tmp ;
  char *buf ;
  void *tmp___0 ;
  char *wp ;
  _Bool first ;
  char *tmp___1 ;
  int vsiz___0 ;
  char const   *vbuf ;
  void const   *tmp___2 ;
  char *tmp___3 ;
  void const   *tmp___4 ;

  {
  num = (int )map->rnum;
  size = num * 2 + 1;
  cur = (TCMAPREC *)map->cur;
  tcmapiterinit((TCMAP *)map);
  while (1) {
    tmp = tcmapiternext((TCMAP *)map, & ksiz);
    kbuf = (char const   *)tmp;
    if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
      break;
    }
    tcmapiterval((void const   *)kbuf, & vsiz);
    size += ksiz + vsiz;
  }
  while (1) {
    tmp___0 = malloc((unsigned int )size);
    buf = (char *)tmp___0;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  tcmapiterinit((TCMAP *)map);
  first = (_Bool)1;
  while (1) {
    tmp___4 = tcmapiternext((TCMAP *)map, & ksiz);
    kbuf = (char const   *)tmp___4;
    if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
      break;
    }
    if (first) {
      first = (_Bool)0;
    } else {
      tmp___1 = wp;
      wp ++;
      *tmp___1 = (char )'\000';
    }
    memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    wp += ksiz;
    tmp___2 = tcmapiterval((void const   *)kbuf, & vsiz___0);
    vbuf = (char const   *)tmp___2;
    tmp___3 = wp;
    wp ++;
    *tmp___3 = (char )'\000';
    memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz___0);
    wp += vsiz___0;
  }
  *wp = (char )'\000';
  *sp = wp - buf;
  ((TCMAP *)map)->cur = cur;
  return ((void *)buf);
}
}
void tctopsort(void *base , size_t nmemb , size_t size , size_t top , int (*compar)(void const   * ,
                                                                                    void const   * ) ) 
{ char *bp ;
  char *ep ;
  char *rp ;
  int num ;
  char *swap ;
  unsigned int __lengthofswap ;
  void *tmp ;
  int cidx ;
  int pidx ;
  int tmp___0 ;
  int pidx___0 ;
  int bot ;
  int cidx___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int pidx___1 ;
  int bot___0 ;
  int cidx___1 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  if (nmemb < 1U) {
    return;
  }
  if (top > nmemb) {
    top = nmemb;
  }
  bp = (char *)base;
  ep = bp + nmemb * size;
  rp = bp + size;
  num = 1;
  __lengthofswap = size;
  tmp = __builtin_alloca(sizeof(*swap) * __lengthofswap);
  swap = (char *)tmp;
  while ((unsigned int )rp < (unsigned int )ep) {
    if ((unsigned int )num < top) {
      cidx = num;
      while (cidx > 0) {
        pidx = (cidx - 1) / 2;
        tmp___0 = (*compar)((void const   *)(bp + (unsigned int )cidx * size), (void const   *)(bp + (unsigned int )pidx * size));
        if (tmp___0 <= 0) {
          break;
        }
        memcpy((void * __restrict  )swap, (void const   * __restrict  )(bp + (unsigned int )cidx * size),
               size);
        memcpy((void * __restrict  )(bp + (unsigned int )cidx * size), (void const   * __restrict  )(bp + (unsigned int )pidx * size),
               size);
        memcpy((void * __restrict  )(bp + (unsigned int )pidx * size), (void const   * __restrict  )swap,
               size);
        cidx = pidx;
      }
      num ++;
    } else {
      tmp___3 = (*compar)((void const   *)rp, (void const   *)bp);
      if (tmp___3 < 0) {
        memcpy((void * __restrict  )swap, (void const   * __restrict  )bp, size);
        memcpy((void * __restrict  )bp, (void const   * __restrict  )rp, size);
        memcpy((void * __restrict  )rp, (void const   * __restrict  )swap, size);
        pidx___0 = 0;
        bot = num / 2;
        while (pidx___0 < bot) {
          cidx___0 = pidx___0 * 2 + 1;
          if (cidx___0 < num - 1) {
            tmp___1 = (*compar)((void const   *)(bp + (unsigned int )cidx___0 * size),
                                (void const   *)(bp + (unsigned int )(cidx___0 + 1) * size));
            if (tmp___1 < 0) {
              cidx___0 ++;
            }
          }
          tmp___2 = (*compar)((void const   *)(bp + (unsigned int )pidx___0 * size),
                              (void const   *)(bp + (unsigned int )cidx___0 * size));
          if (tmp___2 > 0) {
            break;
          }
          memcpy((void * __restrict  )swap, (void const   * __restrict  )(bp + (unsigned int )pidx___0 * size),
                 size);
          memcpy((void * __restrict  )(bp + (unsigned int )pidx___0 * size), (void const   * __restrict  )(bp + (unsigned int )cidx___0 * size),
                 size);
          memcpy((void * __restrict  )(bp + (unsigned int )cidx___0 * size), (void const   * __restrict  )swap,
                 size);
          pidx___0 = cidx___0;
        }
      }
    }
    rp += size;
  }
  num = (int )(top - 1U);
  while (num > 0) {
    memcpy((void * __restrict  )swap, (void const   * __restrict  )bp, size);
    memcpy((void * __restrict  )bp, (void const   * __restrict  )(bp + (unsigned int )num * size),
           size);
    memcpy((void * __restrict  )(bp + (unsigned int )num * size), (void const   * __restrict  )swap,
           size);
    pidx___1 = 0;
    bot___0 = num / 2;
    while (pidx___1 < bot___0) {
      cidx___1 = pidx___1 * 2 + 1;
      if (cidx___1 < num - 1) {
        tmp___4 = (*compar)((void const   *)(bp + (unsigned int )cidx___1 * size),
                            (void const   *)(bp + (unsigned int )(cidx___1 + 1) * size));
        if (tmp___4 < 0) {
          cidx___1 ++;
        }
      }
      tmp___5 = (*compar)((void const   *)(bp + (unsigned int )pidx___1 * size), (void const   *)(bp + (unsigned int )cidx___1 * size));
      if (tmp___5 > 0) {
        break;
      }
      memcpy((void * __restrict  )swap, (void const   * __restrict  )(bp + (unsigned int )pidx___1 * size),
             size);
      memcpy((void * __restrict  )(bp + (unsigned int )pidx___1 * size), (void const   * __restrict  )(bp + (unsigned int )cidx___1 * size),
             size);
      memcpy((void * __restrict  )(bp + (unsigned int )cidx___1 * size), (void const   * __restrict  )swap,
             size);
      pidx___1 = cidx___1;
    }
    num --;
  }
  return;
}
}
_Bool tcsleep(double sec ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  double integ ;
  double fract ;
  struct timespec req ;
  struct timespec rem ;
  int *tmp___6 ;
  int tmp___7 ;

  {
  if ((int )sizeof(sec) == (int )sizeof(float )) {
    tmp = __fpclassifyf((float )sec);
    tmp___3 = tmp;
  } else {
    if ((int )sizeof(sec) == (int )sizeof(double )) {
      tmp___0 = __fpclassify(sec);
      tmp___2 = tmp___0;
    } else {
      tmp___1 = __fpclassifyl((long double )sec);
      tmp___2 = tmp___1;
    }
    tmp___3 = tmp___2;
  }
  if (tmp___3 == 4) {
    if (sec <= 0.0) {
      return ((_Bool)0);
    }
  } else {
    return ((_Bool)0);
  }
  tmp___5 = sysconf(2);
  if (sec <= 1.0 / (double )tmp___5) {
    tmp___4 = sched_yield();
    return ((_Bool )(tmp___4 == 0));
  }
  fract = modf(sec, & integ);
  req.tv_sec = (long )integ;
  req.tv_nsec = tclmin((long )(((fract * 1000.0) * 1000.0) * 1000.0), 999999999L);
  while (1) {
    tmp___7 = nanosleep((struct timespec  const  *)(& req), & rem);
    if (! (tmp___7 != 0)) {
      break;
    }
    tmp___6 = __errno_location();
    if (*tmp___6 != 4) {
      return ((_Bool)0);
    }
    req = rem;
  }
  return ((_Bool)1);
}
}
TCMAP *tcsysinfo(void) 
{ TCMAP *info ;
  TCMAP *tmp ;
  char path[1024] ;
  __pid_t tmp___0 ;
  TCLIST *lines ;
  TCLIST *tmp___1 ;
  int ln ;
  int tmp___2 ;
  char numbuf[32] ;
  int i ;
  char const   *line ;
  char const   *rp ;
  char *tmp___4 ;
  int64_t size ;
  int64_t tmp___5 ;
  int64_t size___0 ;
  int64_t tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  int ln___0 ;
  int tmp___9 ;
  char numbuf___0[32] ;
  int i___0 ;
  char const   *line___0 ;
  char const   *rp___0 ;
  char *tmp___11 ;
  int64_t size___1 ;
  int64_t tmp___12 ;
  int64_t size___2 ;
  int64_t tmp___13 ;
  int64_t size___3 ;
  int64_t tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;

  {
  tmp = tcmapnew2(31U);
  info = tmp;
  tmp___0 = getpid();
  sprintf((char * __restrict  )(path), (char const   * __restrict  )"/proc/%d/status",
          tmp___0);
  tmp___1 = tcreadfilelines((char const   *)(path));
  lines = tmp___1;
  if (lines) {
    tmp___2 = tclistnum((TCLIST const   *)lines);
    ln = tmp___2;
    i = 0;
    while (i < ln) {
      line = (char const   *)((void *)(lines->array + (i + lines->start))->ptr);
      tmp___4 = __builtin_strchr((char *)line, ':');
      rp = (char const   *)tmp___4;
      if (! rp) {
        goto __Cont;
      }
      rp ++;
      while (1) {
        if ((int const   )*rp > 0) {
          if (! ((int const   )*rp <= 32)) {
            break;
          }
        } else {
          break;
        }
        rp ++;
      }
      tmp___8 = tcstrifwm(line, "VmSize:");
      if (tmp___8) {
        tmp___5 = tcatoix(rp);
        size = tmp___5;
        sprintf((char * __restrict  )(numbuf), (char const   * __restrict  )"%lld",
                size);
        tcmapput2(info, "size", (char const   *)(numbuf));
      } else {
        tmp___7 = tcstrifwm(line, "VmRSS:");
        if (tmp___7) {
          tmp___6 = tcatoix(rp);
          size___0 = tmp___6;
          sprintf((char * __restrict  )(numbuf), (char const   * __restrict  )"%lld",
                  size___0);
          tcmapput2(info, "rss", (char const   *)(numbuf));
        }
      }
      __Cont: 
      i ++;
    }
    tclistdel(lines);
  }
  sprintf((char * __restrict  )(path), (char const   * __restrict  )"/proc/meminfo");
  lines = tcreadfilelines((char const   *)(path));
  if (lines) {
    tmp___9 = tclistnum((TCLIST const   *)lines);
    ln___0 = tmp___9;
    i___0 = 0;
    while (i___0 < ln___0) {
      line___0 = (char const   *)((void *)(lines->array + (i___0 + lines->start))->ptr);
      tmp___11 = __builtin_strchr((char *)line___0, ':');
      rp___0 = (char const   *)tmp___11;
      if (! rp___0) {
        goto __Cont___0;
      }
      rp___0 ++;
      while (1) {
        if ((int const   )*rp___0 > 0) {
          if (! ((int const   )*rp___0 <= 32)) {
            break;
          }
        } else {
          break;
        }
        rp___0 ++;
      }
      tmp___17 = tcstrifwm(line___0, "MemTotal:");
      if (tmp___17) {
        tmp___12 = tcatoix(rp___0);
        size___1 = tmp___12;
        sprintf((char * __restrict  )(numbuf___0), (char const   * __restrict  )"%lld",
                size___1);
        tcmapput2(info, "total", (char const   *)(numbuf___0));
      } else {
        tmp___16 = tcstrifwm(line___0, "MemFree:");
        if (tmp___16) {
          tmp___13 = tcatoix(rp___0);
          size___2 = tmp___13;
          sprintf((char * __restrict  )(numbuf___0), (char const   * __restrict  )"%lld",
                  size___2);
          tcmapput2(info, "free", (char const   *)(numbuf___0));
        } else {
          tmp___15 = tcstrifwm(line___0, "Cached:");
          if (tmp___15) {
            tmp___14 = tcatoix(rp___0);
            size___3 = tmp___14;
            sprintf((char * __restrict  )(numbuf___0), (char const   * __restrict  )"%lld",
                    size___3);
            tcmapput2(info, "cached", (char const   *)(numbuf___0));
          }
        }
      }
      __Cont___0: 
      i___0 ++;
    }
    tclistdel(lines);
  }
  return (info);
}
}
TCCHIDX *tcchidxnew(int range ) 
{ TCCHIDX *chidx ;
  void *tmp ;
  int nnum ;
  TCCHIDXNODE *nodes ;
  void *tmp___0 ;
  unsigned int seed___0 ;
  int i ;
  int end ;
  int j ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*chidx)));
    chidx = (TCCHIDX *)tmp;
    if (! chidx) {
      tcmyfatal("out of memory");
    }
    break;
  }
  nnum = range * 128;
  while (1) {
    tmp___0 = malloc((unsigned int )(nnum * (int )sizeof(*nodes)));
    nodes = (TCCHIDXNODE *)tmp___0;
    if (! nodes) {
      tcmyfatal("out of memory");
    }
    break;
  }
  seed___0 = 725U;
  i = 0;
  while (i < range) {
    end = (i + 1) * 128;
    j = i * 128;
    while (j < end) {
      (nodes + j)->seq = (unsigned int )i;
      seed___0 = seed___0 * 123456761U + 211U;
      (nodes + j)->hash = seed___0;
      j ++;
    }
    i ++;
  }
  qsort((void *)nodes, (unsigned int )nnum, (unsigned int )((int )sizeof(*nodes)),
        & tcchidxcmp);
  chidx->nodes = nodes;
  chidx->nnum = nnum;
  return (chidx);
}
}
void tcchidxdel(TCCHIDX *chidx ) 
{ 

  {
  while (1) {
    free((void *)chidx->nodes);
    break;
  }
  while (1) {
    free((void *)chidx);
    break;
  }
  return;
}
}
int tcchidxhash(TCCHIDX *chidx , void const   *ptr , int size ) 
{ uint32_t hash ;
  char const   *rp ;
  int tmp ;
  TCCHIDXNODE *nodes ;
  int low ;
  int high ;
  int mid ;
  uint32_t nhash ;

  {
  hash = 19771007U;
  rp = (char const   *)((char *)ptr + size);
  while (1) {
    tmp = size;
    size --;
    if (! tmp) {
      break;
    }
    rp --;
    hash = hash * 31U ^ (unsigned int )*((uint8_t *)rp);
    hash ^= hash << 7;
  }
  nodes = chidx->nodes;
  low = 0;
  high = chidx->nnum;
  while (low < high) {
    mid = (low + high) >> 1;
    nhash = (nodes + mid)->hash;
    if (hash < nhash) {
      high = mid;
    } else {
      if (hash > nhash) {
        low = mid + 1;
      } else {
        low = mid;
        break;
      }
    }
  }
  if (low >= chidx->nnum) {
    low = 0;
  }
  return ((int )((nodes + low)->seq & 2147483647U));
}
}
static int tcstrutfkwicputtext(uint16_t const   *oary , uint16_t const   *nary , int si ,
                               int ti , int end , char *buf , TCLIST const   *uwords ,
                               int opts ) 
{ int tmp ;
  int tmp___0 ;
  int wnum ;
  int ri ;
  int wi ;
  int step ;
  int i ;
  char const   *val ;
  int uwnum ;
  uint16_t *uwary ;
  int ci ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  if (! (opts & 16777216)) {
    tmp = tcstrucstoutf(oary + si, ti - si, buf);
    return (tmp);
  }
  if (! (opts & 1)) {
    if (! (opts & 2)) {
      if (! (opts & 4)) {
        tmp___0 = tcstrucstoutf(oary + si, ti - si, buf);
        return (tmp___0);
      }
    }
  }
  wnum = (int )uwords->num;
  ri = si;
  wi = 0;
  while (ri < ti) {
    step = 0;
    i = 0;
    while (i < wnum) {
      while (1) {
        val = (char const   *)(uwords->array + (i + (int )uwords->start))->ptr;
        uwnum = (uwords->array + (i + (int )uwords->start))->size;
        break;
      }
      uwary = (uint16_t *)val;
      uwnum /= (int )sizeof(*uwary);
      if (ri + uwnum <= end) {
        ci = 0;
        while (1) {
          if (ci < uwnum) {
            if (! ((int const   )*(nary + (ri + ci)) == (int const   )*(uwary + ci))) {
              break;
            }
          } else {
            break;
          }
          ci ++;
        }
        if (ci == uwnum) {
          if (opts & 1) {
            tmp___1 = wi;
            wi ++;
            *(buf + tmp___1) = (char )'\t';
          } else {
            if (opts & 2) {
              tmp___2 = wi;
              wi ++;
              *(buf + tmp___2) = (char)2;
            } else {
              if (opts & 4) {
                tmp___3 = wi;
                wi ++;
                *(buf + tmp___3) = (char )'[';
              }
            }
          }
          tmp___4 = tcstrucstoutf(oary + ri, ci, buf + wi);
          wi += tmp___4;
          if (opts & 1) {
            tmp___5 = wi;
            wi ++;
            *(buf + tmp___5) = (char )'\t';
          } else {
            if (opts & 2) {
              tmp___6 = wi;
              wi ++;
              *(buf + tmp___6) = (char)3;
            } else {
              if (opts & 4) {
                tmp___7 = wi;
                wi ++;
                *(buf + tmp___7) = (char )']';
              }
            }
          }
          step = ri + ci;
          break;
        }
      }
      i ++;
    }
    if (step > 0) {
      ri = step;
    } else {
      tmp___8 = tcstrucstoutf(oary + ri, 1, buf + wi);
      wi += tmp___8;
      ri ++;
    }
  }
  return (wi);
}
}
static int tcchidxcmp(void const   *a , void const   *b ) 
{ 

  {
  if (((TCCHIDXNODE *)a)->hash == ((TCCHIDXNODE *)b)->hash) {
    return (0);
  }
  return (((TCCHIDXNODE *)a)->hash > ((TCCHIDXNODE *)b)->hash);
}
}
char *tcrealpath(char const   *path ) 
{ char buf[4097] ;
  char *tmp ;
  char *tmp___0 ;
  char const   *pv ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *prefix ;
  void *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *str ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int *tmp___9 ;

  {
  tmp___0 = realpath((char const   * __restrict  )path, (char * __restrict  )(buf));
  if (tmp___0) {
    tmp = tcstrdup((void const   *)(buf));
    return (tmp);
  }
  tmp___9 = __errno_location();
  if (*tmp___9 == 2) {
    tmp___1 = strrchr(path, '/');
    pv = (char const   *)tmp___1;
    if (pv) {
      if ((unsigned int )pv == (unsigned int )path) {
        tmp___2 = tcstrdup((void const   *)path);
        return (tmp___2);
      }
      tmp___3 = tcmemdup((void const   *)path, (unsigned int )(pv - path));
      prefix = (char *)tmp___3;
      tmp___4 = realpath((char const   * __restrict  )prefix, (char * __restrict  )(buf));
      if (! tmp___4) {
        while (1) {
          free((void *)prefix);
          break;
        }
        return ((char *)((void *)0));
      }
      while (1) {
        free((void *)prefix);
        break;
      }
      pv ++;
    } else {
      tmp___5 = realpath((char const   * __restrict  )".", (char * __restrict  )(buf));
      if (! tmp___5) {
        return ((char *)((void *)0));
      }
      pv = path;
    }
    if ((int )buf[0] == 47) {
      if ((int )buf[1] == 0) {
        buf[0] = (char )'\000';
      }
    }
    while (1) {
      tmp___6 = strlen((char const   *)(buf));
      tmp___7 = strlen(pv);
      tmp___8 = malloc((tmp___6 + tmp___7) + 2U);
      str = (char *)tmp___8;
      if (! str) {
        tcmyfatal("out of memory");
      }
      break;
    }
    sprintf((char * __restrict  )str, (char const   * __restrict  )"%s%c%s", buf,
            '/', pv);
    return (str);
  }
  return ((char *)((void *)0));
}
}
_Bool tcstatfile(char const   *path , _Bool *isdirp , int64_t *sizep , int64_t *mtimep ) 
{ struct stat sbuf ;
  int tmp ;

  {
  tmp = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
  if (tmp != 0) {
    return ((_Bool)0);
  }
  if (isdirp) {
    *isdirp = (_Bool )((sbuf.st_mode & 61440U) == 16384U);
  }
  if (sizep) {
    *sizep = (long long )sbuf.st_size;
  }
  if (mtimep) {
    *mtimep = (long long )sbuf.st_mtim.tv_sec;
  }
  return ((_Bool)1);
}
}
void *tcreadfile(char const   *path , int limit , int *sp ) 
{ int fd ;
  int tmp ;
  int tmp___0 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___1 ;
  char buf[16384] ;
  int rsiz ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  struct stat sbuf ;
  int tmp___6 ;
  long tmp___7 ;
  char *buf___0 ;
  void *tmp___8 ;
  char *wp ;
  int rsiz___0 ;

  {
  if (path) {
    tmp = open(path, 0, 420);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  fd = tmp___0;
  if (fd == -1) {
    return ((void *)0);
  }
  if (fd == 0) {
    tmp___1 = tcxstrnew();
    xstr = tmp___1;
    if (limit > 0) {
      limit = limit;
    } else {
      limit = 2147483647;
    }
    while (1) {
      tmp___4 = tclmin(16384L, (long )limit);
      rsiz = read(fd, (void *)(buf), (unsigned int )tmp___4);
      if (! (rsiz > 0)) {
        break;
      }
      while (1) {
        TC_mysize = rsiz;
        TC_nsize = (xstr->size + TC_mysize) + 1;
        if (xstr->asize < TC_nsize) {
          while (xstr->asize < TC_nsize) {
            xstr->asize *= 2;
            if (xstr->asize < TC_nsize) {
              xstr->asize = TC_nsize;
            }
          }
          while (1) {
            tmp___3 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
            tmp___2 = (char *)tmp___3;
            xstr->ptr = tmp___2;
            if (! tmp___2) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )(buf),
               (unsigned int )TC_mysize);
        xstr->size += TC_mysize;
        *(xstr->ptr + xstr->size) = (char )'\000';
        break;
      }
      limit -= rsiz;
    }
    if (sp) {
      *sp = xstr->size;
    }
    tmp___5 = tcxstrtomalloc(xstr);
    return (tmp___5);
  }
  tmp___6 = fstat(fd, & sbuf);
  if (tmp___6 == -1) {
    close(fd);
    return ((void *)0);
  } else {
    if (! ((sbuf.st_mode & 61440U) == 32768U)) {
      close(fd);
      return ((void *)0);
    }
  }
  if (limit > 0) {
    tmp___7 = tclmin((long )((int )sbuf.st_size), (long )limit);
    limit = (int )tmp___7;
  } else {
    limit = (int )sbuf.st_size;
  }
  while (1) {
    tmp___8 = malloc((unsigned int )(sbuf.st_size + 1L));
    buf___0 = (char *)tmp___8;
    if (! buf___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf___0;
  while (1) {
    rsiz___0 = read(fd, (void *)wp, (unsigned int )(limit - (wp - buf___0)));
    if (! (rsiz___0 > 0)) {
      break;
    }
    wp += rsiz___0;
  }
  *wp = (char )'\000';
  close(fd);
  if (sp) {
    *sp = wp - buf___0;
  }
  return ((void *)buf___0);
}
}
TCLIST *tcreadfilelines(char const   *path ) 
{ int fd ;
  int tmp ;
  int tmp___0 ;
  TCLIST *list ;
  TCLIST *tmp___1 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___2 ;
  char buf[16384] ;
  int rsiz ;
  int i ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___3 ;
  void *tmp___4 ;
  TCLISTDATUM *array ;
  char *tmp___5 ;
  void *tmp___6 ;
  int TC_mysize___0 ;
  int TC_nsize ;
  char *tmp___7 ;
  void *tmp___8 ;
  int TC_mysize___1 ;
  int TC_index___0 ;
  TCLISTDATUM *tmp___9 ;
  void *tmp___10 ;
  TCLISTDATUM *array___0 ;
  char *tmp___11 ;
  void *tmp___12 ;

  {
  if (path) {
    tmp = open(path, 0, 420);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0;
  }
  fd = tmp___0;
  if (fd == -1) {
    return ((TCLIST *)((void *)0));
  }
  tmp___1 = tclistnew();
  list = tmp___1;
  tmp___2 = tcxstrnew();
  xstr = tmp___2;
  while (1) {
    rsiz = read(fd, (void *)(buf), 16384U);
    if (! (rsiz > 0)) {
      break;
    }
    i = 0;
    while (i < rsiz) {
      switch ((int )buf[i]) {
      case 13: 
      break;
      case 10: 
      while (1) {
        TC_mysize = xstr->size;
        TC_index = list->start + list->num;
        if (TC_index >= list->anum) {
          list->anum += list->num + 1;
          while (1) {
            tmp___4 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
            tmp___3 = (TCLISTDATUM *)tmp___4;
            list->array = tmp___3;
            if (! tmp___3) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        array = list->array;
        while (1) {
          tmp___6 = malloc((unsigned int )(TC_mysize + 1));
          tmp___5 = (char *)tmp___6;
          (array + TC_index)->ptr = tmp___5;
          if (! tmp___5) {
            tcmyfatal("out of memory");
          }
          break;
        }
        memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )xstr->ptr,
               (unsigned int )TC_mysize);
        *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
        (array + TC_index)->size = TC_mysize;
        (list->num) ++;
        break;
      }
      tcxstrclear(xstr);
      break;
      default: ;
      while (1) {
        TC_mysize___0 = 1;
        TC_nsize = (xstr->size + TC_mysize___0) + 1;
        if (xstr->asize < TC_nsize) {
          while (xstr->asize < TC_nsize) {
            xstr->asize *= 2;
            if (xstr->asize < TC_nsize) {
              xstr->asize = TC_nsize;
            }
          }
          while (1) {
            tmp___8 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
            tmp___7 = (char *)tmp___8;
            xstr->ptr = tmp___7;
            if (! tmp___7) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )(buf + i),
               (unsigned int )TC_mysize___0);
        xstr->size += TC_mysize___0;
        *(xstr->ptr + xstr->size) = (char )'\000';
        break;
      }
      break;
      }
      i ++;
    }
  }
  while (1) {
    TC_mysize___1 = xstr->size;
    TC_index___0 = list->start + list->num;
    if (TC_index___0 >= list->anum) {
      list->anum += list->num + 1;
      while (1) {
        tmp___10 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
        tmp___9 = (TCLISTDATUM *)tmp___10;
        list->array = tmp___9;
        if (! tmp___9) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    array___0 = list->array;
    while (1) {
      tmp___12 = malloc((unsigned int )(TC_mysize___1 + 1));
      tmp___11 = (char *)tmp___12;
      (array___0 + TC_index___0)->ptr = tmp___11;
      if (! tmp___11) {
        tcmyfatal("out of memory");
      }
      break;
    }
    memcpy((void * __restrict  )(array___0 + TC_index___0)->ptr, (void const   * __restrict  )xstr->ptr,
           (unsigned int )TC_mysize___1);
    *((array___0 + TC_index___0)->ptr + TC_mysize___1) = (char )'\000';
    (array___0 + TC_index___0)->size = TC_mysize___1;
    (list->num) ++;
    break;
  }
  tcxstrdel(xstr);
  if (path) {
    close(fd);
  }
  return (list);
}
}
_Bool tcwritefile(char const   *path , void const   *ptr , int size ) 
{ int fd ;
  _Bool err ;
  _Bool tmp ;
  int tmp___0 ;

  {
  fd = 1;
  if (path) {
    fd = open(path, 577, 420);
    if (fd == -1) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  tmp = tcwrite(fd, ptr, (unsigned int )size);
  if (! tmp) {
    err = (_Bool)1;
  }
  tmp___0 = close(fd);
  if (tmp___0 == -1) {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
_Bool tccopyfile(char const   *src , char const   *dest ) 
{ int ifd ;
  int tmp ;
  int ofd ;
  int tmp___0 ;
  _Bool err ;
  char buf[16384] ;
  int size ;
  ssize_t tmp___1 ;
  _Bool tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  tmp = open(src, 0, 420);
  ifd = tmp;
  if (ifd == -1) {
    return ((_Bool)0);
  }
  tmp___0 = open(dest, 577, 420);
  ofd = tmp___0;
  if (ofd == -1) {
    close(ifd);
    return ((_Bool)0);
  }
  err = (_Bool)0;
  while (1) {
    tmp___1 = read(ifd, (void *)(buf), 16384U);
    size = tmp___1;
    if (size > 0) {
      tmp___2 = tcwrite(ofd, (void const   *)(buf), (unsigned int )size);
      if (! tmp___2) {
        err = (_Bool)1;
        break;
      }
    } else {
      if (size == -1) {
        tmp___3 = __errno_location();
        if (*tmp___3 != 4) {
          err = (_Bool)1;
          break;
        }
      } else {
        break;
      }
    }
  }
  tmp___4 = close(ofd);
  if (tmp___4 == -1) {
    err = (_Bool)1;
  }
  tmp___5 = close(ifd);
  if (tmp___5 == -1) {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
TCLIST *tcreaddir(char const   *path ) 
{ DIR *DD ;
  struct dirent *dp ;
  TCLIST *list ;
  TCLIST *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int TC_mysize ;
  size_t tmp___14 ;
  int TC_index ;
  TCLISTDATUM *tmp___15 ;
  void *tmp___16 ;
  TCLISTDATUM *array ;
  char *tmp___17 ;
  void *tmp___18 ;

  {
  DD = opendir(path);
  if (! DD) {
    return ((TCLIST *)((void *)0));
  }
  tmp = tclistnew();
  list = tmp;
  while (1) {
    dp = readdir(DD);
    if (! ((unsigned int )dp != (unsigned int )((void *)0))) {
      break;
    }
    if (0) {
      __s1_len = strlen((char const   *)(dp->d_name));
      __s2_len = strlen(".");
      if (! ((unsigned int )((void const   *)(dp->d_name + 1)) - (unsigned int )((void const   *)(dp->d_name)) == 1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
            tmp___6 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___6 = 1;
            } else {
              tmp___6 = 0;
            }
          }
        } else {
          tmp___6 = 0;
        }
      }
      if (tmp___6) {
        tmp___1 = __builtin_strcmp((char const   *)(dp->d_name), ".");
        tmp___5 = tmp___1;
      } else {
        tmp___4 = __builtin_strcmp((char const   *)(dp->d_name), ".");
        tmp___5 = tmp___4;
      }
    } else {
      tmp___4 = __builtin_strcmp((char const   *)(dp->d_name), ".");
      tmp___5 = tmp___4;
    }
    if (tmp___5) {
      if (0) {
        __s1_len___0 = strlen((char const   *)(dp->d_name));
        __s2_len___0 = strlen("..");
        if (! ((unsigned int )((void const   *)(dp->d_name + 1)) - (unsigned int )((void const   *)(dp->d_name)) == 1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
              tmp___13 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___13 = 1;
              } else {
                tmp___13 = 0;
              }
            }
          } else {
            tmp___13 = 0;
          }
        }
        if (tmp___13) {
          tmp___8 = __builtin_strcmp((char const   *)(dp->d_name), "..");
          tmp___12 = tmp___8;
        } else {
          tmp___11 = __builtin_strcmp((char const   *)(dp->d_name), "..");
          tmp___12 = tmp___11;
        }
      } else {
        tmp___11 = __builtin_strcmp((char const   *)(dp->d_name), "..");
        tmp___12 = tmp___11;
      }
      if (! tmp___12) {
        continue;
      }
    } else {
      continue;
    }
    while (1) {
      tmp___14 = strlen((char const   *)(dp->d_name));
      TC_mysize = (int )tmp___14;
      TC_index = list->start + list->num;
      if (TC_index >= list->anum) {
        list->anum += list->num + 1;
        while (1) {
          tmp___16 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
          tmp___15 = (TCLISTDATUM *)tmp___16;
          list->array = tmp___15;
          if (! tmp___15) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array = list->array;
      while (1) {
        tmp___18 = malloc((unsigned int )(TC_mysize + 1));
        tmp___17 = (char *)tmp___18;
        (array + TC_index)->ptr = tmp___17;
        if (! tmp___17) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )(dp->d_name),
             (unsigned int )TC_mysize);
      *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
      (array + TC_index)->size = TC_mysize;
      (list->num) ++;
      break;
    }
  }
  closedir(DD);
  return (list);
}
}
TCLIST *tcglobpat(char const   *pattern ) 
{ TCLIST *list ;
  TCLIST *tmp ;
  glob_t gbuf ;
  int i ;
  int tmp___0 ;

  {
  tmp = tclistnew();
  list = tmp;
  memset((void *)(& gbuf), 0, (unsigned int )((int )sizeof(gbuf)));
  tmp___0 = glob((char const   * __restrict  )pattern, 1 | (1 << 2), (int (*)(char const   * ,
                                                                              int  ))((void *)0),
                 (glob_t * __restrict  )(& gbuf));
  if (tmp___0 == 0) {
    i = 0;
    while ((unsigned int )i < gbuf.gl_pathc) {
      tclistpush2(list, (char const   *)*(gbuf.gl_pathv + i));
      i ++;
    }
    globfree(& gbuf);
  }
  return (list);
}
}
_Bool tcremovelink(char const   *path ) 
{ struct stat sbuf ;
  int tmp ;
  int tmp___0 ;
  TCLIST *list ;
  _Bool tail ;
  size_t tmp___1 ;
  int tmp___2 ;
  int i ;
  char const   *elem ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *cpath ;
  int tmp___18 ;
  int tmp___19 ;

  {
  tmp = lstat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
  if (tmp == -1) {
    return ((_Bool)0);
  }
  tmp___0 = unlink(path);
  if (tmp___0 == 0) {
    return ((_Bool)1);
  }
  if (! ((sbuf.st_mode & 61440U) == 16384U)) {
    return ((_Bool)0);
  } else {
    list = tcreaddir(path);
    if (! list) {
      return ((_Bool)0);
    }
  }
  if ((int const   )*(path + 0) != 0) {
    tmp___1 = strlen(path);
    if ((int const   )*(path + (tmp___1 - 1U)) == 47) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  tail = (_Bool )tmp___2;
  i = 0;
  while (i < list->num) {
    elem = (char const   *)((void *)(list->array + (i + list->start))->ptr);
    if (0) {
      __s1_len = strlen(".");
      __s2_len = strlen(elem);
      if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)(elem + 1)) - (unsigned int )((void const   *)elem) == 1U)) {
            tmp___9 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___9 = 1;
            } else {
              tmp___9 = 0;
            }
          }
        } else {
          tmp___9 = 0;
        }
      }
      if (tmp___9) {
        tmp___4 = __builtin_strcmp(".", elem);
        tmp___8 = tmp___4;
      } else {
        tmp___7 = __builtin_strcmp(".", elem);
        tmp___8 = tmp___7;
      }
    } else {
      tmp___7 = __builtin_strcmp(".", elem);
      tmp___8 = tmp___7;
    }
    if (tmp___8) {
      if (0) {
        __s1_len___0 = strlen("..");
        __s2_len___0 = strlen(elem);
        if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)(elem + 1)) - (unsigned int )((void const   *)elem) == 1U)) {
              tmp___16 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___16 = 1;
              } else {
                tmp___16 = 0;
              }
            }
          } else {
            tmp___16 = 0;
          }
        }
        if (tmp___16) {
          tmp___11 = __builtin_strcmp("..", elem);
          tmp___15 = tmp___11;
        } else {
          tmp___14 = __builtin_strcmp("..", elem);
          tmp___15 = tmp___14;
        }
      } else {
        tmp___14 = __builtin_strcmp("..", elem);
        tmp___15 = tmp___14;
      }
      if (! tmp___15) {
        goto __Cont;
      }
    } else {
      goto __Cont;
    }
    if (tail) {
      cpath = tcsprintf("%s%s", path, elem);
    } else {
      cpath = tcsprintf("%s%c%s", path, '/', elem);
    }
    tcremovelink((char const   *)cpath);
    while (1) {
      free((void *)cpath);
      break;
    }
    __Cont: 
    i ++;
  }
  tclistdel(list);
  tmp___19 = rmdir(path);
  if (tmp___19 == 0) {
    tmp___18 = 1;
  } else {
    tmp___18 = 0;
  }
  return ((_Bool )tmp___18);
}
}
_Bool tcwrite(int fd , void const   *buf , size_t size ) 
{ char const   *rp ;
  int wb ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  rp = (char const   *)buf;
  while (1) {
    tmp = write(fd, (void const   *)rp, size);
    wb = tmp;
    switch (wb) {
    case -1: 
    tmp___0 = __errno_location();
    if (*tmp___0 != 4) {
      return ((_Bool)0);
    }
    case 0: 
    break;
    default: 
    rp += wb;
    size -= (unsigned int )wb;
    break;
    }
    if (! (size > 0U)) {
      break;
    }
  }
  return ((_Bool)1);
}
}
_Bool tcread(int fd , void *buf , size_t size ) 
{ char *wp ;
  int rb ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  wp = (char *)buf;
  while (1) {
    tmp = read(fd, (void *)wp, size);
    rb = tmp;
    switch (rb) {
    case -1: 
    tmp___0 = __errno_location();
    if (*tmp___0 != 4) {
      return ((_Bool)0);
    }
    case 0: 
    return ((_Bool )(size < 1U));
    default: 
    wp += rb;
    size -= (unsigned int )rb;
    }
    if (! (size > 0U)) {
      break;
    }
  }
  return ((_Bool)1);
}
}
_Bool tclock(int fd , _Bool ex , _Bool nb ) 
{ struct flock lock ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  memset((void *)(& lock), 0, (unsigned int )((int )sizeof(struct flock )));
  if (ex) {
    lock.l_type = (short)1;
  } else {
    lock.l_type = (short)0;
  }
  lock.l_whence = (short)0;
  lock.l_start = 0L;
  lock.l_len = 0L;
  lock.l_pid = 0;
  while (1) {
    if (nb) {
      tmp___0 = 6;
    } else {
      tmp___0 = 7;
    }
    tmp___1 = fcntl(fd, tmp___0, & lock);
    if (! (tmp___1 == -1)) {
      break;
    }
    tmp = __errno_location();
    if (*tmp != 4) {
      return ((_Bool)0);
    }
  }
  return ((_Bool)1);
}
}
_Bool tcunlock(int fd ) 
{ struct flock lock ;
  int *tmp ;
  int tmp___0 ;

  {
  memset((void *)(& lock), 0, (unsigned int )((int )sizeof(struct flock )));
  lock.l_type = (short)2;
  lock.l_whence = (short)0;
  lock.l_start = 0L;
  lock.l_len = 0L;
  lock.l_pid = 0;
  while (1) {
    tmp___0 = fcntl(fd, 7, & lock);
    if (! (tmp___0 == -1)) {
      break;
    }
    tmp = __errno_location();
    if (*tmp != 4) {
      return ((_Bool)0);
    }
  }
  return ((_Bool)1);
}
}
int tcsystem(char const   **args , int anum ) 
{ TCXSTR *phrase ;
  TCXSTR *tmp ;
  int i ;
  char const   *rp ;
  int len ;
  size_t tmp___0 ;
  char *token ;
  void *tmp___1 ;
  char *wp ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int rv ;
  void const   *tmp___6 ;
  int tmp___7 ;
  union __anonunion___u_98 __u ;
  union __anonunion___u_99 __u___0 ;

  {
  if (anum < 1) {
    return (-1);
  }
  tmp = tcxstrnew3(anum * 32 + 1);
  phrase = tmp;
  i = 0;
  while (i < anum) {
    rp = *(args + i);
    tmp___0 = strlen(rp);
    len = (int )tmp___0;
    while (1) {
      tmp___1 = malloc((unsigned int )(len * 2 + 1));
      token = (char *)tmp___1;
      if (! token) {
        tcmyfatal("out of memory");
      }
      break;
    }
    wp = token;
    while ((int const   )*rp != 0) {
      switch ((int )*rp) {
      case 34: 
      case 92: 
      case 36: 
      case 96: 
      tmp___2 = wp;
      wp ++;
      *tmp___2 = (char )'\\';
      tmp___3 = wp;
      wp ++;
      *tmp___3 = (char )*rp;
      break;
      default: 
      tmp___4 = wp;
      wp ++;
      *tmp___4 = (char )*rp;
      break;
      }
      rp ++;
    }
    *wp = (char )'\000';
    tmp___5 = tcxstrsize((TCXSTR const   *)phrase);
    if (tmp___5) {
      tcxstrcat(phrase, (void const   *)" ", 1);
    }
    tcxstrprintf(phrase, "\"%s\"", token);
    while (1) {
      free((void *)token);
      break;
    }
    i ++;
  }
  tmp___6 = tcxstrptr((TCXSTR const   *)phrase);
  tmp___7 = system((char const   *)tmp___6);
  rv = tmp___7;
  __u___0.__in = rv;
  if ((__u___0.__i & 127) == 0) {
    __u.__in = rv;
    rv = (__u.__i & 65280) >> 8;
  } else {
    rv = 2147483647;
  }
  tcxstrdel(phrase);
  return (rv);
}
}
char *tcurlencode(char const   *ptr , int size ) 
{ char *buf ;
  void *tmp ;
  char *wp ;
  int i ;
  int c ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___3 ;

  {
  while (1) {
    tmp = malloc((unsigned int )(size * 3 + 1));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  i = 0;
  while (i < size) {
    c = (int )*((unsigned char *)ptr + i);
    if (c >= 65) {
      if (c <= 90) {
        tmp___0 = wp;
        wp ++;
        *tmp___0 = (char )c;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if (c >= 97) {
        if (c <= 122) {
          tmp___0 = wp;
          wp ++;
          *tmp___0 = (char )c;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        if (c >= 48) {
          if (c <= 57) {
            tmp___0 = wp;
            wp ++;
            *tmp___0 = (char )c;
          } else {
            goto _L;
          }
        } else {
          _L: 
          if (c != 0) {
            tmp___3 = __builtin_strchr((char *)"_-.!~*\'()", c);
            if (tmp___3) {
              tmp___0 = wp;
              wp ++;
              *tmp___0 = (char )c;
            } else {
              tmp___1 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"%%%02X",
                                c);
              wp += tmp___1;
            }
          } else {
            tmp___1 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"%%%02X",
                              c);
            wp += tmp___1;
          }
        }
      }
    }
    i ++;
  }
  *wp = (char )'\000';
  return (buf);
}
}
char *tcurldecode(char const   *str , int *sp ) 
{ char *buf ;
  char *tmp ;
  char *wp ;
  unsigned char c ;

  {
  tmp = tcstrdup((void const   *)str);
  buf = tmp;
  wp = buf;
  while ((int const   )*str != 0) {
    if ((int const   )*str == 37) {
      str ++;
      if ((int const   )*(str + 0) >= 48) {
        if ((int const   )*(str + 0) <= 57) {
          goto _L___2;
        } else {
          goto _L___4;
        }
      } else {
        _L___4: 
        if ((int const   )*(str + 0) >= 65) {
          if ((int const   )*(str + 0) <= 70) {
            goto _L___2;
          } else {
            goto _L___3;
          }
        } else {
          _L___3: 
          if ((int const   )*(str + 0) >= 97) {
            if ((int const   )*(str + 0) <= 102) {
              _L___2: 
              if ((int const   )*(str + 1) >= 48) {
                if ((int const   )*(str + 1) <= 57) {
                  goto _L;
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: 
                if ((int const   )*(str + 1) >= 65) {
                  if ((int const   )*(str + 1) <= 70) {
                    goto _L;
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: 
                  if ((int const   )*(str + 1) >= 97) {
                    if ((int const   )*(str + 1) <= 102) {
                      _L: 
                      c = (unsigned char )*str;
                      if ((int )c >= 65) {
                        if ((int )c <= 90) {
                          c = (unsigned char )((int )c + 32);
                        }
                      }
                      if ((int )c >= 97) {
                        if ((int )c <= 122) {
                          *wp = (char )(((int )c - 97) + 10);
                        } else {
                          *wp = (char )((int )c - 48);
                        }
                      } else {
                        *wp = (char )((int )c - 48);
                      }
                      *wp = (char )((int )*wp * 16);
                      str ++;
                      c = (unsigned char )*str;
                      if ((int )c >= 65) {
                        if ((int )c <= 90) {
                          c = (unsigned char )((int )c + 32);
                        }
                      }
                      if ((int )c >= 97) {
                        if ((int )c <= 122) {
                          *wp = (char )((int )*wp + (((int )c - 97) + 10));
                        } else {
                          *wp = (char )((int )*wp + ((int )c - 48));
                        }
                      } else {
                        *wp = (char )((int )*wp + ((int )c - 48));
                      }
                      str ++;
                      wp ++;
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                }
              }
            } else {
              break;
            }
          } else {
            break;
          }
        }
      }
    } else {
      if ((int const   )*str == 43) {
        *wp = (char )' ';
        str ++;
        wp ++;
      } else {
        *wp = (char )*str;
        str ++;
        wp ++;
      }
    }
  }
  *wp = (char )'\000';
  *sp = wp - buf;
  return (buf);
}
}
TCMAP *tcurlbreak(char const   *str ) 
{ TCMAP *map ;
  TCMAP *tmp ;
  char *trim ;
  char *tmp___0 ;
  char const   *rp ;
  char *norm ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *wp ;
  char *tmp___3 ;
  int tmp___4 ;
  _Bool serv ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  char *ep ;
  char *tmp___15 ;
  char *tmp___17 ;
  char *tmp___19 ;
  char *tmp___21 ;
  char *tmp___23 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___32 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;

  {
  tmp = tcmapnew2(31U);
  map = tmp;
  tmp___0 = tcstrdup((void const   *)str);
  trim = tmp___0;
  tcstrtrim(trim);
  rp = (char const   *)trim;
  while (1) {
    tmp___1 = strlen((char const   *)trim);
    tmp___2 = malloc(tmp___1 * 3U + 1U);
    norm = (char *)tmp___2;
    if (! norm) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = norm;
  while ((int const   )*rp != 0) {
    if ((int const   )*rp > 32) {
      if ((int const   )*rp < 127) {
        tmp___3 = wp;
        wp ++;
        *tmp___3 = (char )*rp;
      } else {
        tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"%%%02X",
                          *((unsigned char *)rp));
        wp += tmp___4;
      }
    } else {
      tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"%%%02X",
                        *((unsigned char *)rp));
      wp += tmp___4;
    }
    rp ++;
  }
  *wp = (char )'\000';
  rp = (char const   *)norm;
  tcmapput2(map, "self", rp);
  serv = (_Bool)0;
  tmp___13 = tcstrifwm(rp, "http://");
  if (tmp___13) {
    tcmapput2(map, "scheme", "http");
    rp += 7;
    serv = (_Bool)1;
  } else {
    tmp___12 = tcstrifwm(rp, "https://");
    if (tmp___12) {
      tcmapput2(map, "scheme", "https");
      rp += 8;
      serv = (_Bool)1;
    } else {
      tmp___11 = tcstrifwm(rp, "ftp://");
      if (tmp___11) {
        tcmapput2(map, "scheme", "ftp");
        rp += 6;
        serv = (_Bool)1;
      } else {
        tmp___10 = tcstrifwm(rp, "sftp://");
        if (tmp___10) {
          tcmapput2(map, "scheme", "sftp");
          rp += 7;
          serv = (_Bool)1;
        } else {
          tmp___9 = tcstrifwm(rp, "ftps://");
          if (tmp___9) {
            tcmapput2(map, "scheme", "ftps");
            rp += 7;
            serv = (_Bool)1;
          } else {
            tmp___8 = tcstrifwm(rp, "tftp://");
            if (tmp___8) {
              tcmapput2(map, "scheme", "tftp");
              rp += 7;
              serv = (_Bool)1;
            } else {
              tmp___7 = tcstrifwm(rp, "ldap://");
              if (tmp___7) {
                tcmapput2(map, "scheme", "ldap");
                rp += 7;
                serv = (_Bool)1;
              } else {
                tmp___6 = tcstrifwm(rp, "ldaps://");
                if (tmp___6) {
                  tcmapput2(map, "scheme", "ldaps");
                  rp += 8;
                  serv = (_Bool)1;
                } else {
                  tmp___5 = tcstrifwm(rp, "file://");
                  if (tmp___5) {
                    tcmapput2(map, "scheme", "file");
                    rp += 7;
                    serv = (_Bool)1;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  tmp___15 = __builtin_strchr((char *)rp, '#');
  ep = tmp___15;
  if ((unsigned int )ep != (unsigned int )((void *)0)) {
    tcmapput2(map, "fragment", (char const   *)(ep + 1));
    *ep = (char )'\000';
  }
  tmp___17 = __builtin_strchr((char *)rp, '?');
  ep = tmp___17;
  if ((unsigned int )ep != (unsigned int )((void *)0)) {
    tcmapput2(map, "query", (char const   *)(ep + 1));
    *ep = (char )'\000';
  }
  if (serv) {
    tmp___19 = __builtin_strchr((char *)rp, '/');
    ep = tmp___19;
    if ((unsigned int )ep != (unsigned int )((void *)0)) {
      tcmapput2(map, "path", (char const   *)ep);
      *ep = (char )'\000';
    } else {
      tcmapput2(map, "path", "/");
    }
    tmp___21 = __builtin_strchr((char *)rp, '@');
    ep = tmp___21;
    if ((unsigned int )ep != (unsigned int )((void *)0)) {
      *ep = (char )'\000';
      if ((int const   )*(rp + 0) != 0) {
        tcmapput2(map, "authority", rp);
      }
      rp = (char const   *)(ep + 1);
    }
    tmp___23 = __builtin_strchr((char *)rp, ':');
    ep = tmp___23;
    if ((unsigned int )ep != (unsigned int )((void *)0)) {
      if ((int )*(ep + 1) != 0) {
        tcmapput2(map, "port", (char const   *)(ep + 1));
      }
      *ep = (char )'\000';
    }
    if ((int const   )*(rp + 0) != 0) {
      tcmapput2(map, "host", rp);
    }
  } else {
    tcmapput2(map, "path", rp);
  }
  while (1) {
    free((void *)norm);
    break;
  }
  while (1) {
    free((void *)trim);
    break;
  }
  rp = tcmapget2((TCMAP const   *)map, "path");
  if ((unsigned int )rp != (unsigned int )((void *)0)) {
    ep = strrchr(rp, '/');
    if ((unsigned int )ep != (unsigned int )((void *)0)) {
      if ((int )*(ep + 1) != 0) {
        tcmapput2(map, "file", (char const   *)(ep + 1));
      }
    } else {
      tcmapput2(map, "file", rp);
    }
  }
  rp = tcmapget2((TCMAP const   *)map, "file");
  if ((unsigned int )rp != (unsigned int )((void *)0)) {
    if (0) {
      __s1_len = strlen(rp);
      __s2_len = strlen(".");
      if (! ((unsigned int )((void const   *)(rp + 1)) - (unsigned int )((void const   *)rp) == 1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
            tmp___30 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___30 = 1;
            } else {
              tmp___30 = 0;
            }
          }
        } else {
          tmp___30 = 0;
        }
      }
      if (tmp___30) {
        tmp___25 = __builtin_strcmp(rp, ".");
        tmp___29 = tmp___25;
      } else {
        tmp___28 = __builtin_strcmp(rp, ".");
        tmp___29 = tmp___28;
      }
    } else {
      tmp___28 = __builtin_strcmp(rp, ".");
      tmp___29 = tmp___28;
    }
    if (tmp___29) {
      if (0) {
        __s1_len___0 = strlen(rp);
        __s2_len___0 = strlen("..");
        if (! ((unsigned int )((void const   *)(rp + 1)) - (unsigned int )((void const   *)rp) == 1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: 
            if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
              tmp___37 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___37 = 1;
              } else {
                tmp___37 = 0;
              }
            }
          } else {
            tmp___37 = 0;
          }
        }
        if (tmp___37) {
          tmp___32 = __builtin_strcmp(rp, "..");
          tmp___36 = tmp___32;
        } else {
          tmp___35 = __builtin_strcmp(rp, "..");
          tmp___36 = tmp___35;
        }
      } else {
        tmp___35 = __builtin_strcmp(rp, "..");
        tmp___36 = tmp___35;
      }
      if (! tmp___36) {
        tcmapout2(map, "file");
      }
    } else {
      tcmapout2(map, "file");
    }
  }
  return (map);
}
}
char *tcurlresolve(char const   *base , char const   *target ) 
{ char const   *vbuf ;
  char const   *path ;
  char *tmp ;
  char *wp ;
  char *enc ;
  TCXSTR *rbuf ;
  TCXSTR *tmp___0 ;
  TCMAP *telems ;
  TCMAP *tmp___1 ;
  int port ;
  TCMAP *belems ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  TCMAP *tmp___5 ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int vsiz ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___15 ;
  void *tmp___16 ;
  char *tmp___18 ;
  int TC_mysize___1 ;
  int TC_nsize___1 ;
  char *tmp___19 ;
  void *tmp___20 ;
  int TC_mysize___2 ;
  int TC_nsize___2 ;
  char *tmp___21 ;
  void *tmp___22 ;
  int num ;
  char numbuf[32] ;
  int64_t tmp___23 ;
  TCLIST *bpaths ;
  TCLIST *tmp___24 ;
  TCLIST *opaths ;
  char *tmp___25 ;
  int i ;
  void const   *tmp___26 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  int TC_mysize___3 ;
  int TC_index ;
  TCLISTDATUM *tmp___35 ;
  void *tmp___36 ;
  TCLISTDATUM *array ;
  char *tmp___37 ;
  void *tmp___38 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___40 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int i___0 ;
  void const   *tmp___46 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;
  int TC_mysize___4 ;
  int TC_index___0 ;
  TCLISTDATUM *tmp___55 ;
  void *tmp___56 ;
  TCLISTDATUM *array___0 ;
  char *tmp___57 ;
  void *tmp___58 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___60 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int i___1 ;
  char *tmp___67 ;
  size_t tmp___68 ;
  int TC_mysize___5 ;
  int TC_nsize___3 ;
  char *tmp___69 ;
  void *tmp___70 ;
  int TC_mysize___6 ;
  int TC_nsize___4 ;
  char *tmp___71 ;
  void *tmp___72 ;
  _Bool tmp___73 ;
  int TC_mysize___7 ;
  int TC_nsize___5 ;
  char *tmp___74 ;
  void *tmp___75 ;
  TCLIST *qelems ;
  TCLIST *tmp___76 ;
  int i___2 ;
  int TC_mysize___8 ;
  int TC_nsize___6 ;
  char *tmp___77 ;
  void *tmp___78 ;
  int TC_mysize___9 ;
  int TC_nsize___7 ;
  char *tmp___79 ;
  void *tmp___80 ;
  size_t tmp___81 ;
  char *tmp___83 ;
  int TC_mysize___10 ;
  int TC_nsize___8 ;
  char *tmp___84 ;
  void *tmp___85 ;
  void *tmp___86 ;

  {
  while (1) {
    if ((int const   )*base > 0) {
      if (! ((int const   )*base <= 32)) {
        break;
      }
    } else {
      break;
    }
    base ++;
  }
  while (1) {
    if ((int const   )*target > 0) {
      if (! ((int const   )*target <= 32)) {
        break;
      }
    } else {
      break;
    }
    target ++;
  }
  if ((int const   )*target == 0) {
    target = base;
  }
  tmp___0 = tcxstrnew();
  rbuf = tmp___0;
  tmp___1 = tcurlbreak(target);
  telems = tmp___1;
  port = 80;
  tmp___4 = tcmapget2((TCMAP const   *)telems, "scheme");
  if (tmp___4) {
    tmp___3 = target;
  } else {
    tmp___3 = base;
  }
  tmp___5 = tcurlbreak(tmp___3);
  belems = tmp___5;
  vbuf = tcmapget2((TCMAP const   *)belems, "scheme");
  if ((unsigned int )vbuf != (unsigned int )((void *)0)) {
    tcxstrcat2(rbuf, vbuf);
    while (1) {
      TC_mysize = 3;
      TC_nsize = (rbuf->size + TC_mysize) + 1;
      if (rbuf->asize < TC_nsize) {
        while (rbuf->asize < TC_nsize) {
          rbuf->asize *= 2;
          if (rbuf->asize < TC_nsize) {
            rbuf->asize = TC_nsize;
          }
        }
        while (1) {
          tmp___7 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
          tmp___6 = (char *)tmp___7;
          rbuf->ptr = tmp___6;
          if (! tmp___6) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )"://",
             (unsigned int )TC_mysize);
      rbuf->size += TC_mysize;
      *(rbuf->ptr + rbuf->size) = (char )'\000';
      break;
    }
    tmp___14 = tcstricmp(vbuf, "https");
    if (tmp___14) {
      tmp___13 = tcstricmp(vbuf, "ftp");
      if (tmp___13) {
        tmp___12 = tcstricmp(vbuf, "sftp");
        if (tmp___12) {
          tmp___11 = tcstricmp(vbuf, "ftps");
          if (tmp___11) {
            tmp___10 = tcstricmp(vbuf, "tftp");
            if (tmp___10) {
              tmp___9 = tcstricmp(vbuf, "ldap");
              if (tmp___9) {
                tmp___8 = tcstricmp(vbuf, "ldaps");
                if (! tmp___8) {
                  port = 636;
                }
              } else {
                port = 389;
              }
            } else {
              port = 69;
            }
          } else {
            port = 22;
          }
        } else {
          port = 115;
        }
      } else {
        port = 21;
      }
    } else {
      port = 443;
    }
  } else {
    tcxstrcat2(rbuf, "http://");
  }
  vbuf = tcmapget2((TCMAP const   *)belems, "authority");
  if ((unsigned int )vbuf != (unsigned int )((void *)0)) {
    tmp___18 = __builtin_strchr((char *)vbuf, ':');
    wp = tmp___18;
    if ((unsigned int )wp != (unsigned int )((void *)0)) {
      *wp = (char )'\000';
      tmp = tcurldecode(vbuf, & vsiz);
      enc = tcurlencode((char const   *)tmp, vsiz);
      tcxstrcat2(rbuf, (char const   *)enc);
      while (1) {
        free((void *)enc);
        break;
      }
      while (1) {
        free((void *)tmp);
        break;
      }
      while (1) {
        TC_mysize___0 = 1;
        TC_nsize___0 = (rbuf->size + TC_mysize___0) + 1;
        if (rbuf->asize < TC_nsize___0) {
          while (rbuf->asize < TC_nsize___0) {
            rbuf->asize *= 2;
            if (rbuf->asize < TC_nsize___0) {
              rbuf->asize = TC_nsize___0;
            }
          }
          while (1) {
            tmp___16 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
            tmp___15 = (char *)tmp___16;
            rbuf->ptr = tmp___15;
            if (! tmp___15) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )":",
               (unsigned int )TC_mysize___0);
        rbuf->size += TC_mysize___0;
        *(rbuf->ptr + rbuf->size) = (char )'\000';
        break;
      }
      wp ++;
      tmp = tcurldecode((char const   *)wp, & vsiz);
      enc = tcurlencode((char const   *)tmp, vsiz);
      tcxstrcat2(rbuf, (char const   *)enc);
      while (1) {
        free((void *)enc);
        break;
      }
      while (1) {
        free((void *)tmp);
        break;
      }
    } else {
      tmp = tcurldecode(vbuf, & vsiz);
      enc = tcurlencode((char const   *)tmp, vsiz);
      tcxstrcat2(rbuf, (char const   *)enc);
      while (1) {
        free((void *)enc);
        break;
      }
      while (1) {
        free((void *)tmp);
        break;
      }
    }
    while (1) {
      TC_mysize___1 = 1;
      TC_nsize___1 = (rbuf->size + TC_mysize___1) + 1;
      if (rbuf->asize < TC_nsize___1) {
        while (rbuf->asize < TC_nsize___1) {
          rbuf->asize *= 2;
          if (rbuf->asize < TC_nsize___1) {
            rbuf->asize = TC_nsize___1;
          }
        }
        while (1) {
          tmp___20 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
          tmp___19 = (char *)tmp___20;
          rbuf->ptr = tmp___19;
          if (! tmp___19) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )"@",
             (unsigned int )TC_mysize___1);
      rbuf->size += TC_mysize___1;
      *(rbuf->ptr + rbuf->size) = (char )'\000';
      break;
    }
  }
  vbuf = tcmapget2((TCMAP const   *)belems, "host");
  if ((unsigned int )vbuf != (unsigned int )((void *)0)) {
    tmp = tcurldecode(vbuf, & vsiz);
    tcstrtolower(tmp);
    enc = tcurlencode((char const   *)tmp, vsiz);
    tcxstrcat2(rbuf, (char const   *)enc);
    while (1) {
      free((void *)enc);
      break;
    }
    while (1) {
      free((void *)tmp);
      break;
    }
  } else {
    while (1) {
      TC_mysize___2 = 9;
      TC_nsize___2 = (rbuf->size + TC_mysize___2) + 1;
      if (rbuf->asize < TC_nsize___2) {
        while (rbuf->asize < TC_nsize___2) {
          rbuf->asize *= 2;
          if (rbuf->asize < TC_nsize___2) {
            rbuf->asize = TC_nsize___2;
          }
        }
        while (1) {
          tmp___22 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
          tmp___21 = (char *)tmp___22;
          rbuf->ptr = tmp___21;
          if (! tmp___21) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )"localhost",
             (unsigned int )TC_mysize___2);
      rbuf->size += TC_mysize___2;
      *(rbuf->ptr + rbuf->size) = (char )'\000';
      break;
    }
  }
  vbuf = tcmapget2((TCMAP const   *)belems, "port");
  if ((unsigned int )vbuf != (unsigned int )((void *)0)) {
    tmp___23 = tcatoi(vbuf);
    num = (int )tmp___23;
    if (num != port) {
      if (num > 0) {
        sprintf((char * __restrict  )(numbuf), (char const   * __restrict  )":%d",
                num);
        tcxstrcat2(rbuf, (char const   *)(numbuf));
      }
    }
  }
  path = tcmapget2((TCMAP const   *)telems, "path");
  if (! path) {
    path = "/";
  }
  if ((int const   )*(path + 0) == 0) {
    vbuf = tcmapget2((TCMAP const   *)belems, "path");
    if ((unsigned int )vbuf != (unsigned int )((void *)0)) {
      path = vbuf;
    }
  }
  if ((int const   )*(path + 0) == 0) {
    path = "/";
  }
  tmp___24 = tclistnew();
  bpaths = tmp___24;
  if ((int const   )*(path + 0) != 47) {
    vbuf = tcmapget2((TCMAP const   *)belems, "path");
    if ((unsigned int )vbuf != (unsigned int )((void *)0)) {
      opaths = tcstrsplit(vbuf, "/");
    } else {
      opaths = tcstrsplit("/", "/");
    }
  } else {
    opaths = tcstrsplit("/", "/");
  }
  while (1) {
    tmp___25 = tclistpop2(opaths);
    free((void *)tmp___25);
    break;
  }
  i = 0;
  while (i < opaths->num) {
    tmp___26 = tclistval((TCLIST const   *)opaths, i, & vsiz);
    vbuf = (char const   *)tmp___26;
    if (vsiz < 1) {
      goto __Cont;
    } else {
      if (0) {
        __s1_len = strlen(vbuf);
        __s2_len = strlen(".");
        if (! ((unsigned int )((void const   *)(vbuf + 1)) - (unsigned int )((void const   *)vbuf) == 1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
              tmp___33 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___33 = 1;
              } else {
                tmp___33 = 0;
              }
            }
          } else {
            tmp___33 = 0;
          }
        }
        if (tmp___33) {
          tmp___28 = __builtin_strcmp(vbuf, ".");
          tmp___32 = tmp___28;
        } else {
          tmp___31 = __builtin_strcmp(vbuf, ".");
          tmp___32 = tmp___31;
        }
      } else {
        tmp___31 = __builtin_strcmp(vbuf, ".");
        tmp___32 = tmp___31;
      }
      if (! tmp___32) {
        goto __Cont;
      }
    }
    if (0) {
      __s1_len___0 = strlen(vbuf);
      __s2_len___0 = strlen("..");
      if (! ((unsigned int )((void const   *)(vbuf + 1)) - (unsigned int )((void const   *)vbuf) == 1U)) {
        goto _L___2;
      } else {
        if (__s1_len___0 >= 4U) {
          _L___2: 
          if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
            tmp___45 = 1;
          } else {
            if (__s2_len___0 >= 4U) {
              tmp___45 = 1;
            } else {
              tmp___45 = 0;
            }
          }
        } else {
          tmp___45 = 0;
        }
      }
      if (tmp___45) {
        tmp___40 = __builtin_strcmp(vbuf, "..");
        tmp___44 = tmp___40;
      } else {
        tmp___43 = __builtin_strcmp(vbuf, "..");
        tmp___44 = tmp___43;
      }
    } else {
      tmp___43 = __builtin_strcmp(vbuf, "..");
      tmp___44 = tmp___43;
    }
    if (tmp___44) {
      while (1) {
        TC_mysize___3 = vsiz;
        TC_index = bpaths->start + bpaths->num;
        if (TC_index >= bpaths->anum) {
          bpaths->anum += bpaths->num + 1;
          while (1) {
            tmp___36 = realloc((void *)bpaths->array, (unsigned int )(bpaths->anum * (int )sizeof(*(bpaths->array + 0))));
            tmp___35 = (TCLISTDATUM *)tmp___36;
            bpaths->array = tmp___35;
            if (! tmp___35) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        array = bpaths->array;
        while (1) {
          tmp___38 = malloc((unsigned int )(TC_mysize___3 + 1));
          tmp___37 = (char *)tmp___38;
          (array + TC_index)->ptr = tmp___37;
          if (! tmp___37) {
            tcmyfatal("out of memory");
          }
          break;
        }
        memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )vbuf,
               (unsigned int )TC_mysize___3);
        *((array + TC_index)->ptr + TC_mysize___3) = (char )'\000';
        (array + TC_index)->size = TC_mysize___3;
        (bpaths->num) ++;
        break;
      }
    } else {
      while (1) {
        tmp___34 = tclistpop2(bpaths);
        free((void *)tmp___34);
        break;
      }
    }
    __Cont: 
    i ++;
  }
  tclistdel(opaths);
  opaths = tcstrsplit(path, "/");
  i___0 = 0;
  while (i___0 < opaths->num) {
    tmp___46 = tclistval((TCLIST const   *)opaths, i___0, & vsiz);
    vbuf = (char const   *)tmp___46;
    if (vsiz < 1) {
      goto __Cont___0;
    } else {
      if (0) {
        __s1_len___1 = strlen(vbuf);
        __s2_len___1 = strlen(".");
        if (! ((unsigned int )((void const   *)(vbuf + 1)) - (unsigned int )((void const   *)vbuf) == 1U)) {
          goto _L___4;
        } else {
          if (__s1_len___1 >= 4U) {
            _L___4: 
            if (! ((unsigned int )((void const   *)("." + 1)) - (unsigned int )((void const   *)".") == 1U)) {
              tmp___53 = 1;
            } else {
              if (__s2_len___1 >= 4U) {
                tmp___53 = 1;
              } else {
                tmp___53 = 0;
              }
            }
          } else {
            tmp___53 = 0;
          }
        }
        if (tmp___53) {
          tmp___48 = __builtin_strcmp(vbuf, ".");
          tmp___52 = tmp___48;
        } else {
          tmp___51 = __builtin_strcmp(vbuf, ".");
          tmp___52 = tmp___51;
        }
      } else {
        tmp___51 = __builtin_strcmp(vbuf, ".");
        tmp___52 = tmp___51;
      }
      if (! tmp___52) {
        goto __Cont___0;
      }
    }
    if (0) {
      __s1_len___2 = strlen(vbuf);
      __s2_len___2 = strlen("..");
      if (! ((unsigned int )((void const   *)(vbuf + 1)) - (unsigned int )((void const   *)vbuf) == 1U)) {
        goto _L___6;
      } else {
        if (__s1_len___2 >= 4U) {
          _L___6: 
          if (! ((unsigned int )((void const   *)(".." + 1)) - (unsigned int )((void const   *)"..") == 1U)) {
            tmp___65 = 1;
          } else {
            if (__s2_len___2 >= 4U) {
              tmp___65 = 1;
            } else {
              tmp___65 = 0;
            }
          }
        } else {
          tmp___65 = 0;
        }
      }
      if (tmp___65) {
        tmp___60 = __builtin_strcmp(vbuf, "..");
        tmp___64 = tmp___60;
      } else {
        tmp___63 = __builtin_strcmp(vbuf, "..");
        tmp___64 = tmp___63;
      }
    } else {
      tmp___63 = __builtin_strcmp(vbuf, "..");
      tmp___64 = tmp___63;
    }
    if (tmp___64) {
      while (1) {
        TC_mysize___4 = vsiz;
        TC_index___0 = bpaths->start + bpaths->num;
        if (TC_index___0 >= bpaths->anum) {
          bpaths->anum += bpaths->num + 1;
          while (1) {
            tmp___56 = realloc((void *)bpaths->array, (unsigned int )(bpaths->anum * (int )sizeof(*(bpaths->array + 0))));
            tmp___55 = (TCLISTDATUM *)tmp___56;
            bpaths->array = tmp___55;
            if (! tmp___55) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        array___0 = bpaths->array;
        while (1) {
          tmp___58 = malloc((unsigned int )(TC_mysize___4 + 1));
          tmp___57 = (char *)tmp___58;
          (array___0 + TC_index___0)->ptr = tmp___57;
          if (! tmp___57) {
            tcmyfatal("out of memory");
          }
          break;
        }
        memcpy((void * __restrict  )(array___0 + TC_index___0)->ptr, (void const   * __restrict  )vbuf,
               (unsigned int )TC_mysize___4);
        *((array___0 + TC_index___0)->ptr + TC_mysize___4) = (char )'\000';
        (array___0 + TC_index___0)->size = TC_mysize___4;
        (bpaths->num) ++;
        break;
      }
    } else {
      while (1) {
        tmp___54 = tclistpop2(bpaths);
        free((void *)tmp___54);
        break;
      }
    }
    __Cont___0: 
    i___0 ++;
  }
  tclistdel(opaths);
  i___1 = 0;
  while (i___1 < bpaths->num) {
    vbuf = (char const   *)((void *)(bpaths->array + (i___1 + bpaths->start))->ptr);
    tmp___67 = __builtin_strchr((char *)vbuf, '%');
    if (tmp___67) {
      tmp = tcurldecode(vbuf, & vsiz);
    } else {
      tmp = tcstrdup((void const   *)vbuf);
    }
    tmp___68 = strlen((char const   *)tmp);
    enc = tcurlencode((char const   *)tmp, (int )tmp___68);
    while (1) {
      TC_mysize___5 = 1;
      TC_nsize___3 = (rbuf->size + TC_mysize___5) + 1;
      if (rbuf->asize < TC_nsize___3) {
        while (rbuf->asize < TC_nsize___3) {
          rbuf->asize *= 2;
          if (rbuf->asize < TC_nsize___3) {
            rbuf->asize = TC_nsize___3;
          }
        }
        while (1) {
          tmp___70 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
          tmp___69 = (char *)tmp___70;
          rbuf->ptr = tmp___69;
          if (! tmp___69) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )"/",
             (unsigned int )TC_mysize___5);
      rbuf->size += TC_mysize___5;
      *(rbuf->ptr + rbuf->size) = (char )'\000';
      break;
    }
    tcxstrcat2(rbuf, (char const   *)enc);
    while (1) {
      free((void *)enc);
      break;
    }
    while (1) {
      free((void *)tmp);
      break;
    }
    i___1 ++;
  }
  tmp___73 = tcstrbwm(path, "/");
  if (tmp___73) {
    while (1) {
      TC_mysize___6 = 1;
      TC_nsize___4 = (rbuf->size + TC_mysize___6) + 1;
      if (rbuf->asize < TC_nsize___4) {
        while (rbuf->asize < TC_nsize___4) {
          rbuf->asize *= 2;
          if (rbuf->asize < TC_nsize___4) {
            rbuf->asize = TC_nsize___4;
          }
        }
        while (1) {
          tmp___72 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
          tmp___71 = (char *)tmp___72;
          rbuf->ptr = tmp___71;
          if (! tmp___71) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )"/",
             (unsigned int )TC_mysize___6);
      rbuf->size += TC_mysize___6;
      *(rbuf->ptr + rbuf->size) = (char )'\000';
      break;
    }
  }
  tclistdel(bpaths);
  vbuf = tcmapget2((TCMAP const   *)telems, "query");
  if ((unsigned int )vbuf != (unsigned int )((void *)0)) {
    goto _L___7;
  } else {
    if ((int const   )*target == 35) {
      vbuf = tcmapget2((TCMAP const   *)belems, "query");
      if ((unsigned int )vbuf != (unsigned int )((void *)0)) {
        _L___7: 
        while (1) {
          TC_mysize___7 = 1;
          TC_nsize___5 = (rbuf->size + TC_mysize___7) + 1;
          if (rbuf->asize < TC_nsize___5) {
            while (rbuf->asize < TC_nsize___5) {
              rbuf->asize *= 2;
              if (rbuf->asize < TC_nsize___5) {
                rbuf->asize = TC_nsize___5;
              }
            }
            while (1) {
              tmp___75 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
              tmp___74 = (char *)tmp___75;
              rbuf->ptr = tmp___74;
              if (! tmp___74) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )"?",
                 (unsigned int )TC_mysize___7);
          rbuf->size += TC_mysize___7;
          *(rbuf->ptr + rbuf->size) = (char )'\000';
          break;
        }
        tmp___76 = tcstrsplit(vbuf, "&;");
        qelems = tmp___76;
        i___2 = 0;
        while (i___2 < qelems->num) {
          vbuf = (char const   *)((void *)(qelems->array + (i___2 + qelems->start))->ptr);
          if (i___2 > 0) {
            while (1) {
              TC_mysize___8 = 1;
              TC_nsize___6 = (rbuf->size + TC_mysize___8) + 1;
              if (rbuf->asize < TC_nsize___6) {
                while (rbuf->asize < TC_nsize___6) {
                  rbuf->asize *= 2;
                  if (rbuf->asize < TC_nsize___6) {
                    rbuf->asize = TC_nsize___6;
                  }
                }
                while (1) {
                  tmp___78 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
                  tmp___77 = (char *)tmp___78;
                  rbuf->ptr = tmp___77;
                  if (! tmp___77) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )"&",
                     (unsigned int )TC_mysize___8);
              rbuf->size += TC_mysize___8;
              *(rbuf->ptr + rbuf->size) = (char )'\000';
              break;
            }
          }
          tmp___83 = __builtin_strchr((char *)vbuf, '=');
          wp = tmp___83;
          if ((unsigned int )wp != (unsigned int )((void *)0)) {
            *wp = (char )'\000';
            tmp = tcurldecode(vbuf, & vsiz);
            enc = tcurlencode((char const   *)tmp, vsiz);
            tcxstrcat2(rbuf, (char const   *)enc);
            while (1) {
              free((void *)enc);
              break;
            }
            while (1) {
              free((void *)tmp);
              break;
            }
            while (1) {
              TC_mysize___9 = 1;
              TC_nsize___7 = (rbuf->size + TC_mysize___9) + 1;
              if (rbuf->asize < TC_nsize___7) {
                while (rbuf->asize < TC_nsize___7) {
                  rbuf->asize *= 2;
                  if (rbuf->asize < TC_nsize___7) {
                    rbuf->asize = TC_nsize___7;
                  }
                }
                while (1) {
                  tmp___80 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
                  tmp___79 = (char *)tmp___80;
                  rbuf->ptr = tmp___79;
                  if (! tmp___79) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )"=",
                     (unsigned int )TC_mysize___9);
              rbuf->size += TC_mysize___9;
              *(rbuf->ptr + rbuf->size) = (char )'\000';
              break;
            }
            wp ++;
            tmp = tcurldecode((char const   *)wp, & vsiz);
            tmp___81 = strlen((char const   *)tmp);
            enc = tcurlencode((char const   *)tmp, (int )tmp___81);
            tcxstrcat2(rbuf, (char const   *)enc);
            while (1) {
              free((void *)enc);
              break;
            }
            while (1) {
              free((void *)tmp);
              break;
            }
          } else {
            tmp = tcurldecode(vbuf, & vsiz);
            enc = tcurlencode((char const   *)tmp, vsiz);
            tcxstrcat2(rbuf, (char const   *)enc);
            while (1) {
              free((void *)enc);
              break;
            }
            while (1) {
              free((void *)tmp);
              break;
            }
          }
          i___2 ++;
        }
        tclistdel(qelems);
      }
    }
  }
  vbuf = tcmapget2((TCMAP const   *)telems, "fragment");
  if ((unsigned int )vbuf != (unsigned int )((void *)0)) {
    tmp = tcurldecode(vbuf, & vsiz);
    enc = tcurlencode((char const   *)tmp, vsiz);
    while (1) {
      TC_mysize___10 = 1;
      TC_nsize___8 = (rbuf->size + TC_mysize___10) + 1;
      if (rbuf->asize < TC_nsize___8) {
        while (rbuf->asize < TC_nsize___8) {
          rbuf->asize *= 2;
          if (rbuf->asize < TC_nsize___8) {
            rbuf->asize = TC_nsize___8;
          }
        }
        while (1) {
          tmp___85 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
          tmp___84 = (char *)tmp___85;
          rbuf->ptr = tmp___84;
          if (! tmp___84) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )"#",
             (unsigned int )TC_mysize___10);
      rbuf->size += TC_mysize___10;
      *(rbuf->ptr + rbuf->size) = (char )'\000';
      break;
    }
    tcxstrcat2(rbuf, (char const   *)enc);
    while (1) {
      free((void *)enc);
      break;
    }
    while (1) {
      free((void *)tmp);
      break;
    }
  }
  tcmapdel(belems);
  tcmapdel(telems);
  tmp___86 = tcxstrtomalloc(rbuf);
  return ((char *)tmp___86);
}
}
char *tcbaseencode(char const   *ptr , int size ) 
{ char *tbl ;
  unsigned char const   *obj ;
  char *buf ;
  void *tmp ;
  char *wp ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
  tbl = (char *)"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  obj = (unsigned char const   *)ptr;
  while (1) {
    tmp = malloc((unsigned int )((4 * (size + 2)) / 3 + 1));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  i = 0;
  while (i < size) {
    switch (size - i) {
    case 1: 
    tmp___0 = wp;
    wp ++;
    *tmp___0 = *(tbl + ((int const   )*(obj + 0) >> 2));
    tmp___1 = wp;
    wp ++;
    *tmp___1 = *(tbl + (((int const   )*(obj + 0) & 3) << 4));
    tmp___2 = wp;
    wp ++;
    *tmp___2 = (char )'=';
    tmp___3 = wp;
    wp ++;
    *tmp___3 = (char )'=';
    break;
    case 2: 
    tmp___4 = wp;
    wp ++;
    *tmp___4 = *(tbl + ((int const   )*(obj + 0) >> 2));
    tmp___5 = wp;
    wp ++;
    *tmp___5 = *(tbl + ((((int const   )*(obj + 0) & 3) << 4) + ((int const   )*(obj + 1) >> 4)));
    tmp___6 = wp;
    wp ++;
    *tmp___6 = *(tbl + (((int const   )*(obj + 1) & 15) << 2));
    tmp___7 = wp;
    wp ++;
    *tmp___7 = (char )'=';
    break;
    default: 
    tmp___8 = wp;
    wp ++;
    *tmp___8 = *(tbl + ((int const   )*(obj + 0) >> 2));
    tmp___9 = wp;
    wp ++;
    *tmp___9 = *(tbl + ((((int const   )*(obj + 0) & 3) << 4) + ((int const   )*(obj + 1) >> 4)));
    tmp___10 = wp;
    wp ++;
    *tmp___10 = *(tbl + ((((int const   )*(obj + 1) & 15) << 2) + ((int const   )*(obj + 2) >> 6)));
    tmp___11 = wp;
    wp ++;
    *tmp___11 = *(tbl + ((int const   )*(obj + 2) & 63));
    break;
    }
    obj += 3;
    i += 3;
  }
  *wp = (char )'\000';
  return (buf);
}
}
char *tcbasedecode(char const   *str , int *sp ) 
{ int cnt___0 ;
  int bpos ;
  int eqcnt ;
  int len ;
  size_t tmp ;
  unsigned char *obj ;
  void *tmp___0 ;
  unsigned char *wp ;
  int bits ;
  int i ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;

  {
  cnt___0 = 0;
  bpos = 0;
  eqcnt = 0;
  tmp = strlen(str);
  len = (int )tmp;
  while (1) {
    tmp___0 = malloc((unsigned int )(len + 4));
    obj = (unsigned char *)tmp___0;
    if (! obj) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = obj;
  while (1) {
    if (bpos < len) {
      if (! (eqcnt == 0)) {
        break;
      }
    } else {
      break;
    }
    bits = 0;
    i = 0;
    while (1) {
      if (bpos < len) {
        if (! (i < 4)) {
          break;
        }
      } else {
        break;
      }
      if ((int const   )*(str + bpos) >= 65) {
        if ((int const   )*(str + bpos) <= 90) {
          bits = (bits << 6) | (int )((int const   )*(str + bpos) - 65);
          i ++;
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
        if ((int const   )*(str + bpos) >= 97) {
          if ((int const   )*(str + bpos) <= 122) {
            bits = (bits << 6) | (int )(((int const   )*(str + bpos) - 97) + 26);
            i ++;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: 
          if ((int const   )*(str + bpos) >= 48) {
            if ((int const   )*(str + bpos) <= 57) {
              bits = (bits << 6) | (int )(((int const   )*(str + bpos) - 48) + 52);
              i ++;
            } else {
              goto _L;
            }
          } else {
            _L: 
            if ((int const   )*(str + bpos) == 43) {
              bits = (bits << 6) | 62;
              i ++;
            } else {
              if ((int const   )*(str + bpos) == 47) {
                bits = (bits << 6) | 63;
                i ++;
              } else {
                if ((int const   )*(str + bpos) == 61) {
                  bits <<= 6;
                  i ++;
                  eqcnt ++;
                }
              }
            }
          }
        }
      }
      bpos ++;
    }
    if (i == 0) {
      if (bpos >= len) {
        continue;
      }
    }
    switch (eqcnt) {
    case 0: 
    tmp___1 = wp;
    wp ++;
    *tmp___1 = (unsigned char )((bits >> 16) & 255);
    tmp___2 = wp;
    wp ++;
    *tmp___2 = (unsigned char )((bits >> 8) & 255);
    tmp___3 = wp;
    wp ++;
    *tmp___3 = (unsigned char )(bits & 255);
    cnt___0 += 3;
    break;
    case 1: 
    tmp___4 = wp;
    wp ++;
    *tmp___4 = (unsigned char )((bits >> 16) & 255);
    tmp___5 = wp;
    wp ++;
    *tmp___5 = (unsigned char )((bits >> 8) & 255);
    cnt___0 += 2;
    break;
    case 2: 
    tmp___6 = wp;
    wp ++;
    *tmp___6 = (unsigned char )((bits >> 16) & 255);
    cnt___0 ++;
    break;
    }
  }
  *(obj + cnt___0) = (unsigned char )'\000';
  *sp = cnt___0;
  return ((char *)obj);
}
}
char *tcquoteencode(char const   *ptr , int size ) 
{ unsigned char const   *rp ;
  char *buf ;
  void *tmp ;
  char *wp ;
  int cols ;
  int i ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  rp = (unsigned char const   *)ptr;
  while (1) {
    tmp = malloc((unsigned int )(size * 3 + 1));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  cols = 0;
  i = 0;
  while (i < size) {
    if ((int const   )*(rp + i) == 61) {
      tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"=%02X",
                        *(rp + i));
      wp += tmp___0;
      cols += 3;
    } else {
      if ((int const   )*(rp + i) < 32) {
        if ((int const   )*(rp + i) != 13) {
          if ((int const   )*(rp + i) != 10) {
            if ((int const   )*(rp + i) != 9) {
              tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"=%02X",
                                *(rp + i));
              wp += tmp___0;
              cols += 3;
            } else {
              goto _L___1;
            }
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      } else {
        _L___1: 
        if ((int const   )*(rp + i) > 126) {
          tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"=%02X",
                            *(rp + i));
          wp += tmp___0;
          cols += 3;
        } else {
          tmp___1 = wp;
          wp ++;
          *tmp___1 = (char )*(rp + i);
          cols ++;
        }
      }
    }
    i ++;
  }
  *wp = (char )'\000';
  return (buf);
}
}
char *tcquotedecode(char const   *str , int *sp ) 
{ char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  char *wp ;

  {
  while (1) {
    tmp = strlen(str);
    tmp___0 = malloc(tmp + 1U);
    buf = (char *)tmp___0;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  while ((int const   )*str != 0) {
    if ((int const   )*str == 61) {
      str ++;
      if ((int const   )*str == 0) {
        break;
      } else {
        if ((int const   )*(str + 0) == 13) {
          if ((int const   )*(str + 1) == 10) {
            str ++;
          } else {
            goto _L___1;
          }
        } else {
          _L___1: 
          if ((int const   )*(str + 0) != 10) {
            if ((int const   )*(str + 0) != 13) {
              if ((int const   )*str >= 65) {
                if ((int const   )*str <= 90) {
                  *wp = (char )((((int const   )*str - 65) + 10) * 16);
                } else {
                  goto _L;
                }
              } else {
                _L: 
                if ((int const   )*str >= 97) {
                  if ((int const   )*str <= 122) {
                    *wp = (char )((((int const   )*str - 97) + 10) * 16);
                  } else {
                    *wp = (char )(((int const   )*str - 48) * 16);
                  }
                } else {
                  *wp = (char )(((int const   )*str - 48) * 16);
                }
              }
              str ++;
              if ((int const   )*str == 0) {
                break;
              }
              if ((int const   )*str >= 65) {
                if ((int const   )*str <= 90) {
                  *wp = (char )((int )*wp + (int )(((int const   )*str - 65) + 10));
                } else {
                  goto _L___0;
                }
              } else {
                _L___0: 
                if ((int const   )*str >= 97) {
                  if ((int const   )*str <= 122) {
                    *wp = (char )((int )*wp + (int )(((int const   )*str - 97) + 10));
                  } else {
                    *wp = (char )((int )*wp + (int )((int const   )*str - 48));
                  }
                } else {
                  *wp = (char )((int )*wp + (int )((int const   )*str - 48));
                }
              }
              wp ++;
            }
          }
        }
      }
    } else {
      *wp = (char )*str;
      wp ++;
    }
    str ++;
  }
  *wp = (char )'\000';
  *sp = wp - buf;
  return (buf);
}
}
char *tcmimeencode(char const   *str , char const   *encname , _Bool base ) 
{ int len ;
  size_t tmp ;
  char *buf ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *wp ;
  int tmp___2 ;
  int tmp___3 ;
  char *enc ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  tmp = strlen(str);
  len = (int )tmp;
  while (1) {
    tmp___0 = strlen(encname);
    tmp___1 = malloc(((unsigned int )(len * 3) + tmp___0) + 16U);
    buf = (char *)tmp___1;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  if (base) {
    tmp___2 = 'B';
  } else {
    tmp___2 = 'Q';
  }
  tmp___3 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"=?%s?%c?",
                    encname, tmp___2);
  wp += tmp___3;
  if (base) {
    tmp___4 = tcbaseencode(str, len);
    tmp___6 = tmp___4;
  } else {
    tmp___5 = tcquoteencode(str, len);
    tmp___6 = tmp___5;
  }
  enc = tmp___6;
  tmp___7 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"%s?=",
                    enc);
  wp += tmp___7;
  while (1) {
    free((void *)enc);
    break;
  }
  return (buf);
}
}
char *tcmimedecode(char const   *str , char *enp ) 
{ char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  char *wp ;
  char const   *pv ;
  char const   *ep ;
  char *tmp___2 ;
  _Bool quoted ;
  int tmp___3 ;
  char *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int len ;
  char *dec ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  _Bool tmp___13 ;

  {
  if (enp) {
    sprintf((char * __restrict  )enp, (char const   * __restrict  )"US-ASCII");
  }
  while (1) {
    tmp = strlen(str);
    tmp___0 = malloc(tmp + 1U);
    buf = (char *)tmp___0;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  while ((int const   )*str != 0) {
    tmp___13 = tcstrfwm(str, "=?");
    if (tmp___13) {
      str += 2;
      pv = str;
      tmp___2 = __builtin_strchr((char *)str, '?');
      ep = (char const   *)tmp___2;
      if (! ep) {
        continue;
      }
      if (enp) {
        if (ep - pv < 32) {
          memcpy((void * __restrict  )enp, (void const   * __restrict  )pv, (unsigned int )(ep - pv));
          *(enp + (ep - pv)) = (char )'\000';
        }
      }
      pv = ep + 1;
      if ((int const   )*pv == 81) {
        tmp___3 = 1;
      } else {
        if ((int const   )*pv == 113) {
          tmp___3 = 1;
        } else {
          tmp___3 = 0;
        }
      }
      quoted = (_Bool )tmp___3;
      if ((int const   )*pv != 0) {
        pv ++;
      }
      if ((int const   )*pv != 0) {
        pv ++;
      }
      tmp___5 = __builtin_strchr((char *)pv, '?');
      ep = (char const   *)tmp___5;
      if (! ep) {
        continue;
      }
      while (1) {
        while (1) {
          tmp___7 = malloc((unsigned int )((ep - pv) + 1));
          tmp___6 = (char *)tmp___7;
          if (! tmp___6) {
            tcmyfatal("out of memory");
          }
          break;
        }
        memcpy((void * __restrict  )tmp___6, (void const   * __restrict  )pv, (unsigned int )(ep - pv));
        *(tmp___6 + (ep - pv)) = (char )'\000';
        break;
      }
      if (quoted) {
        tmp___8 = tcquotedecode((char const   *)tmp___6, & len);
        tmp___10 = tmp___8;
      } else {
        tmp___9 = tcbasedecode((char const   *)tmp___6, & len);
        tmp___10 = tmp___9;
      }
      dec = tmp___10;
      tmp___11 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"%s",
                         dec);
      wp += tmp___11;
      while (1) {
        free((void *)dec);
        break;
      }
      while (1) {
        free((void *)tmp___6);
        break;
      }
      str = ep + 1;
      if ((int const   )*str != 0) {
        str ++;
      }
    } else {
      tmp___12 = wp;
      wp ++;
      *tmp___12 = (char )*str;
      str ++;
    }
  }
  *wp = (char )'\000';
  return (buf);
}
}
char *tcmimebreak(char const   *ptr , int size , TCMAP *headers , int *sp ) 
{ char const   *head ;
  int hlen ;
  int i ;
  char *hbuf ;
  void *tmp ;
  int wi ;
  int i___0 ;
  int tmp___0 ;
  int tmp___1 ;
  TCLIST *list ;
  TCLIST *tmp___2 ;
  int ln ;
  int i___1 ;
  char const   *line ;
  char const   *pv ;
  char *tmp___4 ;
  char *name ;
  void *tmp___5 ;
  int j ;
  char const   *pv___0 ;
  char const   *tmp___6 ;
  char const   *ep ;
  char *tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  char *tmp___12 ;
  size_t tmp___13 ;
  char *ep___0 ;
  char *tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  char *tmp___19 ;
  size_t tmp___20 ;
  char *rv ;
  void *tmp___21 ;

  {
  head = (char const   *)((void *)0);
  hlen = 0;
  i = 0;
  while (i < size) {
    if (i < size - 4) {
      if ((int const   )*(ptr + i) == 13) {
        if ((int const   )*(ptr + (i + 1)) == 10) {
          if ((int const   )*(ptr + (i + 2)) == 13) {
            if ((int const   )*(ptr + (i + 3)) == 10) {
              head = ptr;
              hlen = i;
              ptr += i + 4;
              size -= i + 4;
              break;
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
      if (i < size - 2) {
        if ((int const   )*(ptr + i) == 10) {
          if ((int const   )*(ptr + (i + 1)) == 10) {
            head = ptr;
            hlen = i;
            ptr += i + 2;
            size -= i + 2;
            break;
          }
        }
      }
    }
    i ++;
  }
  if (head) {
    if (headers) {
      while (1) {
        tmp = malloc((unsigned int )(hlen + 1));
        hbuf = (char *)tmp;
        if (! hbuf) {
          tcmyfatal("out of memory");
        }
        break;
      }
      wi = 0;
      i___0 = 0;
      while (i___0 < hlen) {
        if ((int const   )*(head + i___0) == 13) {
          goto __Cont;
        }
        if (i___0 < hlen - 1) {
          if ((int const   )*(head + i___0) == 10) {
            if ((int const   )*(head + (i___0 + 1)) == 32) {
              tmp___0 = wi;
              wi ++;
              *(hbuf + tmp___0) = (char )' ';
              i___0 ++;
            } else {
              if ((int const   )*(head + (i___0 + 1)) == 9) {
                tmp___0 = wi;
                wi ++;
                *(hbuf + tmp___0) = (char )' ';
                i___0 ++;
              } else {
                tmp___1 = wi;
                wi ++;
                *(hbuf + tmp___1) = (char )*(head + i___0);
              }
            }
          } else {
            tmp___1 = wi;
            wi ++;
            *(hbuf + tmp___1) = (char )*(head + i___0);
          }
        } else {
          tmp___1 = wi;
          wi ++;
          *(hbuf + tmp___1) = (char )*(head + i___0);
        }
        __Cont: 
        i___0 ++;
      }
      *(hbuf + wi) = (char )'\000';
      tmp___2 = tcstrsplit((char const   *)hbuf, "\n");
      list = tmp___2;
      ln = list->num;
      i___1 = 0;
      while (i___1 < ln) {
        line = (char const   *)((void *)(list->array + (i___1 + list->start))->ptr);
        tmp___4 = __builtin_strchr((char *)line, ':');
        pv = (char const   *)tmp___4;
        if (pv) {
          while (1) {
            while (1) {
              tmp___5 = malloc((unsigned int )((pv - line) + 1));
              name = (char *)tmp___5;
              if (! name) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )name, (void const   * __restrict  )line, (unsigned int )(pv - line));
            *(name + (pv - line)) = (char )'\000';
            break;
          }
          j = 0;
          while ((int )*(name + j) != 0) {
            if ((int )*(name + j) >= 65) {
              if ((int )*(name + j) <= 90) {
                *(name + j) = (char )((int )*(name + j) - -32);
              }
            }
            j ++;
          }
          pv ++;
          while (1) {
            if (! ((int const   )*pv == 32)) {
              if (! ((int const   )*pv == 9)) {
                break;
              }
            }
            pv ++;
          }
          tcmapput2(headers, (char const   *)name, pv);
          while (1) {
            free((void *)name);
            break;
          }
        }
        i___1 ++;
      }
      tclistdel(list);
      while (1) {
        free((void *)hbuf);
        break;
      }
      tmp___6 = tcmapget2((TCMAP const   *)headers, "content-type");
      pv___0 = tmp___6;
      if (pv___0) {
        tmp___8 = __builtin_strchr((char *)pv___0, ';');
        ep = (char const   *)tmp___8;
        if (ep) {
          tcmapput(headers, (void const   *)"TYPE", 4, (void const   *)pv___0, ep - pv___0);
          while (1) {
            ep ++;
            while ((int const   )*(ep + 0) == 32) {
              ep ++;
            }
            tmp___10 = tcstrifwm(ep, "charset=");
            if (tmp___10) {
              ep += 8;
              while (1) {
                if ((int const   )*ep > 0) {
                  if (! ((int const   )*ep <= 32)) {
                    break;
                  }
                } else {
                  break;
                }
                ep ++;
              }
              if ((int const   )*(ep + 0) == 34) {
                ep ++;
              }
              pv___0 = ep;
              while (1) {
                if ((int const   )*(ep + 0) != 0) {
                  if ((int const   )*(ep + 0) != 32) {
                    if ((int const   )*(ep + 0) != 34) {
                      if (! ((int const   )*(ep + 0) != 59)) {
                        break;
                      }
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                ep ++;
              }
              tcmapput(headers, (void const   *)"CHARSET", 7, (void const   *)pv___0,
                       ep - pv___0);
            } else {
              tmp___9 = tcstrifwm(ep, "boundary=");
              if (tmp___9) {
                ep += 9;
                while (1) {
                  if ((int const   )*ep > 0) {
                    if (! ((int const   )*ep <= 32)) {
                      break;
                    }
                  } else {
                    break;
                  }
                  ep ++;
                }
                if ((int const   )*(ep + 0) == 34) {
                  ep ++;
                  pv___0 = ep;
                  while (1) {
                    if ((int const   )*(ep + 0) != 0) {
                      if (! ((int const   )*(ep + 0) != 34)) {
                        break;
                      }
                    } else {
                      break;
                    }
                    ep ++;
                  }
                } else {
                  pv___0 = ep;
                  while (1) {
                    if ((int const   )*(ep + 0) != 0) {
                      if ((int const   )*(ep + 0) != 32) {
                        if ((int const   )*(ep + 0) != 34) {
                          if (! ((int const   )*(ep + 0) != 59)) {
                            break;
                          }
                        } else {
                          break;
                        }
                      } else {
                        break;
                      }
                    } else {
                      break;
                    }
                    ep ++;
                  }
                }
                tcmapput(headers, (void const   *)"BOUNDARY", 8, (void const   *)pv___0,
                         ep - pv___0);
              }
            }
            tmp___12 = __builtin_strchr((char *)ep, ';');
            ep = (char const   *)tmp___12;
            if (! ((unsigned int )ep != (unsigned int )((void *)0))) {
              break;
            }
          }
        } else {
          tmp___13 = strlen(pv___0);
          tcmapput(headers, (void const   *)"TYPE", 4, (void const   *)pv___0, (int )tmp___13);
        }
      }
      pv___0 = tcmapget2((TCMAP const   *)headers, "content-disposition");
      if ((unsigned int )pv___0 != (unsigned int )((void *)0)) {
        tmp___15 = __builtin_strchr((char *)pv___0, ';');
        ep___0 = tmp___15;
        if (ep___0) {
          tcmapput(headers, (void const   *)"DISPOSITION", 11, (void const   *)pv___0,
                   ep___0 - (char *)pv___0);
          while (1) {
            ep___0 ++;
            while ((int )*(ep___0 + 0) == 32) {
              ep___0 ++;
            }
            tmp___17 = tcstrifwm((char const   *)ep___0, "filename=");
            if (tmp___17) {
              ep___0 += 9;
              if ((int )*(ep___0 + 0) == 34) {
                ep___0 ++;
              }
              pv___0 = (char const   *)ep___0;
              while (1) {
                if ((int )*(ep___0 + 0) != 0) {
                  if (! ((int )*(ep___0 + 0) != 34)) {
                    break;
                  }
                } else {
                  break;
                }
                ep___0 ++;
              }
              tcmapput(headers, (void const   *)"FILENAME", 8, (void const   *)pv___0,
                       ep___0 - (char *)pv___0);
            } else {
              tmp___16 = tcstrifwm((char const   *)ep___0, "name=");
              if (tmp___16) {
                ep___0 += 5;
                if ((int )*(ep___0 + 0) == 34) {
                  ep___0 ++;
                }
                pv___0 = (char const   *)ep___0;
                while (1) {
                  if ((int )*(ep___0 + 0) != 0) {
                    if (! ((int )*(ep___0 + 0) != 34)) {
                      break;
                    }
                  } else {
                    break;
                  }
                  ep___0 ++;
                }
                tcmapput(headers, (void const   *)"NAME", 4, (void const   *)pv___0,
                         ep___0 - (char *)pv___0);
              }
            }
            tmp___19 = __builtin_strchr(ep___0, ';');
            ep___0 = tmp___19;
            if (! ((unsigned int )ep___0 != (unsigned int )((void *)0))) {
              break;
            }
          }
        } else {
          tmp___20 = strlen(pv___0);
          tcmapput(headers, (void const   *)"DISPOSITION", 11, (void const   *)pv___0,
                   (int )tmp___20);
        }
      }
    }
  }
  *sp = size;
  while (1) {
    while (1) {
      tmp___21 = malloc((unsigned int )(size + 1));
      rv = (char *)tmp___21;
      if (! rv) {
        tcmyfatal("out of memory");
      }
      break;
    }
    memcpy((void * __restrict  )rv, (void const   * __restrict  )ptr, (unsigned int )size);
    *(rv + size) = (char )'\000';
    break;
  }
  return (rv);
}
}
TCLIST *tcmimeparts(char const   *ptr , int size , char const   *boundary ) 
{ TCLIST *list ;
  TCLIST *tmp ;
  int blen ;
  size_t tmp___0 ;
  char const   *pv ;
  int i ;
  _Bool tmp___1 ;
  char *tmp___3 ;
  int i___0 ;
  char const   *ep ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___4 ;
  void *tmp___5 ;
  TCLISTDATUM *array ;
  char *tmp___6 ;
  void *tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___10 ;

  {
  tmp = tclistnew();
  list = tmp;
  tmp___0 = strlen(boundary);
  blen = (int )tmp___0;
  if (blen < 1) {
    return (list);
  }
  pv = (char const   *)((void *)0);
  i = 0;
  while (i < size) {
    if ((int const   )*(ptr + i) == 45) {
      if ((int const   )*(ptr + (i + 1)) == 45) {
        if ((i + 2) + blen < size) {
          tmp___1 = tcstrfwm((ptr + i) + 2, boundary);
          if (tmp___1) {
            tmp___3 = __builtin_strchr((char *)"\t\n\v\f\r ", (int )*(ptr + ((i + 2) + blen)));
            if (tmp___3) {
              pv = ((ptr + i) + 2) + blen;
              if ((int const   )*pv == 13) {
                pv ++;
              }
              if ((int const   )*pv == 10) {
                pv ++;
              }
              size -= pv - ptr;
              ptr = pv;
              break;
            }
          }
        }
      }
    }
    i ++;
  }
  if (! pv) {
    return (list);
  }
  i___0 = 0;
  while (i___0 < size) {
    if ((int const   )*(ptr + i___0) == 45) {
      if ((int const   )*(ptr + (i___0 + 1)) == 45) {
        if ((i___0 + 2) + blen < size) {
          tmp___8 = tcstrfwm((ptr + i___0) + 2, boundary);
          if (tmp___8) {
            tmp___10 = __builtin_strchr((char *)"\t\n\v\f\r -", (int )*(ptr + ((i___0 + 2) + blen)));
            if (tmp___10) {
              ep = ptr + i___0;
              if ((unsigned int )ep > (unsigned int )ptr) {
                if ((int const   )*(ep + -1) == 10) {
                  ep --;
                }
              }
              if ((unsigned int )ep > (unsigned int )ptr) {
                if ((int const   )*(ep + -1) == 13) {
                  ep --;
                }
              }
              if ((unsigned int )ep > (unsigned int )pv) {
                while (1) {
                  TC_mysize = ep - pv;
                  TC_index = list->start + list->num;
                  if (TC_index >= list->anum) {
                    list->anum += list->num + 1;
                    while (1) {
                      tmp___5 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
                      tmp___4 = (TCLISTDATUM *)tmp___5;
                      list->array = tmp___4;
                      if (! tmp___4) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                  }
                  array = list->array;
                  while (1) {
                    tmp___7 = malloc((unsigned int )(TC_mysize + 1));
                    tmp___6 = (char *)tmp___7;
                    (array + TC_index)->ptr = tmp___6;
                    if (! tmp___6) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                  memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )pv,
                         (unsigned int )TC_mysize);
                  *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
                  (array + TC_index)->size = TC_mysize;
                  (list->num) ++;
                  break;
                }
              }
              pv = ((ptr + i___0) + 2) + blen;
              if ((int const   )*pv == 13) {
                pv ++;
              }
              if ((int const   )*pv == 10) {
                pv ++;
              }
            }
          }
        }
      }
    }
    i___0 ++;
  }
  return (list);
}
}
char *tchexencode(char const   *ptr , int size ) 
{ unsigned char const   *rp ;
  char *buf ;
  void *tmp ;
  char *wp ;
  int i ;
  int tmp___0 ;

  {
  rp = (unsigned char const   *)ptr;
  while (1) {
    tmp = malloc((unsigned int )(size * 2 + 1));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  i = 0;
  while (i < size) {
    tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"%02x",
                      *(rp + i));
    wp += tmp___0;
    i ++;
  }
  *wp = (char )'\000';
  return (buf);
}
}
char *tchexdecode(char const   *str , int *sp ) 
{ int len ;
  size_t tmp ;
  char *buf ;
  void *tmp___0 ;
  char *wp ;
  int i ;
  int num ;
  int c ;
  char *tmp___1 ;

  {
  tmp = strlen(str);
  len = (int )tmp;
  while (1) {
    tmp___0 = malloc((unsigned int )(len + 1));
    buf = (char *)tmp___0;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  i = 0;
  while (i < len) {
    while (1) {
      if ((int const   )*(str + i) >= 0) {
        if (! ((int const   )*(str + i) <= 32)) {
          break;
        }
      } else {
        break;
      }
      i ++;
    }
    num = 0;
    c = (int )*(str + i);
    if (c == 0) {
      break;
    }
    if (c >= 48) {
      if (c <= 57) {
        num = c - 48;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: 
      if (c >= 97) {
        if (c <= 102) {
          num = (c - 97) + 10;
        } else {
          goto _L___0;
        }
      } else {
        _L___0: 
        if (c >= 65) {
          if (c <= 70) {
            num = (c - 65) + 10;
          } else {
            goto _L;
          }
        } else {
          _L: 
          if (c == 0) {
            break;
          }
        }
      }
    }
    c = (int )*(str + (i + 1));
    if (c >= 48) {
      if (c <= 57) {
        num = (num * 16 + c) - 48;
      } else {
        goto _L___4;
      }
    } else {
      _L___4: 
      if (c >= 97) {
        if (c <= 102) {
          num = ((num * 16 + c) - 97) + 10;
        } else {
          goto _L___3;
        }
      } else {
        _L___3: 
        if (c >= 65) {
          if (c <= 70) {
            num = ((num * 16 + c) - 65) + 10;
          } else {
            goto _L___2;
          }
        } else {
          _L___2: 
          if (c == 0) {
            break;
          }
        }
      }
    }
    tmp___1 = wp;
    wp ++;
    *tmp___1 = (char )num;
    i += 2;
  }
  *wp = (char )'\000';
  *sp = wp - buf;
  return (buf);
}
}
char *tcpackencode(char const   *ptr , int size , int *sp ) 
{ char *buf ;
  void *tmp ;
  char *wp ;
  char const   *end ;
  char *sp___0 ;
  char const   *rp ;
  int step ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  while (1) {
    tmp = malloc((unsigned int )(size * 2 + 1));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  end = ptr + size;
  while ((unsigned int )ptr < (unsigned int )end) {
    sp___0 = wp;
    rp = ptr + 1;
    step = 1;
    while (1) {
      if ((unsigned int )rp < (unsigned int )end) {
        if (step < 127) {
          if (! ((int const   )*rp == (int const   )*ptr)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      step ++;
      rp ++;
    }
    if (step <= 1) {
      if ((unsigned int )rp < (unsigned int )end) {
        wp = sp___0 + 1;
        tmp___0 = wp;
        wp ++;
        *tmp___0 = (char )*ptr;
        while (1) {
          if ((unsigned int )rp < (unsigned int )end) {
            if (step < 127) {
              if (! ((int const   )*rp != (int const   )*(rp - 1))) {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
          tmp___1 = wp;
          wp ++;
          *tmp___1 = (char )*rp;
          step ++;
          rp ++;
        }
        if ((unsigned int )rp < (unsigned int )end) {
          if ((int const   )*(rp - 1) == (int const   )*rp) {
            wp --;
            rp --;
            step --;
          }
        }
        if (step == 1) {
          *sp___0 = (char)1;
        } else {
          *sp___0 = (char )(- step);
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      tmp___2 = wp;
      wp ++;
      *tmp___2 = (char )step;
      tmp___3 = wp;
      wp ++;
      *tmp___3 = (char )*ptr;
    }
    ptr += step;
  }
  *sp = wp - buf;
  return (buf);
}
}
char *tcpackdecode(char const   *ptr , int size , int *sp ) 
{ int asiz ;
  char *buf ;
  void *tmp ;
  int wi ;
  char const   *end ;
  int step ;
  int tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  char const   *tmp___3 ;

  {
  asiz = size * 3;
  while (1) {
    tmp = malloc((unsigned int )(asiz + 1));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wi = 0;
  end = ptr + size;
  while ((unsigned int )ptr < (unsigned int )end) {
    tmp___0 = abs((int )*ptr);
    step = tmp___0;
    if (wi + step >= asiz) {
      asiz = asiz * 2 + step;
      while (1) {
        tmp___1 = realloc((void *)buf, (unsigned int )(asiz + 1));
        buf = (char *)tmp___1;
        if (! buf) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    tmp___3 = ptr;
    ptr ++;
    if ((int const   )*tmp___3 >= 0) {
      memset((void *)(buf + wi), (int )*ptr, (unsigned int )step);
      ptr ++;
    } else {
      tmp___2 = tclmin((long )step, (long )(end - ptr));
      step = (int )tmp___2;
      memcpy((void * __restrict  )(buf + wi), (void const   * __restrict  )ptr, (unsigned int )step);
      ptr += step;
    }
    wi += step;
  }
  *(buf + wi) = (char )'\000';
  *sp = wi;
  return (buf);
}
}
char *tcdeflate(char const   *ptr , int size , int *sp ) 
{ char *tmp ;

  {
  if (! _tc_deflate) {
    return ((char *)((void *)0));
  }
  tmp = (*_tc_deflate)(ptr, size, sp, 0);
  return (tmp);
}
}
char *tcinflate(char const   *ptr , int size , int *sp ) 
{ char *tmp ;

  {
  if (! _tc_inflate) {
    return ((char *)((void *)0));
  }
  tmp = (*_tc_inflate)(ptr, size, sp, 0);
  return (tmp);
}
}
char *tcgzipencode(char const   *ptr , int size , int *sp ) 
{ char *tmp ;

  {
  if (! _tc_deflate) {
    return ((char *)((void *)0));
  }
  tmp = (*_tc_deflate)(ptr, size, sp, 2);
  return (tmp);
}
}
char *tcgzipdecode(char const   *ptr , int size , int *sp ) 
{ char *tmp ;

  {
  if (! _tc_inflate) {
    return ((char *)((void *)0));
  }
  tmp = (*_tc_inflate)(ptr, size, sp, 2);
  return (tmp);
}
}
unsigned int tcgetcrc(char const   *ptr , int size ) 
{ unsigned int tmp ;

  {
  if (! _tc_getcrc) {
    return (0U);
  }
  tmp = (*_tc_getcrc)(ptr, size);
  return (tmp);
}
}
char *tcbzipencode(char const   *ptr , int size , int *sp ) 
{ char *tmp ;

  {
  if (! _tc_bzcompress) {
    return ((char *)((void *)0));
  }
  tmp = (*_tc_bzcompress)(ptr, size, sp);
  return (tmp);
}
}
char *tcbzipdecode(char const   *ptr , int size , int *sp ) 
{ char *tmp ;

  {
  if (! _tc_bzdecompress) {
    return ((char *)((void *)0));
  }
  tmp = (*_tc_bzdecompress)(ptr, size, sp);
  return (tmp);
}
}
char *tcberencode(unsigned int const   *ary , int anum , int *sp ) 
{ char *buf ;
  void *tmp ;
  char *wp ;
  int i ;
  unsigned int num ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  while (1) {
    tmp = malloc((unsigned int )(anum * ((int )sizeof(int ) + 1) + 1));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  i = 0;
  while (i < anum) {
    num = (unsigned int )*(ary + i);
    if (num < (unsigned int )(1 << 7)) {
      tmp___0 = wp;
      wp ++;
      *tmp___0 = (char )num;
    } else {
      if (num < (unsigned int )(1 << 14)) {
        tmp___1 = wp;
        wp ++;
        *tmp___1 = (char )((num >> 7) | 128U);
        tmp___2 = wp;
        wp ++;
        *tmp___2 = (char )(num & 127U);
      } else {
        if (num < (unsigned int )(1 << 21)) {
          tmp___3 = wp;
          wp ++;
          *tmp___3 = (char )((num >> 14) | 128U);
          tmp___4 = wp;
          wp ++;
          *tmp___4 = (char )(((num >> 7) & 127U) | 128U);
          tmp___5 = wp;
          wp ++;
          *tmp___5 = (char )(num & 127U);
        } else {
          if (num < (unsigned int )(1 << 28)) {
            tmp___6 = wp;
            wp ++;
            *tmp___6 = (char )((num >> 21) | 128U);
            tmp___7 = wp;
            wp ++;
            *tmp___7 = (char )(((num >> 14) & 127U) | 128U);
            tmp___8 = wp;
            wp ++;
            *tmp___8 = (char )(((num >> 7) & 127U) | 128U);
            tmp___9 = wp;
            wp ++;
            *tmp___9 = (char )(num & 127U);
          } else {
            tmp___10 = wp;
            wp ++;
            *tmp___10 = (char )((num >> 28) | 128U);
            tmp___11 = wp;
            wp ++;
            *tmp___11 = (char )(((num >> 21) & 127U) | 128U);
            tmp___12 = wp;
            wp ++;
            *tmp___12 = (char )(((num >> 14) & 127U) | 128U);
            tmp___13 = wp;
            wp ++;
            *tmp___13 = (char )(((num >> 7) & 127U) | 128U);
            tmp___14 = wp;
            wp ++;
            *tmp___14 = (char )(num & 127U);
          }
        }
      }
    }
    i ++;
  }
  *sp = wp - buf;
  return (buf);
}
}
unsigned int *tcberdecode(char const   *ptr , int size , int *np ) 
{ unsigned int *buf ;
  void *tmp ;
  unsigned int *wp ;
  unsigned int num ;
  int c ;
  unsigned int *tmp___0 ;

  {
  while (1) {
    tmp = malloc((unsigned int )(size * (int )sizeof(*buf) + 1));
    buf = (unsigned int *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  while (size > 0) {
    num = 0U;
    while (1) {
      c = (int )*((unsigned char *)ptr);
      num = num * 128U + (unsigned int )(c & 127);
      ptr ++;
      size --;
      if (c >= 128) {
        if (! (size > 0)) {
          break;
        }
      } else {
        break;
      }
    }
    tmp___0 = wp;
    wp ++;
    *tmp___0 = num;
  }
  *np = wp - buf;
  return (buf);
}
}
char *tcxmlescape(char const   *str ) 
{ char const   *rp ;
  int bsiz ;
  char *buf ;
  void *tmp ;
  char *wp ;
  char *tmp___0 ;

  {
  rp = str;
  bsiz = 0;
  while ((int const   )*rp != 0) {
    switch ((int )*rp) {
    case 38: 
    bsiz += 5;
    break;
    case 60: 
    bsiz += 4;
    break;
    case 62: 
    bsiz += 4;
    break;
    case 34: 
    bsiz += 6;
    break;
    default: 
    bsiz ++;
    break;
    }
    rp ++;
  }
  while (1) {
    tmp = malloc((unsigned int )(bsiz + 1));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  while ((int const   )*str != 0) {
    switch ((int )*str) {
    case 38: 
    memcpy((void * __restrict  )wp, (void const   * __restrict  )"&amp;", 5U);
    wp += 5;
    break;
    case 60: 
    memcpy((void * __restrict  )wp, (void const   * __restrict  )"&lt;", 4U);
    wp += 4;
    break;
    case 62: 
    memcpy((void * __restrict  )wp, (void const   * __restrict  )"&gt;", 4U);
    wp += 4;
    break;
    case 34: 
    memcpy((void * __restrict  )wp, (void const   * __restrict  )"&quot;", 6U);
    wp += 6;
    break;
    default: 
    tmp___0 = wp;
    wp ++;
    *tmp___0 = (char )*str;
    break;
    }
    str ++;
  }
  *wp = (char )'\000';
  return (buf);
}
}
char *tcxmlunescape(char const   *str ) 
{ char *buf ;
  size_t tmp ;
  void *tmp___0 ;
  char *wp ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  char *tmp___11 ;
  char const   *tmp___12 ;

  {
  while (1) {
    tmp = strlen(str);
    tmp___0 = malloc(tmp + 1U);
    buf = (char *)tmp___0;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  while ((int const   )*str != 0) {
    if ((int const   )*str == 38) {
      tmp___10 = tcstrfwm(str, "&amp;");
      if (tmp___10) {
        tmp___1 = wp;
        wp ++;
        *tmp___1 = (char )'&';
        str += 5;
      } else {
        tmp___9 = tcstrfwm(str, "&lt;");
        if (tmp___9) {
          tmp___2 = wp;
          wp ++;
          *tmp___2 = (char )'<';
          str += 4;
        } else {
          tmp___8 = tcstrfwm(str, "&gt;");
          if (tmp___8) {
            tmp___3 = wp;
            wp ++;
            *tmp___3 = (char )'>';
            str += 4;
          } else {
            tmp___7 = tcstrfwm(str, "&quot;");
            if (tmp___7) {
              tmp___4 = wp;
              wp ++;
              *tmp___4 = (char )'\"';
              str += 6;
            } else {
              tmp___5 = wp;
              wp ++;
              tmp___6 = str;
              str ++;
              *tmp___5 = (char )*tmp___6;
            }
          }
        }
      }
    } else {
      tmp___11 = wp;
      wp ++;
      tmp___12 = str;
      str ++;
      *tmp___11 = (char )*tmp___12;
    }
  }
  *wp = (char )'\000';
  return (buf);
}
}
char *tcwwwformencode(TCMAP const   *params ) 
{ TCXSTR *xstr ;
  uint64_t tmp ;
  TCXSTR *tmp___0 ;
  TCMAPREC *cur ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___1 ;
  char *kenc ;
  char *tmp___2 ;
  char *venc ;
  char *tmp___3 ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___4 ;
  void *tmp___5 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___6 ;
  void *tmp___7 ;
  void const   *tmp___8 ;
  void *tmp___9 ;

  {
  tmp = tcmaprnum(params);
  tmp___0 = tcxstrnew3((int )((tmp * 12ULL) * 3ULL + 1ULL));
  xstr = tmp___0;
  cur = (TCMAPREC *)params->cur;
  tcmapiterinit((TCMAP *)params);
  while (1) {
    tmp___8 = tcmapiternext((TCMAP *)params, & ksiz);
    kbuf = (char const   *)tmp___8;
    if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
      break;
    }
    tmp___1 = tcmapiterval((void const   *)kbuf, & vsiz);
    vbuf = (char const   *)tmp___1;
    tmp___2 = tcurlencode(kbuf, ksiz);
    kenc = tmp___2;
    tmp___3 = tcurlencode(vbuf, vsiz);
    venc = tmp___3;
    if (xstr->size > 0) {
      while (1) {
        TC_mysize = 1;
        TC_nsize = (xstr->size + TC_mysize) + 1;
        if (xstr->asize < TC_nsize) {
          while (xstr->asize < TC_nsize) {
            xstr->asize *= 2;
            if (xstr->asize < TC_nsize) {
              xstr->asize = TC_nsize;
            }
          }
          while (1) {
            tmp___5 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
            tmp___4 = (char *)tmp___5;
            xstr->ptr = tmp___4;
            if (! tmp___4) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )"&",
               (unsigned int )TC_mysize);
        xstr->size += TC_mysize;
        *(xstr->ptr + xstr->size) = (char )'\000';
        break;
      }
    }
    tcxstrcat2(xstr, (char const   *)kenc);
    while (1) {
      TC_mysize___0 = 1;
      TC_nsize___0 = (xstr->size + TC_mysize___0) + 1;
      if (xstr->asize < TC_nsize___0) {
        while (xstr->asize < TC_nsize___0) {
          xstr->asize *= 2;
          if (xstr->asize < TC_nsize___0) {
            xstr->asize = TC_nsize___0;
          }
        }
        while (1) {
          tmp___7 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
          tmp___6 = (char *)tmp___7;
          xstr->ptr = tmp___6;
          if (! tmp___6) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )"=",
             (unsigned int )TC_mysize___0);
      xstr->size += TC_mysize___0;
      *(xstr->ptr + xstr->size) = (char )'\000';
      break;
    }
    tcxstrcat2(xstr, (char const   *)venc);
    while (1) {
      free((void *)venc);
      break;
    }
    while (1) {
      free((void *)kenc);
      break;
    }
  }
  ((TCMAP *)params)->cur = cur;
  tmp___9 = tcxstrtomalloc(xstr);
  return ((char *)tmp___9);
}
}
void tcwwwformdecode(char const   *str , TCMAP *params ) 
{ size_t tmp ;

  {
  tmp = strlen(str);
  tcwwwformdecode2((void const   *)str, (int )tmp, (char const   *)((void *)0), params);
  return;
}
}
void tcwwwformdecode2(void const   *ptr , int size , char const   *type , TCMAP *params ) 
{ char const   *brd ;
  char *tmp ;
  char *bstr ;
  char *tmp___0 ;
  char *wp ;
  char *tmp___2 ;
  char *tmp___4 ;
  TCLIST *parts ;
  TCLIST *tmp___5 ;
  int pnum ;
  int tmp___6 ;
  int i ;
  int psiz ;
  char const   *part ;
  void const   *tmp___7 ;
  TCMAP *hmap ;
  TCMAP *tmp___8 ;
  int bsiz ;
  char *body ;
  char *tmp___9 ;
  int nsiz ;
  char const   *name ;
  void const   *tmp___10 ;
  char numbuf[32] ;
  char const   *tenc ;
  char const   *tmp___11 ;
  char *ebuf ;
  char *tmp___12 ;
  char *ebuf___0 ;
  char *tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  char const   *fname ;
  char const   *tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *key ;
  unsigned int __lengthofkey ;
  void *tmp___19 ;
  char const   *rp ;
  char const   *pv ;
  char const   *ep ;
  char stack[16384] ;
  int len ;
  char *rbuf ;
  void *tmp___20 ;
  char *sep ;
  char *tmp___22 ;
  char *tmp___23 ;
  int ksiz ;
  char *kbuf ;
  char *tmp___24 ;
  int vsiz ;
  char *vbuf ;
  char *tmp___25 ;
  _Bool tmp___26 ;
  int len___0 ;
  char *rbuf___0 ;
  void *tmp___27 ;
  char *sep___0 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int ksiz___0 ;
  char *kbuf___0 ;
  char *tmp___31 ;
  int vsiz___0 ;
  char *vbuf___0 ;
  char *tmp___32 ;
  _Bool tmp___33 ;
  char const   *tmp___34 ;
  _Bool tmp___35 ;

  {
  if (type) {
    tmp___34 = tcstrskipspc(type);
    tmp___35 = tcstrfwm(tmp___34, "multipart/");
    if (tmp___35) {
      tmp = strstr(type, "boundary=");
      brd = (char const   *)tmp;
      if (brd) {
        brd += 9;
        if ((int const   )*brd == 34) {
          brd ++;
        }
        tmp___0 = tcstrdup((void const   *)brd);
        bstr = tmp___0;
        tmp___2 = __builtin_strchr(bstr, ';');
        wp = tmp___2;
        if (wp) {
          *wp = (char )'\000';
        }
        tmp___4 = __builtin_strchr(bstr, '\"');
        wp = tmp___4;
        if (wp) {
          *wp = (char )'\000';
        }
        tmp___5 = tcmimeparts((char const   *)ptr, size, (char const   *)bstr);
        parts = tmp___5;
        tmp___6 = tclistnum((TCLIST const   *)parts);
        pnum = tmp___6;
        i = 0;
        while (i < pnum) {
          tmp___7 = tclistval((TCLIST const   *)parts, i, & psiz);
          part = (char const   *)tmp___7;
          tmp___8 = tcmapnew2(31U);
          hmap = tmp___8;
          tmp___9 = tcmimebreak(part, psiz, hmap, & bsiz);
          body = tmp___9;
          tmp___10 = tcmapget((TCMAP const   *)hmap, (void const   *)"NAME", 4, & nsiz);
          name = (char const   *)tmp___10;
          if (! name) {
            nsiz = sprintf((char * __restrict  )(numbuf), (char const   * __restrict  )"part:%d",
                           i + 1);
            name = (char const   *)(numbuf);
          }
          tmp___11 = tcmapget2((TCMAP const   *)hmap, "content-transfer-encoding");
          tenc = tmp___11;
          if (tenc) {
            tmp___15 = tcstrifwm(tenc, "base64");
            if (tmp___15) {
              tmp___12 = tcbasedecode((char const   *)body, & bsiz);
              ebuf = tmp___12;
              while (1) {
                free((void *)body);
                break;
              }
              body = ebuf;
            } else {
              tmp___14 = tcstrifwm(tenc, "quoted-printable");
              if (tmp___14) {
                tmp___13 = tcquotedecode((char const   *)body, & bsiz);
                ebuf___0 = tmp___13;
                while (1) {
                  free((void *)body);
                  break;
                }
                body = ebuf___0;
              }
            }
          }
          tcmapputkeep(params, (void const   *)name, nsiz, (void const   *)body, bsiz);
          tmp___16 = tcmapget2((TCMAP const   *)hmap, "FILENAME");
          fname = tmp___16;
          if (fname) {
            if ((int const   )*fname == 47) {
              tmp___17 = strrchr(fname, '/');
              fname = (char const   *)(tmp___17 + 1);
            } else {
              if ((int const   )*fname >= 97) {
                if ((int const   )*fname <= 122) {
                  goto _L;
                } else {
                  goto _L___0;
                }
              } else {
                _L___0: 
                if ((int const   )*fname >= 65) {
                  if ((int const   )*fname <= 90) {
                    _L: 
                    if ((int const   )*(fname + 1) == 58) {
                      if ((int const   )*(fname + 2) == 92) {
                        tmp___18 = strrchr(fname, '\\');
                        fname = (char const   *)(tmp___18 + 1);
                      }
                    }
                  }
                }
              }
            }
            if ((int const   )*fname != 0) {
              __lengthofkey = (unsigned int )(nsiz + 10);
              tmp___19 = __builtin_alloca(sizeof(*key) * __lengthofkey);
              key = (char *)tmp___19;
              sprintf((char * __restrict  )key, (char const   * __restrict  )"%s_filename",
                      name);
              tcmapput2(params, (char const   *)key, fname);
            }
          }
          tcfree((void *)body);
          tcmapdel(hmap);
          i ++;
        }
        tclistdel(parts);
        tcfree((void *)bstr);
      }
    } else {
      goto _L___2;
    }
  } else {
    _L___2: 
    rp = (char const   *)ptr;
    pv = rp;
    ep = rp + size;
    while ((unsigned int )rp < (unsigned int )ep) {
      if ((int const   )*rp == 38) {
        goto _L___1;
      } else {
        if ((int const   )*rp == 59) {
          _L___1: 
          if ((unsigned int )rp > (unsigned int )pv) {
            len = rp - pv;
            if (len < (int )sizeof(stack)) {
              rbuf = stack;
            } else {
              while (1) {
                tmp___20 = malloc((unsigned int )(len + 1));
                rbuf = (char *)tmp___20;
                if (! rbuf) {
                  tcmyfatal("out of memory");
                }
                break;
              }
            }
            memcpy((void * __restrict  )rbuf, (void const   * __restrict  )pv, (unsigned int )len);
            *(rbuf + len) = (char )'\000';
            tmp___22 = __builtin_strchr(rbuf, '=');
            sep = tmp___22;
            if (sep) {
              tmp___23 = sep;
              sep ++;
              *tmp___23 = (char )'\000';
            } else {
              sep = (char *)"";
            }
            tmp___24 = tcurldecode((char const   *)rbuf, & ksiz);
            kbuf = tmp___24;
            tmp___25 = tcurldecode((char const   *)sep, & vsiz);
            vbuf = tmp___25;
            tmp___26 = tcmapputkeep(params, (void const   *)kbuf, ksiz, (void const   *)vbuf,
                                    vsiz);
            if (! tmp___26) {
              tcmapputcat(params, (void const   *)kbuf, ksiz, (void const   *)"",
                          1);
              tcmapputcat(params, (void const   *)kbuf, ksiz, (void const   *)vbuf,
                          vsiz);
            }
            while (1) {
              free((void *)vbuf);
              break;
            }
            while (1) {
              free((void *)kbuf);
              break;
            }
            if ((unsigned int )rbuf != (unsigned int )(stack)) {
              while (1) {
                free((void *)rbuf);
                break;
              }
            }
          }
          pv = rp + 1;
        }
      }
      rp ++;
    }
    if ((unsigned int )rp > (unsigned int )pv) {
      len___0 = rp - pv;
      if (len___0 < (int )sizeof(stack)) {
        rbuf___0 = stack;
      } else {
        while (1) {
          tmp___27 = malloc((unsigned int )(len___0 + 1));
          rbuf___0 = (char *)tmp___27;
          if (! rbuf___0) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )rbuf___0, (void const   * __restrict  )pv, (unsigned int )len___0);
      *(rbuf___0 + len___0) = (char )'\000';
      tmp___29 = __builtin_strchr(rbuf___0, '=');
      sep___0 = tmp___29;
      if (sep___0) {
        tmp___30 = sep___0;
        sep___0 ++;
        *tmp___30 = (char )'\000';
      } else {
        sep___0 = (char *)"";
      }
      tmp___31 = tcurldecode((char const   *)rbuf___0, & ksiz___0);
      kbuf___0 = tmp___31;
      tmp___32 = tcurldecode((char const   *)sep___0, & vsiz___0);
      vbuf___0 = tmp___32;
      tmp___33 = tcmapputkeep(params, (void const   *)kbuf___0, ksiz___0, (void const   *)vbuf___0,
                              vsiz___0);
      if (! tmp___33) {
        tcmapputcat(params, (void const   *)kbuf___0, ksiz___0, (void const   *)"",
                    1);
        tcmapputcat(params, (void const   *)kbuf___0, ksiz___0, (void const   *)vbuf___0,
                    vsiz___0);
      }
      while (1) {
        free((void *)vbuf___0);
        break;
      }
      while (1) {
        free((void *)kbuf___0);
        break;
      }
      if ((unsigned int )rbuf___0 != (unsigned int )(stack)) {
        while (1) {
          free((void *)rbuf___0);
          break;
        }
      }
    }
  }
  return;
}
}
TCLIST *tcxmlbreak(char const   *str ) 
{ TCLIST *list ;
  TCLIST *tmp ;
  int i ;
  int pv ;
  _Bool tag ;
  char *ep ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___0 ;
  void *tmp___1 ;
  TCLISTDATUM *array ;
  char *tmp___2 ;
  void *tmp___3 ;
  int TC_mysize___0 ;
  int TC_index___0 ;
  TCLISTDATUM *tmp___4 ;
  void *tmp___5 ;
  TCLISTDATUM *array___0 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int TC_mysize___1 ;
  int TC_index___1 ;
  TCLISTDATUM *tmp___8 ;
  void *tmp___9 ;
  TCLISTDATUM *array___1 ;
  char *tmp___10 ;
  void *tmp___11 ;
  int TC_mysize___2 ;
  int TC_index___2 ;
  TCLISTDATUM *tmp___12 ;
  void *tmp___13 ;
  TCLISTDATUM *array___2 ;
  char *tmp___14 ;
  void *tmp___15 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___16 ;
  int TC_mysize___3 ;
  int TC_nsize ;
  char *tmp___17 ;
  void *tmp___18 ;
  int TC_mysize___4 ;
  int TC_nsize___0 ;
  char *tmp___19 ;
  void *tmp___20 ;
  int TC_mysize___5 ;
  int TC_nsize___1 ;
  char *tmp___21 ;
  void *tmp___22 ;
  int TC_mysize___6 ;
  int TC_nsize___2 ;
  char *tmp___23 ;
  void *tmp___24 ;
  int TC_mysize___7 ;
  int TC_index___3 ;
  TCLISTDATUM *tmp___25 ;
  void *tmp___26 ;
  TCLISTDATUM *array___3 ;
  char *tmp___27 ;
  void *tmp___28 ;
  int TC_mysize___8 ;
  int TC_index___4 ;
  TCLISTDATUM *tmp___29 ;
  void *tmp___30 ;
  TCLISTDATUM *array___4 ;
  char *tmp___31 ;
  void *tmp___32 ;
  _Bool tmp___33 ;
  int TC_mysize___9 ;
  int TC_index___5 ;
  TCLISTDATUM *tmp___34 ;
  void *tmp___35 ;
  TCLISTDATUM *array___5 ;
  char *tmp___36 ;
  void *tmp___37 ;

  {
  tmp = tclistnew();
  list = tmp;
  i = 0;
  pv = 0;
  tag = (_Bool)0;
  while (1) {
    if ((int const   )*(str + i) == 0) {
      if (i > pv) {
        while (1) {
          TC_mysize = i - pv;
          TC_index = list->start + list->num;
          if (TC_index >= list->anum) {
            list->anum += list->num + 1;
            while (1) {
              tmp___1 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
              tmp___0 = (TCLISTDATUM *)tmp___1;
              list->array = tmp___0;
              if (! tmp___0) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          array = list->array;
          while (1) {
            tmp___3 = malloc((unsigned int )(TC_mysize + 1));
            tmp___2 = (char *)tmp___3;
            (array + TC_index)->ptr = tmp___2;
            if (! tmp___2) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )(str + pv),
                 (unsigned int )TC_mysize);
          *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
          (array + TC_index)->size = TC_mysize;
          (list->num) ++;
          break;
        }
      }
      break;
    } else {
      if (! tag) {
        if ((int const   )*(str + i) == 60) {
          if ((int const   )*(str + (i + 1)) == 33) {
            if ((int const   )*(str + (i + 2)) == 45) {
              if ((int const   )*(str + (i + 3)) == 45) {
                if (i > pv) {
                  while (1) {
                    TC_mysize___0 = i - pv;
                    TC_index___0 = list->start + list->num;
                    if (TC_index___0 >= list->anum) {
                      list->anum += list->num + 1;
                      while (1) {
                        tmp___5 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
                        tmp___4 = (TCLISTDATUM *)tmp___5;
                        list->array = tmp___4;
                        if (! tmp___4) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    array___0 = list->array;
                    while (1) {
                      tmp___7 = malloc((unsigned int )(TC_mysize___0 + 1));
                      tmp___6 = (char *)tmp___7;
                      (array___0 + TC_index___0)->ptr = tmp___6;
                      if (! tmp___6) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )(array___0 + TC_index___0)->ptr, (void const   * __restrict  )(str + pv),
                           (unsigned int )TC_mysize___0);
                    *((array___0 + TC_index___0)->ptr + TC_mysize___0) = (char )'\000';
                    (array___0 + TC_index___0)->size = TC_mysize___0;
                    (list->num) ++;
                    break;
                  }
                }
                ep = strstr(str + i, "-->");
                if ((unsigned int )ep != (unsigned int )((void *)0)) {
                  while (1) {
                    TC_mysize___1 = ((ep - (char *)str) - i) + 3;
                    TC_index___1 = list->start + list->num;
                    if (TC_index___1 >= list->anum) {
                      list->anum += list->num + 1;
                      while (1) {
                        tmp___9 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
                        tmp___8 = (TCLISTDATUM *)tmp___9;
                        list->array = tmp___8;
                        if (! tmp___8) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    array___1 = list->array;
                    while (1) {
                      tmp___11 = malloc((unsigned int )(TC_mysize___1 + 1));
                      tmp___10 = (char *)tmp___11;
                      (array___1 + TC_index___1)->ptr = tmp___10;
                      if (! tmp___10) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )(array___1 + TC_index___1)->ptr, (void const   * __restrict  )(str + i),
                           (unsigned int )TC_mysize___1);
                    *((array___1 + TC_index___1)->ptr + TC_mysize___1) = (char )'\000';
                    (array___1 + TC_index___1)->size = TC_mysize___1;
                    (list->num) ++;
                    break;
                  }
                  i = (ep - (char *)str) + 2;
                  pv = i + 1;
                }
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          } else {
            _L___2: 
            if ((int const   )*(str + (i + 1)) == 33) {
              if ((int const   )*(str + (i + 2)) == 91) {
                tmp___33 = tcstrifwm(str + i, "<![CDATA[");
                if (tmp___33) {
                  if (i > pv) {
                    while (1) {
                      TC_mysize___2 = i - pv;
                      TC_index___2 = list->start + list->num;
                      if (TC_index___2 >= list->anum) {
                        list->anum += list->num + 1;
                        while (1) {
                          tmp___13 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
                          tmp___12 = (TCLISTDATUM *)tmp___13;
                          list->array = tmp___12;
                          if (! tmp___12) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                      }
                      array___2 = list->array;
                      while (1) {
                        tmp___15 = malloc((unsigned int )(TC_mysize___2 + 1));
                        tmp___14 = (char *)tmp___15;
                        (array___2 + TC_index___2)->ptr = tmp___14;
                        if (! tmp___14) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                      memcpy((void * __restrict  )(array___2 + TC_index___2)->ptr,
                             (void const   * __restrict  )(str + pv), (unsigned int )TC_mysize___2);
                      *((array___2 + TC_index___2)->ptr + TC_mysize___2) = (char )'\000';
                      (array___2 + TC_index___2)->size = TC_mysize___2;
                      (list->num) ++;
                      break;
                    }
                  }
                  ep = strstr(str + i, "]]>");
                  if ((unsigned int )ep != (unsigned int )((void *)0)) {
                    i += 9;
                    tmp___16 = tcxstrnew();
                    xstr = tmp___16;
                    while ((unsigned int )(str + i) < (unsigned int )ep) {
                      if ((int const   )*(str + i) == 38) {
                        while (1) {
                          TC_mysize___3 = 5;
                          TC_nsize = (xstr->size + TC_mysize___3) + 1;
                          if (xstr->asize < TC_nsize) {
                            while (xstr->asize < TC_nsize) {
                              xstr->asize *= 2;
                              if (xstr->asize < TC_nsize) {
                                xstr->asize = TC_nsize;
                              }
                            }
                            while (1) {
                              tmp___18 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                              tmp___17 = (char *)tmp___18;
                              xstr->ptr = tmp___17;
                              if (! tmp___17) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                          }
                          memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )"&amp;",
                                 (unsigned int )TC_mysize___3);
                          xstr->size += TC_mysize___3;
                          *(xstr->ptr + xstr->size) = (char )'\000';
                          break;
                        }
                      } else {
                        if ((int const   )*(str + i) == 60) {
                          while (1) {
                            TC_mysize___4 = 4;
                            TC_nsize___0 = (xstr->size + TC_mysize___4) + 1;
                            if (xstr->asize < TC_nsize___0) {
                              while (xstr->asize < TC_nsize___0) {
                                xstr->asize *= 2;
                                if (xstr->asize < TC_nsize___0) {
                                  xstr->asize = TC_nsize___0;
                                }
                              }
                              while (1) {
                                tmp___20 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                                tmp___19 = (char *)tmp___20;
                                xstr->ptr = tmp___19;
                                if (! tmp___19) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                            }
                            memcpy((void * __restrict  )(xstr->ptr + xstr->size),
                                   (void const   * __restrict  )"&lt;", (unsigned int )TC_mysize___4);
                            xstr->size += TC_mysize___4;
                            *(xstr->ptr + xstr->size) = (char )'\000';
                            break;
                          }
                        } else {
                          if ((int const   )*(str + i) == 62) {
                            while (1) {
                              TC_mysize___5 = 4;
                              TC_nsize___1 = (xstr->size + TC_mysize___5) + 1;
                              if (xstr->asize < TC_nsize___1) {
                                while (xstr->asize < TC_nsize___1) {
                                  xstr->asize *= 2;
                                  if (xstr->asize < TC_nsize___1) {
                                    xstr->asize = TC_nsize___1;
                                  }
                                }
                                while (1) {
                                  tmp___22 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                                  tmp___21 = (char *)tmp___22;
                                  xstr->ptr = tmp___21;
                                  if (! tmp___21) {
                                    tcmyfatal("out of memory");
                                  }
                                  break;
                                }
                              }
                              memcpy((void * __restrict  )(xstr->ptr + xstr->size),
                                     (void const   * __restrict  )"&gt;", (unsigned int )TC_mysize___5);
                              xstr->size += TC_mysize___5;
                              *(xstr->ptr + xstr->size) = (char )'\000';
                              break;
                            }
                          } else {
                            while (1) {
                              TC_mysize___6 = 1;
                              TC_nsize___2 = (xstr->size + TC_mysize___6) + 1;
                              if (xstr->asize < TC_nsize___2) {
                                while (xstr->asize < TC_nsize___2) {
                                  xstr->asize *= 2;
                                  if (xstr->asize < TC_nsize___2) {
                                    xstr->asize = TC_nsize___2;
                                  }
                                }
                                while (1) {
                                  tmp___24 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                                  tmp___23 = (char *)tmp___24;
                                  xstr->ptr = tmp___23;
                                  if (! tmp___23) {
                                    tcmyfatal("out of memory");
                                  }
                                  break;
                                }
                              }
                              memcpy((void * __restrict  )(xstr->ptr + xstr->size),
                                     (void const   * __restrict  )(str + i), (unsigned int )TC_mysize___6);
                              xstr->size += TC_mysize___6;
                              *(xstr->ptr + xstr->size) = (char )'\000';
                              break;
                            }
                          }
                        }
                      }
                      i ++;
                    }
                    if (xstr->size > 0) {
                      while (1) {
                        TC_mysize___7 = xstr->size;
                        TC_index___3 = list->start + list->num;
                        if (TC_index___3 >= list->anum) {
                          list->anum += list->num + 1;
                          while (1) {
                            tmp___26 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
                            tmp___25 = (TCLISTDATUM *)tmp___26;
                            list->array = tmp___25;
                            if (! tmp___25) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___3 = list->array;
                        while (1) {
                          tmp___28 = malloc((unsigned int )(TC_mysize___7 + 1));
                          tmp___27 = (char *)tmp___28;
                          (array___3 + TC_index___3)->ptr = tmp___27;
                          if (! tmp___27) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___3 + TC_index___3)->ptr,
                               (void const   * __restrict  )xstr->ptr, (unsigned int )TC_mysize___7);
                        *((array___3 + TC_index___3)->ptr + TC_mysize___7) = (char )'\000';
                        (array___3 + TC_index___3)->size = TC_mysize___7;
                        (list->num) ++;
                        break;
                      }
                    }
                    tcxstrdel(xstr);
                    i = (ep - (char *)str) + 2;
                    pv = i + 1;
                  }
                } else {
                  goto _L___0;
                }
              } else {
                goto _L___0;
              }
            } else {
              _L___0: 
              if (i > pv) {
                while (1) {
                  TC_mysize___8 = i - pv;
                  TC_index___4 = list->start + list->num;
                  if (TC_index___4 >= list->anum) {
                    list->anum += list->num + 1;
                    while (1) {
                      tmp___30 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
                      tmp___29 = (TCLISTDATUM *)tmp___30;
                      list->array = tmp___29;
                      if (! tmp___29) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                  }
                  array___4 = list->array;
                  while (1) {
                    tmp___32 = malloc((unsigned int )(TC_mysize___8 + 1));
                    tmp___31 = (char *)tmp___32;
                    (array___4 + TC_index___4)->ptr = tmp___31;
                    if (! tmp___31) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                  memcpy((void * __restrict  )(array___4 + TC_index___4)->ptr, (void const   * __restrict  )(str + pv),
                         (unsigned int )TC_mysize___8);
                  *((array___4 + TC_index___4)->ptr + TC_mysize___8) = (char )'\000';
                  (array___4 + TC_index___4)->size = TC_mysize___8;
                  (list->num) ++;
                  break;
                }
              }
              tag = (_Bool)1;
              pv = i;
            }
          }
        } else {
          goto _L___3;
        }
      } else {
        _L___3: 
        if (tag) {
          if ((int const   )*(str + i) == 62) {
            if (i > pv) {
              while (1) {
                TC_mysize___9 = (i - pv) + 1;
                TC_index___5 = list->start + list->num;
                if (TC_index___5 >= list->anum) {
                  list->anum += list->num + 1;
                  while (1) {
                    tmp___35 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
                    tmp___34 = (TCLISTDATUM *)tmp___35;
                    list->array = tmp___34;
                    if (! tmp___34) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                }
                array___5 = list->array;
                while (1) {
                  tmp___37 = malloc((unsigned int )(TC_mysize___9 + 1));
                  tmp___36 = (char *)tmp___37;
                  (array___5 + TC_index___5)->ptr = tmp___36;
                  if (! tmp___36) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
                memcpy((void * __restrict  )(array___5 + TC_index___5)->ptr, (void const   * __restrict  )(str + pv),
                       (unsigned int )TC_mysize___9);
                *((array___5 + TC_index___5)->ptr + TC_mysize___9) = (char )'\000';
                (array___5 + TC_index___5)->size = TC_mysize___9;
                (list->num) ++;
                break;
              }
            }
            tag = (_Bool)0;
            pv = i + 1;
          }
        }
      }
    }
    i ++;
  }
  return (list);
}
}
TCMAP *tcxmlattrs(char const   *str ) 
{ TCMAP *map ;
  TCMAP *tmp ;
  unsigned char const   *rp ;
  unsigned char const   *key ;
  int ksiz ;
  unsigned char const   *val ;
  int vsiz ;
  char *copy ;
  void *tmp___0 ;
  char *raw ;
  char *tmp___1 ;
  size_t tmp___2 ;

  {
  tmp = tcmapnew2(31U);
  map = tmp;
  rp = (unsigned char const   *)((unsigned char *)str);
  while (1) {
    if (! ((int const   )*rp == 60)) {
      if (! ((int const   )*rp == 47)) {
        if (! ((int const   )*rp == 63)) {
          if (! ((int const   )*rp == 33)) {
            if (! ((int const   )*rp == 32)) {
              break;
            }
          }
        }
      }
    }
    rp ++;
  }
  key = rp;
  while (1) {
    if ((int const   )*rp > 32) {
      if ((int const   )*rp != 47) {
        if (! ((int const   )*rp != 62)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    rp ++;
  }
  tcmapputkeep(map, (void const   *)"", 0, (void const   *)((char *)key), rp - key);
  while ((int const   )*rp != 0) {
    while (1) {
      if ((int const   )*rp != 0) {
        if (! ((int const   )*rp <= 32)) {
          if (! ((int const   )*rp == 47)) {
            if (! ((int const   )*rp == 63)) {
              if (! ((int const   )*rp == 62)) {
                break;
              }
            }
          }
        }
      } else {
        break;
      }
      rp ++;
    }
    key = rp;
    while (1) {
      if ((int const   )*rp > 32) {
        if ((int const   )*rp != 47) {
          if ((int const   )*rp != 62) {
            if (! ((int const   )*rp != 61)) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      rp ++;
    }
    ksiz = rp - key;
    while (1) {
      if ((int const   )*rp != 0) {
        if (! ((int const   )*rp == 61)) {
          if (! ((int const   )*rp <= 32)) {
            break;
          }
        }
      } else {
        break;
      }
      rp ++;
    }
    if ((int const   )*rp == 34) {
      rp ++;
      val = rp;
      while (1) {
        if ((int const   )*rp != 0) {
          if (! ((int const   )*rp != 34)) {
            break;
          }
        } else {
          break;
        }
        rp ++;
      }
      vsiz = rp - val;
    } else {
      if ((int const   )*rp == 39) {
        rp ++;
        val = rp;
        while (1) {
          if ((int const   )*rp != 0) {
            if (! ((int const   )*rp != 39)) {
              break;
            }
          } else {
            break;
          }
          rp ++;
        }
        vsiz = rp - val;
      } else {
        val = rp;
        while (1) {
          if ((int const   )*rp > 32) {
            if ((int const   )*rp != 34) {
              if ((int const   )*rp != 39) {
                if (! ((int const   )*rp != 62)) {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
          } else {
            break;
          }
          rp ++;
        }
        vsiz = rp - val;
      }
    }
    if ((int const   )*rp != 0) {
      rp ++;
    }
    if (ksiz > 0) {
      while (1) {
        while (1) {
          tmp___0 = malloc((unsigned int )(vsiz + 1));
          copy = (char *)tmp___0;
          if (! copy) {
            tcmyfatal("out of memory");
          }
          break;
        }
        memcpy((void * __restrict  )copy, (void const   * __restrict  )val, (unsigned int )vsiz);
        *(copy + vsiz) = (char )'\000';
        break;
      }
      tmp___1 = tcxmlunescape((char const   *)copy);
      raw = tmp___1;
      tmp___2 = strlen((char const   *)raw);
      tcmapputkeep(map, (void const   *)((char *)key), ksiz, (void const   *)raw,
                   (int )tmp___2);
      while (1) {
        free((void *)raw);
        break;
      }
      while (1) {
        free((void *)copy);
        break;
      }
    }
  }
  return (map);
}
}
char *tccstrescape(char const   *str ) 
{ int asiz ;
  char *buf ;
  void *tmp ;
  int wi ;
  _Bool hex ;
  int c ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  asiz = 24;
  while (1) {
    tmp = malloc((unsigned int )(asiz + 4));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wi = 0;
  hex = (_Bool)0;
  while (1) {
    c = (int )*((unsigned char *)str);
    if (! (c != 0)) {
      break;
    }
    if (wi >= asiz) {
      asiz *= 2;
      while (1) {
        tmp___0 = realloc((void *)buf, (unsigned int )(asiz + 4));
        buf = (char *)tmp___0;
        if (! buf) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    if (c < 32) {
      goto _L___1;
    } else {
      if (c == 127) {
        goto _L___1;
      } else {
        if (c == 34) {
          goto _L___1;
        } else {
          if (c == 39) {
            goto _L___1;
          } else {
            if (c == 92) {
              _L___1: 
              switch (c) {
              case 9: 
              tmp___1 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\t");
              wi += tmp___1;
              break;
              case 10: 
              tmp___2 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\n");
              wi += tmp___2;
              break;
              case 13: 
              tmp___3 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\r");
              wi += tmp___3;
              break;
              case 92: 
              tmp___4 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\\\");
              wi += tmp___4;
              break;
              default: 
              tmp___5 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\x%02X",
                                c);
              wi += tmp___5;
              hex = (_Bool)1;
              break;
              }
            } else {
              if (hex) {
                if (c >= 48) {
                  if (c <= 57) {
                    tmp___6 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\x%02X",
                                      c);
                    wi += tmp___6;
                    hex = (_Bool)1;
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: 
                  if (c >= 65) {
                    if (c <= 70) {
                      tmp___6 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\x%02X",
                                        c);
                      wi += tmp___6;
                      hex = (_Bool)1;
                    } else {
                      goto _L;
                    }
                  } else {
                    _L: 
                    if (c >= 97) {
                      if (c <= 102) {
                        tmp___6 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\x%02X",
                                          c);
                        wi += tmp___6;
                        hex = (_Bool)1;
                      } else {
                        tmp___7 = wi;
                        wi ++;
                        *(buf + tmp___7) = (char )c;
                        hex = (_Bool)0;
                      }
                    } else {
                      tmp___7 = wi;
                      wi ++;
                      *(buf + tmp___7) = (char )c;
                      hex = (_Bool)0;
                    }
                  }
                }
              } else {
                tmp___7 = wi;
                wi ++;
                *(buf + tmp___7) = (char )c;
                hex = (_Bool)0;
              }
            }
          }
        }
      }
    }
    str ++;
  }
  *(buf + wi) = (char )'\000';
  return (buf);
}
}
char *tccstrunescape(char const   *str ) 
{ int asiz ;
  char *buf ;
  void *tmp ;
  int wi ;
  int c ;
  void *tmp___0 ;
  int si ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int code ;
  int i ;
  int tmp___8 ;
  int len ;
  int tmp___9 ;
  int code___0 ;
  int i___0 ;
  uint16_t ary[1] ;
  int tmp___10 ;
  int code___1 ;
  int i___1 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  asiz = 24;
  while (1) {
    tmp = malloc((unsigned int )(asiz + 4));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wi = 0;
  while (1) {
    c = (int )*((unsigned char *)str);
    if (! (c != 0)) {
      break;
    }
    if (wi >= asiz) {
      asiz *= 2;
      while (1) {
        tmp___0 = realloc((void *)buf, (unsigned int )(asiz + 4));
        buf = (char *)tmp___0;
        if (! buf) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    if (c == 92) {
      if ((int const   )*(str + 1) != 0) {
        str ++;
        si = wi;
        switch ((int )*str) {
        case 97: 
        tmp___1 = wi;
        wi ++;
        *(buf + tmp___1) = (char )'\a';
        break;
        case 98: 
        tmp___2 = wi;
        wi ++;
        *(buf + tmp___2) = (char )'\b';
        break;
        case 116: 
        tmp___3 = wi;
        wi ++;
        *(buf + tmp___3) = (char )'\t';
        break;
        case 110: 
        tmp___4 = wi;
        wi ++;
        *(buf + tmp___4) = (char )'\n';
        break;
        case 118: 
        tmp___5 = wi;
        wi ++;
        *(buf + tmp___5) = (char )'\v';
        break;
        case 102: 
        tmp___6 = wi;
        wi ++;
        *(buf + tmp___6) = (char )'\f';
        break;
        case 114: 
        tmp___7 = wi;
        wi ++;
        *(buf + tmp___7) = (char )'\r';
        break;
        }
        if (si == wi) {
          c = (int )*str;
          if (c == 120) {
            str ++;
            code = 0;
            i = 0;
            while (i < 2) {
              c = (int )*str;
              if (c >= 48) {
                if (c <= 57) {
                  code = (code * 16 + c) - 48;
                } else {
                  goto _L___0;
                }
              } else {
                _L___0: 
                if (c >= 65) {
                  if (c <= 70) {
                    code = ((code * 16 + c) - 65) + 10;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: 
                  if (c >= 97) {
                    if (c <= 102) {
                      code = ((code * 16 + c) - 97) + 10;
                    } else {
                      break;
                    }
                  } else {
                    break;
                  }
                }
              }
              str ++;
              i ++;
            }
            tmp___8 = wi;
            wi ++;
            *(buf + tmp___8) = (char )code;
          } else {
            if (c == 117) {
              goto _L___4;
            } else {
              if (c == 85) {
                _L___4: 
                if (c == 85) {
                  tmp___9 = 8;
                } else {
                  tmp___9 = 4;
                }
                len = tmp___9;
                str ++;
                code___0 = 0;
                i___0 = 0;
                while (i___0 < len) {
                  c = (int )*str;
                  if (c >= 48) {
                    if (c <= 57) {
                      code___0 = (code___0 * 16 + c) - 48;
                    } else {
                      goto _L___2;
                    }
                  } else {
                    _L___2: 
                    if (c >= 65) {
                      if (c <= 70) {
                        code___0 = ((code___0 * 16 + c) - 65) + 10;
                      } else {
                        goto _L___1;
                      }
                    } else {
                      _L___1: 
                      if (c >= 97) {
                        if (c <= 102) {
                          code___0 = ((code___0 * 16 + c) - 97) + 10;
                        } else {
                          break;
                        }
                      } else {
                        break;
                      }
                    }
                  }
                  str ++;
                  i___0 ++;
                }
                ary[0] = (unsigned short )code___0;
                tmp___10 = tcstrucstoutf((uint16_t const   *)(ary), 1, buf + wi);
                wi += tmp___10;
              } else {
                if (c >= 48) {
                  if (c <= 56) {
                    code___1 = 0;
                    i___1 = 0;
                    while (i___1 < 3) {
                      c = (int )*str;
                      if (c >= 48) {
                        if (c <= 55) {
                          code___1 = (code___1 * 8 + c) - 48;
                        } else {
                          break;
                        }
                      } else {
                        break;
                      }
                      str ++;
                      i___1 ++;
                    }
                    tmp___11 = wi;
                    wi ++;
                    *(buf + tmp___11) = (char )code___1;
                  } else {
                    goto _L___3;
                  }
                } else {
                  _L___3: 
                  if (c != 0) {
                    tmp___12 = wi;
                    wi ++;
                    *(buf + tmp___12) = (char )c;
                    str ++;
                  }
                }
              }
            }
          }
        } else {
          str ++;
        }
      } else {
        tmp___13 = wi;
        wi ++;
        *(buf + tmp___13) = (char )c;
        str ++;
      }
    } else {
      tmp___13 = wi;
      wi ++;
      *(buf + tmp___13) = (char )c;
      str ++;
    }
  }
  *(buf + wi) = (char )'\000';
  return (buf);
}
}
char *tcjsonescape(char const   *str ) 
{ int asiz ;
  char *buf ;
  void *tmp ;
  int wi ;
  int c ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  asiz = 24;
  while (1) {
    tmp = malloc((unsigned int )(asiz + 6));
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wi = 0;
  while (1) {
    c = (int )*((unsigned char *)str);
    if (! (c != 0)) {
      break;
    }
    if (wi >= asiz) {
      asiz *= 2;
      while (1) {
        tmp___0 = realloc((void *)buf, (unsigned int )(asiz + 6));
        buf = (char *)tmp___0;
        if (! buf) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    if (c < 32) {
      goto _L;
    } else {
      if (c == 127) {
        goto _L;
      } else {
        if (c == 34) {
          goto _L;
        } else {
          if (c == 39) {
            goto _L;
          } else {
            if (c == 92) {
              _L: 
              switch (c) {
              case 9: 
              tmp___1 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\t");
              wi += tmp___1;
              break;
              case 10: 
              tmp___2 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\n");
              wi += tmp___2;
              break;
              case 13: 
              tmp___3 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\r");
              wi += tmp___3;
              break;
              case 92: 
              tmp___4 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\\\");
              wi += tmp___4;
              break;
              default: 
              tmp___5 = sprintf((char * __restrict  )(buf + wi), (char const   * __restrict  )"\\u%04X",
                                c);
              wi += tmp___5;
              break;
              }
            } else {
              tmp___6 = wi;
              wi ++;
              *(buf + tmp___6) = (char )c;
            }
          }
        }
      }
    }
    str ++;
  }
  *(buf + wi) = (char )'\000';
  return (buf);
}
}
char *tcjsonunescape(char const   *str ) 
{ char *tmp ;

  {
  tmp = tccstrunescape(str);
  return (tmp);
}
}
static TCLIST *tctmpltokenize(char const   *expr ) ;
static int tctmpldumpeval(TCXSTR *xstr , char const   *expr , TCLIST const   *elems ,
                          int cur , int num , TCMAP const   **stack , int depth ) ;
static char const   *tctmpldumpevalvar(TCMAP const   **stack , int depth , char const   *name ,
                                       int *sp , int *np ) ;
TCTMPL *tctmplnew(void) 
{ TCTMPL *tmpl ;
  void *tmp ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*tmpl)));
    tmpl = (TCTMPL *)tmp;
    if (! tmpl) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tmpl->elems = (TCLIST *)((void *)0);
  tmpl->begsep = (char *)((void *)0);
  tmpl->endsep = (char *)((void *)0);
  tmpl->conf = tcmapnew2(31U);
  return (tmpl);
}
}
void tctmpldel(TCTMPL *tmpl ) 
{ 

  {
  tcmapdel(tmpl->conf);
  if (tmpl->endsep) {
    while (1) {
      free((void *)tmpl->endsep);
      break;
    }
  }
  if (tmpl->begsep) {
    while (1) {
      free((void *)tmpl->begsep);
      break;
    }
  }
  if (tmpl->elems) {
    tclistdel(tmpl->elems);
  }
  while (1) {
    free((void *)tmpl);
    break;
  }
  return;
}
}
void tctmplsetsep(TCTMPL *tmpl , char const   *begsep , char const   *endsep ) 
{ 

  {
  if (tmpl->endsep) {
    while (1) {
      free((void *)tmpl->endsep);
      break;
    }
  }
  if (tmpl->begsep) {
    while (1) {
      free((void *)tmpl->begsep);
      break;
    }
  }
  tmpl->begsep = tcstrdup((void const   *)begsep);
  tmpl->endsep = tcstrdup((void const   *)endsep);
  return;
}
}
void tctmplload(TCTMPL *tmpl , char const   *str ) 
{ char const   *begsep ;
  char const   *endsep ;
  int beglen ;
  size_t tmp ;
  int endlen ;
  size_t tmp___0 ;
  int begchr ;
  int endchr ;
  TCLIST *elems ;
  TCLIST *tmp___1 ;
  char const   *rp ;
  char const   *pv ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___2 ;
  void *tmp___3 ;
  TCLISTDATUM *array ;
  char *tmp___4 ;
  void *tmp___5 ;
  _Bool chop ;
  char const   *sp ;
  int TC_mysize___0 ;
  int TC_index___0 ;
  TCLISTDATUM *tmp___6 ;
  void *tmp___7 ;
  TCLISTDATUM *array___0 ;
  char *tmp___8 ;
  void *tmp___9 ;
  char const   *sp___0 ;
  int TC_mysize___1 ;
  int TC_index___1 ;
  TCLISTDATUM *tmp___10 ;
  void *tmp___11 ;
  TCLISTDATUM *array___1 ;
  char *tmp___12 ;
  void *tmp___13 ;
  char const   *ep ;
  int len ;
  char *buf ;
  void *tmp___14 ;
  char const   *expr ;
  TCLIST *tokens ;
  TCLIST *tmp___15 ;
  int tnum ;
  char const   *name ;
  char const   *value ;
  char const   *tmp___16 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  _Bool tmp___24 ;
  _Bool tmp___25 ;
  _Bool tmp___26 ;
  int TC_mysize___2 ;
  int TC_index___2 ;
  TCLISTDATUM *tmp___27 ;
  void *tmp___28 ;
  TCLISTDATUM *array___2 ;
  char *tmp___29 ;
  void *tmp___30 ;

  {
  begsep = (char const   *)tmpl->begsep;
  if (! begsep) {
    begsep = "[%";
  }
  endsep = (char const   *)tmpl->endsep;
  if (! endsep) {
    endsep = "%]";
  }
  tmp = strlen(begsep);
  beglen = (int )tmp;
  tmp___0 = strlen(endsep);
  endlen = (int )tmp___0;
  if (beglen < 1) {
    return;
  } else {
    if (endlen < 1) {
      return;
    }
  }
  begchr = (int )*begsep;
  endchr = (int )*endsep;
  if (tmpl->elems) {
    tclistdel(tmpl->elems);
  }
  tcmapclear(tmpl->conf);
  tmp___1 = tclistnew();
  elems = tmp___1;
  rp = str;
  pv = rp;
  while ((int const   )*rp != 0) {
    if ((int const   )*rp == (int const   )begchr) {
      tmp___26 = tcstrfwm(rp, begsep);
      if (tmp___26) {
        if ((unsigned int )rp > (unsigned int )pv) {
          while (1) {
            TC_mysize = rp - pv;
            TC_index = elems->start + elems->num;
            if (TC_index >= elems->anum) {
              elems->anum += elems->num + 1;
              while (1) {
                tmp___3 = realloc((void *)elems->array, (unsigned int )(elems->anum * (int )sizeof(*(elems->array + 0))));
                tmp___2 = (TCLISTDATUM *)tmp___3;
                elems->array = tmp___2;
                if (! tmp___2) {
                  tcmyfatal("out of memory");
                }
                break;
              }
            }
            array = elems->array;
            while (1) {
              tmp___5 = malloc((unsigned int )(TC_mysize + 1));
              tmp___4 = (char *)tmp___5;
              (array + TC_index)->ptr = tmp___4;
              if (! tmp___4) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )pv,
                   (unsigned int )TC_mysize);
            *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
            (array + TC_index)->size = TC_mysize;
            (elems->num) ++;
            break;
          }
        }
        rp += beglen;
        pv = rp;
        while ((int const   )*rp != 0) {
          if ((int const   )*rp == (int const   )endchr) {
            tmp___25 = tcstrfwm(rp, endsep);
            if (tmp___25) {
              chop = (_Bool)0;
              while (1) {
                if ((unsigned int )pv < (unsigned int )rp) {
                  if ((int const   )*pv > 0) {
                    if (! ((int const   )*pv <= 32)) {
                      break;
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
                pv ++;
              }
              if ((int const   )*pv == 34) {
                pv ++;
                sp = pv;
                while (1) {
                  if ((unsigned int )pv < (unsigned int )rp) {
                    if (! ((int const   )*pv != 34)) {
                      break;
                    }
                  } else {
                    break;
                  }
                  pv ++;
                }
                if ((unsigned int )pv > (unsigned int )sp) {
                  while (1) {
                    TC_mysize___0 = pv - sp;
                    TC_index___0 = elems->start + elems->num;
                    if (TC_index___0 >= elems->anum) {
                      elems->anum += elems->num + 1;
                      while (1) {
                        tmp___7 = realloc((void *)elems->array, (unsigned int )(elems->anum * (int )sizeof(*(elems->array + 0))));
                        tmp___6 = (TCLISTDATUM *)tmp___7;
                        elems->array = tmp___6;
                        if (! tmp___6) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    array___0 = elems->array;
                    while (1) {
                      tmp___9 = malloc((unsigned int )(TC_mysize___0 + 1));
                      tmp___8 = (char *)tmp___9;
                      (array___0 + TC_index___0)->ptr = tmp___8;
                      if (! tmp___8) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )(array___0 + TC_index___0)->ptr, (void const   * __restrict  )sp,
                           (unsigned int )TC_mysize___0);
                    *((array___0 + TC_index___0)->ptr + TC_mysize___0) = (char )'\000';
                    (array___0 + TC_index___0)->size = TC_mysize___0;
                    (elems->num) ++;
                    break;
                  }
                }
              } else {
                if ((int const   )*pv == 39) {
                  pv ++;
                  sp___0 = pv;
                  while (1) {
                    if ((unsigned int )pv < (unsigned int )rp) {
                      if (! ((int const   )*pv != 39)) {
                        break;
                      }
                    } else {
                      break;
                    }
                    pv ++;
                  }
                  if ((unsigned int )pv > (unsigned int )sp___0) {
                    while (1) {
                      TC_mysize___1 = pv - sp___0;
                      TC_index___1 = elems->start + elems->num;
                      if (TC_index___1 >= elems->anum) {
                        elems->anum += elems->num + 1;
                        while (1) {
                          tmp___11 = realloc((void *)elems->array, (unsigned int )(elems->anum * (int )sizeof(*(elems->array + 0))));
                          tmp___10 = (TCLISTDATUM *)tmp___11;
                          elems->array = tmp___10;
                          if (! tmp___10) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                      }
                      array___1 = elems->array;
                      while (1) {
                        tmp___13 = malloc((unsigned int )(TC_mysize___1 + 1));
                        tmp___12 = (char *)tmp___13;
                        (array___1 + TC_index___1)->ptr = tmp___12;
                        if (! tmp___12) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                      memcpy((void * __restrict  )(array___1 + TC_index___1)->ptr,
                             (void const   * __restrict  )sp___0, (unsigned int )TC_mysize___1);
                      *((array___1 + TC_index___1)->ptr + TC_mysize___1) = (char )'\000';
                      (array___1 + TC_index___1)->size = TC_mysize___1;
                      (elems->num) ++;
                      break;
                    }
                  }
                } else {
                  ep = rp;
                  if ((unsigned int )ep > (unsigned int )pv) {
                    if ((int const   )*(ep + -1) == 92) {
                      ep --;
                      chop = (_Bool)1;
                    }
                  }
                  while (1) {
                    if ((unsigned int )ep > (unsigned int )pv) {
                      if (! ((int )*((unsigned char *)ep + -1) <= 32)) {
                        break;
                      }
                    } else {
                      break;
                    }
                    ep --;
                  }
                  len = ep - pv;
                  while (1) {
                    tmp___14 = malloc((unsigned int )(len + 1));
                    buf = (char *)tmp___14;
                    if (! buf) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                  *buf = (char )'\000';
                  memcpy((void * __restrict  )(buf + 1), (void const   * __restrict  )pv,
                         (unsigned int )len);
                  tclistpushmalloc(elems, (void *)buf, len + 1);
                  tmp___24 = tcstrfwm(pv, "CONF");
                  if (tmp___24) {
                    expr = (char const   *)((char *)((void *)(elems->array + ((elems->num - 1) + elems->start))->ptr) + 1);
                    tmp___15 = tctmpltokenize(expr);
                    tokens = tmp___15;
                    tnum = tokens->num;
                    if (tnum > 1) {
                      if (0) {
                        __s1_len = strlen((char const   *)((void *)(tokens->array + tokens->start)->ptr));
                        __s2_len = strlen("CONF");
                        if (! ((unsigned int )((void const   *)((void *)(tokens->array + tokens->start)->ptr + 1)) - (unsigned int )((void const   *)((void *)(tokens->array + tokens->start)->ptr)) == 1U)) {
                          goto _L___0;
                        } else {
                          if (__s1_len >= 4U) {
                            _L___0: 
                            if (! ((unsigned int )((void const   *)("CONF" + 1)) - (unsigned int )((void const   *)"CONF") == 1U)) {
                              tmp___23 = 1;
                            } else {
                              if (__s2_len >= 4U) {
                                tmp___23 = 1;
                              } else {
                                tmp___23 = 0;
                              }
                            }
                          } else {
                            tmp___23 = 0;
                          }
                        }
                        if (tmp___23) {
                          tmp___18 = __builtin_strcmp((char const   *)((void *)(tokens->array + tokens->start)->ptr),
                                                      "CONF");
                          tmp___22 = tmp___18;
                        } else {
                          tmp___21 = __builtin_strcmp((char const   *)((void *)(tokens->array + tokens->start)->ptr),
                                                      "CONF");
                          tmp___22 = tmp___21;
                        }
                      } else {
                        tmp___21 = __builtin_strcmp((char const   *)((void *)(tokens->array + tokens->start)->ptr),
                                                    "CONF");
                        tmp___22 = tmp___21;
                      }
                      if (! tmp___22) {
                        name = (char const   *)((void *)(tokens->array + (1 + tokens->start))->ptr);
                        if (tnum > 2) {
                          tmp___16 = (char const   *)((void *)(tokens->array + (2 + tokens->start))->ptr);
                        } else {
                          tmp___16 = "";
                        }
                        value = tmp___16;
                        tcmapput2(tmpl->conf, name, value);
                      }
                    }
                    tclistdel(tokens);
                  }
                }
              }
              rp += endlen;
              if (chop) {
                if ((int const   )*rp == 13) {
                  rp ++;
                }
                if ((int const   )*rp == 10) {
                  rp ++;
                }
              }
              break;
            }
          }
          rp ++;
        }
        pv = rp;
      } else {
        rp ++;
      }
    } else {
      rp ++;
    }
  }
  if ((unsigned int )rp > (unsigned int )pv) {
    while (1) {
      TC_mysize___2 = rp - pv;
      TC_index___2 = elems->start + elems->num;
      if (TC_index___2 >= elems->anum) {
        elems->anum += elems->num + 1;
        while (1) {
          tmp___28 = realloc((void *)elems->array, (unsigned int )(elems->anum * (int )sizeof(*(elems->array + 0))));
          tmp___27 = (TCLISTDATUM *)tmp___28;
          elems->array = tmp___27;
          if (! tmp___27) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array___2 = elems->array;
      while (1) {
        tmp___30 = malloc((unsigned int )(TC_mysize___2 + 1));
        tmp___29 = (char *)tmp___30;
        (array___2 + TC_index___2)->ptr = tmp___29;
        if (! tmp___29) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array___2 + TC_index___2)->ptr, (void const   * __restrict  )pv,
             (unsigned int )TC_mysize___2);
      *((array___2 + TC_index___2)->ptr + TC_mysize___2) = (char )'\000';
      (array___2 + TC_index___2)->size = TC_mysize___2;
      (elems->num) ++;
      break;
    }
  }
  tmpl->elems = elems;
  return;
}
}
_Bool tctmplload2(TCTMPL *tmpl , char const   *path ) 
{ char *str ;
  void *tmp ;

  {
  tmp = tcreadfile(path, -1, (int *)((void *)0));
  str = (char *)tmp;
  if (! str) {
    return ((_Bool)0);
  }
  tctmplload(tmpl, (char const   *)str);
  while (1) {
    free((void *)str);
    break;
  }
  return ((_Bool)1);
}
}
char *tctmpldump(TCTMPL *tmpl , TCMAP const   *vars ) 
{ TCXSTR *xstr ;
  TCXSTR *tmp ;
  TCLIST *elems ;
  TCMAP *svars ;
  TCMAP *tmp___0 ;
  int cur ;
  int num ;
  TCMAP const   *stack[256] ;
  int depth ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *elem ;
  int esiz ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  tmp = tcxstrnew3(65536);
  xstr = tmp;
  elems = tmpl->elems;
  if (elems) {
    tmp___0 = tcmapnew2(31U);
    svars = tmp___0;
    cur = 0;
    num = elems->num;
    depth = 0;
    tmp___1 = depth;
    depth ++;
    stack[tmp___1] = (TCMAP const   *)tmpl->conf;
    tmp___2 = depth;
    depth ++;
    stack[tmp___2] = (TCMAP const   *)svars;
    tmp___3 = depth;
    depth ++;
    stack[tmp___3] = vars;
    while (cur < num) {
      while (1) {
        elem = (char const   *)(elems->array + (cur + elems->start))->ptr;
        esiz = (elems->array + (cur + elems->start))->size;
        break;
      }
      if ((int const   )*elem == 0) {
        if (esiz > 0) {
          cur = tctmpldumpeval(xstr, elem + 1, (TCLIST const   *)elems, cur, num,
                               stack, depth);
        } else {
          goto _L;
        }
      } else {
        _L: 
        while (1) {
          TC_mysize = esiz;
          TC_nsize = (xstr->size + TC_mysize) + 1;
          if (xstr->asize < TC_nsize) {
            while (xstr->asize < TC_nsize) {
              xstr->asize *= 2;
              if (xstr->asize < TC_nsize) {
                xstr->asize = TC_nsize;
              }
            }
            while (1) {
              tmp___5 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
              tmp___4 = (char *)tmp___5;
              xstr->ptr = tmp___4;
              if (! tmp___4) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )elem,
                 (unsigned int )TC_mysize);
          xstr->size += TC_mysize;
          *(xstr->ptr + xstr->size) = (char )'\000';
          break;
        }
        cur ++;
      }
    }
    tcmapdel(svars);
  }
  tmp___6 = tcxstrtomalloc(xstr);
  return ((char *)tmp___6);
}
}
char const   *tctmplconf(TCTMPL *tmpl , char const   *name ) 
{ char const   *tmp ;

  {
  tmp = tcmapget2((TCMAP const   *)tmpl->conf, name);
  return (tmp);
}
}
void tclistpushlist(TCLIST *list , TCLIST const   *obj ) 
{ char vbuf[((int )sizeof("[list]\000:") - 1) + (int )sizeof(obj)] ;

  {
  memcpy((void * __restrict  )(vbuf), (void const   * __restrict  )"[list]\000:",
         (unsigned int )((int )sizeof("[list]\000:") - 1));
  memcpy((void * __restrict  )((vbuf + (int )sizeof("[list]\000:")) - 1), (void const   * __restrict  )(& obj),
         (unsigned int )((int )sizeof(obj)));
  tclistpush(list, (void const   *)(vbuf), (int )sizeof(vbuf));
  return;
}
}
void tclistpushmap(TCLIST *list , TCMAP const   *obj ) 
{ char vbuf[((int )sizeof("[map]\000:") - 1) + (int )sizeof(obj)] ;

  {
  memcpy((void * __restrict  )(vbuf), (void const   * __restrict  )"[map]\000:", (unsigned int )((int )sizeof("[map]\000:") - 1));
  memcpy((void * __restrict  )((vbuf + (int )sizeof("[map]\000:")) - 1), (void const   * __restrict  )(& obj),
         (unsigned int )((int )sizeof(obj)));
  tclistpush(list, (void const   *)(vbuf), (int )sizeof(vbuf));
  return;
}
}
void tcmapputlist(TCMAP *map , char const   *kstr , TCLIST const   *obj ) 
{ char vbuf[((int )sizeof("[list]\000:") - 1) + (int )sizeof(obj)] ;
  size_t tmp ;

  {
  memcpy((void * __restrict  )(vbuf), (void const   * __restrict  )"[list]\000:",
         (unsigned int )((int )sizeof("[list]\000:") - 1));
  memcpy((void * __restrict  )((vbuf + (int )sizeof("[list]\000:")) - 1), (void const   * __restrict  )(& obj),
         (unsigned int )((int )sizeof(obj)));
  tmp = strlen(kstr);
  tcmapput(map, (void const   *)kstr, (int )tmp, (void const   *)(vbuf), (int )sizeof(vbuf));
  return;
}
}
void tcmapputmap(TCMAP *map , char const   *kstr , TCMAP const   *obj ) 
{ char vbuf[((int )sizeof("[map]\000:") - 1) + (int )sizeof(obj)] ;
  size_t tmp ;

  {
  memcpy((void * __restrict  )(vbuf), (void const   * __restrict  )"[map]\000:", (unsigned int )((int )sizeof("[map]\000:") - 1));
  memcpy((void * __restrict  )((vbuf + (int )sizeof("[map]\000:")) - 1), (void const   * __restrict  )(& obj),
         (unsigned int )((int )sizeof(obj)));
  tmp = strlen(kstr);
  tcmapput(map, (void const   *)kstr, (int )tmp, (void const   *)(vbuf), (int )sizeof(vbuf));
  return;
}
}
static TCLIST *tctmpltokenize(char const   *expr ) 
{ TCLIST *tokens ;
  TCLIST *tmp ;
  unsigned char const   *rp ;
  unsigned char const   *pv ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___0 ;
  void *tmp___1 ;
  TCLISTDATUM *array ;
  char *tmp___2 ;
  void *tmp___3 ;
  int TC_mysize___0 ;
  int TC_index___0 ;
  TCLISTDATUM *tmp___4 ;
  void *tmp___5 ;
  TCLISTDATUM *array___0 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int TC_mysize___1 ;
  int TC_index___1 ;
  TCLISTDATUM *tmp___8 ;
  void *tmp___9 ;
  TCLISTDATUM *array___1 ;
  char *tmp___10 ;
  void *tmp___11 ;

  {
  tmp = tclistnew();
  tokens = tmp;
  rp = (unsigned char const   *)((unsigned char *)expr);
  while ((int const   )*rp != 0) {
    while (1) {
      if ((int const   )*rp > 0) {
        if (! ((int const   )*rp <= 32)) {
          break;
        }
      } else {
        break;
      }
      rp ++;
    }
    pv = rp;
    if ((int const   )*rp == 34) {
      pv ++;
      rp ++;
      while (1) {
        if ((int const   )*rp != 0) {
          if (! ((int const   )*rp != 34)) {
            break;
          }
        } else {
          break;
        }
        rp ++;
      }
      while (1) {
        TC_mysize = rp - pv;
        TC_index = tokens->start + tokens->num;
        if (TC_index >= tokens->anum) {
          tokens->anum += tokens->num + 1;
          while (1) {
            tmp___1 = realloc((void *)tokens->array, (unsigned int )(tokens->anum * (int )sizeof(*(tokens->array + 0))));
            tmp___0 = (TCLISTDATUM *)tmp___1;
            tokens->array = tmp___0;
            if (! tmp___0) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        array = tokens->array;
        while (1) {
          tmp___3 = malloc((unsigned int )(TC_mysize + 1));
          tmp___2 = (char *)tmp___3;
          (array + TC_index)->ptr = tmp___2;
          if (! tmp___2) {
            tcmyfatal("out of memory");
          }
          break;
        }
        memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )pv,
               (unsigned int )TC_mysize);
        *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
        (array + TC_index)->size = TC_mysize;
        (tokens->num) ++;
        break;
      }
      if ((int const   )*rp == 34) {
        rp ++;
      }
    } else {
      if ((int const   )*rp == 39) {
        pv ++;
        rp ++;
        while (1) {
          if ((int const   )*rp != 0) {
            if (! ((int const   )*rp != 39)) {
              break;
            }
          } else {
            break;
          }
          rp ++;
        }
        while (1) {
          TC_mysize___0 = rp - pv;
          TC_index___0 = tokens->start + tokens->num;
          if (TC_index___0 >= tokens->anum) {
            tokens->anum += tokens->num + 1;
            while (1) {
              tmp___5 = realloc((void *)tokens->array, (unsigned int )(tokens->anum * (int )sizeof(*(tokens->array + 0))));
              tmp___4 = (TCLISTDATUM *)tmp___5;
              tokens->array = tmp___4;
              if (! tmp___4) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          array___0 = tokens->array;
          while (1) {
            tmp___7 = malloc((unsigned int )(TC_mysize___0 + 1));
            tmp___6 = (char *)tmp___7;
            (array___0 + TC_index___0)->ptr = tmp___6;
            if (! tmp___6) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )(array___0 + TC_index___0)->ptr, (void const   * __restrict  )pv,
                 (unsigned int )TC_mysize___0);
          *((array___0 + TC_index___0)->ptr + TC_mysize___0) = (char )'\000';
          (array___0 + TC_index___0)->size = TC_mysize___0;
          (tokens->num) ++;
          break;
        }
        if ((int const   )*rp == 39) {
          rp ++;
        }
      } else {
        while ((int const   )*rp > 32) {
          rp ++;
        }
        if ((unsigned int )rp > (unsigned int )pv) {
          while (1) {
            TC_mysize___1 = rp - pv;
            TC_index___1 = tokens->start + tokens->num;
            if (TC_index___1 >= tokens->anum) {
              tokens->anum += tokens->num + 1;
              while (1) {
                tmp___9 = realloc((void *)tokens->array, (unsigned int )(tokens->anum * (int )sizeof(*(tokens->array + 0))));
                tmp___8 = (TCLISTDATUM *)tmp___9;
                tokens->array = tmp___8;
                if (! tmp___8) {
                  tcmyfatal("out of memory");
                }
                break;
              }
            }
            array___1 = tokens->array;
            while (1) {
              tmp___11 = malloc((unsigned int )(TC_mysize___1 + 1));
              tmp___10 = (char *)tmp___11;
              (array___1 + TC_index___1)->ptr = tmp___10;
              if (! tmp___10) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )(array___1 + TC_index___1)->ptr, (void const   * __restrict  )pv,
                   (unsigned int )TC_mysize___1);
            *((array___1 + TC_index___1)->ptr + TC_mysize___1) = (char )'\000';
            (array___1 + TC_index___1)->size = TC_mysize___1;
            (tokens->num) ++;
            break;
          }
        }
      }
    }
  }
  return (tokens);
}
}
static int tctmpldumpeval(TCXSTR *xstr , char const   *expr , TCLIST const   *elems ,
                          int cur , int num , TCMAP const   **stack , int depth ) 
{ TCLIST *tokens ;
  TCLIST *tmp ;
  int tnum ;
  char const   *cmd ;
  _Bool sign ;
  char const   *eq ;
  char const   *inc ;
  _Bool prt ;
  char const   *rx ;
  int i ;
  char const   *token ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  TCXSTR *altxstr ;
  char const   *name ;
  char const   *tmp___35 ;
  int vsiz ;
  int vnum ;
  char const   *vbuf ;
  char const   *tmp___36 ;
  char numbuf[32] ;
  _Bool bval ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___38 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  char const   *tmp___45 ;
  _Bool tmp___46 ;
  char const   *elem ;
  int esiz ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___48 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___61 ;
  void *tmp___62 ;
  TCLIST const   *list ;
  char const   *name___0 ;
  char const   *tmp___63 ;
  int vsiz___0 ;
  int vnum___0 ;
  char const   *vbuf___0 ;
  char const   *tmp___64 ;
  int tmp___65 ;
  char const   *name___1 ;
  char const   *tmp___66 ;
  TCMAP *vars ;
  TCMAP *tmp___67 ;
  int lnum ;
  int beg ;
  int i___0 ;
  char const   *vbuf___1 ;
  int vsiz___1 ;
  TCLIST *obj ;
  TCMAP *obj___0 ;
  int tmp___68 ;
  int tmp___69 ;
  char const   *elem___0 ;
  int esiz___0 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___71 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___77 ;
  void *tmp___78 ;
  char const   *elem___1 ;
  int esiz___1 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___80 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  char const   *name___2 ;
  char const   *tmp___86 ;
  char const   *value ;
  char const   *tmp___87 ;
  int vsiz___2 ;
  int vnum___1 ;
  char const   *vbuf___2 ;
  char const   *tmp___88 ;
  char numbuf___0[32] ;
  char const   *enc ;
  char const   *def ;
  int i___1 ;
  char const   *token___0 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___90 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___97 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  size_t tmp___103 ;
  char *ebuf ;
  char *tmp___104 ;
  char *ebuf___0 ;
  char *tmp___105 ;
  char *ebuf___1 ;
  char *tmp___106 ;
  char *ebuf___2 ;
  char *tmp___107 ;
  char *ebuf___3 ;
  char *tmp___108 ;
  char *ebuf___4 ;
  char *tmp___109 ;
  char *ebuf___5 ;
  char *tmp___110 ;
  char ebuf___6[48] ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___112 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___119 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___126 ;
  int tmp___129 ;
  int tmp___130 ;
  int tmp___131 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___133 ;
  int tmp___136 ;
  int tmp___137 ;
  int tmp___138 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___140 ;
  int tmp___143 ;
  int tmp___144 ;
  int tmp___145 ;
  size_t __s1_len___16 ;
  size_t __s2_len___16 ;
  int tmp___147 ;
  int tmp___150 ;
  int tmp___151 ;
  int tmp___152 ;
  size_t __s1_len___17 ;
  size_t __s2_len___17 ;
  int tmp___154 ;
  int tmp___157 ;
  int tmp___158 ;
  int tmp___159 ;
  size_t __s1_len___18 ;
  size_t __s2_len___18 ;
  int tmp___161 ;
  int tmp___164 ;
  int tmp___165 ;
  int tmp___166 ;
  size_t __s1_len___19 ;
  size_t __s2_len___19 ;
  int tmp___168 ;
  int tmp___171 ;
  int tmp___172 ;
  int tmp___173 ;
  size_t __s1_len___20 ;
  size_t __s2_len___20 ;
  int tmp___175 ;
  int tmp___178 ;
  int tmp___179 ;
  int tmp___180 ;
  size_t __s1_len___21 ;
  size_t __s2_len___21 ;
  int tmp___182 ;
  int tmp___185 ;
  int tmp___186 ;
  int tmp___187 ;

  {
  cur ++;
  tmp = tctmpltokenize(expr);
  tokens = tmp;
  tnum = tokens->num;
  if (tnum > 0) {
    cmd = (char const   *)((void *)(tokens->array + tokens->start)->ptr);
    if (0) {
      __s1_len___21 = strlen(cmd);
      __s2_len___21 = strlen("IF");
      if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
        goto _L___48;
      } else {
        if (__s1_len___21 >= 4U) {
          _L___48: 
          if (! ((unsigned int )((void const   *)("IF" + 1)) - (unsigned int )((void const   *)"IF") == 1U)) {
            tmp___187 = 1;
          } else {
            if (__s2_len___21 >= 4U) {
              tmp___187 = 1;
            } else {
              tmp___187 = 0;
            }
          }
        } else {
          tmp___187 = 0;
        }
      }
      if (tmp___187) {
        tmp___182 = __builtin_strcmp(cmd, "IF");
        tmp___186 = tmp___182;
      } else {
        tmp___185 = __builtin_strcmp(cmd, "IF");
        tmp___186 = tmp___185;
      }
    } else {
      tmp___185 = __builtin_strcmp(cmd, "IF");
      tmp___186 = tmp___185;
    }
    if (tmp___186) {
      if (0) {
        __s1_len___20 = strlen(cmd);
        __s2_len___20 = strlen("FOREACH");
        if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
          goto _L___46;
        } else {
          if (__s1_len___20 >= 4U) {
            _L___46: 
            if (! ((unsigned int )((void const   *)("FOREACH" + 1)) - (unsigned int )((void const   *)"FOREACH") == 1U)) {
              tmp___180 = 1;
            } else {
              if (__s2_len___20 >= 4U) {
                tmp___180 = 1;
              } else {
                tmp___180 = 0;
              }
            }
          } else {
            tmp___180 = 0;
          }
        }
        if (tmp___180) {
          tmp___175 = __builtin_strcmp(cmd, "FOREACH");
          tmp___179 = tmp___175;
        } else {
          tmp___178 = __builtin_strcmp(cmd, "FOREACH");
          tmp___179 = tmp___178;
        }
      } else {
        tmp___178 = __builtin_strcmp(cmd, "FOREACH");
        tmp___179 = tmp___178;
      }
      if (tmp___179) {
        if (0) {
          __s1_len___19 = strlen(cmd);
          __s2_len___19 = strlen("SET");
          if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
            goto _L___44;
          } else {
            if (__s1_len___19 >= 4U) {
              _L___44: 
              if (! ((unsigned int )((void const   *)("SET" + 1)) - (unsigned int )((void const   *)"SET") == 1U)) {
                tmp___173 = 1;
              } else {
                if (__s2_len___19 >= 4U) {
                  tmp___173 = 1;
                } else {
                  tmp___173 = 0;
                }
              }
            } else {
              tmp___173 = 0;
            }
          }
          if (tmp___173) {
            tmp___168 = __builtin_strcmp(cmd, "SET");
            tmp___172 = tmp___168;
          } else {
            tmp___171 = __builtin_strcmp(cmd, "SET");
            tmp___172 = tmp___171;
          }
        } else {
          tmp___171 = __builtin_strcmp(cmd, "SET");
          tmp___172 = tmp___171;
        }
        if (tmp___172) {
          if (xstr) {
            tmp___88 = tctmpldumpevalvar(stack, depth, cmd, & vsiz___2, & vnum___1);
            vbuf___2 = tmp___88;
            if (vbuf___2) {
              if (vnum___1 >= 0) {
                vsiz___2 = sprintf((char * __restrict  )(numbuf___0), (char const   * __restrict  )"%d",
                                   vnum___1);
                vbuf___2 = (char const   *)(numbuf___0);
              }
            }
            enc = "";
            def = (char const   *)((void *)0);
            i___1 = 1;
            while (i___1 < tnum) {
              token___0 = (char const   *)((void *)(tokens->array + (i___1 + tokens->start))->ptr);
              if (0) {
                __s1_len___10 = strlen(token___0);
                __s2_len___10 = strlen("ENC");
                if (! ((unsigned int )((void const   *)(token___0 + 1)) - (unsigned int )((void const   *)token___0) == 1U)) {
                  goto _L___26;
                } else {
                  if (__s1_len___10 >= 4U) {
                    _L___26: 
                    if (! ((unsigned int )((void const   *)("ENC" + 1)) - (unsigned int )((void const   *)"ENC") == 1U)) {
                      tmp___102 = 1;
                    } else {
                      if (__s2_len___10 >= 4U) {
                        tmp___102 = 1;
                      } else {
                        tmp___102 = 0;
                      }
                    }
                  } else {
                    tmp___102 = 0;
                  }
                }
                if (tmp___102) {
                  tmp___97 = __builtin_strcmp(token___0, "ENC");
                  tmp___101 = tmp___97;
                } else {
                  tmp___100 = __builtin_strcmp(token___0, "ENC");
                  tmp___101 = tmp___100;
                }
              } else {
                tmp___100 = __builtin_strcmp(token___0, "ENC");
                tmp___101 = tmp___100;
              }
              if (tmp___101) {
                if (0) {
                  __s1_len___9 = strlen(token___0);
                  __s2_len___9 = strlen("DEF");
                  if (! ((unsigned int )((void const   *)(token___0 + 1)) - (unsigned int )((void const   *)token___0) == 1U)) {
                    goto _L___24;
                  } else {
                    if (__s1_len___9 >= 4U) {
                      _L___24: 
                      if (! ((unsigned int )((void const   *)("DEF" + 1)) - (unsigned int )((void const   *)"DEF") == 1U)) {
                        tmp___95 = 1;
                      } else {
                        if (__s2_len___9 >= 4U) {
                          tmp___95 = 1;
                        } else {
                          tmp___95 = 0;
                        }
                      }
                    } else {
                      tmp___95 = 0;
                    }
                  }
                  if (tmp___95) {
                    tmp___90 = __builtin_strcmp(token___0, "DEF");
                    tmp___94 = tmp___90;
                  } else {
                    tmp___93 = __builtin_strcmp(token___0, "DEF");
                    tmp___94 = tmp___93;
                  }
                } else {
                  tmp___93 = __builtin_strcmp(token___0, "DEF");
                  tmp___94 = tmp___93;
                }
                if (! tmp___94) {
                  i___1 ++;
                  if (i___1 < tnum) {
                    def = (char const   *)((void *)(tokens->array + (i___1 + tokens->start))->ptr);
                  }
                }
              } else {
                i___1 ++;
                if (i___1 < tnum) {
                  enc = (char const   *)((void *)(tokens->array + (i___1 + tokens->start))->ptr);
                }
              }
              i___1 ++;
            }
            if (! vbuf___2) {
              if (def) {
                vbuf___2 = def;
                tmp___103 = strlen(def);
                vsiz___2 = (int )tmp___103;
              }
            }
            if (vbuf___2) {
              if (0) {
                __s1_len___18 = strlen(enc);
                __s2_len___18 = strlen("URL");
                if (! ((unsigned int )((void const   *)(enc + 1)) - (unsigned int )((void const   *)enc) == 1U)) {
                  goto _L___42;
                } else {
                  if (__s1_len___18 >= 4U) {
                    _L___42: 
                    if (! ((unsigned int )((void const   *)("URL" + 1)) - (unsigned int )((void const   *)"URL") == 1U)) {
                      tmp___166 = 1;
                    } else {
                      if (__s2_len___18 >= 4U) {
                        tmp___166 = 1;
                      } else {
                        tmp___166 = 0;
                      }
                    }
                  } else {
                    tmp___166 = 0;
                  }
                }
                if (tmp___166) {
                  tmp___161 = __builtin_strcmp(enc, "URL");
                  tmp___165 = tmp___161;
                } else {
                  tmp___164 = __builtin_strcmp(enc, "URL");
                  tmp___165 = tmp___164;
                }
              } else {
                tmp___164 = __builtin_strcmp(enc, "URL");
                tmp___165 = tmp___164;
              }
              if (tmp___165) {
                if (0) {
                  __s1_len___17 = strlen(enc);
                  __s2_len___17 = strlen("BASE");
                  if (! ((unsigned int )((void const   *)(enc + 1)) - (unsigned int )((void const   *)enc) == 1U)) {
                    goto _L___40;
                  } else {
                    if (__s1_len___17 >= 4U) {
                      _L___40: 
                      if (! ((unsigned int )((void const   *)("BASE" + 1)) - (unsigned int )((void const   *)"BASE") == 1U)) {
                        tmp___159 = 1;
                      } else {
                        if (__s2_len___17 >= 4U) {
                          tmp___159 = 1;
                        } else {
                          tmp___159 = 0;
                        }
                      }
                    } else {
                      tmp___159 = 0;
                    }
                  }
                  if (tmp___159) {
                    tmp___154 = __builtin_strcmp(enc, "BASE");
                    tmp___158 = tmp___154;
                  } else {
                    tmp___157 = __builtin_strcmp(enc, "BASE");
                    tmp___158 = tmp___157;
                  }
                } else {
                  tmp___157 = __builtin_strcmp(enc, "BASE");
                  tmp___158 = tmp___157;
                }
                if (tmp___158) {
                  if (0) {
                    __s1_len___16 = strlen(enc);
                    __s2_len___16 = strlen("QUOTE");
                    if (! ((unsigned int )((void const   *)(enc + 1)) - (unsigned int )((void const   *)enc) == 1U)) {
                      goto _L___38;
                    } else {
                      if (__s1_len___16 >= 4U) {
                        _L___38: 
                        if (! ((unsigned int )((void const   *)("QUOTE" + 1)) - (unsigned int )((void const   *)"QUOTE") == 1U)) {
                          tmp___152 = 1;
                        } else {
                          if (__s2_len___16 >= 4U) {
                            tmp___152 = 1;
                          } else {
                            tmp___152 = 0;
                          }
                        }
                      } else {
                        tmp___152 = 0;
                      }
                    }
                    if (tmp___152) {
                      tmp___147 = __builtin_strcmp(enc, "QUOTE");
                      tmp___151 = tmp___147;
                    } else {
                      tmp___150 = __builtin_strcmp(enc, "QUOTE");
                      tmp___151 = tmp___150;
                    }
                  } else {
                    tmp___150 = __builtin_strcmp(enc, "QUOTE");
                    tmp___151 = tmp___150;
                  }
                  if (tmp___151) {
                    if (0) {
                      __s1_len___15 = strlen(enc);
                      __s2_len___15 = strlen("HEX");
                      if (! ((unsigned int )((void const   *)(enc + 1)) - (unsigned int )((void const   *)enc) == 1U)) {
                        goto _L___36;
                      } else {
                        if (__s1_len___15 >= 4U) {
                          _L___36: 
                          if (! ((unsigned int )((void const   *)("HEX" + 1)) - (unsigned int )((void const   *)"HEX") == 1U)) {
                            tmp___145 = 1;
                          } else {
                            if (__s2_len___15 >= 4U) {
                              tmp___145 = 1;
                            } else {
                              tmp___145 = 0;
                            }
                          }
                        } else {
                          tmp___145 = 0;
                        }
                      }
                      if (tmp___145) {
                        tmp___140 = __builtin_strcmp(enc, "HEX");
                        tmp___144 = tmp___140;
                      } else {
                        tmp___143 = __builtin_strcmp(enc, "HEX");
                        tmp___144 = tmp___143;
                      }
                    } else {
                      tmp___143 = __builtin_strcmp(enc, "HEX");
                      tmp___144 = tmp___143;
                    }
                    if (tmp___144) {
                      if (0) {
                        __s1_len___14 = strlen(enc);
                        __s2_len___14 = strlen("XML");
                        if (! ((unsigned int )((void const   *)(enc + 1)) - (unsigned int )((void const   *)enc) == 1U)) {
                          goto _L___34;
                        } else {
                          if (__s1_len___14 >= 4U) {
                            _L___34: 
                            if (! ((unsigned int )((void const   *)("XML" + 1)) - (unsigned int )((void const   *)"XML") == 1U)) {
                              tmp___138 = 1;
                            } else {
                              if (__s2_len___14 >= 4U) {
                                tmp___138 = 1;
                              } else {
                                tmp___138 = 0;
                              }
                            }
                          } else {
                            tmp___138 = 0;
                          }
                        }
                        if (tmp___138) {
                          tmp___133 = __builtin_strcmp(enc, "XML");
                          tmp___137 = tmp___133;
                        } else {
                          tmp___136 = __builtin_strcmp(enc, "XML");
                          tmp___137 = tmp___136;
                        }
                      } else {
                        tmp___136 = __builtin_strcmp(enc, "XML");
                        tmp___137 = tmp___136;
                      }
                      if (tmp___137) {
                        if (0) {
                          __s1_len___13 = strlen(enc);
                          __s2_len___13 = strlen("CSTR");
                          if (! ((unsigned int )((void const   *)(enc + 1)) - (unsigned int )((void const   *)enc) == 1U)) {
                            goto _L___32;
                          } else {
                            if (__s1_len___13 >= 4U) {
                              _L___32: 
                              if (! ((unsigned int )((void const   *)("CSTR" + 1)) - (unsigned int )((void const   *)"CSTR") == 1U)) {
                                tmp___131 = 1;
                              } else {
                                if (__s2_len___13 >= 4U) {
                                  tmp___131 = 1;
                                } else {
                                  tmp___131 = 0;
                                }
                              }
                            } else {
                              tmp___131 = 0;
                            }
                          }
                          if (tmp___131) {
                            tmp___126 = __builtin_strcmp(enc, "CSTR");
                            tmp___130 = tmp___126;
                          } else {
                            tmp___129 = __builtin_strcmp(enc, "CSTR");
                            tmp___130 = tmp___129;
                          }
                        } else {
                          tmp___129 = __builtin_strcmp(enc, "CSTR");
                          tmp___130 = tmp___129;
                        }
                        if (tmp___130) {
                          if (0) {
                            __s1_len___12 = strlen(enc);
                            __s2_len___12 = strlen("JSON");
                            if (! ((unsigned int )((void const   *)(enc + 1)) - (unsigned int )((void const   *)enc) == 1U)) {
                              goto _L___30;
                            } else {
                              if (__s1_len___12 >= 4U) {
                                _L___30: 
                                if (! ((unsigned int )((void const   *)("JSON" + 1)) - (unsigned int )((void const   *)"JSON") == 1U)) {
                                  tmp___124 = 1;
                                } else {
                                  if (__s2_len___12 >= 4U) {
                                    tmp___124 = 1;
                                  } else {
                                    tmp___124 = 0;
                                  }
                                }
                              } else {
                                tmp___124 = 0;
                              }
                            }
                            if (tmp___124) {
                              tmp___119 = __builtin_strcmp(enc, "JSON");
                              tmp___123 = tmp___119;
                            } else {
                              tmp___122 = __builtin_strcmp(enc, "JSON");
                              tmp___123 = tmp___122;
                            }
                          } else {
                            tmp___122 = __builtin_strcmp(enc, "JSON");
                            tmp___123 = tmp___122;
                          }
                          if (tmp___123) {
                            if (0) {
                              __s1_len___11 = strlen(enc);
                              __s2_len___11 = strlen("MD5");
                              if (! ((unsigned int )((void const   *)(enc + 1)) - (unsigned int )((void const   *)enc) == 1U)) {
                                goto _L___28;
                              } else {
                                if (__s1_len___11 >= 4U) {
                                  _L___28: 
                                  if (! ((unsigned int )((void const   *)("MD5" + 1)) - (unsigned int )((void const   *)"MD5") == 1U)) {
                                    tmp___117 = 1;
                                  } else {
                                    if (__s2_len___11 >= 4U) {
                                      tmp___117 = 1;
                                    } else {
                                      tmp___117 = 0;
                                    }
                                  }
                                } else {
                                  tmp___117 = 0;
                                }
                              }
                              if (tmp___117) {
                                tmp___112 = __builtin_strcmp(enc, "MD5");
                                tmp___116 = tmp___112;
                              } else {
                                tmp___115 = __builtin_strcmp(enc, "MD5");
                                tmp___116 = tmp___115;
                              }
                            } else {
                              tmp___115 = __builtin_strcmp(enc, "MD5");
                              tmp___116 = tmp___115;
                            }
                            if (tmp___116) {
                              tcxstrcat2(xstr, vbuf___2);
                            } else {
                              tcmd5hash((void const   *)vbuf___2, vsiz___2, ebuf___6);
                              tcxstrcat2(xstr, (char const   *)(ebuf___6));
                            }
                          } else {
                            tmp___110 = tcjsonescape(vbuf___2);
                            ebuf___5 = tmp___110;
                            tcxstrcat2(xstr, (char const   *)ebuf___5);
                            while (1) {
                              free((void *)ebuf___5);
                              break;
                            }
                          }
                        } else {
                          tmp___109 = tccstrescape(vbuf___2);
                          ebuf___4 = tmp___109;
                          tcxstrcat2(xstr, (char const   *)ebuf___4);
                          while (1) {
                            free((void *)ebuf___4);
                            break;
                          }
                        }
                      } else {
                        tmp___108 = tcxmlescape(vbuf___2);
                        ebuf___3 = tmp___108;
                        tcxstrcat2(xstr, (char const   *)ebuf___3);
                        while (1) {
                          free((void *)ebuf___3);
                          break;
                        }
                      }
                    } else {
                      tmp___107 = tchexencode(vbuf___2, vsiz___2);
                      ebuf___2 = tmp___107;
                      tcxstrcat2(xstr, (char const   *)ebuf___2);
                      while (1) {
                        free((void *)ebuf___2);
                        break;
                      }
                    }
                  } else {
                    tmp___106 = tcquoteencode(vbuf___2, vsiz___2);
                    ebuf___1 = tmp___106;
                    tcxstrcat2(xstr, (char const   *)ebuf___1);
                    while (1) {
                      free((void *)ebuf___1);
                      break;
                    }
                  }
                } else {
                  tmp___105 = tcbaseencode(vbuf___2, vsiz___2);
                  ebuf___0 = tmp___105;
                  tcxstrcat2(xstr, (char const   *)ebuf___0);
                  while (1) {
                    free((void *)ebuf___0);
                    break;
                  }
                }
              } else {
                tmp___104 = tcurlencode(vbuf___2, vsiz___2);
                ebuf = tmp___104;
                tcxstrcat2(xstr, (char const   *)ebuf);
                while (1) {
                  free((void *)ebuf);
                  break;
                }
              }
            }
          }
        } else {
          if (xstr) {
            if (tnum > 1) {
              tmp___86 = (char const   *)((void *)(tokens->array + (1 + tokens->start))->ptr);
            } else {
              tmp___86 = "";
            }
            name___2 = tmp___86;
            if (tnum > 2) {
              tmp___87 = (char const   *)((void *)(tokens->array + (2 + tokens->start))->ptr);
            } else {
              tmp___87 = "";
            }
            value = tmp___87;
            tcmapput2((TCMAP *)*(stack + 1), name___2, value);
          }
        }
      } else {
        list = (TCLIST const   *)((void *)0);
        if (xstr) {
          if (tnum > 1) {
            tmp___63 = (char const   *)((void *)(tokens->array + (1 + tokens->start))->ptr);
          } else {
            tmp___63 = "";
          }
          name___0 = tmp___63;
          tmp___64 = tctmpldumpevalvar(stack, depth, name___0, & vsiz___0, & vnum___0);
          vbuf___0 = tmp___64;
          if (vbuf___0) {
            if (vsiz___0 == ((int )sizeof("[list]\000:") - 1) + (int )sizeof(list)) {
              tmp___65 = memcmp((void const   *)vbuf___0, (void const   *)"[list]\000:",
                                (unsigned int )((int )sizeof("[list]\000:") - 1));
              if (! tmp___65) {
                memcpy((void * __restrict  )(& list), (void const   * __restrict  )((vbuf___0 + (int )sizeof("[list]\000:")) - 1),
                       (unsigned int )((int )sizeof(list)));
              }
            }
          }
        }
        if (list) {
          if (list->num > 0) {
            if (tnum > 2) {
              tmp___66 = (char const   *)((void *)(tokens->array + (2 + tokens->start))->ptr);
            } else {
              tmp___66 = "";
            }
            name___1 = tmp___66;
            tmp___67 = tcmapnew2(1U);
            vars = tmp___67;
            if (depth < 256) {
              *(stack + depth) = (TCMAP const   *)vars;
              depth ++;
            }
            lnum = (int )list->num;
            beg = cur;
            i___0 = 0;
            while (i___0 < lnum) {
              while (1) {
                vbuf___1 = (char const   *)(list->array + (i___0 + (int )list->start))->ptr;
                vsiz___1 = (list->array + (i___0 + (int )list->start))->size;
                break;
              }
              if (vsiz___1 == ((int )sizeof("[list]\000:") - 1) + (int )sizeof(TCLIST *)) {
                tmp___69 = memcmp((void const   *)vbuf___1, (void const   *)"[list]\000:",
                                  (unsigned int )((int )sizeof("[list]\000:") - 1));
                if (tmp___69) {
                  goto _L___16;
                } else {
                  memcpy((void * __restrict  )(& obj), (void const   * __restrict  )((vbuf___1 + (int )sizeof("[list]\000:")) - 1),
                         (unsigned int )((int )sizeof(obj)));
                  tcmapputlist(vars, name___1, (TCLIST const   *)obj);
                }
              } else {
                _L___16: 
                if (vsiz___1 == ((int )sizeof("[map]\000:") - 1) + (int )sizeof(TCMAP *)) {
                  tmp___68 = memcmp((void const   *)vbuf___1, (void const   *)"[map]\000:",
                                    (unsigned int )((int )sizeof("[map]\000:") - 1));
                  if (tmp___68) {
                    tcmapput2(vars, name___1, vbuf___1);
                  } else {
                    memcpy((void * __restrict  )(& obj___0), (void const   * __restrict  )((vbuf___1 + (int )sizeof("[map]\000:")) - 1),
                           (unsigned int )((int )sizeof(obj___0)));
                    tcmapputmap(vars, name___1, (TCMAP const   *)obj___0);
                  }
                } else {
                  tcmapput2(vars, name___1, vbuf___1);
                }
              }
              cur = beg;
              while (cur < num) {
                while (1) {
                  elem___0 = (char const   *)(elems->array + (cur + (int )elems->start))->ptr;
                  esiz___0 = (elems->array + (cur + (int )elems->start))->size;
                  break;
                }
                if ((int const   )*elem___0 == 0) {
                  if (esiz___0 > 0) {
                    cur = tctmpldumpeval(xstr, elem___0 + 1, elems, cur, num, stack,
                                         depth);
                    if (0) {
                      __s1_len___7 = strlen(elem___0 + 1);
                      __s2_len___7 = strlen("END");
                      if (! ((unsigned int )((void const   *)((elem___0 + 1) + 1)) - (unsigned int )((void const   *)(elem___0 + 1)) == 1U)) {
                        goto _L___18;
                      } else {
                        if (__s1_len___7 >= 4U) {
                          _L___18: 
                          if (! ((unsigned int )((void const   *)("END" + 1)) - (unsigned int )((void const   *)"END") == 1U)) {
                            tmp___76 = 1;
                          } else {
                            if (__s2_len___7 >= 4U) {
                              tmp___76 = 1;
                            } else {
                              tmp___76 = 0;
                            }
                          }
                        } else {
                          tmp___76 = 0;
                        }
                      }
                      if (tmp___76) {
                        tmp___71 = __builtin_strcmp(elem___0 + 1, "END");
                        tmp___75 = tmp___71;
                      } else {
                        tmp___74 = __builtin_strcmp(elem___0 + 1, "END");
                        tmp___75 = tmp___74;
                      }
                    } else {
                      tmp___74 = __builtin_strcmp(elem___0 + 1, "END");
                      tmp___75 = tmp___74;
                    }
                    if (! tmp___75) {
                      break;
                    }
                  } else {
                    goto _L___19;
                  }
                } else {
                  _L___19: 
                  if (xstr) {
                    while (1) {
                      TC_mysize___0 = esiz___0;
                      TC_nsize___0 = (xstr->size + TC_mysize___0) + 1;
                      if (xstr->asize < TC_nsize___0) {
                        while (xstr->asize < TC_nsize___0) {
                          xstr->asize *= 2;
                          if (xstr->asize < TC_nsize___0) {
                            xstr->asize = TC_nsize___0;
                          }
                        }
                        while (1) {
                          tmp___78 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                          tmp___77 = (char *)tmp___78;
                          xstr->ptr = tmp___77;
                          if (! tmp___77) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                      }
                      memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )elem___0,
                             (unsigned int )TC_mysize___0);
                      xstr->size += TC_mysize___0;
                      *(xstr->ptr + xstr->size) = (char )'\000';
                      break;
                    }
                  }
                  cur ++;
                }
              }
              i___0 ++;
            }
            tcmapdel(vars);
          } else {
            goto _L___22;
          }
        } else {
          _L___22: 
          while (cur < num) {
            while (1) {
              elem___1 = (char const   *)(elems->array + (cur + (int )elems->start))->ptr;
              esiz___1 = (elems->array + (cur + (int )elems->start))->size;
              break;
            }
            if ((int const   )*elem___1 == 0) {
              if (esiz___1 > 0) {
                cur = tctmpldumpeval((TCXSTR *)((void *)0), elem___1 + 1, elems, cur,
                                     num, stack, depth);
                if (0) {
                  __s1_len___8 = strlen(elem___1 + 1);
                  __s2_len___8 = strlen("END");
                  if (! ((unsigned int )((void const   *)((elem___1 + 1) + 1)) - (unsigned int )((void const   *)(elem___1 + 1)) == 1U)) {
                    goto _L___21;
                  } else {
                    if (__s1_len___8 >= 4U) {
                      _L___21: 
                      if (! ((unsigned int )((void const   *)("END" + 1)) - (unsigned int )((void const   *)"END") == 1U)) {
                        tmp___85 = 1;
                      } else {
                        if (__s2_len___8 >= 4U) {
                          tmp___85 = 1;
                        } else {
                          tmp___85 = 0;
                        }
                      }
                    } else {
                      tmp___85 = 0;
                    }
                  }
                  if (tmp___85) {
                    tmp___80 = __builtin_strcmp(elem___1 + 1, "END");
                    tmp___84 = tmp___80;
                  } else {
                    tmp___83 = __builtin_strcmp(elem___1 + 1, "END");
                    tmp___84 = tmp___83;
                  }
                } else {
                  tmp___83 = __builtin_strcmp(elem___1 + 1, "END");
                  tmp___84 = tmp___83;
                }
                if (! tmp___84) {
                  break;
                }
              } else {
                cur ++;
              }
            } else {
              cur ++;
            }
          }
        }
      }
    } else {
      sign = (_Bool)1;
      eq = (char const   *)((void *)0);
      inc = (char const   *)((void *)0);
      prt = (_Bool)0;
      rx = (char const   *)((void *)0);
      i = 1;
      while (i < tnum) {
        token = (char const   *)((void *)(tokens->array + (i + tokens->start))->ptr);
        if (0) {
          __s1_len___3 = strlen(token);
          __s2_len___3 = strlen("NOT");
          if (! ((unsigned int )((void const   *)(token + 1)) - (unsigned int )((void const   *)token) == 1U)) {
            goto _L___8;
          } else {
            if (__s1_len___3 >= 4U) {
              _L___8: 
              if (! ((unsigned int )((void const   *)("NOT" + 1)) - (unsigned int )((void const   *)"NOT") == 1U)) {
                tmp___34 = 1;
              } else {
                if (__s2_len___3 >= 4U) {
                  tmp___34 = 1;
                } else {
                  tmp___34 = 0;
                }
              }
            } else {
              tmp___34 = 0;
            }
          }
          if (tmp___34) {
            tmp___29 = __builtin_strcmp(token, "NOT");
            tmp___33 = tmp___29;
          } else {
            tmp___32 = __builtin_strcmp(token, "NOT");
            tmp___33 = tmp___32;
          }
        } else {
          tmp___32 = __builtin_strcmp(token, "NOT");
          tmp___33 = tmp___32;
        }
        if (tmp___33) {
          if (0) {
            __s1_len___2 = strlen(token);
            __s2_len___2 = strlen("EQ");
            if (! ((unsigned int )((void const   *)(token + 1)) - (unsigned int )((void const   *)token) == 1U)) {
              goto _L___6;
            } else {
              if (__s1_len___2 >= 4U) {
                _L___6: 
                if (! ((unsigned int )((void const   *)("EQ" + 1)) - (unsigned int )((void const   *)"EQ") == 1U)) {
                  tmp___27 = 1;
                } else {
                  if (__s2_len___2 >= 4U) {
                    tmp___27 = 1;
                  } else {
                    tmp___27 = 0;
                  }
                }
              } else {
                tmp___27 = 0;
              }
            }
            if (tmp___27) {
              tmp___22 = __builtin_strcmp(token, "EQ");
              tmp___26 = tmp___22;
            } else {
              tmp___25 = __builtin_strcmp(token, "EQ");
              tmp___26 = tmp___25;
            }
          } else {
            tmp___25 = __builtin_strcmp(token, "EQ");
            tmp___26 = tmp___25;
          }
          if (tmp___26) {
            if (0) {
              __s1_len___1 = strlen(token);
              __s2_len___1 = strlen("INC");
              if (! ((unsigned int )((void const   *)(token + 1)) - (unsigned int )((void const   *)token) == 1U)) {
                goto _L___4;
              } else {
                if (__s1_len___1 >= 4U) {
                  _L___4: 
                  if (! ((unsigned int )((void const   *)("INC" + 1)) - (unsigned int )((void const   *)"INC") == 1U)) {
                    tmp___20 = 1;
                  } else {
                    if (__s2_len___1 >= 4U) {
                      tmp___20 = 1;
                    } else {
                      tmp___20 = 0;
                    }
                  }
                } else {
                  tmp___20 = 0;
                }
              }
              if (tmp___20) {
                tmp___15 = __builtin_strcmp(token, "INC");
                tmp___19 = tmp___15;
              } else {
                tmp___18 = __builtin_strcmp(token, "INC");
                tmp___19 = tmp___18;
              }
            } else {
              tmp___18 = __builtin_strcmp(token, "INC");
              tmp___19 = tmp___18;
            }
            if (tmp___19) {
              if (0) {
                __s1_len___0 = strlen(token);
                __s2_len___0 = strlen("PRT");
                if (! ((unsigned int )((void const   *)(token + 1)) - (unsigned int )((void const   *)token) == 1U)) {
                  goto _L___2;
                } else {
                  if (__s1_len___0 >= 4U) {
                    _L___2: 
                    if (! ((unsigned int )((void const   *)("PRT" + 1)) - (unsigned int )((void const   *)"PRT") == 1U)) {
                      tmp___13 = 1;
                    } else {
                      if (__s2_len___0 >= 4U) {
                        tmp___13 = 1;
                      } else {
                        tmp___13 = 0;
                      }
                    }
                  } else {
                    tmp___13 = 0;
                  }
                }
                if (tmp___13) {
                  tmp___8 = __builtin_strcmp(token, "PRT");
                  tmp___12 = tmp___8;
                } else {
                  tmp___11 = __builtin_strcmp(token, "PRT");
                  tmp___12 = tmp___11;
                }
              } else {
                tmp___11 = __builtin_strcmp(token, "PRT");
                tmp___12 = tmp___11;
              }
              if (tmp___12) {
                if (0) {
                  __s1_len = strlen(token);
                  __s2_len = strlen("RX");
                  if (! ((unsigned int )((void const   *)(token + 1)) - (unsigned int )((void const   *)token) == 1U)) {
                    goto _L___0;
                  } else {
                    if (__s1_len >= 4U) {
                      _L___0: 
                      if (! ((unsigned int )((void const   *)("RX" + 1)) - (unsigned int )((void const   *)"RX") == 1U)) {
                        tmp___6 = 1;
                      } else {
                        if (__s2_len >= 4U) {
                          tmp___6 = 1;
                        } else {
                          tmp___6 = 0;
                        }
                      }
                    } else {
                      tmp___6 = 0;
                    }
                  }
                  if (tmp___6) {
                    tmp___1 = __builtin_strcmp(token, "RX");
                    tmp___5 = tmp___1;
                  } else {
                    tmp___4 = __builtin_strcmp(token, "RX");
                    tmp___5 = tmp___4;
                  }
                } else {
                  tmp___4 = __builtin_strcmp(token, "RX");
                  tmp___5 = tmp___4;
                }
                if (! tmp___5) {
                  i ++;
                  if (i < tnum) {
                    rx = (char const   *)((void *)(tokens->array + (i + tokens->start))->ptr);
                  }
                }
              } else {
                prt = (_Bool)1;
              }
            } else {
              i ++;
              if (i < tnum) {
                inc = (char const   *)((void *)(tokens->array + (i + tokens->start))->ptr);
              }
            }
          } else {
            i ++;
            if (i < tnum) {
              eq = (char const   *)((void *)(tokens->array + (i + tokens->start))->ptr);
            }
          }
        } else {
          sign = (_Bool )(! sign);
        }
        i ++;
      }
      altxstr = (TCXSTR *)((void *)0);
      if (xstr) {
        if (tnum > 1) {
          tmp___35 = (char const   *)((void *)(tokens->array + (1 + tokens->start))->ptr);
        } else {
          tmp___35 = "__";
        }
        name = tmp___35;
        tmp___36 = tctmpldumpevalvar(stack, depth, name, & vsiz, & vnum);
        vbuf = tmp___36;
        if (vbuf) {
          if (vnum >= 0) {
            vsiz = sprintf((char * __restrict  )(numbuf), (char const   * __restrict  )"%d",
                           vnum);
            vbuf = (char const   *)(numbuf);
          }
        }
        bval = (_Bool)0;
        if (vbuf) {
          if (eq) {
            if (0) {
              __s1_len___4 = strlen(vbuf);
              __s2_len___4 = strlen(eq);
              if (! ((unsigned int )((void const   *)(vbuf + 1)) - (unsigned int )((void const   *)vbuf) == 1U)) {
                goto _L___10;
              } else {
                if (__s1_len___4 >= 4U) {
                  _L___10: 
                  if (! ((unsigned int )((void const   *)(eq + 1)) - (unsigned int )((void const   *)eq) == 1U)) {
                    tmp___43 = 1;
                  } else {
                    if (__s2_len___4 >= 4U) {
                      tmp___43 = 1;
                    } else {
                      tmp___43 = 0;
                    }
                  }
                } else {
                  tmp___43 = 0;
                }
              }
              if (tmp___43) {
                tmp___38 = __builtin_strcmp(vbuf, eq);
                tmp___42 = tmp___38;
              } else {
                tmp___41 = __builtin_strcmp(vbuf, eq);
                tmp___42 = tmp___41;
              }
            } else {
              tmp___41 = __builtin_strcmp(vbuf, eq);
              tmp___42 = tmp___41;
            }
            if (! tmp___42) {
              bval = (_Bool)1;
            }
          } else {
            if (inc) {
              tmp___44 = strstr(vbuf, inc);
              if (tmp___44) {
                bval = (_Bool)1;
              }
            } else {
              if (prt) {
                tmp___45 = tcstrskipspc(vbuf);
                if ((int const   )*tmp___45 != 0) {
                  bval = (_Bool)1;
                }
              } else {
                if (rx) {
                  tmp___46 = tcregexmatch(vbuf, rx);
                  if (tmp___46) {
                    bval = (_Bool)1;
                  }
                } else {
                  bval = (_Bool)1;
                }
              }
            }
          }
        }
        if ((int )bval != (int )sign) {
          altxstr = xstr;
          xstr = (TCXSTR *)((void *)0);
        }
      }
      while (cur < num) {
        while (1) {
          elem = (char const   *)(elems->array + (cur + (int )elems->start))->ptr;
          esiz = (elems->array + (cur + (int )elems->start))->size;
          break;
        }
        if ((int const   )*elem == 0) {
          if (esiz > 0) {
            cur = tctmpldumpeval(xstr, elem + 1, elems, cur, num, stack, depth);
            if (0) {
              __s1_len___6 = strlen(elem + 1);
              __s2_len___6 = strlen("ELSE");
              if (! ((unsigned int )((void const   *)((elem + 1) + 1)) - (unsigned int )((void const   *)(elem + 1)) == 1U)) {
                goto _L___14;
              } else {
                if (__s1_len___6 >= 4U) {
                  _L___14: 
                  if (! ((unsigned int )((void const   *)("ELSE" + 1)) - (unsigned int )((void const   *)"ELSE") == 1U)) {
                    tmp___60 = 1;
                  } else {
                    if (__s2_len___6 >= 4U) {
                      tmp___60 = 1;
                    } else {
                      tmp___60 = 0;
                    }
                  }
                } else {
                  tmp___60 = 0;
                }
              }
              if (tmp___60) {
                tmp___55 = __builtin_strcmp(elem + 1, "ELSE");
                tmp___59 = tmp___55;
              } else {
                tmp___58 = __builtin_strcmp(elem + 1, "ELSE");
                tmp___59 = tmp___58;
              }
            } else {
              tmp___58 = __builtin_strcmp(elem + 1, "ELSE");
              tmp___59 = tmp___58;
            }
            if (tmp___59) {
              if (0) {
                __s1_len___5 = strlen(elem + 1);
                __s2_len___5 = strlen("END");
                if (! ((unsigned int )((void const   *)((elem + 1) + 1)) - (unsigned int )((void const   *)(elem + 1)) == 1U)) {
                  goto _L___12;
                } else {
                  if (__s1_len___5 >= 4U) {
                    _L___12: 
                    if (! ((unsigned int )((void const   *)("END" + 1)) - (unsigned int )((void const   *)"END") == 1U)) {
                      tmp___53 = 1;
                    } else {
                      if (__s2_len___5 >= 4U) {
                        tmp___53 = 1;
                      } else {
                        tmp___53 = 0;
                      }
                    }
                  } else {
                    tmp___53 = 0;
                  }
                }
                if (tmp___53) {
                  tmp___48 = __builtin_strcmp(elem + 1, "END");
                  tmp___52 = tmp___48;
                } else {
                  tmp___51 = __builtin_strcmp(elem + 1, "END");
                  tmp___52 = tmp___51;
                }
              } else {
                tmp___51 = __builtin_strcmp(elem + 1, "END");
                tmp___52 = tmp___51;
              }
              if (! tmp___52) {
                break;
              }
            } else {
              xstr = altxstr;
            }
          } else {
            goto _L___15;
          }
        } else {
          _L___15: 
          if (xstr) {
            while (1) {
              TC_mysize = esiz;
              TC_nsize = (xstr->size + TC_mysize) + 1;
              if (xstr->asize < TC_nsize) {
                while (xstr->asize < TC_nsize) {
                  xstr->asize *= 2;
                  if (xstr->asize < TC_nsize) {
                    xstr->asize = TC_nsize;
                  }
                }
                while (1) {
                  tmp___62 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                  tmp___61 = (char *)tmp___62;
                  xstr->ptr = tmp___61;
                  if (! tmp___61) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )elem,
                     (unsigned int )TC_mysize);
              xstr->size += TC_mysize;
              *(xstr->ptr + xstr->size) = (char )'\000';
              break;
            }
          }
          cur ++;
        }
      }
    }
  }
  tclistdel(tokens);
  return (cur);
}
}
static char const   *tctmpldumpevalvar(TCMAP const   **stack , int depth , char const   *name ,
                                       int *sp , int *np ) 
{ char const   *result ;
  TCLIST *tokens ;
  TCLIST *tmp ;
  int tnum ;
  char const   *token ;
  int tsiz ;
  int i ;
  TCMAP const   *vars ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___0 ;
  int tidx ;
  TCLIST *list ;
  void const   *tmp___1 ;
  TCMAP *map ;
  uint64_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  result = (char const   *)((void *)0);
  tmp = tcstrsplit(name, ".");
  tokens = tmp;
  tnum = tokens->num;
  if (tnum > 0) {
    while (1) {
      token = (char const   *)(tokens->array + tokens->start)->ptr;
      tsiz = (tokens->array + tokens->start)->size;
      break;
    }
    i = depth - 1;
    while (i >= 0) {
      vars = *(stack + i);
      tmp___0 = tcmapget(vars, (void const   *)token, tsiz, & vsiz);
      vbuf = (char const   *)tmp___0;
      tidx = 1;
      if (vbuf) {
        while (vbuf) {
          if (vsiz == ((int )sizeof("[list]\000:") - 1) + (int )sizeof(TCLIST *)) {
            tmp___4 = memcmp((void const   *)vbuf, (void const   *)"[list]\000:",
                             (unsigned int )((int )sizeof("[list]\000:") - 1));
            if (tmp___4) {
              goto _L;
            } else {
              result = vbuf;
              *sp = vsiz;
              memcpy((void * __restrict  )(& list), (void const   * __restrict  )((vbuf + (int )sizeof("[list]\000:")) - 1),
                     (unsigned int )((int )sizeof(list)));
              *np = tclistnum((TCLIST const   *)list);
              break;
            }
          } else {
            _L: 
            if (vsiz == ((int )sizeof("[map]\000:") - 1) + (int )sizeof(TCMAP *)) {
              tmp___3 = memcmp((void const   *)vbuf, (void const   *)"[map]\000:",
                               (unsigned int )((int )sizeof("[map]\000:") - 1));
              if (tmp___3) {
                result = vbuf;
                *sp = vsiz;
                *np = -1;
                break;
              } else {
                if (tidx < tnum) {
                  memcpy((void * __restrict  )(& vars), (void const   * __restrict  )((vbuf + (int )sizeof("[map]\000:")) - 1),
                         (unsigned int )((int )sizeof(TCMAP *)));
                  while (1) {
                    token = (char const   *)(tokens->array + (tidx + tokens->start))->ptr;
                    tsiz = (tokens->array + (tidx + tokens->start))->size;
                    break;
                  }
                  tmp___1 = tcmapget(vars, (void const   *)token, tsiz, & vsiz);
                  vbuf = (char const   *)tmp___1;
                  tidx ++;
                } else {
                  result = vbuf;
                  *sp = vsiz;
                  memcpy((void * __restrict  )(& map), (void const   * __restrict  )((vbuf + (int )sizeof("[map]\000:")) - 1),
                         (unsigned int )((int )sizeof(map)));
                  tmp___2 = tcmaprnum((TCMAP const   *)map);
                  *np = (int )tmp___2;
                  break;
                }
              }
            } else {
              result = vbuf;
              *sp = vsiz;
              *np = -1;
              break;
            }
          }
        }
        break;
      }
      i --;
    }
  }
  tclistdel(tokens);
  return (result);
}
}
TCPTRLIST *tcptrlistnew(void) 
{ TCPTRLIST *ptrlist ;
  void *tmp ;
  void **tmp___0 ;
  void *tmp___1 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*ptrlist)));
    ptrlist = (TCPTRLIST *)tmp;
    if (! ptrlist) {
      tcmyfatal("out of memory");
    }
    break;
  }
  ptrlist->anum = 64;
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(*(ptrlist->array + 0)) * ptrlist->anum));
    tmp___0 = (void **)tmp___1;
    ptrlist->array = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  ptrlist->start = 0;
  ptrlist->num = 0;
  return (ptrlist);
}
}
TCPTRLIST *tcptrlistnew2(int anum ) 
{ TCPTRLIST *ptrlist ;
  void *tmp ;
  void **tmp___0 ;
  void *tmp___1 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*ptrlist)));
    ptrlist = (TCPTRLIST *)tmp;
    if (! ptrlist) {
      tcmyfatal("out of memory");
    }
    break;
  }
  if (anum < 1) {
    anum = 1;
  }
  ptrlist->anum = anum;
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(*(ptrlist->array + 0)) * ptrlist->anum));
    tmp___0 = (void **)tmp___1;
    ptrlist->array = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  ptrlist->start = 0;
  ptrlist->num = 0;
  return (ptrlist);
}
}
TCPTRLIST *tcptrlistdup(TCPTRLIST const   *ptrlist ) 
{ int num ;
  TCPTRLIST *tmp ;
  void **array ;
  TCPTRLIST *nptrlist ;
  void *tmp___0 ;
  void **narray ;
  void *tmp___1 ;

  {
  num = (int )ptrlist->num;
  if (num < 1) {
    tmp = tcptrlistnew();
    return (tmp);
  }
  array = (void **)(ptrlist->array + ptrlist->start);
  while (1) {
    tmp___0 = malloc((unsigned int )((int )sizeof(*nptrlist)));
    nptrlist = (TCPTRLIST *)tmp___0;
    if (! nptrlist) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(*narray) * num));
    narray = (void **)tmp___1;
    if (! narray) {
      tcmyfatal("out of memory");
    }
    break;
  }
  memcpy((void * __restrict  )narray, (void const   * __restrict  )array, (unsigned int )((int )sizeof(*narray) * num));
  nptrlist->anum = num;
  nptrlist->array = narray;
  nptrlist->start = 0;
  nptrlist->num = num;
  return (nptrlist);
}
}
void tcptrlistdel(TCPTRLIST *ptrlist ) 
{ 

  {
  while (1) {
    free((void *)ptrlist->array);
    break;
  }
  while (1) {
    free((void *)ptrlist);
    break;
  }
  return;
}
}
int tcptrlistnum(TCPTRLIST const   *ptrlist ) 
{ 

  {
  return ((int )ptrlist->num);
}
}
void *tcptrlistval(TCPTRLIST const   *ptrlist , int index___0 ) 
{ 

  {
  if (index___0 >= (int )ptrlist->num) {
    return ((void *)0);
  }
  return (*(ptrlist->array + (ptrlist->start + (int const   )index___0)));
}
}
void tcptrlistpush(TCPTRLIST *ptrlist , void *ptr ) 
{ int index___0 ;
  void **tmp ;
  void *tmp___0 ;

  {
  index___0 = ptrlist->start + ptrlist->num;
  if (index___0 >= ptrlist->anum) {
    ptrlist->anum += ptrlist->num + 1;
    while (1) {
      tmp___0 = realloc((void *)ptrlist->array, (unsigned int )(ptrlist->anum * (int )sizeof(*(ptrlist->array + 0))));
      tmp = (void **)tmp___0;
      ptrlist->array = tmp;
      if (! tmp) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  *(ptrlist->array + index___0) = ptr;
  (ptrlist->num) ++;
  return;
}
}
void *tcptrlistpop(TCPTRLIST *ptrlist ) 
{ int index___0 ;

  {
  if (ptrlist->num < 1) {
    return ((void *)0);
  }
  index___0 = (ptrlist->start + ptrlist->num) - 1;
  (ptrlist->num) --;
  return (*(ptrlist->array + index___0));
}
}
void tcptrlistunshift(TCPTRLIST *ptrlist , void *ptr ) 
{ void **tmp ;
  void *tmp___0 ;

  {
  if (ptrlist->start < 1) {
    if (ptrlist->start + ptrlist->num >= ptrlist->anum) {
      ptrlist->anum += ptrlist->num + 1;
      while (1) {
        tmp___0 = realloc((void *)ptrlist->array, (unsigned int )(ptrlist->anum * (int )sizeof(*(ptrlist->array + 0))));
        tmp = (void **)tmp___0;
        ptrlist->array = tmp;
        if (! tmp) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    ptrlist->start = ptrlist->anum - ptrlist->num;
    memmove((void *)(ptrlist->array + ptrlist->start), (void const   *)ptrlist->array,
            (unsigned int )(ptrlist->num * (int )sizeof(*(ptrlist->array + 0))));
  }
  (ptrlist->start) --;
  *(ptrlist->array + ptrlist->start) = ptr;
  (ptrlist->num) ++;
  return;
}
}
void *tcptrlistshift(TCPTRLIST *ptrlist ) 
{ int index___0 ;
  void *rv ;

  {
  if (ptrlist->num < 1) {
    return ((void *)0);
  }
  index___0 = ptrlist->start;
  (ptrlist->start) ++;
  (ptrlist->num) --;
  rv = *(ptrlist->array + index___0);
  if ((ptrlist->start & 255) == 0) {
    if (ptrlist->start > ptrlist->num >> 1) {
      memmove((void *)ptrlist->array, (void const   *)(ptrlist->array + ptrlist->start),
              (unsigned int )(ptrlist->num * (int )sizeof(*(ptrlist->array + 0))));
      ptrlist->start = 0;
    }
  }
  return (rv);
}
}
void tcptrlistinsert(TCPTRLIST *ptrlist , int index___0 , void *ptr ) 
{ void **tmp ;
  void *tmp___0 ;

  {
  if (index___0 > ptrlist->num) {
    return;
  }
  index___0 += ptrlist->start;
  if (ptrlist->start + ptrlist->num >= ptrlist->anum) {
    ptrlist->anum += ptrlist->num + 1;
    while (1) {
      tmp___0 = realloc((void *)ptrlist->array, (unsigned int )(ptrlist->anum * (int )sizeof(*(ptrlist->array + 0))));
      tmp = (void **)tmp___0;
      ptrlist->array = tmp;
      if (! tmp) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  memmove((void *)((ptrlist->array + index___0) + 1), (void const   *)(ptrlist->array + index___0),
          (unsigned int )((int )sizeof(*(ptrlist->array + 0)) * ((ptrlist->start + ptrlist->num) - index___0)));
  *(ptrlist->array + index___0) = ptr;
  (ptrlist->num) ++;
  return;
}
}
void *tcptrlistremove(TCPTRLIST *ptrlist , int index___0 ) 
{ void *rv ;

  {
  if (index___0 >= ptrlist->num) {
    return ((void *)0);
  }
  index___0 += ptrlist->start;
  rv = *(ptrlist->array + index___0);
  (ptrlist->num) --;
  memmove((void *)(ptrlist->array + index___0), (void const   *)((ptrlist->array + index___0) + 1),
          (unsigned int )((int )sizeof(*(ptrlist->array + 0)) * ((ptrlist->start + ptrlist->num) - index___0)));
  return (rv);
}
}
void tcptrlistover(TCPTRLIST *ptrlist , int index___0 , void *ptr ) 
{ 

  {
  if (index___0 >= ptrlist->num) {
    return;
  }
  index___0 += ptrlist->start;
  *(ptrlist->array + index___0) = ptr;
  return;
}
}
void tcptrlistclear(TCPTRLIST *ptrlist ) 
{ 

  {
  ptrlist->start = 0;
  ptrlist->num = 0;
  return;
}
}
static void tcglobalinit(void) ;
static void tcglobaldestroy(void) ;
static void tcbwtsortstrcount(char const   **arrays , int anum , int len , int level ) ;
static void tcbwtsortstrinsert(char const   **arrays , int anum , int len , int skip ) ;
static void tcbwtsortstrheap(char const   **arrays , int anum , int len , int skip ) ;
static void tcbwtsortchrcount(unsigned char *str , int len ) ;
static void tcbwtsortchrinsert(unsigned char *str , int len ) ;
static void tcbwtsortreccount(TCBWTREC *array , int anum ) ;
static void tcbwtsortrecinsert(TCBWTREC *array , int anum ) ;
static int tcbwtsearchrec(TCBWTREC *array , int anum , int tchr ) ;
static void tcmtfencode(char *ptr , int size ) ;
static void tcmtfdecode(char *ptr , int size ) ;
static int tcgammaencode(char const   *ptr , int size , char *obuf ) ;
static int tcgammadecode(char const   *ptr , int size , char *obuf ) ;
char const   *tcerrmsg(int ecode ) 
{ 

  {
  switch (ecode) {
  case 0: 
  return ("success");
  case 1: 
  return ("threading error");
  case 2: 
  return ("invalid operation");
  case 3: 
  return ("file not found");
  case 4: 
  return ("no permission");
  case 5: 
  return ("invalid meta data");
  case 6: 
  return ("invalid record header");
  case 7: 
  return ("open error");
  case 8: 
  return ("close error");
  case 9: 
  return ("trunc error");
  case 10: 
  return ("sync error");
  case 11: 
  return ("stat error");
  case 12: 
  return ("seek error");
  case 13: 
  return ("read error");
  case 14: 
  return ("write error");
  case 15: 
  return ("mmap error");
  case 16: 
  return ("lock error");
  case 17: 
  return ("unlink error");
  case 18: 
  return ("rename error");
  case 19: 
  return ("mkdir error");
  case 20: 
  return ("rmdir error");
  case 21: 
  return ("existing record");
  case 22: 
  return ("no record found");
  case 9999: 
  return ("miscellaneous error");
  }
  return ("unknown error");
}
}
void *tcmyfatal(char const   *message ) 
{ 

  {
  if (tcfatalfunc) {
    (*tcfatalfunc)(message);
  } else {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fatal error: %s\n",
            message);
  }
  exit(1);
  return ((void *)0);
}
}
void *tczeromap(uint64_t size ) 
{ void *ptr ;
  void *tmp ;

  {
  tmp = mmap((void *)0, (unsigned int )((unsigned long long )((int )sizeof(size)) + size),
             3, 34, -1, 0L);
  ptr = tmp;
  if ((unsigned int )ptr == (unsigned int )((void *)-1)) {
    tcmyfatal("out of memory");
  }
  *((uint64_t *)ptr) = size;
  return ((void *)((char *)ptr + (int )sizeof(size)));
}
}
void tczerounmap(void *ptr ) 
{ uint64_t size ;

  {
  size = *((uint64_t *)ptr - 1);
  munmap((void *)((char *)ptr - (int )sizeof(size)), (unsigned int )((unsigned long long )((int )sizeof(size)) + size));
  return;
}
}
static pthread_once_t tcglobalonce  =    0;
static pthread_rwlock_t tcglobalmutex  ;
static pthread_mutex_t tcpathmutex  ;
static TCMAP *tcpathmap  ;
_Bool tcglobalmutexlock(void) 
{ int tmp ;

  {
  pthread_once(& tcglobalonce, & tcglobalinit);
  tmp = pthread_rwlock_wrlock(& tcglobalmutex);
  return ((_Bool )(tmp == 0));
}
}
_Bool tcglobalmutexlockshared(void) 
{ int tmp ;

  {
  pthread_once(& tcglobalonce, & tcglobalinit);
  tmp = pthread_rwlock_rdlock(& tcglobalmutex);
  return ((_Bool )(tmp == 0));
}
}
_Bool tcglobalmutexunlock(void) 
{ int tmp ;

  {
  tmp = pthread_rwlock_unlock(& tcglobalmutex);
  return ((_Bool )(tmp == 0));
}
}
_Bool tcpathlock(char const   *path ) 
{ int tmp ;
  _Bool err ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  pthread_once(& tcglobalonce, & tcglobalinit);
  tmp = pthread_mutex_lock(& tcpathmutex);
  if (tmp != 0) {
    return ((_Bool)0);
  }
  err = (_Bool)0;
  if (tcpathmap) {
    tmp___0 = tcmapputkeep2(tcpathmap, path, "");
    if (! tmp___0) {
      err = (_Bool)1;
    }
  }
  tmp___1 = pthread_mutex_unlock(& tcpathmutex);
  if (tmp___1 != 0) {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
_Bool tcpathunlock(char const   *path ) 
{ int tmp ;
  _Bool err ;
  _Bool tmp___0 ;
  int tmp___1 ;

  {
  pthread_once(& tcglobalonce, & tcglobalinit);
  tmp = pthread_mutex_lock(& tcpathmutex);
  if (tmp != 0) {
    return ((_Bool)0);
  }
  err = (_Bool)0;
  if (tcpathmap) {
    tmp___0 = tcmapout2(tcpathmap, path);
    if (! tmp___0) {
      err = (_Bool)1;
    }
  }
  tmp___1 = pthread_mutex_unlock(& tcpathmutex);
  if (tmp___1 != 0) {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
int tcnumtostrbin(uint64_t num , char *buf , int col , int fc ) 
{ char *wp ;
  int len ;
  _Bool zero ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int i ;
  char *tmp___2 ;

  {
  wp = buf;
  len = (int )sizeof(num) * 8;
  zero = (_Bool)1;
  while (1) {
    tmp___1 = len;
    len --;
    if (! (tmp___1 > 0)) {
      break;
    }
    if (num & (1ULL << 63)) {
      tmp = wp;
      wp ++;
      *tmp = (char )'1';
      zero = (_Bool)0;
    } else {
      if (! zero) {
        tmp___0 = wp;
        wp ++;
        *tmp___0 = (char )'0';
      }
    }
    num <<= 1;
  }
  if (col > 0) {
    if (col > (int )sizeof(num) * 8) {
      col = (int )sizeof(num) * 8;
    }
    len = col - (wp - buf);
    if (len > 0) {
      memmove((void *)(buf + len), (void const   *)buf, (unsigned int )(wp - buf));
      i = 0;
      while (i < len) {
        *(buf + i) = (char )fc;
        i ++;
      }
      wp += len;
    }
  } else {
    if (zero) {
      tmp___2 = wp;
      wp ++;
      *tmp___2 = (char )'0';
    }
  }
  *wp = (char )'\000';
  return (wp - buf);
}
}
int tccmplexical(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) 
{ int rv ;
  int _TC_min ;
  int tmp ;
  int _TC_i ;

  {
  while (1) {
    rv = 0;
    if (asiz < bsiz) {
      tmp = asiz;
    } else {
      tmp = bsiz;
    }
    _TC_min = tmp;
    _TC_i = 0;
    while (_TC_i < _TC_min) {
      if ((int )*((unsigned char *)aptr + _TC_i) != (int )*((unsigned char *)bptr + _TC_i)) {
        rv = (int )*((unsigned char *)aptr + _TC_i) - (int )*((unsigned char *)bptr + _TC_i);
        break;
      }
      _TC_i ++;
    }
    if (rv == 0) {
      rv = asiz - bsiz;
    }
    break;
  }
  return (rv);
}
}
int tccmpdecimal(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) 
{ unsigned char const   *arp ;
  int alen ;
  int64_t anum ;
  int asign ;
  int c ;
  unsigned char const   *brp ;
  int blen ;
  int64_t bnum ;
  int bsign ;
  int c___0 ;
  long double aflt ;
  long double base ;
  long double bflt ;
  long double base___0 ;
  int rv ;
  int _TC_min ;
  int tmp ;
  int _TC_i ;

  {
  arp = (unsigned char const   *)((unsigned char *)aptr);
  alen = asiz;
  while (1) {
    if (alen > 0) {
      if (! ((int const   )*arp <= 32)) {
        if (! ((int const   )*arp == 127)) {
          break;
        }
      }
    } else {
      break;
    }
    arp ++;
    alen --;
  }
  anum = 0LL;
  asign = 1;
  if (alen > 0) {
    if ((int const   )*arp == 45) {
      arp ++;
      alen --;
      asign = -1;
    }
  }
  while (alen > 0) {
    c = (int )*arp;
    if (c < 48) {
      break;
    } else {
      if (c > 57) {
        break;
      }
    }
    anum = (anum * 10LL + (long long )c) - 48LL;
    arp ++;
    alen --;
  }
  anum *= (long long )asign;
  brp = (unsigned char const   *)((unsigned char *)bptr);
  blen = bsiz;
  while (1) {
    if (blen > 0) {
      if (! ((int const   )*brp <= 32)) {
        if (! ((int const   )*brp == 127)) {
          break;
        }
      }
    } else {
      break;
    }
    brp ++;
    blen --;
  }
  bnum = 0LL;
  bsign = 1;
  if (blen > 0) {
    if ((int const   )*brp == 45) {
      brp ++;
      blen --;
      bsign = -1;
    }
  }
  while (blen > 0) {
    c___0 = (int )*brp;
    if (c___0 < 48) {
      break;
    } else {
      if (c___0 > 57) {
        break;
      }
    }
    bnum = (bnum * 10LL + (long long )c___0) - 48LL;
    brp ++;
    blen --;
  }
  bnum *= (long long )bsign;
  if (anum < bnum) {
    return (-1);
  }
  if (anum > bnum) {
    return (1);
  }
  if (alen > 1) {
    if ((int const   )*arp == 46) {
      goto _L;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (blen > 1) {
      if ((int const   )*brp == 46) {
        _L: 
        aflt = (long double )0;
        if (alen > 1) {
          if ((int const   )*arp == 46) {
            arp ++;
            alen --;
            if (alen > 16) {
              alen = 16;
            }
            base = (long double )10;
            while (alen > 0) {
              if ((int const   )*arp < 48) {
                break;
              } else {
                if ((int const   )*arp > 57) {
                  break;
                }
              }
              aflt += (long double )((int const   )*arp - 48) / base;
              arp ++;
              alen --;
              base *= (long double )10;
            }
            aflt *= (long double )asign;
          }
        }
        bflt = (long double )0;
        if (blen > 1) {
          if ((int const   )*brp == 46) {
            brp ++;
            blen --;
            if (blen > 16) {
              blen = 16;
            }
            base___0 = (long double )10;
            while (blen > 0) {
              if ((int const   )*brp < 48) {
                break;
              } else {
                if ((int const   )*brp > 57) {
                  break;
                }
              }
              bflt += (long double )((int const   )*brp - 48) / base___0;
              brp ++;
              blen --;
              base___0 *= (long double )10;
            }
            bflt *= (long double )bsign;
          }
        }
        if (aflt < bflt) {
          return (-1);
        }
        if (aflt > bflt) {
          return (1);
        }
      }
    }
  }
  while (1) {
    rv = 0;
    if (asiz < bsiz) {
      tmp = asiz;
    } else {
      tmp = bsiz;
    }
    _TC_min = tmp;
    _TC_i = 0;
    while (_TC_i < _TC_min) {
      if ((int )*((unsigned char *)aptr + _TC_i) != (int )*((unsigned char *)bptr + _TC_i)) {
        rv = (int )*((unsigned char *)aptr + _TC_i) - (int )*((unsigned char *)bptr + _TC_i);
        break;
      }
      _TC_i ++;
    }
    if (rv == 0) {
      rv = asiz - bsiz;
    }
    break;
  }
  return (rv);
}
}
int tccmpint32(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) 
{ int32_t anum ;
  int32_t bnum ;
  int tmp ;

  {
  if (asiz == (int )sizeof(int32_t )) {
    memcpy((void * __restrict  )(& anum), (void const   * __restrict  )aptr, (unsigned int )((int )sizeof(int32_t )));
  } else {
    if (asiz < (int )sizeof(int32_t )) {
      memset((void *)(& anum), 0, (unsigned int )((int )sizeof(int32_t )));
      memcpy((void * __restrict  )(& anum), (void const   * __restrict  )aptr, (unsigned int )asiz);
    } else {
      memcpy((void * __restrict  )(& anum), (void const   * __restrict  )aptr, (unsigned int )((int )sizeof(int32_t )));
    }
  }
  if (bsiz == (int )sizeof(int32_t )) {
    memcpy((void * __restrict  )(& bnum), (void const   * __restrict  )bptr, (unsigned int )((int )sizeof(int32_t )));
  } else {
    if (bsiz < (int )sizeof(int32_t )) {
      memset((void *)(& bnum), 0, (unsigned int )((int )sizeof(int32_t )));
      memcpy((void * __restrict  )(& bnum), (void const   * __restrict  )bptr, (unsigned int )bsiz);
    } else {
      memcpy((void * __restrict  )(& bnum), (void const   * __restrict  )bptr, (unsigned int )((int )sizeof(int32_t )));
    }
  }
  if (anum < bnum) {
    tmp = -1;
  } else {
    tmp = anum > bnum;
  }
  return (tmp);
}
}
int tccmpint64(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) 
{ int64_t anum ;
  int64_t bnum ;
  int tmp ;

  {
  if (asiz == (int )sizeof(int64_t )) {
    memcpy((void * __restrict  )(& anum), (void const   * __restrict  )aptr, (unsigned int )((int )sizeof(int64_t )));
  } else {
    if (asiz < (int )sizeof(int64_t )) {
      memset((void *)(& anum), 0, (unsigned int )((int )sizeof(int64_t )));
      memcpy((void * __restrict  )(& anum), (void const   * __restrict  )aptr, (unsigned int )asiz);
    } else {
      memcpy((void * __restrict  )(& anum), (void const   * __restrict  )aptr, (unsigned int )((int )sizeof(int64_t )));
    }
  }
  if (bsiz == (int )sizeof(int64_t )) {
    memcpy((void * __restrict  )(& bnum), (void const   * __restrict  )bptr, (unsigned int )((int )sizeof(int64_t )));
  } else {
    if (bsiz < (int )sizeof(int64_t )) {
      memset((void *)(& bnum), 0, (unsigned int )((int )sizeof(int64_t )));
      memcpy((void * __restrict  )(& bnum), (void const   * __restrict  )bptr, (unsigned int )bsiz);
    } else {
      memcpy((void * __restrict  )(& bnum), (void const   * __restrict  )bptr, (unsigned int )((int )sizeof(int64_t )));
    }
  }
  if (anum < bnum) {
    tmp = -1;
  } else {
    tmp = anum > bnum;
  }
  return (tmp);
}
}
char *tcbsencode(char const   *ptr , int size , int *sp ) 
{ char *result ;
  void *tmp ;
  char *pv ;
  char *wp ;
  char *tp ;
  char const   *end ;
  int usiz ;
  long tmp___0 ;
  char *sp___0 ;
  uint16_t idx ;
  char const   **arrays ;
  unsigned int __lengthofarrays ;
  void *tmp___1 ;
  int i ;
  char const   *fp ;
  int i___0 ;
  int tidx ;
  char *tmp___2 ;
  char *tmp___3 ;
  int nsiz ;
  int tmp___4 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((((size * 7) / 3 + (size / 8192 + 1) * (int )sizeof(uint16_t )) + 16384) + 512));
    result = (char *)tmp;
    if (! result) {
      tcmyfatal("out of memory");
    }
    break;
  }
  pv = (result + size) + 256;
  wp = pv;
  tp = (pv + size) + 256;
  end = ptr + size;
  while ((unsigned int )ptr < (unsigned int )end) {
    tmp___0 = tclmin(8192L, (long )(end - ptr));
    usiz = (int )tmp___0;
    memcpy((void * __restrict  )tp, (void const   * __restrict  )ptr, (unsigned int )usiz);
    memcpy((void * __restrict  )(tp + usiz), (void const   * __restrict  )ptr, (unsigned int )usiz);
    sp___0 = wp;
    idx = (unsigned short)0;
    wp += (int )sizeof(idx);
    __lengthofarrays = (unsigned int )(usiz + 1);
    tmp___1 = __builtin_alloca(sizeof(*arrays) * __lengthofarrays);
    arrays = (char const   **)tmp___1;
    i = 0;
    while (i < usiz) {
      *(arrays + i) = (char const   *)(tp + i);
      i ++;
    }
    fp = *(arrays + 0);
    if (usiz >= 64) {
      tcbwtsortstrcount(arrays, usiz, usiz, 0);
    } else {
      if (usiz > 1) {
        tcbwtsortstrinsert(arrays, usiz, usiz, 0);
      }
    }
    i___0 = 0;
    while (i___0 < usiz) {
      tidx = *(arrays + i___0) - fp;
      if (tidx == 0) {
        idx = (unsigned short )i___0;
        tmp___2 = wp;
        wp ++;
        *tmp___2 = (char )*(ptr + (usiz - 1));
      } else {
        tmp___3 = wp;
        wp ++;
        *tmp___3 = (char )*(ptr + (tidx - 1));
      }
      i___0 ++;
    }
    idx = idx;
    memcpy((void * __restrict  )sp___0, (void const   * __restrict  )(& idx), (unsigned int )((int )sizeof(idx)));
    ptr += 8192;
  }
  size = wp - pv;
  tcmtfencode(pv, size);
  tmp___4 = tcgammaencode((char const   *)pv, size, result);
  nsiz = tmp___4;
  *sp = nsiz;
  return (result);
}
}
char *tcbsdecode(char const   *ptr , int size , int *sp ) 
{ char *result ;
  void *tmp ;
  char *wp ;
  int nsiz ;
  int tmp___0 ;
  char const   *end ;
  uint16_t idx ;
  int usiz ;
  long tmp___1 ;
  char *rbuf ;
  unsigned int __lengthofrbuf ;
  void *tmp___2 ;
  int fnums[256] ;
  int tnums[256] ;
  TCBWTREC *array ;
  unsigned int __lengthofarray ;
  void *tmp___3 ;
  TCBWTREC *rp ;
  int i ;
  int fc ;
  int tmp___4 ;
  int tc ;
  int tmp___5 ;
  unsigned int fchr ;
  int i___0 ;
  int i___1 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  while (1) {
    tmp = malloc((unsigned int )(size * 9 + 512));
    result = (char *)tmp;
    if (! result) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = (result + size) + 256;
  tmp___0 = tcgammadecode(ptr, size, wp);
  nsiz = tmp___0;
  tcmtfdecode(wp, nsiz);
  ptr = (char const   *)wp;
  wp = result;
  end = ptr + nsiz;
  while ((unsigned int )ptr < (unsigned int )end) {
    memcpy((void * __restrict  )(& idx), (void const   * __restrict  )ptr, (unsigned int )((int )sizeof(idx)));
    idx = idx;
    ptr += (int )sizeof(idx);
    tmp___1 = tclmin(8192L, (long )(end - ptr));
    usiz = (int )tmp___1;
    if ((int )idx >= usiz) {
      idx = (unsigned short)0;
    }
    __lengthofrbuf = (unsigned int )(usiz + 1);
    tmp___2 = __builtin_alloca(sizeof(*rbuf) * __lengthofrbuf);
    rbuf = (char *)tmp___2;
    memcpy((void * __restrict  )rbuf, (void const   * __restrict  )ptr, (unsigned int )usiz);
    if (usiz >= 64) {
      tcbwtsortchrcount((unsigned char *)rbuf, usiz);
    } else {
      if (usiz > 0) {
        tcbwtsortchrinsert((unsigned char *)rbuf, usiz);
      }
    }
    memset((void *)(fnums), 0, (unsigned int )((int )sizeof(fnums)));
    memset((void *)(tnums), 0, (unsigned int )((int )sizeof(tnums)));
    __lengthofarray = (unsigned int )(usiz + 1);
    tmp___3 = __builtin_alloca(sizeof(*array) * __lengthofarray);
    array = (TCBWTREC *)tmp___3;
    rp = array;
    i = 0;
    while (i < usiz) {
      fc = (int )*((unsigned char *)(rbuf + i));
      tmp___4 = fnums[fc];
      (fnums[fc]) ++;
      rp->fchr = (fc << 23) + tmp___4;
      tc = (int )*((unsigned char *)(ptr + i));
      tmp___5 = tnums[tc];
      (tnums[tc]) ++;
      rp->tchr = (tc << 23) + tmp___5;
      rp ++;
      i ++;
    }
    fchr = (unsigned int )(array + (int )idx)->fchr;
    if (usiz >= 64) {
      tcbwtsortreccount(array, usiz);
    } else {
      if (usiz > 1) {
        tcbwtsortrecinsert(array, usiz);
      }
    }
    i___0 = 0;
    while (i___0 < usiz) {
      if ((unsigned int )(array + i___0)->fchr == fchr) {
        idx = (unsigned short )i___0;
        break;
      }
      i___0 ++;
    }
    i___1 = 0;
    while (i___1 < usiz) {
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (char )((array + (int )idx)->fchr >> 23);
      tmp___7 = tcbwtsearchrec(array, usiz, (array + (int )idx)->fchr);
      idx = (unsigned short )tmp___7;
      i___1 ++;
    }
    ptr += usiz;
  }
  *wp = (char )'\000';
  *sp = wp - result;
  return (result);
}
}
char *tcbwtencode(char const   *ptr , int size , int *idxp ) 
{ char *rv ;
  void *tmp ;
  char *result ;
  void *tmp___0 ;
  char *tp ;
  char const   *abuf[16384] ;
  char const   **arrays ;
  void *tmp___1 ;
  int i ;
  char const   *fp ;
  int i___0 ;
  int idx ;

  {
  if (size < 1) {
    *idxp = 0;
    while (1) {
      while (1) {
        tmp = malloc(1U);
        rv = (char *)tmp;
        if (! rv) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )rv, (void const   * __restrict  )"", 0U);
      *(rv + 0) = (char )'\000';
      break;
    }
    return (rv);
  }
  while (1) {
    tmp___0 = malloc((unsigned int )(size * 3 + 1));
    result = (char *)tmp___0;
    if (! result) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tp = (result + size) + 1;
  memcpy((void * __restrict  )tp, (void const   * __restrict  )ptr, (unsigned int )size);
  memcpy((void * __restrict  )(tp + size), (void const   * __restrict  )ptr, (unsigned int )size);
  arrays = abuf;
  if (size > 16384) {
    while (1) {
      tmp___1 = malloc((unsigned int )((int )sizeof(*arrays) * size));
      arrays = (char const   **)tmp___1;
      if (! arrays) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  i = 0;
  while (i < size) {
    *(arrays + i) = (char const   *)(tp + i);
    i ++;
  }
  fp = *(arrays + 0);
  if (size >= 64) {
    tcbwtsortstrcount(arrays, size, size, -1);
  } else {
    if (size > 1) {
      tcbwtsortstrinsert(arrays, size, size, 0);
    }
  }
  i___0 = 0;
  while (i___0 < size) {
    idx = *(arrays + i___0) - fp;
    if (idx == 0) {
      *idxp = i___0;
      *(result + i___0) = (char )*(ptr + (size - 1));
    } else {
      *(result + i___0) = (char )*(ptr + (idx - 1));
    }
    i___0 ++;
  }
  if ((unsigned int )arrays != (unsigned int )(abuf)) {
    while (1) {
      free((void *)arrays);
      break;
    }
  }
  *(result + size) = (char )'\000';
  return (result);
}
}
char *tcbwtdecode(char const   *ptr , int size , int idx ) 
{ char *rv ;
  void *tmp ;
  char *result ;
  void *tmp___0 ;
  int fnums[256] ;
  int tnums[256] ;
  TCBWTREC abuf[16384] ;
  TCBWTREC *array ;
  void *tmp___1 ;
  TCBWTREC *rp ;
  int i ;
  int fc ;
  int tmp___2 ;
  int tc ;
  int tmp___3 ;
  unsigned int fchr ;
  int i___0 ;
  char *wp ;
  int i___1 ;
  char *tmp___4 ;

  {
  if (size < 1) {
    goto _L;
  } else {
    if (idx < 0) {
      _L: 
      while (1) {
        while (1) {
          tmp = malloc(1U);
          rv = (char *)tmp;
          if (! rv) {
            tcmyfatal("out of memory");
          }
          break;
        }
        memcpy((void * __restrict  )rv, (void const   * __restrict  )"", 0U);
        *(rv + 0) = (char )'\000';
        break;
      }
      return (rv);
    }
  }
  if (idx >= size) {
    idx = 0;
  }
  while (1) {
    tmp___0 = malloc((unsigned int )(size + 1));
    result = (char *)tmp___0;
    if (! result) {
      tcmyfatal("out of memory");
    }
    break;
  }
  memcpy((void * __restrict  )result, (void const   * __restrict  )ptr, (unsigned int )size);
  if (size >= 64) {
    tcbwtsortchrcount((unsigned char *)result, size);
  } else {
    tcbwtsortchrinsert((unsigned char *)result, size);
  }
  memset((void *)(fnums), 0, (unsigned int )((int )sizeof(fnums)));
  memset((void *)(tnums), 0, (unsigned int )((int )sizeof(tnums)));
  array = abuf;
  if (size > 16384) {
    while (1) {
      tmp___1 = malloc((unsigned int )((int )sizeof(*array) * size));
      array = (TCBWTREC *)tmp___1;
      if (! array) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  rp = array;
  i = 0;
  while (i < size) {
    fc = (int )*((unsigned char *)(result + i));
    tmp___2 = fnums[fc];
    (fnums[fc]) ++;
    rp->fchr = (fc << 23) + tmp___2;
    tc = (int )*((unsigned char *)(ptr + i));
    tmp___3 = tnums[tc];
    (tnums[tc]) ++;
    rp->tchr = (tc << 23) + tmp___3;
    rp ++;
    i ++;
  }
  fchr = (unsigned int )(array + idx)->fchr;
  if (size >= 64) {
    tcbwtsortreccount(array, size);
  } else {
    if (size > 1) {
      tcbwtsortrecinsert(array, size);
    }
  }
  i___0 = 0;
  while (i___0 < size) {
    if ((unsigned int )(array + i___0)->fchr == fchr) {
      idx = i___0;
      break;
    }
    i___0 ++;
  }
  wp = result;
  i___1 = 0;
  while (i___1 < size) {
    tmp___4 = wp;
    wp ++;
    *tmp___4 = (char )((array + idx)->fchr >> 23);
    idx = tcbwtsearchrec(array, size, (array + idx)->fchr);
    i___1 ++;
  }
  *wp = (char )'\000';
  if ((unsigned int )array != (unsigned int )(abuf)) {
    while (1) {
      free((void *)array);
      break;
    }
  }
  return (result);
}
}
long tclog2l(long num ) 
{ long rv ;

  {
  if (num <= 1L) {
    return (0L);
  }
  num >>= 1;
  rv = 0L;
  while (num > 0L) {
    rv ++;
    num >>= 1;
  }
  return (rv);
}
}
double tclog2d(double num ) 
{ double tmp ;
  double tmp___0 ;

  {
  tmp = log(num);
  tmp___0 = log((double )2);
  return (tmp / tmp___0);
}
}
uint64_t tcpagealign(uint64_t off ) 
{ int ps ;
  long tmp ;
  int diff ;
  uint64_t tmp___0 ;

  {
  tmp = sysconf(30);
  ps = (int )tmp;
  diff = (int )(off & (unsigned long long )(ps - 1));
  if (diff > 0) {
    tmp___0 = (off + (unsigned long long )ps) - (unsigned long long )diff;
  } else {
    tmp___0 = off;
  }
  return (tmp___0);
}
}
static void tcglobalinit(void) 
{ int tmp ;
  int tmp___0 ;

  {
  tmp = pthread_rwlock_init((pthread_rwlock_t * __restrict  )(& tcglobalmutex), (pthread_rwlockattr_t const   * __restrict  )((void *)0));
  if (tmp != 0) {
    tcmyfatal("rwlock error");
  }
  tmp___0 = pthread_mutex_init(& tcpathmutex, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___0 != 0) {
    tcmyfatal("mutex error");
  }
  tcpathmap = tcmapnew2(31U);
  atexit(& tcglobaldestroy);
  return;
}
}
static void tcglobaldestroy(void) 
{ 

  {
  tcmapdel(tcpathmap);
  pthread_mutex_destroy(& tcpathmutex);
  pthread_rwlock_destroy(& tcglobalmutex);
  return;
}
}
static void tcbwtsortstrcount(char const   **arrays , int anum , int len , int level ) 
{ char const   *nbuf[16384] ;
  char const   **narrays ;
  void *tmp ;
  int count[256] ;
  int accum[256] ;
  int skip ;
  int tmp___0 ;
  int i ;
  int i___0 ;
  int i___1 ;
  int off ;
  int i___2 ;
  int c ;
  int i___3 ;
  int c___0 ;

  {
  narrays = nbuf;
  if (anum > 16384) {
    while (1) {
      tmp = malloc((unsigned int )((int )sizeof(*narrays) * anum));
      narrays = (char const   **)tmp;
      if (! narrays) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  memset((void *)(count), 0, (unsigned int )((int )sizeof(count)));
  if (level < 0) {
    tmp___0 = 0;
  } else {
    tmp___0 = level;
  }
  skip = tmp___0;
  i = 0;
  while (i < anum) {
    (count[*((unsigned char *)*(arrays + i) + skip)]) ++;
    i ++;
  }
  memcpy((void * __restrict  )(accum), (void const   * __restrict  )(count), (unsigned int )((int )sizeof(count)));
  i___0 = 1;
  while (i___0 < 256) {
    accum[i___0] = accum[i___0 - 1] + accum[i___0];
    i___0 ++;
  }
  i___1 = 0;
  while (i___1 < anum) {
    (accum[*((unsigned char *)*(arrays + i___1) + skip)]) --;
    *(narrays + accum[*((unsigned char *)*(arrays + i___1) + skip)]) = *(arrays + i___1);
    i___1 ++;
  }
  off = 0;
  if (level >= 0) {
    if (level < 4) {
      i___2 = 0;
      while (i___2 < 256) {
        c = count[i___2];
        if (c > 1) {
          if (c >= 64) {
            tcbwtsortstrcount(narrays + off, c, len, level + 1);
          } else {
            tcbwtsortstrinsert(narrays + off, c, len, skip + 1);
          }
        }
        off += c;
        i___2 ++;
      }
    } else {
      goto _L;
    }
  } else {
    _L: 
    i___3 = 0;
    while (i___3 < 256) {
      c___0 = count[i___3];
      if (c___0 > 1) {
        if (c___0 >= 64) {
          tcbwtsortstrheap(narrays + off, c___0, len, skip + 1);
        } else {
          tcbwtsortstrinsert(narrays + off, c___0, len, skip + 1);
        }
      }
      off += c___0;
      i___3 ++;
    }
  }
  memcpy((void * __restrict  )arrays, (void const   * __restrict  )narrays, (unsigned int )(anum * (int )sizeof(*narrays)));
  if ((unsigned int )narrays != (unsigned int )(nbuf)) {
    while (1) {
      free((void *)narrays);
      break;
    }
  }
  return;
}
}
static void tcbwtsortstrinsert(char const   **arrays , int anum , int len , int skip ) 
{ int i ;
  int cmp ;
  unsigned char const   *ap ;
  unsigned char const   *bp ;
  int j ;
  char const   *swap ;
  int j___0 ;
  int cmp___0 ;
  unsigned char const   *ap___0 ;
  unsigned char const   *bp___0 ;
  int k ;

  {
  i = 1;
  while (i < anum) {
    cmp = 0;
    ap = (unsigned char const   *)((unsigned char *)*(arrays + (i - 1)));
    bp = (unsigned char const   *)((unsigned char *)*(arrays + i));
    j = skip;
    while (j < len) {
      if ((int const   )*(ap + j) != (int const   )*(bp + j)) {
        cmp = (int )((int const   )*(ap + j) - (int const   )*(bp + j));
        break;
      }
      j ++;
    }
    if (cmp > 0) {
      swap = *(arrays + i);
      j___0 = i;
      while (j___0 > 0) {
        cmp___0 = 0;
        ap___0 = (unsigned char const   *)((unsigned char *)*(arrays + (j___0 - 1)));
        bp___0 = (unsigned char const   *)((unsigned char *)swap);
        k = skip;
        while (k < len) {
          if ((int const   )*(ap___0 + k) != (int const   )*(bp___0 + k)) {
            cmp___0 = (int )((int const   )*(ap___0 + k) - (int const   )*(bp___0 + k));
            break;
          }
          k ++;
        }
        if (cmp___0 < 0) {
          break;
        }
        *(arrays + j___0) = *(arrays + (j___0 - 1));
        j___0 --;
      }
      *(arrays + j___0) = swap;
    }
    i ++;
  }
  return;
}
}
static void tcbwtsortstrheap(char const   **arrays , int anum , int len , int skip ) 
{ int bottom ;
  int top ;
  int mybot ;
  int i ;
  int cmp ;
  unsigned char const   *ap ;
  unsigned char const   *bp ;
  int j ;
  int cmp___0 ;
  unsigned char const   *ap___0 ;
  unsigned char const   *bp___0 ;
  int j___0 ;
  char const   *swap ;
  char const   *swap___0 ;
  int mybot___0 ;
  int i___0 ;
  int cmp___1 ;
  unsigned char const   *ap___1 ;
  unsigned char const   *bp___1 ;
  int j___1 ;
  int cmp___2 ;
  unsigned char const   *ap___2 ;
  unsigned char const   *bp___2 ;
  int j___2 ;

  {
  anum --;
  bottom = (anum >> 1) + 1;
  top = anum;
  while (bottom > 0) {
    bottom --;
    mybot = bottom;
    i = mybot * 2;
    while (i <= top) {
      if (i < top) {
        cmp = 0;
        ap = (unsigned char const   *)((unsigned char *)*(arrays + (i + 1)));
        bp = (unsigned char const   *)((unsigned char *)*(arrays + i));
        j = skip;
        while (j < len) {
          if ((int const   )*(ap + j) != (int const   )*(bp + j)) {
            cmp = (int )((int const   )*(ap + j) - (int const   )*(bp + j));
            break;
          }
          j ++;
        }
        if (cmp > 0) {
          i ++;
        }
      }
      cmp___0 = 0;
      ap___0 = (unsigned char const   *)((unsigned char *)*(arrays + mybot));
      bp___0 = (unsigned char const   *)((unsigned char *)*(arrays + i));
      j___0 = skip;
      while (j___0 < len) {
        if ((int const   )*(ap___0 + j___0) != (int const   )*(bp___0 + j___0)) {
          cmp___0 = (int )((int const   )*(ap___0 + j___0) - (int const   )*(bp___0 + j___0));
          break;
        }
        j___0 ++;
      }
      if (cmp___0 >= 0) {
        break;
      }
      swap = *(arrays + mybot);
      *(arrays + mybot) = *(arrays + i);
      *(arrays + i) = swap;
      mybot = i;
      i = mybot * 2;
    }
  }
  while (top > 0) {
    swap___0 = *(arrays + 0);
    *(arrays + 0) = *(arrays + top);
    *(arrays + top) = swap___0;
    top --;
    mybot___0 = bottom;
    i___0 = mybot___0 * 2;
    while (i___0 <= top) {
      if (i___0 < top) {
        cmp___1 = 0;
        ap___1 = (unsigned char const   *)((unsigned char *)*(arrays + (i___0 + 1)));
        bp___1 = (unsigned char const   *)((unsigned char *)*(arrays + i___0));
        j___1 = 0;
        while (j___1 < len) {
          if ((int const   )*(ap___1 + j___1) != (int const   )*(bp___1 + j___1)) {
            cmp___1 = (int )((int const   )*(ap___1 + j___1) - (int const   )*(bp___1 + j___1));
            break;
          }
          j___1 ++;
        }
        if (cmp___1 > 0) {
          i___0 ++;
        }
      }
      cmp___2 = 0;
      ap___2 = (unsigned char const   *)((unsigned char *)*(arrays + mybot___0));
      bp___2 = (unsigned char const   *)((unsigned char *)*(arrays + i___0));
      j___2 = 0;
      while (j___2 < len) {
        if ((int const   )*(ap___2 + j___2) != (int const   )*(bp___2 + j___2)) {
          cmp___2 = (int )((int const   )*(ap___2 + j___2) - (int const   )*(bp___2 + j___2));
          break;
        }
        j___2 ++;
      }
      if (cmp___2 >= 0) {
        break;
      }
      swap___0 = *(arrays + mybot___0);
      *(arrays + mybot___0) = *(arrays + i___0);
      *(arrays + i___0) = swap___0;
      mybot___0 = i___0;
      i___0 = mybot___0 * 2;
    }
  }
  return;
}
}
static void tcbwtsortchrcount(unsigned char *str , int len ) 
{ int cnt___0[256] ;
  int i ;
  int pos ;
  int i___0 ;

  {
  memset((void *)(cnt___0), 0, (unsigned int )((int )sizeof(cnt___0)));
  i = 0;
  while (i < len) {
    (cnt___0[*(str + i)]) ++;
    i ++;
  }
  pos = 0;
  i___0 = 0;
  while (i___0 < 256) {
    memset((void *)(str + pos), i___0, (unsigned int )cnt___0[i___0]);
    pos += cnt___0[i___0];
    i___0 ++;
  }
  return;
}
}
static void tcbwtsortchrinsert(unsigned char *str , int len ) 
{ int i ;
  unsigned char swap ;
  int j ;

  {
  i = 1;
  while (i < len) {
    if ((int )*(str + (i - 1)) - (int )*(str + i) > 0) {
      swap = *(str + i);
      j = i;
      while (j > 0) {
        if ((int )*(str + (j - 1)) - (int )swap < 0) {
          break;
        }
        *(str + j) = *(str + (j - 1));
        j --;
      }
      *(str + j) = swap;
    }
    i ++;
  }
  return;
}
}
static void tcbwtsortreccount(TCBWTREC *array , int anum ) 
{ TCBWTREC nbuf[16384] ;
  TCBWTREC *narray ;
  void *tmp ;
  int count[256] ;
  int accum[256] ;
  int i ;
  int i___0 ;
  int i___1 ;
  int i___2 ;
  int tmp___0 ;

  {
  narray = nbuf;
  if (anum > 16384) {
    while (1) {
      tmp = malloc((unsigned int )((int )sizeof(*narray) * anum));
      narray = (TCBWTREC *)tmp;
      if (! narray) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  memset((void *)(count), 0, (unsigned int )((int )sizeof(count)));
  i = 0;
  while (i < anum) {
    (count[(array + i)->tchr >> 23]) ++;
    i ++;
  }
  memcpy((void * __restrict  )(accum), (void const   * __restrict  )(count), (unsigned int )((int )sizeof(count)));
  i___0 = 1;
  while (i___0 < 256) {
    accum[i___0] = accum[i___0 - 1] + accum[i___0];
    i___0 ++;
  }
  i___1 = 0;
  while (i___1 < 256) {
    accum[i___1] -= count[i___1];
    i___1 ++;
  }
  i___2 = 0;
  while (i___2 < anum) {
    tmp___0 = accum[(array + i___2)->tchr >> 23];
    (accum[(array + i___2)->tchr >> 23]) ++;
    *(narray + tmp___0) = *(array + i___2);
    i___2 ++;
  }
  memcpy((void * __restrict  )array, (void const   * __restrict  )narray, (unsigned int )(anum * (int )sizeof(*narray)));
  if ((unsigned int )narray != (unsigned int )(nbuf)) {
    while (1) {
      free((void *)narray);
      break;
    }
  }
  return;
}
}
static void tcbwtsortrecinsert(TCBWTREC *array , int anum ) 
{ int i ;
  TCBWTREC swap ;
  int j ;

  {
  i = 1;
  while (i < anum) {
    if ((array + (i - 1))->tchr - (array + i)->tchr > 0) {
      swap = *(array + i);
      j = i;
      while (j > 0) {
        if ((array + (j - 1))->tchr - swap.tchr < 0) {
          break;
        }
        *(array + j) = *(array + (j - 1));
        j --;
      }
      *(array + j) = swap;
    }
    i ++;
  }
  return;
}
}
static int tcbwtsearchrec(TCBWTREC *array , int anum , int tchr ) 
{ int bottom ;
  int top ;
  int mid ;

  {
  bottom = 0;
  top = anum;
  while (1) {
    mid = (bottom + top) >> 1;
    if ((array + mid)->tchr == tchr) {
      return (mid);
    } else {
      if ((array + mid)->tchr < tchr) {
        bottom = mid + 1;
        if (bottom >= anum) {
          break;
        }
      } else {
        top = mid - 1;
      }
    }
    if (! (bottom <= top)) {
      break;
    }
  }
  return (-1);
}
}
unsigned char const   tcmtftable[256]  = 
  {      (unsigned char const   )0,      (unsigned char const   )1,      (unsigned char const   )2,      (unsigned char const   )3, 
        (unsigned char const   )4,      (unsigned char const   )5,      (unsigned char const   )6,      (unsigned char const   )7, 
        (unsigned char const   )8,      (unsigned char const   )9,      (unsigned char const   )10,      (unsigned char const   )11, 
        (unsigned char const   )12,      (unsigned char const   )13,      (unsigned char const   )14,      (unsigned char const   )15, 
        (unsigned char const   )16,      (unsigned char const   )17,      (unsigned char const   )18,      (unsigned char const   )19, 
        (unsigned char const   )20,      (unsigned char const   )21,      (unsigned char const   )22,      (unsigned char const   )23, 
        (unsigned char const   )24,      (unsigned char const   )25,      (unsigned char const   )26,      (unsigned char const   )27, 
        (unsigned char const   )28,      (unsigned char const   )29,      (unsigned char const   )30,      (unsigned char const   )31, 
        (unsigned char const   )32,      (unsigned char const   )33,      (unsigned char const   )34,      (unsigned char const   )35, 
        (unsigned char const   )36,      (unsigned char const   )37,      (unsigned char const   )38,      (unsigned char const   )39, 
        (unsigned char const   )40,      (unsigned char const   )41,      (unsigned char const   )42,      (unsigned char const   )43, 
        (unsigned char const   )44,      (unsigned char const   )45,      (unsigned char const   )46,      (unsigned char const   )47, 
        (unsigned char const   )48,      (unsigned char const   )49,      (unsigned char const   )50,      (unsigned char const   )51, 
        (unsigned char const   )52,      (unsigned char const   )53,      (unsigned char const   )54,      (unsigned char const   )55, 
        (unsigned char const   )56,      (unsigned char const   )57,      (unsigned char const   )58,      (unsigned char const   )59, 
        (unsigned char const   )60,      (unsigned char const   )61,      (unsigned char const   )62,      (unsigned char const   )63, 
        (unsigned char const   )64,      (unsigned char const   )65,      (unsigned char const   )66,      (unsigned char const   )67, 
        (unsigned char const   )68,      (unsigned char const   )69,      (unsigned char const   )70,      (unsigned char const   )71, 
        (unsigned char const   )72,      (unsigned char const   )73,      (unsigned char const   )74,      (unsigned char const   )75, 
        (unsigned char const   )76,      (unsigned char const   )77,      (unsigned char const   )78,      (unsigned char const   )79, 
        (unsigned char const   )80,      (unsigned char const   )81,      (unsigned char const   )82,      (unsigned char const   )83, 
        (unsigned char const   )84,      (unsigned char const   )85,      (unsigned char const   )86,      (unsigned char const   )87, 
        (unsigned char const   )88,      (unsigned char const   )89,      (unsigned char const   )90,      (unsigned char const   )91, 
        (unsigned char const   )92,      (unsigned char const   )93,      (unsigned char const   )94,      (unsigned char const   )95, 
        (unsigned char const   )96,      (unsigned char const   )97,      (unsigned char const   )98,      (unsigned char const   )99, 
        (unsigned char const   )100,      (unsigned char const   )101,      (unsigned char const   )102,      (unsigned char const   )103, 
        (unsigned char const   )104,      (unsigned char const   )105,      (unsigned char const   )106,      (unsigned char const   )107, 
        (unsigned char const   )108,      (unsigned char const   )109,      (unsigned char const   )110,      (unsigned char const   )111, 
        (unsigned char const   )112,      (unsigned char const   )113,      (unsigned char const   )114,      (unsigned char const   )115, 
        (unsigned char const   )116,      (unsigned char const   )117,      (unsigned char const   )118,      (unsigned char const   )119, 
        (unsigned char const   )120,      (unsigned char const   )121,      (unsigned char const   )122,      (unsigned char const   )123, 
        (unsigned char const   )124,      (unsigned char const   )125,      (unsigned char const   )126,      (unsigned char const   )127, 
        (unsigned char const   )128,      (unsigned char const   )129,      (unsigned char const   )130,      (unsigned char const   )131, 
        (unsigned char const   )132,      (unsigned char const   )133,      (unsigned char const   )134,      (unsigned char const   )135, 
        (unsigned char const   )136,      (unsigned char const   )137,      (unsigned char const   )138,      (unsigned char const   )139, 
        (unsigned char const   )140,      (unsigned char const   )141,      (unsigned char const   )142,      (unsigned char const   )143, 
        (unsigned char const   )144,      (unsigned char const   )145,      (unsigned char const   )146,      (unsigned char const   )147, 
        (unsigned char const   )148,      (unsigned char const   )149,      (unsigned char const   )150,      (unsigned char const   )151, 
        (unsigned char const   )152,      (unsigned char const   )153,      (unsigned char const   )154,      (unsigned char const   )155, 
        (unsigned char const   )156,      (unsigned char const   )157,      (unsigned char const   )158,      (unsigned char const   )159, 
        (unsigned char const   )160,      (unsigned char const   )161,      (unsigned char const   )162,      (unsigned char const   )163, 
        (unsigned char const   )164,      (unsigned char const   )165,      (unsigned char const   )166,      (unsigned char const   )167, 
        (unsigned char const   )168,      (unsigned char const   )169,      (unsigned char const   )170,      (unsigned char const   )171, 
        (unsigned char const   )172,      (unsigned char const   )173,      (unsigned char const   )174,      (unsigned char const   )175, 
        (unsigned char const   )176,      (unsigned char const   )177,      (unsigned char const   )178,      (unsigned char const   )179, 
        (unsigned char const   )180,      (unsigned char const   )181,      (unsigned char const   )182,      (unsigned char const   )183, 
        (unsigned char const   )184,      (unsigned char const   )185,      (unsigned char const   )186,      (unsigned char const   )187, 
        (unsigned char const   )188,      (unsigned char const   )189,      (unsigned char const   )190,      (unsigned char const   )191, 
        (unsigned char const   )192,      (unsigned char const   )193,      (unsigned char const   )194,      (unsigned char const   )195, 
        (unsigned char const   )196,      (unsigned char const   )197,      (unsigned char const   )198,      (unsigned char const   )199, 
        (unsigned char const   )200,      (unsigned char const   )201,      (unsigned char const   )202,      (unsigned char const   )203, 
        (unsigned char const   )204,      (unsigned char const   )205,      (unsigned char const   )206,      (unsigned char const   )207, 
        (unsigned char const   )208,      (unsigned char const   )209,      (unsigned char const   )210,      (unsigned char const   )211, 
        (unsigned char const   )212,      (unsigned char const   )213,      (unsigned char const   )214,      (unsigned char const   )215, 
        (unsigned char const   )216,      (unsigned char const   )217,      (unsigned char const   )218,      (unsigned char const   )219, 
        (unsigned char const   )220,      (unsigned char const   )221,      (unsigned char const   )222,      (unsigned char const   )223, 
        (unsigned char const   )224,      (unsigned char const   )225,      (unsigned char const   )226,      (unsigned char const   )227, 
        (unsigned char const   )228,      (unsigned char const   )229,      (unsigned char const   )230,      (unsigned char const   )231, 
        (unsigned char const   )232,      (unsigned char const   )233,      (unsigned char const   )234,      (unsigned char const   )235, 
        (unsigned char const   )236,      (unsigned char const   )237,      (unsigned char const   )238,      (unsigned char const   )239, 
        (unsigned char const   )240,      (unsigned char const   )241,      (unsigned char const   )242,      (unsigned char const   )243, 
        (unsigned char const   )244,      (unsigned char const   )245,      (unsigned char const   )246,      (unsigned char const   )247, 
        (unsigned char const   )248,      (unsigned char const   )249,      (unsigned char const   )250,      (unsigned char const   )251, 
        (unsigned char const   )252,      (unsigned char const   )253,      (unsigned char const   )254,      (unsigned char const   )255};
static void tcmtfencode(char *ptr , int size ) 
{ unsigned char table1[256] ;
  unsigned char table2[256] ;
  unsigned char *table ;
  unsigned char *another ;
  char const   *end ;
  char *wp ;
  unsigned char c ;
  unsigned char *tp ;
  unsigned char *tend ;
  int idx ;
  char *tmp ;
  unsigned char *swap ;

  {
  memcpy((void * __restrict  )(table1), (void const   * __restrict  )(tcmtftable),
         (unsigned int )((int )sizeof(tcmtftable)));
  table = table1;
  another = table2;
  end = (char const   *)(ptr + size);
  wp = ptr;
  while ((unsigned int )ptr < (unsigned int )end) {
    c = (unsigned char )*ptr;
    tp = table;
    tend = table + 256;
    while (1) {
      if ((unsigned int )tp < (unsigned int )tend) {
        if (! ((int )*tp != (int )c)) {
          break;
        }
      } else {
        break;
      }
      tp ++;
    }
    idx = tp - table;
    tmp = wp;
    wp ++;
    *tmp = (char )idx;
    if (idx > 0) {
      memcpy((void * __restrict  )another, (void const   * __restrict  )(& c), 1U);
      memcpy((void * __restrict  )(another + 1), (void const   * __restrict  )table,
             (unsigned int )idx);
      memcpy((void * __restrict  )((another + 1) + idx), (void const   * __restrict  )((table + idx) + 1),
             (unsigned int )(255 - idx));
      swap = table;
      table = another;
      another = swap;
    }
    ptr ++;
  }
  return;
}
}
static void tcmtfdecode(char *ptr , int size ) 
{ unsigned char table1[256] ;
  unsigned char table2[256] ;
  unsigned char *table ;
  unsigned char *another ;
  char const   *end ;
  char *wp ;
  int idx ;
  unsigned char c ;
  char *tmp ;
  unsigned char *swap ;

  {
  memcpy((void * __restrict  )(table1), (void const   * __restrict  )(tcmtftable),
         (unsigned int )((int )sizeof(tcmtftable)));
  table = table1;
  another = table2;
  end = (char const   *)(ptr + size);
  wp = ptr;
  while ((unsigned int )ptr < (unsigned int )end) {
    idx = (int )*((unsigned char *)ptr);
    c = *(table + idx);
    tmp = wp;
    wp ++;
    *tmp = (char )c;
    if (idx > 0) {
      memcpy((void * __restrict  )another, (void const   * __restrict  )(& c), 1U);
      memcpy((void * __restrict  )(another + 1), (void const   * __restrict  )table,
             (unsigned int )idx);
      memcpy((void * __restrict  )((another + 1) + idx), (void const   * __restrict  )((table + idx) + 1),
             (unsigned int )(255 - idx));
      swap = table;
      table = another;
      another = swap;
    }
    ptr ++;
  }
  return;
}
}
static int tcgammaencode(char const   *ptr , int size , char *obuf ) 
{ TCBITSTRM strm ;
  char const   *end ;
  unsigned int c ;
  int plen ;
  int jlen ;
  int tmp ;
  int sign ;

  {
  while (1) {
    strm.sp = (uint8_t *)obuf;
    strm.cp = strm.sp;
    *(strm.cp) = (unsigned char)0;
    strm.idx = 3;
    strm.size = 1;
    break;
  }
  end = ptr + size;
  while ((unsigned int )ptr < (unsigned int )end) {
    c = (unsigned int )*((unsigned char *)ptr);
    if (! c) {
      while (1) {
        if (strm.idx >= 8) {
          (strm.cp) ++;
          *(strm.cp) = (unsigned char)0;
          strm.idx = 0;
          (strm.size) ++;
        }
        *(strm.cp) = (unsigned char )((int )*(strm.cp) | (1 << strm.idx));
        (strm.idx) ++;
        break;
      }
    } else {
      c ++;
      plen = 8;
      while (1) {
        if (plen > 0) {
          if (! (! (c & (unsigned int )(1 << plen)))) {
            break;
          }
        } else {
          break;
        }
        plen --;
      }
      jlen = plen;
      while (1) {
        tmp = jlen;
        jlen --;
        if (! (tmp > 0)) {
          break;
        }
        while (1) {
          if (strm.idx >= 8) {
            (strm.cp) ++;
            *(strm.cp) = (unsigned char)0;
            strm.idx = 0;
            (strm.size) ++;
          }
          *(strm.cp) = (unsigned char )((int )*(strm.cp));
          (strm.idx) ++;
          break;
        }
      }
      while (plen >= 0) {
        sign = (c & (unsigned int )(1 << plen)) > 0U;
        while (1) {
          if (strm.idx >= 8) {
            (strm.cp) ++;
            *(strm.cp) = (unsigned char)0;
            strm.idx = 0;
            (strm.size) ++;
          }
          *(strm.cp) = (unsigned char )((int )*(strm.cp) | (sign << strm.idx));
          (strm.idx) ++;
          break;
        }
        plen --;
      }
    }
    ptr ++;
  }
  while (1) {
    if (strm.idx >= 8) {
      (strm.cp) ++;
      *(strm.cp) = (unsigned char)0;
      strm.idx = 0;
      (strm.size) ++;
    }
    *(strm.sp) = (unsigned char )((int )*(strm.sp) | (strm.idx & 7));
    break;
  }
  return (strm.size);
}
}
static int tcgammadecode(char const   *ptr , int size , char *obuf ) 
{ char *wp ;
  TCBITSTRM strm ;
  int bnum ;
  int sign ;
  char *tmp ;
  int plen ;
  unsigned int c ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  wp = obuf;
  while (1) {
    strm.sp = (uint8_t *)ptr;
    strm.cp = strm.sp;
    strm.idx = 3;
    strm.size = size;
    break;
  }
  bnum = (((strm.size - 1) << 3) + ((int )*(strm.sp) & 7)) - 3;
  while (bnum > 0) {
    while (1) {
      if (strm.idx >= 8) {
        (strm.cp) ++;
        strm.idx = 0;
      }
      sign = ((int )*(strm.cp) & (1 << strm.idx)) > 0;
      (strm.idx) ++;
      break;
    }
    bnum --;
    if (sign) {
      tmp = wp;
      wp ++;
      *tmp = (char)0;
    } else {
      plen = 1;
      while (bnum > 0) {
        while (1) {
          if (strm.idx >= 8) {
            (strm.cp) ++;
            strm.idx = 0;
          }
          sign = ((int )*(strm.cp) & (1 << strm.idx)) > 0;
          (strm.idx) ++;
          break;
        }
        bnum --;
        if (sign) {
          break;
        }
        plen ++;
      }
      c = 1U;
      while (1) {
        if (bnum > 0) {
          tmp___0 = plen;
          plen --;
          if (! (tmp___0 > 0)) {
            break;
          }
        } else {
          break;
        }
        while (1) {
          if (strm.idx >= 8) {
            (strm.cp) ++;
            strm.idx = 0;
          }
          sign = ((int )*(strm.cp) & (1 << strm.idx)) > 0;
          (strm.idx) ++;
          break;
        }
        bnum --;
        c = (c << 1) + (unsigned int )(sign > 0);
      }
      tmp___1 = wp;
      wp ++;
      *tmp___1 = (char )(c - 1U);
    }
  }
  return (wp - obuf);
}
}
#pragma merger(0,"/tmp/cil-7phmH4Qs.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
extern  __attribute__((__nothrow__)) int rename(char const   *__old , char const   *__new ) ;
char const   *tchdberrmsg(int ecode ) ;
TCHDB *tchdbnew(void) ;
void tchdbdel(TCHDB *hdb ) ;
int tchdbecode(TCHDB *hdb ) ;
_Bool tchdbsetmutex(TCHDB *hdb ) ;
_Bool tchdbtune(TCHDB *hdb , int64_t bnum , int8_t apow , int8_t fpow , uint8_t opts ) ;
_Bool tchdbsetcache(TCHDB *hdb , int32_t rcnum ) ;
_Bool tchdbsetxmsiz(TCHDB *hdb , int64_t xmsiz ) ;
_Bool tchdbsetdfunit(TCHDB *hdb , int32_t dfunit ) ;
_Bool tchdbopen(TCHDB *hdb , char const   *path , int omode ) ;
_Bool tchdbclose(TCHDB *hdb ) ;
_Bool tchdbput(TCHDB *hdb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) ;
_Bool tchdbput2(TCHDB *hdb , char const   *kstr , char const   *vstr ) ;
_Bool tchdbputkeep(TCHDB *hdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) ;
_Bool tchdbputkeep2(TCHDB *hdb , char const   *kstr , char const   *vstr ) ;
_Bool tchdbputcat(TCHDB *hdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) ;
_Bool tchdbputcat2(TCHDB *hdb , char const   *kstr , char const   *vstr ) ;
_Bool tchdbputasync(TCHDB *hdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                    int vsiz ) ;
_Bool tchdbputasync2(TCHDB *hdb , char const   *kstr , char const   *vstr ) ;
_Bool tchdbout(TCHDB *hdb , void const   *kbuf , int ksiz ) ;
_Bool tchdbout2(TCHDB *hdb , char const   *kstr ) ;
void *tchdbget(TCHDB *hdb , void const   *kbuf , int ksiz , int *sp ) ;
char *tchdbget2(TCHDB *hdb , char const   *kstr ) ;
int tchdbget3(TCHDB *hdb , void const   *kbuf , int ksiz , void *vbuf , int max ) ;
int tchdbvsiz(TCHDB *hdb , void const   *kbuf , int ksiz ) ;
int tchdbvsiz2(TCHDB *hdb , char const   *kstr ) ;
_Bool tchdbiterinit(TCHDB *hdb ) ;
void *tchdbiternext(TCHDB *hdb , int *sp ) ;
char *tchdbiternext2(TCHDB *hdb ) ;
_Bool tchdbiternext3(TCHDB *hdb , TCXSTR *kxstr , TCXSTR *vxstr ) ;
TCLIST *tchdbfwmkeys(TCHDB *hdb , void const   *pbuf , int psiz , int max ) ;
TCLIST *tchdbfwmkeys2(TCHDB *hdb , char const   *pstr , int max ) ;
int tchdbaddint(TCHDB *hdb , void const   *kbuf , int ksiz , int num ) ;
double tchdbadddouble(TCHDB *hdb , void const   *kbuf , int ksiz , double num ) ;
_Bool tchdbsync(TCHDB *hdb ) ;
_Bool tchdboptimize(TCHDB *hdb , int64_t bnum , int8_t apow , int8_t fpow , uint8_t opts ) ;
_Bool tchdbvanish(TCHDB *hdb ) ;
_Bool tchdbcopy(TCHDB *hdb , char const   *path ) ;
_Bool tchdbtranbegin(TCHDB *hdb ) ;
_Bool tchdbtrancommit(TCHDB *hdb ) ;
_Bool tchdbtranabort(TCHDB *hdb ) ;
char const   *tchdbpath(TCHDB *hdb ) ;
uint64_t tchdbrnum(TCHDB *hdb ) ;
uint64_t tchdbfsiz(TCHDB *hdb ) ;
void tchdbsetecode(TCHDB *hdb , int ecode , char const   *filename , int line , char const   *func ) ;
void tchdbsettype(TCHDB *hdb , uint8_t type ) ;
void tchdbsetdbgfd(TCHDB *hdb , int fd ) ;
int tchdbdbgfd(TCHDB *hdb ) ;
_Bool tchdbhasmutex(TCHDB *hdb ) ;
_Bool tchdbmemsync(TCHDB *hdb , _Bool phys ) ;
_Bool tchdbcacheclear(TCHDB *hdb ) ;
uint64_t tchdbbnum(TCHDB *hdb ) ;
uint32_t tchdbalign(TCHDB *hdb ) ;
uint32_t tchdbfbpmax(TCHDB *hdb ) ;
uint64_t tchdbxmsiz(TCHDB *hdb ) ;
uint64_t tchdbinode(TCHDB *hdb ) ;
time_t tchdbmtime(TCHDB *hdb ) ;
int tchdbomode(TCHDB *hdb ) ;
uint8_t tchdbtype(TCHDB *hdb ) ;
uint8_t tchdbflags(TCHDB *hdb ) ;
uint8_t tchdbopts(TCHDB *hdb ) ;
char *tchdbopaque(TCHDB *hdb ) ;
uint64_t tchdbbnumused(TCHDB *hdb ) ;
_Bool tchdbsetcodecfunc(TCHDB *hdb , void *(*enc)(void const   *ptr , int size , int *sp ,
                                                  void *op ) , void *encop , void *(*dec)(void const   *ptr ,
                                                                                          int size ,
                                                                                          int *sp ,
                                                                                          void *op ) ,
                        void *decop ) ;
void tchdbcodecfunc(TCHDB *hdb , TCCODEC *ep , void **eop , TCCODEC *dp , void **dop ) ;
uint32_t tchdbdfunit(TCHDB *hdb ) ;
_Bool tchdbdefrag(TCHDB *hdb , int64_t step ) ;
_Bool tchdbputproc(TCHDB *hdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) ;
void *tchdbgetnext(TCHDB *hdb , void const   *kbuf , int ksiz , int *sp ) ;
char *tchdbgetnext2(TCHDB *hdb , char const   *kstr ) ;
char *tchdbgetnext3(TCHDB *hdb , char const   *kbuf , int ksiz , int *sp , char const   **vbp ,
                    int *vsp ) ;
_Bool tchdbiterinit2(TCHDB *hdb , void const   *kbuf , int ksiz ) ;
_Bool tchdbiterinit3(TCHDB *hdb , char const   *kstr ) ;
_Bool tchdbforeach(TCHDB *hdb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                              int vsiz , void *op ) , void *op ) ;
_Bool tchdbtranvoid(TCHDB *hdb ) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
extern  __attribute__((__nothrow__)) __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off_t __offset ) ;
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __n , __off_t __offset ) ;
extern int fsync(int __fd ) ;
extern  __attribute__((__nothrow__)) int ftruncate(int __fd , __off_t __length ) ;
extern int msync(void *__addr , size_t __len , int __flags ) ;
extern  __attribute__((__nothrow__)) int pthread_mutexattr_init(pthread_mutexattr_t *__attr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutexattr_destroy(pthread_mutexattr_t *__attr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_mutexattr_settype(pthread_mutexattr_t *__attr ,
                                                                   int __kind )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_key_create(pthread_key_t *__key ,
                                                            void (*__destr_function)(void * ) )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_key_delete(pthread_key_t __key ) ;
extern  __attribute__((__nothrow__)) void *pthread_getspecific(pthread_key_t __key ) ;
extern  __attribute__((__nothrow__)) int pthread_setspecific(pthread_key_t __key ,
                                                             void const   *__pointer ) ;
static uint64_t tcgetprime(uint64_t num ) ;
static _Bool tchdbseekwrite(TCHDB *hdb , off_t off , void const   *buf , size_t size ) ;
static _Bool tchdbseekread(TCHDB *hdb , off_t off , void *buf , size_t size ) ;
static _Bool tchdbseekreadtry(TCHDB *hdb , off_t off , void *buf , size_t size ) ;
static void tchdbdumpmeta(TCHDB *hdb , char *hbuf ) ;
static void tchdbloadmeta(TCHDB *hdb , char const   *hbuf ) ;
static void tchdbclear(TCHDB *hdb ) ;
static int32_t tchdbpadsize(TCHDB *hdb , uint64_t off ) ;
static void tchdbsetflag(TCHDB *hdb , int flag , _Bool sign ) ;
static uint64_t tchdbbidx(TCHDB *hdb , char const   *kbuf , int ksiz , uint8_t *hp ) ;
static off_t tchdbgetbucket(TCHDB *hdb , uint64_t bidx ) ;
static void tchdbsetbucket(TCHDB *hdb , uint64_t bidx , uint64_t off ) ;
static _Bool tchdbsavefbp(TCHDB *hdb ) ;
static _Bool tchdbloadfbp(TCHDB *hdb ) ;
static void tcfbpsortbyoff(HDBFB *fbpool , int fbpnum ) ;
static void tcfbpsortbyrsiz(HDBFB *fbpool , int fbpnum ) ;
static void tchdbfbpmerge(TCHDB *hdb ) ;
static void tchdbfbpinsert(TCHDB *hdb , uint64_t off , uint32_t rsiz ) ;
static _Bool tchdbfbpsearch(TCHDB *hdb , TCHREC *rec ) ;
static _Bool tchdbfbpsplice(TCHDB *hdb , TCHREC *rec , uint32_t nsiz ) ;
static void tchdbfbptrim(TCHDB *hdb , uint64_t base , uint64_t next , uint64_t off ,
                         uint32_t rsiz ) ;
static _Bool tchdbwritefb(TCHDB *hdb , uint64_t off , uint32_t rsiz ) ;
static _Bool tchdbwriterec(TCHDB *hdb , TCHREC *rec , uint64_t bidx , off_t entoff ) ;
static _Bool tchdbreadrec(TCHDB *hdb , TCHREC *rec , char *rbuf ) ;
static _Bool tchdbreadrecbody(TCHDB *hdb , TCHREC *rec ) ;
static _Bool tchdbremoverec(TCHDB *hdb , TCHREC *rec , char *rbuf , uint64_t bidx ,
                            off_t entoff ) ;
static _Bool tchdbshiftrec(TCHDB *hdb , TCHREC *rec , char *rbuf , off_t destoff ) ;
static int tcreckeycmp(char const   *abuf , int asiz , char const   *bbuf , int bsiz ) ;
static _Bool tchdbflushdrp(TCHDB *hdb ) ;
static void tchdbcacheadjust(TCHDB *hdb ) ;
static _Bool tchdbwalinit(TCHDB *hdb ) ;
static _Bool tchdbwalwrite(TCHDB *hdb , uint64_t off , int64_t size ) ;
static int tchdbwalrestore(TCHDB *hdb , char const   *path ) ;
static _Bool tchdbwalremove(TCHDB *hdb , char const   *path ) ;
static _Bool tchdbopenimpl(TCHDB *hdb , char const   *path , int omode ) ;
static _Bool tchdbcloseimpl(TCHDB *hdb ) ;
static _Bool tchdbputimpl(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                          uint8_t hash , char const   *vbuf , int vsiz , int dmode ) ;
static void tchdbdrpappend(TCHDB *hdb , char const   *kbuf , int ksiz , char const   *vbuf ,
                           int vsiz , uint8_t hash ) ;
static _Bool tchdbputasyncimpl(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                               uint8_t hash , char const   *vbuf , int vsiz ) ;
static _Bool tchdboutimpl(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                          uint8_t hash ) ;
static char *tchdbgetimpl(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                          uint8_t hash , int *sp ) ;
static int tchdbgetintobuf(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                           uint8_t hash , char *vbuf , int max ) ;
static char *tchdbgetnextimpl(TCHDB *hdb , char const   *kbuf , int ksiz , int *sp ,
                              char const   **vbp , int *vsp ) ;
static int tchdbvsizimpl(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                         uint8_t hash ) ;
static _Bool tchdbiterinitimpl(TCHDB *hdb ) ;
static char *tchdbiternextimpl(TCHDB *hdb , int *sp ) ;
static _Bool tchdbiternextintoxstr(TCHDB *hdb , TCXSTR *kxstr , TCXSTR *vxstr ) ;
static _Bool tchdboptimizeimpl(TCHDB *hdb , int64_t bnum , int8_t apow , int8_t fpow ,
                               uint8_t opts ) ;
static _Bool tchdbvanishimpl(TCHDB *hdb ) ;
static _Bool tchdbcopyimpl(TCHDB *hdb , char const   *path ) ;
static _Bool tchdbdefragimpl(TCHDB *hdb , int64_t step ) ;
static _Bool tchdbiterjumpimpl(TCHDB *hdb , char const   *kbuf , int ksiz ) ;
static _Bool tchdbforeachimpl(TCHDB *hdb , _Bool (*iter)(void const   *kbuf , int ksiz ,
                                                         void const   *vbuf , int vsiz ,
                                                         void *op ) , void *op ) ;
static _Bool tchdblockmethod(TCHDB *hdb , _Bool wr ) ;
static _Bool tchdbunlockmethod(TCHDB *hdb ) ;
static _Bool tchdblockrecord(TCHDB *hdb , uint8_t bidx , _Bool wr ) ;
static _Bool tchdbunlockrecord(TCHDB *hdb , uint8_t bidx ) ;
static _Bool tchdblockallrecords(TCHDB *hdb , _Bool wr ) ;
static _Bool tchdbunlockallrecords(TCHDB *hdb ) ;
static _Bool tchdblockdb(TCHDB *hdb ) ;
static _Bool tchdbunlockdb(TCHDB *hdb ) ;
static _Bool tchdblockwal(TCHDB *hdb ) ;
static _Bool tchdbunlockwal(TCHDB *hdb ) ;
void tchdbprintmeta(TCHDB *hdb ) ;
void tchdbprintrec(TCHDB *hdb , TCHREC *rec ) ;
char const   *tchdberrmsg(int ecode ) 
{ char const   *tmp ;

  {
  tmp = tcerrmsg(ecode);
  return (tmp);
}
}
TCHDB *tchdbnew(void) 
{ TCHDB *hdb ;
  void *tmp ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*hdb)));
    hdb = (TCHDB *)tmp;
    if (! hdb) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tchdbclear(hdb);
  return (hdb);
}
}
void tchdbdel(TCHDB *hdb ) 
{ int i ;

  {
  if (hdb->fd >= 0) {
    tchdbclose(hdb);
  }
  if (hdb->mmtx) {
    pthread_key_delete(*((pthread_key_t *)hdb->eckey));
    pthread_mutex_destroy((pthread_mutex_t *)hdb->wmtx);
    pthread_mutex_destroy((pthread_mutex_t *)hdb->tmtx);
    pthread_mutex_destroy((pthread_mutex_t *)hdb->dmtx);
    i = 255;
    while (i >= 0) {
      pthread_rwlock_destroy((pthread_rwlock_t *)hdb->rmtxs + i);
      i --;
    }
    pthread_rwlock_destroy((pthread_rwlock_t *)hdb->mmtx);
    while (1) {
      free(hdb->eckey);
      break;
    }
    while (1) {
      free(hdb->wmtx);
      break;
    }
    while (1) {
      free(hdb->tmtx);
      break;
    }
    while (1) {
      free(hdb->dmtx);
      break;
    }
    while (1) {
      free(hdb->rmtxs);
      break;
    }
    while (1) {
      free(hdb->mmtx);
      break;
    }
  }
  while (1) {
    free((void *)hdb);
    break;
  }
  return;
}
}
int tchdbecode(TCHDB *hdb ) 
{ void *tmp ;
  int tmp___0 ;

  {
  if (hdb->mmtx) {
    tmp = pthread_getspecific(*((pthread_key_t *)hdb->eckey));
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = hdb->ecode;
  }
  return (tmp___0);
}
}
_Bool tchdbsetmutex(TCHDB *hdb ) 
{ pthread_mutexattr_t rma ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  _Bool err ;
  int tmp___5 ;
  int tmp___6 ;
  int i ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  if (hdb->mmtx) {
    tchdbsetecode(hdb, 2, "tchdb.c", 259, "tchdbsetmutex");
    return ((_Bool)0);
  } else {
    if (hdb->fd >= 0) {
      tchdbsetecode(hdb, 2, "tchdb.c", 259, "tchdbsetmutex");
      return ((_Bool)0);
    }
  }
  pthread_mutexattr_init(& rma);
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(pthread_rwlock_t )));
    hdb->mmtx = tmp;
    if (! tmp) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___0 = malloc((unsigned int )(256 * (int )sizeof(pthread_rwlock_t )));
    hdb->rmtxs = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(pthread_mutex_t )));
    hdb->dmtx = tmp___1;
    if (! tmp___1) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___2 = malloc((unsigned int )((int )sizeof(pthread_mutex_t )));
    hdb->tmtx = tmp___2;
    if (! tmp___2) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___3 = malloc((unsigned int )((int )sizeof(pthread_mutex_t )));
    hdb->wmtx = tmp___3;
    if (! tmp___3) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___4 = malloc((unsigned int )((int )sizeof(pthread_key_t )));
    hdb->eckey = tmp___4;
    if (! tmp___4) {
      tcmyfatal("out of memory");
    }
    break;
  }
  err = (_Bool)0;
  tmp___5 = pthread_mutexattr_settype(& rma, 1);
  if (tmp___5 != 0) {
    err = (_Bool)1;
  }
  tmp___6 = pthread_rwlock_init((pthread_rwlock_t * __restrict  )hdb->mmtx, (pthread_rwlockattr_t const   * __restrict  )((void *)0));
  if (tmp___6 != 0) {
    err = (_Bool)1;
  }
  i = 0;
  while (i <= 255) {
    tmp___7 = pthread_rwlock_init((pthread_rwlock_t * __restrict  )((pthread_rwlock_t *)hdb->rmtxs + i),
                                  (pthread_rwlockattr_t const   * __restrict  )((void *)0));
    if (tmp___7 != 0) {
      err = (_Bool)1;
    }
    i ++;
  }
  tmp___8 = pthread_mutex_init((pthread_mutex_t *)hdb->dmtx, (pthread_mutexattr_t const   *)(& rma));
  if (tmp___8 != 0) {
    err = (_Bool)1;
  }
  tmp___9 = pthread_mutex_init((pthread_mutex_t *)hdb->tmtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___9 != 0) {
    err = (_Bool)1;
  }
  tmp___10 = pthread_mutex_init((pthread_mutex_t *)hdb->wmtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___10 != 0) {
    err = (_Bool)1;
  }
  tmp___11 = pthread_key_create((pthread_key_t *)hdb->eckey, (void (*)(void * ))((void *)0));
  if (tmp___11 != 0) {
    err = (_Bool)1;
  }
  if (err) {
    tchdbsetecode(hdb, 1, "tchdb.c", 281, "tchdbsetmutex");
    pthread_mutexattr_destroy(& rma);
    while (1) {
      free(hdb->eckey);
      break;
    }
    while (1) {
      free(hdb->wmtx);
      break;
    }
    while (1) {
      free(hdb->tmtx);
      break;
    }
    while (1) {
      free(hdb->dmtx);
      break;
    }
    while (1) {
      free(hdb->rmtxs);
      break;
    }
    while (1) {
      free(hdb->mmtx);
      break;
    }
    hdb->eckey = (void *)0;
    hdb->wmtx = (void *)0;
    hdb->tmtx = (void *)0;
    hdb->dmtx = (void *)0;
    hdb->rmtxs = (void *)0;
    hdb->mmtx = (void *)0;
    return ((_Bool)0);
  }
  pthread_mutexattr_destroy(& rma);
  return ((_Bool)1);
}
}
_Bool tchdbtune(TCHDB *hdb , int64_t bnum , int8_t apow , int8_t fpow , uint8_t opts ) 
{ uint64_t tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  if (hdb->fd >= 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 306, "tchdbtune");
    return ((_Bool)0);
  }
  if (bnum > 0LL) {
    tmp = tcgetprime((unsigned long long )bnum);
    hdb->bnum = tmp;
  } else {
    hdb->bnum = 131071ULL;
  }
  if ((int )apow >= 0) {
    tmp___0 = tclmin((long )apow, 16L);
    hdb->apow = (unsigned char )tmp___0;
  } else {
    hdb->apow = (unsigned char)4;
  }
  if ((int )fpow >= 0) {
    tmp___1 = tclmin((long )fpow, 20L);
    hdb->fpow = (unsigned char )tmp___1;
  } else {
    hdb->fpow = (unsigned char)10;
  }
  hdb->opts = opts;
  if (! _tc_deflate) {
    hdb->opts = (unsigned char )((int )hdb->opts & -3);
  }
  if (! _tc_bzcompress) {
    hdb->opts = (unsigned char )((int )hdb->opts & -5);
  }
  return ((_Bool)1);
}
}
_Bool tchdbsetcache(TCHDB *hdb , int32_t rcnum ) 
{ long tmp ;
  long tmp___0 ;

  {
  if (hdb->fd >= 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 323, "tchdbsetcache");
    return ((_Bool)0);
  }
  if (rcnum > 0) {
    tmp = tclmax((long )rcnum, 256L);
    tmp___0 = tclmin(tmp, 536870911L);
    hdb->rcnum = (unsigned int )tmp___0;
  } else {
    hdb->rcnum = 0U;
  }
  return ((_Bool)1);
}
}
_Bool tchdbsetxmsiz(TCHDB *hdb , int64_t xmsiz ) 
{ uint64_t tmp ;

  {
  if (hdb->fd >= 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 335, "tchdbsetxmsiz");
    return ((_Bool)0);
  }
  if (xmsiz > 0LL) {
    tmp = tcpagealign((unsigned long long )xmsiz);
    hdb->xmsiz = tmp;
  } else {
    hdb->xmsiz = 0ULL;
  }
  return ((_Bool)1);
}
}
_Bool tchdbsetdfunit(TCHDB *hdb , int32_t dfunit ) 
{ 

  {
  if (hdb->fd >= 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 347, "tchdbsetdfunit");
    return ((_Bool)0);
  }
  if (dfunit > 0) {
    hdb->dfunit = (unsigned int )dfunit;
  } else {
    hdb->dfunit = 0U;
  }
  return ((_Bool)1);
}
}
_Bool tchdbopen(TCHDB *hdb , char const   *path , int omode ) 
{ _Bool tmp ;
  int tmp___0 ;
  char *rpath ;
  char *tmp___1 ;
  int ecode ;
  int *tmp___2 ;
  _Bool tmp___3 ;
  _Bool rv ;
  _Bool tmp___4 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd >= 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 360, "tchdbopen");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcrealpath(path);
  rpath = tmp___1;
  if (! rpath) {
    ecode = 7;
    tmp___2 = __errno_location();
    switch (*tmp___2) {
    case 13: 
    ecode = 4;
    break;
    case 2: 
    ecode = 3;
    break;
    case 20: 
    ecode = 3;
    break;
    }
    tchdbsetecode(hdb, ecode, "tchdb.c", 372, "tchdbopen");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  tmp___3 = tcpathlock((char const   *)rpath);
  if (! tmp___3) {
    tchdbsetecode(hdb, 1, "tchdb.c", 377, "tchdbopen");
    while (1) {
      free((void *)rpath);
      break;
    }
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  tmp___4 = tchdbopenimpl(hdb, path, omode);
  rv = tmp___4;
  if (rv) {
    hdb->rpath = rpath;
  } else {
    tcpathunlock((char const   *)rpath);
    while (1) {
      free((void *)rpath);
      break;
    }
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
_Bool tchdbclose(TCHDB *hdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 399, "tchdbclose");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tchdbcloseimpl(hdb);
  rv = tmp___1;
  tcpathunlock((char const   *)hdb->rpath);
  while (1) {
    free((void *)hdb->rpath);
    break;
  }
  hdb->rpath = (char *)((void *)0);
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
_Bool tchdbput(TCHDB *hdb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  char *zbuf ;
  void *tmp___5 ;
  _Bool rv ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool rv___0 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  tmp___1 = tchdbbidx(hdb, (char const   *)kbuf, ksiz, & hash);
  bidx = tmp___1;
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      _L: 
      tchdbsetecode(hdb, 2, "tchdb.c", 419, "tchdbput");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->async) {
    tmp___2 = tchdbflushdrp(hdb);
    if (! tmp___2) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->mmtx) {
    tmp___3 = tchdblockrecord(hdb, (unsigned char )bidx, (_Bool)1);
    tmp___4 = (int )tmp___3;
  } else {
    tmp___4 = 1;
  }
  if (! tmp___4) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  if (hdb->zmode) {
    if ((int )hdb->opts & 2) {
      zbuf = (*_tc_deflate)((char const   *)vbuf, vsiz, & vsiz, 1);
    } else {
      if ((int )hdb->opts & 4) {
        zbuf = (*_tc_bzcompress)((char const   *)vbuf, vsiz, & vsiz);
      } else {
        if ((int )hdb->opts & 8) {
          zbuf = tcbsencode((char const   *)vbuf, vsiz, & vsiz);
        } else {
          tmp___5 = (*(hdb->enc))(vbuf, vsiz, & vsiz, hdb->encop);
          zbuf = (char *)tmp___5;
        }
      }
    }
    if (! zbuf) {
      tchdbsetecode(hdb, 9999, "tchdb.c", 443, "tchdbput");
      if (hdb->mmtx) {
        tchdbunlockrecord(hdb, (unsigned char )bidx);
      }
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
    tmp___6 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)zbuf,
                           vsiz, 0);
    rv = tmp___6;
    while (1) {
      free((void *)zbuf);
      break;
    }
    if (hdb->mmtx) {
      tchdbunlockrecord(hdb, (unsigned char )bidx);
    }
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    if (hdb->dfunit > 0U) {
      if (hdb->dfcnt > hdb->dfunit) {
        tmp___7 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
        if (! tmp___7) {
          rv = (_Bool)0;
        }
      }
    }
    return (rv);
  }
  tmp___8 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)vbuf,
                         vsiz, 0);
  rv___0 = tmp___8;
  if (hdb->mmtx) {
    tchdbunlockrecord(hdb, (unsigned char )bidx);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  if (hdb->dfunit > 0U) {
    if (hdb->dfcnt > hdb->dfunit) {
      tmp___9 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
      if (! tmp___9) {
        rv___0 = (_Bool)0;
      }
    }
  }
  return (rv___0);
}
}
_Bool tchdbput2(TCHDB *hdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tchdbput(hdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                     (int )tmp);
  return (tmp___1);
}
}
_Bool tchdbputkeep(TCHDB *hdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  char *zbuf ;
  void *tmp___5 ;
  _Bool rv ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool rv___0 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  tmp___1 = tchdbbidx(hdb, (char const   *)kbuf, ksiz, & hash);
  bidx = tmp___1;
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      _L: 
      tchdbsetecode(hdb, 2, "tchdb.c", 479, "tchdbputkeep");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->async) {
    tmp___2 = tchdbflushdrp(hdb);
    if (! tmp___2) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->mmtx) {
    tmp___3 = tchdblockrecord(hdb, (unsigned char )bidx, (_Bool)1);
    tmp___4 = (int )tmp___3;
  } else {
    tmp___4 = 1;
  }
  if (! tmp___4) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  if (hdb->zmode) {
    if ((int )hdb->opts & 2) {
      zbuf = (*_tc_deflate)((char const   *)vbuf, vsiz, & vsiz, 1);
    } else {
      if ((int )hdb->opts & 4) {
        zbuf = (*_tc_bzcompress)((char const   *)vbuf, vsiz, & vsiz);
      } else {
        if ((int )hdb->opts & 8) {
          zbuf = tcbsencode((char const   *)vbuf, vsiz, & vsiz);
        } else {
          tmp___5 = (*(hdb->enc))(vbuf, vsiz, & vsiz, hdb->encop);
          zbuf = (char *)tmp___5;
        }
      }
    }
    if (! zbuf) {
      tchdbsetecode(hdb, 9999, "tchdb.c", 503, "tchdbputkeep");
      if (hdb->mmtx) {
        tchdbunlockrecord(hdb, (unsigned char )bidx);
      }
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
    tmp___6 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)zbuf,
                           vsiz, 1);
    rv = tmp___6;
    while (1) {
      free((void *)zbuf);
      break;
    }
    if (hdb->mmtx) {
      tchdbunlockrecord(hdb, (unsigned char )bidx);
    }
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    if (hdb->dfunit > 0U) {
      if (hdb->dfcnt > hdb->dfunit) {
        tmp___7 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
        if (! tmp___7) {
          rv = (_Bool)0;
        }
      }
    }
    return (rv);
  }
  tmp___8 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)vbuf,
                         vsiz, 1);
  rv___0 = tmp___8;
  if (hdb->mmtx) {
    tchdbunlockrecord(hdb, (unsigned char )bidx);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  if (hdb->dfunit > 0U) {
    if (hdb->dfcnt > hdb->dfunit) {
      tmp___9 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
      if (! tmp___9) {
        rv___0 = (_Bool)0;
      }
    }
  }
  return (rv___0);
}
}
_Bool tchdbputkeep2(TCHDB *hdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tchdbputkeep(hdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                         (int )tmp);
  return (tmp___1);
}
}
_Bool tchdbputcat(TCHDB *hdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  char *zbuf ;
  int osiz ;
  char *obuf ;
  char *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  _Bool rv ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool rv___0 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  tmp___1 = tchdbbidx(hdb, (char const   *)kbuf, ksiz, & hash);
  bidx = tmp___1;
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      _L: 
      tchdbsetecode(hdb, 2, "tchdb.c", 538, "tchdbputcat");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->async) {
    tmp___2 = tchdbflushdrp(hdb);
    if (! tmp___2) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->mmtx) {
    tmp___3 = tchdblockrecord(hdb, (unsigned char )bidx, (_Bool)1);
    tmp___4 = (int )tmp___3;
  } else {
    tmp___4 = 1;
  }
  if (! tmp___4) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  if (hdb->zmode) {
    tmp___5 = tchdbgetimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, & osiz);
    obuf = tmp___5;
    if (obuf) {
      while (1) {
        tmp___6 = realloc((void *)obuf, (unsigned int )((osiz + vsiz) + 1));
        obuf = (char *)tmp___6;
        if (! obuf) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(obuf + osiz), (void const   * __restrict  )vbuf,
             (unsigned int )vsiz);
      if ((int )hdb->opts & 2) {
        zbuf = (*_tc_deflate)((char const   *)obuf, osiz + vsiz, & vsiz, 1);
      } else {
        if ((int )hdb->opts & 4) {
          zbuf = (*_tc_bzcompress)((char const   *)obuf, osiz + vsiz, & vsiz);
        } else {
          if ((int )hdb->opts & 8) {
            zbuf = tcbsencode((char const   *)obuf, osiz + vsiz, & vsiz);
          } else {
            tmp___7 = (*(hdb->enc))((void const   *)obuf, osiz + vsiz, & vsiz, hdb->encop);
            zbuf = (char *)tmp___7;
          }
        }
      }
      while (1) {
        free((void *)obuf);
        break;
      }
    } else {
      if ((int )hdb->opts & 2) {
        zbuf = (*_tc_deflate)((char const   *)vbuf, vsiz, & vsiz, 1);
      } else {
        if ((int )hdb->opts & 4) {
          zbuf = (*_tc_bzcompress)((char const   *)vbuf, vsiz, & vsiz);
        } else {
          if ((int )hdb->opts & 8) {
            zbuf = tcbsencode((char const   *)vbuf, vsiz, & vsiz);
          } else {
            tmp___8 = (*(hdb->enc))(vbuf, vsiz, & vsiz, hdb->encop);
            zbuf = (char *)tmp___8;
          }
        }
      }
    }
    if (! zbuf) {
      tchdbsetecode(hdb, 9999, "tchdb.c", 579, "tchdbputcat");
      if (hdb->mmtx) {
        tchdbunlockrecord(hdb, (unsigned char )bidx);
      }
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
    tmp___9 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)zbuf,
                           vsiz, 0);
    rv = tmp___9;
    while (1) {
      free((void *)zbuf);
      break;
    }
    if (hdb->mmtx) {
      tchdbunlockrecord(hdb, (unsigned char )bidx);
    }
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    if (hdb->dfunit > 0U) {
      if (hdb->dfcnt > hdb->dfunit) {
        tmp___10 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
        if (! tmp___10) {
          rv = (_Bool)0;
        }
      }
    }
    return (rv);
  }
  tmp___11 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)vbuf,
                          vsiz, 2);
  rv___0 = tmp___11;
  if (hdb->mmtx) {
    tchdbunlockrecord(hdb, (unsigned char )bidx);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  if (hdb->dfunit > 0U) {
    if (hdb->dfcnt > hdb->dfunit) {
      tmp___12 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
      if (! tmp___12) {
        rv___0 = (_Bool)0;
      }
    }
  }
  return (rv___0);
}
}
_Bool tchdbputcat2(TCHDB *hdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tchdbputcat(hdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                        (int )tmp);
  return (tmp___1);
}
}
_Bool tchdbputasync(TCHDB *hdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                    int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___1 ;
  char *zbuf ;
  void *tmp___2 ;
  _Bool rv ;
  _Bool tmp___3 ;
  _Bool rv___0 ;
  _Bool tmp___4 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  tmp___1 = tchdbbidx(hdb, (char const   *)kbuf, ksiz, & hash);
  bidx = tmp___1;
  hdb->async = (_Bool)1;
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      _L: 
      tchdbsetecode(hdb, 2, "tchdb.c", 616, "tchdbputasync");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->zmode) {
    if ((int )hdb->opts & 2) {
      zbuf = (*_tc_deflate)((char const   *)vbuf, vsiz, & vsiz, 1);
    } else {
      if ((int )hdb->opts & 4) {
        zbuf = (*_tc_bzcompress)((char const   *)vbuf, vsiz, & vsiz);
      } else {
        if ((int )hdb->opts & 8) {
          zbuf = tcbsencode((char const   *)vbuf, vsiz, & vsiz);
        } else {
          tmp___2 = (*(hdb->enc))(vbuf, vsiz, & vsiz, hdb->encop);
          zbuf = (char *)tmp___2;
        }
      }
    }
    if (! zbuf) {
      tchdbsetecode(hdb, 9999, "tchdb.c", 632, "tchdbputasync");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
    tmp___3 = tchdbputasyncimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)zbuf,
                                vsiz);
    rv = tmp___3;
    while (1) {
      free((void *)zbuf);
      break;
    }
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return (rv);
  }
  tmp___4 = tchdbputasyncimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)vbuf,
                              vsiz);
  rv___0 = tmp___4;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv___0);
}
}
_Bool tchdbputasync2(TCHDB *hdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tchdbputasync(hdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                          (int )tmp);
  return (tmp___1);
}
}
_Bool tchdbout(TCHDB *hdb , void const   *kbuf , int ksiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  _Bool rv ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  tmp___1 = tchdbbidx(hdb, (char const   *)kbuf, ksiz, & hash);
  bidx = tmp___1;
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      _L: 
      tchdbsetecode(hdb, 2, "tchdb.c", 661, "tchdbout");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->async) {
    tmp___2 = tchdbflushdrp(hdb);
    if (! tmp___2) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->mmtx) {
    tmp___3 = tchdblockrecord(hdb, (unsigned char )bidx, (_Bool)1);
    tmp___4 = (int )tmp___3;
  } else {
    tmp___4 = 1;
  }
  if (! tmp___4) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  tmp___5 = tchdboutimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash);
  rv = tmp___5;
  if (hdb->mmtx) {
    tchdbunlockrecord(hdb, (unsigned char )bidx);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  if (hdb->dfunit > 0U) {
    if (hdb->dfcnt > hdb->dfunit) {
      tmp___6 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
      if (! tmp___6) {
        rv = (_Bool)0;
      }
    }
  }
  return (rv);
}
}
_Bool tchdbout2(TCHDB *hdb , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tchdbout(hdb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
void *tchdbget(TCHDB *hdb , void const   *kbuf , int ksiz , int *sp ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  char *rv ;
  char *tmp___5 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((void *)0);
  }
  tmp___1 = tchdbbidx(hdb, (char const   *)kbuf, ksiz, & hash);
  bidx = tmp___1;
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 696, "tchdbget");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((void *)0);
  }
  if (hdb->async) {
    tmp___2 = tchdbflushdrp(hdb);
    if (! tmp___2) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((void *)0);
    }
  }
  if (hdb->mmtx) {
    tmp___3 = tchdblockrecord(hdb, (unsigned char )bidx, (_Bool)0);
    tmp___4 = (int )tmp___3;
  } else {
    tmp___4 = 1;
  }
  if (! tmp___4) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((void *)0);
  }
  tmp___5 = tchdbgetimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, sp);
  rv = tmp___5;
  if (hdb->mmtx) {
    tchdbunlockrecord(hdb, (unsigned char )bidx);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return ((void *)rv);
}
}
char *tchdbget2(TCHDB *hdb , char const   *kstr ) 
{ int vsiz ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tchdbget(hdb, (void const   *)kstr, (int )tmp, & vsiz);
  return ((char *)tmp___0);
}
}
int tchdbget3(TCHDB *hdb , void const   *kbuf , int ksiz , void *vbuf , int max ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  int rv ;
  int tmp___5 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (-1);
  }
  tmp___1 = tchdbbidx(hdb, (char const   *)kbuf, ksiz, & hash);
  bidx = tmp___1;
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 730, "tchdbget3");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return (-1);
  }
  if (hdb->async) {
    tmp___2 = tchdbflushdrp(hdb);
    if (! tmp___2) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return (-1);
    }
  }
  if (hdb->mmtx) {
    tmp___3 = tchdblockrecord(hdb, (unsigned char )bidx, (_Bool)0);
    tmp___4 = (int )tmp___3;
  } else {
    tmp___4 = 1;
  }
  if (! tmp___4) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return (-1);
  }
  tmp___5 = tchdbgetintobuf(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char *)vbuf,
                            max);
  rv = tmp___5;
  if (hdb->mmtx) {
    tchdbunlockrecord(hdb, (unsigned char )bidx);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
int tchdbvsiz(TCHDB *hdb , void const   *kbuf , int ksiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  int rv ;
  int tmp___5 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (-1);
  }
  tmp___1 = tchdbbidx(hdb, (char const   *)kbuf, ksiz, & hash);
  bidx = tmp___1;
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 756, "tchdbvsiz");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return (-1);
  }
  if (hdb->async) {
    tmp___2 = tchdbflushdrp(hdb);
    if (! tmp___2) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return (-1);
    }
  }
  if (hdb->mmtx) {
    tmp___3 = tchdblockrecord(hdb, (unsigned char )bidx, (_Bool)0);
    tmp___4 = (int )tmp___3;
  } else {
    tmp___4 = 1;
  }
  if (! tmp___4) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return (-1);
  }
  tmp___5 = tchdbvsizimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash);
  rv = tmp___5;
  if (hdb->mmtx) {
    tchdbunlockrecord(hdb, (unsigned char )bidx);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
int tchdbvsiz2(TCHDB *hdb , char const   *kstr ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tchdbvsiz(hdb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
_Bool tchdbiterinit(TCHDB *hdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 787, "tchdbiterinit");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___2 = tchdbiterinitimpl(hdb);
  rv = tmp___2;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
void *tchdbiternext(TCHDB *hdb , int *sp ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  char *rv ;
  char *tmp___2 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((void *)0);
  }
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (hdb->iter < 1ULL) {
      _L: 
      tchdbsetecode(hdb, 2, "tchdb.c", 806, "tchdbiternext");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((void *)0);
    }
  }
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((void *)0);
    }
  }
  tmp___2 = tchdbiternextimpl(hdb, sp);
  rv = tmp___2;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return ((void *)rv);
}
}
char *tchdbiternext2(TCHDB *hdb ) 
{ int vsiz ;
  void *tmp ;

  {
  tmp = tchdbiternext(hdb, & vsiz);
  return ((char *)tmp);
}
}
_Bool tchdbiternext3(TCHDB *hdb , TCXSTR *kxstr , TCXSTR *vxstr ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (hdb->iter < 1ULL) {
      _L: 
      tchdbsetecode(hdb, 2, "tchdb.c", 833, "tchdbiternext3");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___2 = tchdbiternextintoxstr(hdb, kxstr, vxstr);
  rv = tmp___2;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
TCLIST *tchdbfwmkeys(TCHDB *hdb , void const   *pbuf , int psiz , int max ) 
{ TCLIST *keys ;
  TCLIST *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  uint64_t iter ;
  char *kbuf ;
  int ksiz ;
  int tmp___3 ;

  {
  tmp = tclistnew();
  keys = tmp;
  if (hdb->mmtx) {
    tmp___0 = tchdblockmethod(hdb, (_Bool)1);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    return (keys);
  }
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 853, "tchdbfwmkeys");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return (keys);
  }
  if (hdb->async) {
    tmp___2 = tchdbflushdrp(hdb);
    if (! tmp___2) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return (keys);
    }
  }
  if (max < 0) {
    max = 2147483647;
  }
  iter = hdb->iter;
  tchdbiterinitimpl(hdb);
  while (1) {
    if (keys->num < max) {
      kbuf = tchdbiternextimpl(hdb, & ksiz);
      if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    if (ksiz >= psiz) {
      tmp___3 = memcmp((void const   *)kbuf, pbuf, (unsigned int )psiz);
      if (tmp___3) {
        goto _L;
      } else {
        tclistpushmalloc(keys, (void *)kbuf, ksiz);
      }
    } else {
      _L: 
      while (1) {
        free((void *)kbuf);
        break;
      }
    }
  }
  hdb->iter = iter;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (keys);
}
}
TCLIST *tchdbfwmkeys2(TCHDB *hdb , char const   *pstr , int max ) 
{ size_t tmp ;
  TCLIST *tmp___0 ;

  {
  tmp = strlen(pstr);
  tmp___0 = tchdbfwmkeys(hdb, (void const   *)pstr, (int )tmp, max);
  return (tmp___0);
}
}
int tchdbaddint(TCHDB *hdb , void const   *kbuf , int ksiz , int num ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  char *zbuf ;
  int osiz ;
  char *obuf ;
  char *tmp___5 ;
  int zsiz ;
  void *tmp___6 ;
  _Bool rv ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  _Bool rv___0 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  int tmp___12 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((-0x7FFFFFFF-1));
  }
  tmp___1 = tchdbbidx(hdb, (char const   *)kbuf, ksiz, & hash);
  bidx = tmp___1;
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      _L: 
      tchdbsetecode(hdb, 2, "tchdb.c", 893, "tchdbaddint");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((-0x7FFFFFFF-1));
    }
  }
  if (hdb->async) {
    tmp___2 = tchdbflushdrp(hdb);
    if (! tmp___2) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((-0x7FFFFFFF-1));
    }
  }
  if (hdb->mmtx) {
    tmp___3 = tchdblockrecord(hdb, (unsigned char )bidx, (_Bool)1);
    tmp___4 = (int )tmp___3;
  } else {
    tmp___4 = 1;
  }
  if (! tmp___4) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((-0x7FFFFFFF-1));
  }
  if (hdb->zmode) {
    tmp___5 = tchdbgetimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, & osiz);
    obuf = tmp___5;
    if (obuf) {
      if (osiz != (int )sizeof(num)) {
        tchdbsetecode(hdb, 21, "tchdb.c", 911, "tchdbaddint");
        while (1) {
          free((void *)obuf);
          break;
        }
        if (hdb->mmtx) {
          tchdbunlockrecord(hdb, (unsigned char )bidx);
        }
        if (hdb->mmtx) {
          tchdbunlockmethod(hdb);
        }
        return ((-0x7FFFFFFF-1));
      }
      num += *((int *)obuf);
      while (1) {
        free((void *)obuf);
        break;
      }
    }
    if ((int )hdb->opts & 2) {
      zbuf = (*_tc_deflate)((char const   *)((char *)(& num)), (int )sizeof(num),
                            & zsiz, 1);
    } else {
      if ((int )hdb->opts & 4) {
        zbuf = (*_tc_bzcompress)((char const   *)((char *)(& num)), (int )sizeof(num),
                                 & zsiz);
      } else {
        if ((int )hdb->opts & 8) {
          zbuf = tcbsencode((char const   *)((char *)(& num)), (int )sizeof(num),
                            & zsiz);
        } else {
          tmp___6 = (*(hdb->enc))((void const   *)((char *)(& num)), (int )sizeof(num),
                                  & zsiz, hdb->encop);
          zbuf = (char *)tmp___6;
        }
      }
    }
    if (! zbuf) {
      tchdbsetecode(hdb, 9999, "tchdb.c", 931, "tchdbaddint");
      if (hdb->mmtx) {
        tchdbunlockrecord(hdb, (unsigned char )bidx);
      }
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((-0x7FFFFFFF-1));
    }
    tmp___7 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)zbuf,
                           zsiz, 0);
    rv = tmp___7;
    while (1) {
      free((void *)zbuf);
      break;
    }
    if (hdb->mmtx) {
      tchdbunlockrecord(hdb, (unsigned char )bidx);
    }
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    if (hdb->dfunit > 0U) {
      if (hdb->dfcnt > hdb->dfunit) {
        tmp___8 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
        if (! tmp___8) {
          rv = (_Bool)0;
        }
      }
    }
    if (rv) {
      tmp___9 = num;
    } else {
      tmp___9 = (-0x7FFFFFFF-1);
    }
    return (tmp___9);
  }
  tmp___10 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)((char *)(& num)),
                          (int )sizeof(num), 3);
  rv___0 = tmp___10;
  if (hdb->mmtx) {
    tchdbunlockrecord(hdb, (unsigned char )bidx);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  if (hdb->dfunit > 0U) {
    if (hdb->dfcnt > hdb->dfunit) {
      tmp___11 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
      if (! tmp___11) {
        rv___0 = (_Bool)0;
      }
    }
  }
  if (rv___0) {
    tmp___12 = num;
  } else {
    tmp___12 = (-0x7FFFFFFF-1);
  }
  return (tmp___12);
}
}
double tchdbadddouble(TCHDB *hdb , void const   *kbuf , int ksiz , double num ) 
{ double tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  _Bool tmp___5 ;
  double tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  char *zbuf ;
  int osiz ;
  char *obuf ;
  char *tmp___9 ;
  double tmp___10 ;
  int zsiz ;
  void *tmp___11 ;
  double tmp___12 ;
  _Bool rv ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  _Bool rv___0 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;

  {
  if (hdb->mmtx) {
    tmp___0 = tchdblockmethod(hdb, (_Bool)0);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    tmp = nan("");
    return (tmp);
  }
  tmp___2 = tchdbbidx(hdb, (char const   *)kbuf, ksiz, & hash);
  bidx = tmp___2;
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      _L: 
      tchdbsetecode(hdb, 2, "tchdb.c", 960, "tchdbadddouble");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      tmp___3 = nan("");
      return (tmp___3);
    }
  }
  if (hdb->async) {
    tmp___5 = tchdbflushdrp(hdb);
    if (! tmp___5) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      tmp___4 = nan("");
      return (tmp___4);
    }
  }
  if (hdb->mmtx) {
    tmp___7 = tchdblockrecord(hdb, (unsigned char )bidx, (_Bool)1);
    tmp___8 = (int )tmp___7;
  } else {
    tmp___8 = 1;
  }
  if (! tmp___8) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    tmp___6 = nan("");
    return (tmp___6);
  }
  if (hdb->zmode) {
    tmp___9 = tchdbgetimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, & osiz);
    obuf = tmp___9;
    if (obuf) {
      if (osiz != (int )sizeof(num)) {
        tchdbsetecode(hdb, 21, "tchdb.c", 978, "tchdbadddouble");
        while (1) {
          free((void *)obuf);
          break;
        }
        if (hdb->mmtx) {
          tchdbunlockrecord(hdb, (unsigned char )bidx);
        }
        if (hdb->mmtx) {
          tchdbunlockmethod(hdb);
        }
        tmp___10 = nan("");
        return (tmp___10);
      }
      num += *((double *)obuf);
      while (1) {
        free((void *)obuf);
        break;
      }
    }
    if ((int )hdb->opts & 2) {
      zbuf = (*_tc_deflate)((char const   *)((char *)(& num)), (int )sizeof(num),
                            & zsiz, 1);
    } else {
      if ((int )hdb->opts & 4) {
        zbuf = (*_tc_bzcompress)((char const   *)((char *)(& num)), (int )sizeof(num),
                                 & zsiz);
      } else {
        if ((int )hdb->opts & 8) {
          zbuf = tcbsencode((char const   *)((char *)(& num)), (int )sizeof(num),
                            & zsiz);
        } else {
          tmp___11 = (*(hdb->enc))((void const   *)((char *)(& num)), (int )sizeof(num),
                                   & zsiz, hdb->encop);
          zbuf = (char *)tmp___11;
        }
      }
    }
    if (! zbuf) {
      tchdbsetecode(hdb, 9999, "tchdb.c", 998, "tchdbadddouble");
      if (hdb->mmtx) {
        tchdbunlockrecord(hdb, (unsigned char )bidx);
      }
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      tmp___12 = nan("");
      return (tmp___12);
    }
    tmp___13 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)zbuf,
                            zsiz, 0);
    rv = tmp___13;
    while (1) {
      free((void *)zbuf);
      break;
    }
    if (hdb->mmtx) {
      tchdbunlockrecord(hdb, (unsigned char )bidx);
    }
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    if (hdb->dfunit > 0U) {
      if (hdb->dfcnt > hdb->dfunit) {
        tmp___14 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
        if (! tmp___14) {
          rv = (_Bool)0;
        }
      }
    }
    if (rv) {
      tmp___16 = num;
    } else {
      tmp___15 = nan("");
      tmp___16 = tmp___15;
    }
    return (tmp___16);
  }
  tmp___17 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)((char *)(& num)),
                          (int )sizeof(num), 4);
  rv___0 = tmp___17;
  if (hdb->mmtx) {
    tchdbunlockrecord(hdb, (unsigned char )bidx);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  if (hdb->dfunit > 0U) {
    if (hdb->dfcnt > hdb->dfunit) {
      tmp___18 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
      if (! tmp___18) {
        rv___0 = (_Bool)0;
      }
    }
  }
  if (rv___0) {
    tmp___20 = num;
  } else {
    tmp___19 = nan("");
    tmp___20 = tmp___19;
  }
  return (tmp___20);
}
}
_Bool tchdbsync(TCHDB *hdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      goto _L;
    } else {
      if (hdb->tran) {
        _L: 
        tchdbsetecode(hdb, 2, "tchdb.c", 1025, "tchdbsync");
        if (hdb->mmtx) {
          tchdbunlockmethod(hdb);
        }
        return ((_Bool)0);
      }
    }
  }
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___2 = tchdbmemsync(hdb, (_Bool)1);
  rv = tmp___2;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
_Bool tchdboptimize(TCHDB *hdb , int64_t bnum , int8_t apow , int8_t fpow , uint8_t opts ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      goto _L;
    } else {
      if (hdb->tran) {
        _L: 
        tchdbsetecode(hdb, 2, "tchdb.c", 1044, "tchdboptimize");
        if (hdb->mmtx) {
          tchdbunlockmethod(hdb);
        }
        return ((_Bool)0);
      }
    }
  }
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  while (1) {
    if (hdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___2 = tchdboptimizeimpl(hdb, bnum, apow, fpow, opts);
  rv = tmp___2;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
_Bool tchdbvanish(TCHDB *hdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      goto _L;
    } else {
      if (hdb->tran) {
        _L: 
        tchdbsetecode(hdb, 2, "tchdb.c", 1064, "tchdbvanish");
        if (hdb->mmtx) {
          tchdbunlockmethod(hdb);
        }
        return ((_Bool)0);
      }
    }
  }
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  while (1) {
    if (hdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___2 = tchdbvanishimpl(hdb);
  rv = tmp___2;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
_Bool tchdbcopy(TCHDB *hdb , char const   *path ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool rv ;
  _Bool tmp___4 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1084, "tchdbcopy");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->mmtx) {
    tmp___2 = tchdblockallrecords(hdb, (_Bool)0);
    tmp___3 = (int )tmp___2;
  } else {
    tmp___3 = 1;
  }
  if (! tmp___3) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  while (1) {
    if (hdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___4 = tchdbcopyimpl(hdb, path);
  rv = tmp___4;
  if (hdb->mmtx) {
    tchdbunlockallrecords(hdb);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
_Bool tchdbtranbegin(TCHDB *hdb ) 
{ double wsec ;
  long tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  char *tpath ;
  char *tmp___5 ;
  int walfd ;
  int tmp___6 ;
  int ecode ;
  int *tmp___7 ;
  _Bool tmp___8 ;

  {
  tmp = sysconf(2);
  wsec = 1.0 / (double )tmp;
  while (1) {
    if (hdb->mmtx) {
      tmp___0 = tchdblockmethod(hdb, (_Bool)1);
      tmp___1 = (int )tmp___0;
    } else {
      tmp___1 = 1;
    }
    if (! tmp___1) {
      return ((_Bool)0);
    }
    if (hdb->fd < 0) {
      goto _L;
    } else {
      if (! (hdb->omode & 2U)) {
        goto _L;
      } else {
        if (hdb->fatal) {
          _L: 
          tchdbsetecode(hdb, 2, "tchdb.c", 1110, "tchdbtranbegin");
          if (hdb->mmtx) {
            tchdbunlockmethod(hdb);
          }
          return ((_Bool)0);
        }
      }
    }
    if (! hdb->tran) {
      break;
    }
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    if (wsec > 1.0) {
      wsec = 1.0;
    }
    tcsleep(wsec);
    wsec *= (double )2;
  }
  if (hdb->async) {
    tmp___2 = tchdbflushdrp(hdb);
    if (! tmp___2) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___3 = tchdbmemsync(hdb, (_Bool)0);
  if (! tmp___3) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  if (hdb->omode & 64U) {
    tmp___4 = fsync(hdb->fd);
    if (tmp___4 == -1) {
      tchdbsetecode(hdb, 10, "tchdb.c", 1128, "tchdbtranbegin");
      return ((_Bool)0);
    }
  }
  if (hdb->walfd < 0) {
    tmp___5 = tcsprintf("%s%c%s", hdb->path, '.', "wal");
    tpath = tmp___5;
    tmp___6 = open((char const   *)tpath, 578, 420);
    walfd = tmp___6;
    while (1) {
      free((void *)tpath);
      break;
    }
    if (walfd < 0) {
      ecode = 7;
      tmp___7 = __errno_location();
      switch (*tmp___7) {
      case 13: 
      ecode = 4;
      break;
      case 2: 
      ecode = 3;
      break;
      case 20: 
      ecode = 3;
      break;
      }
      tchdbsetecode(hdb, ecode, "tchdb.c", 1142, "tchdbtranbegin");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
    hdb->walfd = walfd;
  }
  tchdbsetflag(hdb, 1, (_Bool)0);
  tmp___8 = tchdbwalinit(hdb);
  if (! tmp___8) {
    tchdbsetflag(hdb, 1, (_Bool)1);
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  tchdbsetflag(hdb, 1, (_Bool)1);
  hdb->tran = (_Bool)1;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return ((_Bool)1);
}
}
_Bool tchdbtrancommit(TCHDB *hdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      goto _L;
    } else {
      if (hdb->fatal) {
        goto _L;
      } else {
        if (! hdb->tran) {
          _L: 
          tchdbsetecode(hdb, 2, "tchdb.c", 1166, "tchdbtrancommit");
          if (hdb->mmtx) {
            tchdbunlockmethod(hdb);
          }
          return ((_Bool)0);
        }
      }
    }
  }
  err = (_Bool)0;
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      err = (_Bool)1;
    }
  }
  tmp___2 = tchdbmemsync(hdb, (_Bool )(hdb->omode & 64U));
  if (! tmp___2) {
    err = (_Bool)1;
  }
  if (! err) {
    tmp___3 = ftruncate(hdb->walfd, 0L);
    if (tmp___3 == -1) {
      tchdbsetecode(hdb, 9, "tchdb.c", 1174, "tchdbtrancommit");
      err = (_Bool)1;
    }
  }
  hdb->tran = (_Bool)0;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return ((_Bool )(! err));
}
}
_Bool tchdbtranabort(TCHDB *hdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  char hbuf[256] ;
  _Bool tmp___4 ;
  __off_t tmp___5 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      goto _L;
    } else {
      if (! hdb->tran) {
        _L: 
        tchdbsetecode(hdb, 2, "tchdb.c", 1188, "tchdbtranabort");
        if (hdb->mmtx) {
          tchdbunlockmethod(hdb);
        }
        return ((_Bool)0);
      }
    }
  }
  err = (_Bool)0;
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      err = (_Bool)1;
    }
  }
  tmp___2 = tchdbmemsync(hdb, (_Bool)0);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  tmp___3 = tchdbwalrestore(hdb, (char const   *)hdb->path);
  if (! tmp___3) {
    err = (_Bool)1;
  }
  tmp___5 = lseek(hdb->fd, 0L, 0);
  if (tmp___5 == -1L) {
    tchdbsetecode(hdb, 12, "tchdb.c", 1198, "tchdbtranabort");
    err = (_Bool)0;
  } else {
    tmp___4 = tcread(hdb->fd, (void *)(hbuf), 256U);
    if (tmp___4) {
      tchdbloadmeta(hdb, (char const   *)(hbuf));
    } else {
      tchdbsetecode(hdb, 13, "tchdb.c", 1201, "tchdbtranabort");
      err = (_Bool)0;
    }
  }
  hdb->dfcur = hdb->frec;
  hdb->iter = 0ULL;
  hdb->xfsiz = 0ULL;
  hdb->fbpnum = 0;
  if (hdb->recc) {
    tcmdbvanish(hdb->recc);
  }
  hdb->tran = (_Bool)0;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return ((_Bool )(! err));
}
}
char const   *tchdbpath(TCHDB *hdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  char const   *rv ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((char const   *)((void *)0));
  }
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1222, "tchdbpath");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((char const   *)((void *)0));
  }
  rv = (char const   *)hdb->path;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
uint64_t tchdbrnum(TCHDB *hdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint64_t rv ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0ULL);
  }
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1237, "tchdbrnum");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return (0ULL);
  }
  rv = hdb->rnum;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
uint64_t tchdbfsiz(TCHDB *hdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint64_t rv ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0ULL);
  }
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1252, "tchdbfsiz");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return (0ULL);
  }
  rv = hdb->fsiz;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
void tchdbsetecode(TCHDB *hdb , int ecode , char const   *filename , int line , char const   *func ) 
{ int myerrno ;
  int *tmp ;
  int dbgfd ;
  int tmp___0 ;
  char obuf[8192] ;
  int osiz ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  tmp = __errno_location();
  myerrno = *tmp;
  if (! hdb->fatal) {
    if (hdb->mmtx) {
      pthread_setspecific(*((pthread_key_t *)hdb->eckey), (void const   *)((void *)ecode));
    } else {
      hdb->ecode = ecode;
    }
  }
  if (ecode != 0) {
    if (ecode != 2) {
      if (ecode != 21) {
        if (ecode != 22) {
          hdb->fatal = (_Bool)1;
          if (hdb->fd >= 0) {
            if (hdb->omode & 2U) {
              tchdbsetflag(hdb, 2, (_Bool)1);
            }
          }
        }
      }
    }
  }
  if (hdb->dbgfd >= 0) {
    if (hdb->dbgfd != 65535) {
      goto _L;
    } else {
      if (hdb->fatal) {
        _L: 
        if (hdb->dbgfd == 65535) {
          tmp___0 = 1;
        } else {
          tmp___0 = hdb->dbgfd;
        }
        dbgfd = tmp___0;
        tmp___1 = strerror(myerrno);
        tmp___2 = tchdberrmsg(ecode);
        if (hdb->path) {
          tmp___3 = (char const   *)hdb->path;
        } else {
          tmp___3 = "-";
        }
        tmp___4 = sprintf((char * __restrict  )(obuf), (char const   * __restrict  )"ERROR:%s:%d:%s:%s:%d:%s:%d:%s\n",
                          filename, line, func, tmp___3, ecode, tmp___2, myerrno,
                          tmp___1);
        osiz = tmp___4;
        tcwrite(dbgfd, (void const   *)(obuf), (unsigned int )osiz);
      }
    }
  }
  return;
}
}
void tchdbsettype(TCHDB *hdb , uint8_t type ) 
{ 

  {
  if (hdb->fd >= 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1298, "tchdbsettype");
    return;
  }
  hdb->type = type;
  return;
}
}
void tchdbsetdbgfd(TCHDB *hdb , int fd ) 
{ 

  {
  hdb->dbgfd = fd;
  return;
}
}
int tchdbdbgfd(TCHDB *hdb ) 
{ 

  {
  return (hdb->dbgfd);
}
}
_Bool tchdbhasmutex(TCHDB *hdb ) 
{ 

  {
  return ((_Bool )((unsigned int )hdb->mmtx != (unsigned int )((void *)0)));
}
}
_Bool tchdbmemsync(TCHDB *hdb , _Bool phys ) 
{ _Bool err ;
  char hbuf[256] ;
  size_t xmsiz ;
  uint64_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1330, "tchdbmemsync");
    return ((_Bool)0);
  } else {
    if (! (hdb->omode & 2U)) {
      tchdbsetecode(hdb, 2, "tchdb.c", 1330, "tchdbmemsync");
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  tchdbdumpmeta(hdb, hbuf);
  memcpy((void * __restrict  )hdb->map, (void const   * __restrict  )(hbuf), 128U);
  if (phys) {
    if (hdb->xmsiz > hdb->msiz) {
      tmp = hdb->xmsiz;
    } else {
      tmp = hdb->msiz;
    }
    xmsiz = (unsigned int )tmp;
    tmp___0 = msync((void *)hdb->map, xmsiz, 4);
    if (tmp___0 == -1) {
      tchdbsetecode(hdb, 15, "tchdb.c", 1340, "tchdbmemsync");
      err = (_Bool)1;
    }
    tmp___1 = fsync(hdb->fd);
    if (tmp___1 == -1) {
      tchdbsetecode(hdb, 10, "tchdb.c", 1344, "tchdbmemsync");
      err = (_Bool)1;
    }
  }
  return ((_Bool )(! err));
}
}
_Bool tchdbcacheclear(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1356, "tchdbcacheclear");
    return ((_Bool)0);
  }
  if (hdb->recc) {
    tcmdbvanish(hdb->recc);
  }
  return ((_Bool)1);
}
}
uint64_t tchdbbnum(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1368, "tchdbbnum");
    return (0ULL);
  }
  return (hdb->bnum);
}
}
uint32_t tchdbalign(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1379, "tchdbalign");
    return (0U);
  }
  return (hdb->align);
}
}
uint32_t tchdbfbpmax(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1390, "tchdbfbpmax");
    return (0U);
  }
  return ((unsigned int )hdb->fbpmax);
}
}
uint64_t tchdbxmsiz(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1401, "tchdbxmsiz");
    return (0ULL);
  }
  return (hdb->xmsiz);
}
}
uint64_t tchdbinode(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1412, "tchdbinode");
    return (0ULL);
  }
  return (hdb->inode);
}
}
time_t tchdbmtime(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1423, "tchdbmtime");
    return (0L);
  }
  return (hdb->mtime);
}
}
int tchdbomode(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1434, "tchdbomode");
    return (0);
  }
  return ((int )hdb->omode);
}
}
uint8_t tchdbtype(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1445, "tchdbtype");
    return ((unsigned char)0);
  }
  return (hdb->type);
}
}
uint8_t tchdbflags(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1456, "tchdbflags");
    return ((unsigned char)0);
  }
  return (hdb->flags);
}
}
uint8_t tchdbopts(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1467, "tchdbopts");
    return ((unsigned char)0);
  }
  return (hdb->opts);
}
}
char *tchdbopaque(TCHDB *hdb ) 
{ 

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1478, "tchdbopaque");
    return ((char *)((void *)0));
  }
  return (hdb->map + 128);
}
}
uint64_t tchdbbnumused(TCHDB *hdb ) 
{ uint64_t unum ;
  uint64_t *buckets ;
  int i ;
  uint32_t *buckets___0 ;
  int i___0 ;

  {
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1489, "tchdbbnumused");
    return (0ULL);
  }
  unum = 0ULL;
  if (hdb->ba64) {
    buckets = hdb->ba64;
    i = 0;
    while ((unsigned long long )i < hdb->bnum) {
      if (*(buckets + i)) {
        unum ++;
      }
      i ++;
    }
  } else {
    buckets___0 = hdb->ba32;
    i___0 = 0;
    while ((unsigned long long )i___0 < hdb->bnum) {
      if (*(buckets___0 + i___0)) {
        unum ++;
      }
      i___0 ++;
    }
  }
  return (unum);
}
}
_Bool tchdbsetcodecfunc(TCHDB *hdb , void *(*enc)(void const   *ptr , int size , int *sp ,
                                                  void *op ) , void *encop , void *(*dec)(void const   *ptr ,
                                                                                          int size ,
                                                                                          int *sp ,
                                                                                          void *op ) ,
                        void *decop ) 
{ _Bool tmp ;
  int tmp___0 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd >= 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1513, "tchdbsetcodecfunc");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  hdb->enc = enc;
  hdb->encop = encop;
  hdb->dec = dec;
  hdb->decop = decop;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return ((_Bool)1);
}
}
uint32_t tchdbdfunit(TCHDB *hdb ) 
{ 

  {
  return (hdb->dfunit);
}
}
_Bool tchdbdefrag(TCHDB *hdb , int64_t step ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  _Bool err ;
  _Bool tmp___6 ;
  int tmp___7 ;
  _Bool stop ;
  uint64_t cur ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;

  {
  if (step > 0LL) {
    if (hdb->mmtx) {
      tmp = tchdblockmethod(hdb, (_Bool)1);
      tmp___0 = (int )tmp;
    } else {
      tmp___0 = 1;
    }
    if (! tmp___0) {
      return ((_Bool)0);
    }
    if (hdb->fd < 0) {
      goto _L;
    } else {
      if (! (hdb->omode & 2U)) {
        _L: 
        tchdbsetecode(hdb, 2, "tchdb.c", 1539, "tchdbdefrag");
        if (hdb->mmtx) {
          tchdbunlockmethod(hdb);
        }
        return ((_Bool)0);
      }
    }
    if (hdb->async) {
      tmp___1 = tchdbflushdrp(hdb);
      if (! tmp___1) {
        if (hdb->mmtx) {
          tchdbunlockmethod(hdb);
        }
        return ((_Bool)0);
      }
    }
    tmp___2 = tchdbdefragimpl(hdb, step);
    rv = tmp___2;
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return (rv);
  }
  if (hdb->mmtx) {
    tmp___3 = tchdblockmethod(hdb, (_Bool)0);
    tmp___4 = (int )tmp___3;
  } else {
    tmp___4 = 1;
  }
  if (! tmp___4) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    goto _L___0;
  } else {
    if (! (hdb->omode & 2U)) {
      _L___0: 
      tchdbsetecode(hdb, 2, "tchdb.c", 1553, "tchdbdefrag");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->async) {
    tmp___5 = tchdbflushdrp(hdb);
    if (! tmp___5) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  if (hdb->mmtx) {
    tmp___6 = tchdblockallrecords(hdb, (_Bool)1);
    tmp___7 = (int )tmp___6;
  } else {
    tmp___7 = 1;
  }
  if (tmp___7) {
    hdb->dfcur = hdb->frec;
    if (hdb->mmtx) {
      tchdbunlockallrecords(hdb);
    }
  } else {
    err = (_Bool)1;
  }
  stop = (_Bool)0;
  while (1) {
    if (! err) {
      if (! (! stop)) {
        break;
      }
    } else {
      break;
    }
    if (hdb->mmtx) {
      tmp___9 = tchdblockallrecords(hdb, (_Bool)1);
      tmp___10 = (int )tmp___9;
    } else {
      tmp___10 = 1;
    }
    if (tmp___10) {
      cur = hdb->dfcur;
      tmp___8 = tchdbdefragimpl(hdb, 255LL);
      if (! tmp___8) {
        err = (_Bool)1;
      }
      if (hdb->dfcur <= cur) {
        stop = (_Bool)1;
      }
      if (hdb->mmtx) {
        tchdbunlockallrecords(hdb);
      }
      while (1) {
        if (hdb->mmtx) {
          sched_yield();
        }
        break;
      }
    } else {
      err = (_Bool)1;
    }
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return ((_Bool )(! err));
}
}
_Bool tchdbputproc(TCHDB *hdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  char *zbuf ;
  int osiz ;
  char *obuf ;
  char *tmp___5 ;
  int nsiz ;
  char *nbuf ;
  void *tmp___6 ;
  _Bool rv ;
  _Bool tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  _Bool rv___0 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  HDBPDPROCOP procop ;
  HDBPDPROCOP *procptr ;
  char stack[64] ;
  char *rbuf ;
  void *tmp___12 ;
  char *wp ;
  _Bool rv___1 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  tmp___1 = tchdbbidx(hdb, (char const   *)kbuf, ksiz, & hash);
  bidx = tmp___1;
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      _L: 
      tchdbsetecode(hdb, 2, "tchdb.c", 1593, "tchdbputproc");
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->async) {
    tmp___2 = tchdbflushdrp(hdb);
    if (! tmp___2) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->mmtx) {
    tmp___3 = tchdblockrecord(hdb, (unsigned char )bidx, (_Bool)1);
    tmp___4 = (int )tmp___3;
  } else {
    tmp___4 = 1;
  }
  if (! tmp___4) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  if (hdb->zmode) {
    tmp___5 = tchdbgetimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, & osiz);
    obuf = tmp___5;
    if (obuf) {
      tmp___6 = (*proc___0)((void const   *)obuf, osiz, & nsiz, op);
      nbuf = (char *)tmp___6;
      if ((unsigned int )nbuf == (unsigned int )((void *)-1)) {
        tmp___7 = tchdboutimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash);
        rv = tmp___7;
        while (1) {
          free((void *)obuf);
          break;
        }
        if (hdb->mmtx) {
          tchdbunlockrecord(hdb, (unsigned char )bidx);
        }
        if (hdb->mmtx) {
          tchdbunlockmethod(hdb);
        }
        return (rv);
      } else {
        if (nbuf) {
          if ((int )hdb->opts & 2) {
            zbuf = (*_tc_deflate)((char const   *)nbuf, nsiz, & vsiz, 1);
          } else {
            if ((int )hdb->opts & 4) {
              zbuf = (*_tc_bzcompress)((char const   *)nbuf, nsiz, & vsiz);
            } else {
              if ((int )hdb->opts & 8) {
                zbuf = tcbsencode((char const   *)nbuf, nsiz, & vsiz);
              } else {
                tmp___8 = (*(hdb->enc))((void const   *)nbuf, nsiz, & vsiz, hdb->encop);
                zbuf = (char *)tmp___8;
              }
            }
          }
          while (1) {
            free((void *)nbuf);
            break;
          }
        } else {
          zbuf = (char *)((void *)0);
        }
      }
      while (1) {
        free((void *)obuf);
        break;
      }
    } else {
      if (vbuf) {
        if ((int )hdb->opts & 2) {
          zbuf = (*_tc_deflate)((char const   *)vbuf, vsiz, & vsiz, 1);
        } else {
          if ((int )hdb->opts & 4) {
            zbuf = (*_tc_bzcompress)((char const   *)vbuf, vsiz, & vsiz);
          } else {
            if ((int )hdb->opts & 8) {
              zbuf = tcbsencode((char const   *)vbuf, vsiz, & vsiz);
            } else {
              tmp___9 = (*(hdb->enc))(vbuf, vsiz, & vsiz, hdb->encop);
              zbuf = (char *)tmp___9;
            }
          }
        }
      } else {
        tchdbsetecode(hdb, 22, "tchdb.c", 1644, "tchdbputproc");
        if (hdb->mmtx) {
          tchdbunlockrecord(hdb, (unsigned char )bidx);
        }
        if (hdb->mmtx) {
          tchdbunlockmethod(hdb);
        }
        return ((_Bool)0);
      }
    }
    if (! zbuf) {
      tchdbsetecode(hdb, 21, "tchdb.c", 1650, "tchdbputproc");
      if (hdb->mmtx) {
        tchdbunlockrecord(hdb, (unsigned char )bidx);
      }
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
    tmp___10 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)zbuf,
                            vsiz, 0);
    rv___0 = tmp___10;
    while (1) {
      free((void *)zbuf);
      break;
    }
    if (hdb->mmtx) {
      tchdbunlockrecord(hdb, (unsigned char )bidx);
    }
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    if (hdb->dfunit > 0U) {
      if (hdb->dfcnt > hdb->dfunit) {
        tmp___11 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
        if (! tmp___11) {
          rv___0 = (_Bool)0;
        }
      }
    }
    return (rv___0);
  }
  procop.proc = proc___0;
  procop.op = op;
  procptr = & procop;
  if (ksiz <= (int )sizeof(stack) - (int )sizeof(procptr)) {
    rbuf = stack;
  } else {
    while (1) {
      tmp___12 = malloc((unsigned int )(ksiz + (int )sizeof(procptr)));
      rbuf = (char *)tmp___12;
      if (! rbuf) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  wp = rbuf;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& procptr), (unsigned int )((int )sizeof(procptr)));
  wp += (int )sizeof(procptr);
  memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  kbuf = (void const   *)(rbuf + (int )sizeof(procptr));
  tmp___13 = tchdbputimpl(hdb, (char const   *)kbuf, ksiz, bidx, hash, (char const   *)vbuf,
                          vsiz, 5);
  rv___1 = tmp___13;
  if ((unsigned int )rbuf != (unsigned int )(stack)) {
    while (1) {
      free((void *)rbuf);
      break;
    }
  }
  if (hdb->mmtx) {
    tchdbunlockrecord(hdb, (unsigned char )bidx);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  if (hdb->dfunit > 0U) {
    if (hdb->dfcnt > hdb->dfunit) {
      tmp___14 = tchdbdefrag(hdb, (long long )(hdb->dfunit * 2U + 1U));
      if (! tmp___14) {
        rv___1 = (_Bool)0;
      }
    }
  }
  return (rv___1);
}
}
void tchdbcodecfunc(TCHDB *hdb , TCCODEC *ep , void **eop , TCCODEC *dp , void **dop ) 
{ 

  {
  *ep = hdb->enc;
  *eop = hdb->encop;
  *dp = hdb->dec;
  *dop = hdb->decop;
  return;
}
}
void *tchdbgetnext(TCHDB *hdb , void const   *kbuf , int ksiz , int *sp ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  char *rv ;
  char *tmp___2 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((void *)0);
  }
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1704, "tchdbgetnext");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((void *)0);
  }
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((void *)0);
    }
  }
  tmp___2 = tchdbgetnextimpl(hdb, (char const   *)kbuf, ksiz, sp, (char const   **)((void *)0),
                             (int *)((void *)0));
  rv = tmp___2;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return ((void *)rv);
}
}
char *tchdbgetnext2(TCHDB *hdb , char const   *kstr ) 
{ int vsiz ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tchdbgetnext(hdb, (void const   *)kstr, (int )tmp, & vsiz);
  return ((char *)tmp___0);
}
}
char *tchdbgetnext3(TCHDB *hdb , char const   *kbuf , int ksiz , int *sp , char const   **vbp ,
                    int *vsp ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  char *rv ;
  char *tmp___2 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((char *)((void *)0));
  }
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1731, "tchdbgetnext3");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((char *)((void *)0));
  }
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((char *)((void *)0));
    }
  }
  tmp___2 = tchdbgetnextimpl(hdb, kbuf, ksiz, sp, vbp, vsp);
  rv = tmp___2;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
_Bool tchdbiterinit2(TCHDB *hdb , void const   *kbuf , int ksiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1750, "tchdbiterinit2");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___2 = tchdbiterjumpimpl(hdb, (char const   *)kbuf, ksiz);
  rv = tmp___2;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
_Bool tchdbiterinit3(TCHDB *hdb , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tchdbiterinit2(hdb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
_Bool tchdbforeach(TCHDB *hdb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                              int vsiz , void *op ) , void *op ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  _Bool rv ;
  _Bool tmp___4 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    tchdbsetecode(hdb, 2, "tchdb.c", 1776, "tchdbforeach");
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  if (hdb->async) {
    tmp___1 = tchdbflushdrp(hdb);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockmethod(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->mmtx) {
    tmp___2 = tchdblockallrecords(hdb, (_Bool)0);
    tmp___3 = (int )tmp___2;
  } else {
    tmp___3 = 1;
  }
  if (! tmp___3) {
    if (hdb->mmtx) {
      tchdbunlockmethod(hdb);
    }
    return ((_Bool)0);
  }
  while (1) {
    if (hdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___4 = tchdbforeachimpl(hdb, iter, op);
  rv = tmp___4;
  if (hdb->mmtx) {
    tchdbunlockallrecords(hdb);
  }
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return (rv);
}
}
_Bool tchdbtranvoid(TCHDB *hdb ) 
{ _Bool tmp ;
  int tmp___0 ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockmethod(hdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (hdb->fd < 0) {
    goto _L;
  } else {
    if (! (hdb->omode & 2U)) {
      goto _L;
    } else {
      if (hdb->fatal) {
        goto _L;
      } else {
        if (! hdb->tran) {
          _L: 
          tchdbsetecode(hdb, 2, "tchdb.c", 1801, "tchdbtranvoid");
          if (hdb->mmtx) {
            tchdbunlockmethod(hdb);
          }
          return ((_Bool)0);
        }
      }
    }
  }
  hdb->tran = (_Bool)0;
  if (hdb->mmtx) {
    tchdbunlockmethod(hdb);
  }
  return ((_Bool)1);
}
}
static uint64_t tcgetprime(uint64_t num ) 
{ uint64_t primes[235] ;
  int i ;

  {
  primes[0] = 1ULL;
  primes[1] = 2ULL;
  primes[2] = 3ULL;
  primes[3] = 5ULL;
  primes[4] = 7ULL;
  primes[5] = 11ULL;
  primes[6] = 13ULL;
  primes[7] = 17ULL;
  primes[8] = 19ULL;
  primes[9] = 23ULL;
  primes[10] = 29ULL;
  primes[11] = 31ULL;
  primes[12] = 37ULL;
  primes[13] = 43ULL;
  primes[14] = 47ULL;
  primes[15] = 53ULL;
  primes[16] = 59ULL;
  primes[17] = 61ULL;
  primes[18] = 71ULL;
  primes[19] = 79ULL;
  primes[20] = 83ULL;
  primes[21] = 89ULL;
  primes[22] = 103ULL;
  primes[23] = 109ULL;
  primes[24] = 113ULL;
  primes[25] = 127ULL;
  primes[26] = 139ULL;
  primes[27] = 157ULL;
  primes[28] = 173ULL;
  primes[29] = 191ULL;
  primes[30] = 199ULL;
  primes[31] = 223ULL;
  primes[32] = 239ULL;
  primes[33] = 251ULL;
  primes[34] = 283ULL;
  primes[35] = 317ULL;
  primes[36] = 349ULL;
  primes[37] = 383ULL;
  primes[38] = 409ULL;
  primes[39] = 443ULL;
  primes[40] = 479ULL;
  primes[41] = 509ULL;
  primes[42] = 571ULL;
  primes[43] = 631ULL;
  primes[44] = 701ULL;
  primes[45] = 761ULL;
  primes[46] = 829ULL;
  primes[47] = 887ULL;
  primes[48] = 953ULL;
  primes[49] = 1021ULL;
  primes[50] = 1151ULL;
  primes[51] = 1279ULL;
  primes[52] = 1399ULL;
  primes[53] = 1531ULL;
  primes[54] = 1663ULL;
  primes[55] = 1789ULL;
  primes[56] = 1913ULL;
  primes[57] = 2039ULL;
  primes[58] = 2297ULL;
  primes[59] = 2557ULL;
  primes[60] = 2803ULL;
  primes[61] = 3067ULL;
  primes[62] = 3323ULL;
  primes[63] = 3583ULL;
  primes[64] = 3833ULL;
  primes[65] = 4093ULL;
  primes[66] = 4603ULL;
  primes[67] = 5119ULL;
  primes[68] = 5623ULL;
  primes[69] = 6143ULL;
  primes[70] = 6653ULL;
  primes[71] = 7159ULL;
  primes[72] = 7673ULL;
  primes[73] = 8191ULL;
  primes[74] = 9209ULL;
  primes[75] = 10223ULL;
  primes[76] = 11261ULL;
  primes[77] = 12281ULL;
  primes[78] = 13309ULL;
  primes[79] = 14327ULL;
  primes[80] = 15359ULL;
  primes[81] = 16381ULL;
  primes[82] = 18427ULL;
  primes[83] = 20479ULL;
  primes[84] = 22511ULL;
  primes[85] = 24571ULL;
  primes[86] = 26597ULL;
  primes[87] = 28669ULL;
  primes[88] = 30713ULL;
  primes[89] = 32749ULL;
  primes[90] = 36857ULL;
  primes[91] = 40949ULL;
  primes[92] = 45053ULL;
  primes[93] = 49139ULL;
  primes[94] = 53239ULL;
  primes[95] = 57331ULL;
  primes[96] = 61417ULL;
  primes[97] = 65521ULL;
  primes[98] = 73727ULL;
  primes[99] = 81919ULL;
  primes[100] = 90107ULL;
  primes[101] = 98299ULL;
  primes[102] = 106487ULL;
  primes[103] = 114679ULL;
  primes[104] = 122869ULL;
  primes[105] = 131071ULL;
  primes[106] = 147451ULL;
  primes[107] = 163819ULL;
  primes[108] = 180221ULL;
  primes[109] = 196597ULL;
  primes[110] = 212987ULL;
  primes[111] = 229373ULL;
  primes[112] = 245759ULL;
  primes[113] = 262139ULL;
  primes[114] = 294911ULL;
  primes[115] = 327673ULL;
  primes[116] = 360439ULL;
  primes[117] = 393209ULL;
  primes[118] = 425977ULL;
  primes[119] = 458747ULL;
  primes[120] = 491503ULL;
  primes[121] = 524287ULL;
  primes[122] = 589811ULL;
  primes[123] = 655357ULL;
  primes[124] = 720887ULL;
  primes[125] = 786431ULL;
  primes[126] = 851957ULL;
  primes[127] = 917503ULL;
  primes[128] = 982981ULL;
  primes[129] = 1048573ULL;
  primes[130] = 1179641ULL;
  primes[131] = 1310719ULL;
  primes[132] = 1441771ULL;
  primes[133] = 1572853ULL;
  primes[134] = 1703903ULL;
  primes[135] = 1835003ULL;
  primes[136] = 1966079ULL;
  primes[137] = 2097143ULL;
  primes[138] = 2359267ULL;
  primes[139] = 2621431ULL;
  primes[140] = 2883577ULL;
  primes[141] = 3145721ULL;
  primes[142] = 3407857ULL;
  primes[143] = 3670013ULL;
  primes[144] = 3932153ULL;
  primes[145] = 4194301ULL;
  primes[146] = 4718579ULL;
  primes[147] = 5242877ULL;
  primes[148] = 5767129ULL;
  primes[149] = 6291449ULL;
  primes[150] = 6815741ULL;
  primes[151] = 7340009ULL;
  primes[152] = 7864301ULL;
  primes[153] = 8388593ULL;
  primes[154] = 9437179ULL;
  primes[155] = 10485751ULL;
  primes[156] = 11534329ULL;
  primes[157] = 12582893ULL;
  primes[158] = 13631477ULL;
  primes[159] = 14680063ULL;
  primes[160] = 15728611ULL;
  primes[161] = 16777213ULL;
  primes[162] = 18874367ULL;
  primes[163] = 20971507ULL;
  primes[164] = 23068667ULL;
  primes[165] = 25165813ULL;
  primes[166] = 27262931ULL;
  primes[167] = 29360087ULL;
  primes[168] = 31457269ULL;
  primes[169] = 33554393ULL;
  primes[170] = 37748717ULL;
  primes[171] = 41943023ULL;
  primes[172] = 46137319ULL;
  primes[173] = 50331599ULL;
  primes[174] = 54525917ULL;
  primes[175] = 58720253ULL;
  primes[176] = 62914549ULL;
  primes[177] = 67108859ULL;
  primes[178] = 75497467ULL;
  primes[179] = 83886053ULL;
  primes[180] = 92274671ULL;
  primes[181] = 100663291ULL;
  primes[182] = 109051903ULL;
  primes[183] = 117440509ULL;
  primes[184] = 125829103ULL;
  primes[185] = 134217689ULL;
  primes[186] = 150994939ULL;
  primes[187] = 167772107ULL;
  primes[188] = 184549373ULL;
  primes[189] = 201326557ULL;
  primes[190] = 218103799ULL;
  primes[191] = 234881011ULL;
  primes[192] = 251658227ULL;
  primes[193] = 268435399ULL;
  primes[194] = 301989881ULL;
  primes[195] = 335544301ULL;
  primes[196] = 369098707ULL;
  primes[197] = 402653171ULL;
  primes[198] = 436207613ULL;
  primes[199] = 469762043ULL;
  primes[200] = 503316469ULL;
  primes[201] = 536870909ULL;
  primes[202] = 603979769ULL;
  primes[203] = 671088637ULL;
  primes[204] = 738197503ULL;
  primes[205] = 805306357ULL;
  primes[206] = 872415211ULL;
  primes[207] = 939524087ULL;
  primes[208] = 1006632947ULL;
  primes[209] = 1073741789ULL;
  primes[210] = 1207959503ULL;
  primes[211] = 1342177237ULL;
  primes[212] = 1476394991ULL;
  primes[213] = 1610612711ULL;
  primes[214] = 1744830457ULL;
  primes[215] = 1879048183ULL;
  primes[216] = 2013265907ULL;
  primes[217] = 2576980349ULL;
  primes[218] = 3092376431ULL;
  primes[219] = 3710851741ULL;
  primes[220] = 4718021527ULL;
  primes[221] = 6133428047ULL;
  primes[222] = 7973456459ULL;
  primes[223] = 10365493393ULL;
  primes[224] = 13475141413ULL;
  primes[225] = 17517683831ULL;
  primes[226] = 22772988923ULL;
  primes[227] = 29604885677ULL;
  primes[228] = 38486351381ULL;
  primes[229] = 50032256819ULL;
  primes[230] = 65041933867ULL;
  primes[231] = 84554514043ULL;
  primes[232] = 109920868241ULL;
  primes[233] = 153889215497ULL;
  primes[234] = 0ULL;
  i = 0;
  while (primes[i] > 0ULL) {
    if (num <= primes[i]) {
      return (primes[i]);
    }
    i ++;
  }
  return (primes[i - 1]);
}
}
static _Bool tchdbseekwrite(TCHDB *hdb , off_t off , void const   *buf , size_t size ) 
{ _Bool tmp ;
  off_t end ;
  uint64_t xfsiz ;
  int tmp___0 ;
  int wb ;
  ssize_t tmp___1 ;
  int *tmp___2 ;

  {
  if (hdb->tran) {
    tmp = tchdbwalwrite(hdb, (unsigned long long )off, (long long )size);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  end = (long )((unsigned long )off + (unsigned long )size);
  if ((unsigned long long )end <= hdb->xmsiz) {
    if ((unsigned long long )end >= hdb->fsiz) {
      if ((unsigned long long )end >= hdb->xfsiz) {
        xfsiz = (unsigned long long )(end + 32768L);
        tmp___0 = ftruncate(hdb->fd, (long )xfsiz);
        if (tmp___0 == -1) {
          tchdbsetecode(hdb, 9, "tchdb.c", 1870, "tchdbseekwrite");
          return ((_Bool)0);
        }
        hdb->xfsiz = xfsiz;
      }
    }
    memcpy((void * __restrict  )(hdb->map + off), (void const   * __restrict  )buf,
           size);
    return ((_Bool)1);
  }
  while (1) {
    tmp___1 = pwrite(hdb->fd, buf, size, off);
    wb = tmp___1;
    if ((unsigned int )wb >= size) {
      return ((_Bool)1);
    } else {
      if (wb > 0) {
        buf = (void const   *)((char *)buf + wb);
        size -= (unsigned int )wb;
        off += (long )wb;
      } else {
        if (wb == -1) {
          tmp___2 = __errno_location();
          if (*tmp___2 != 4) {
            tchdbsetecode(hdb, 14, "tchdb.c", 1895, "tchdbseekwrite");
            return ((_Bool)0);
          }
        } else {
          if (size > 0U) {
            tchdbsetecode(hdb, 14, "tchdb.c", 1900, "tchdbseekwrite");
            return ((_Bool)0);
          }
        }
      }
    }
  }
  return ((_Bool)1);
}
}
static _Bool tchdbseekread(TCHDB *hdb , off_t off , void *buf , size_t size ) 
{ int rb ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
  if ((unsigned long long )((unsigned long )off + (unsigned long )size) <= hdb->xmsiz) {
    memcpy((void * __restrict  )buf, (void const   * __restrict  )(hdb->map + off),
           size);
    return ((_Bool)1);
  }
  while (1) {
    tmp = pread(hdb->fd, buf, size, off);
    rb = tmp;
    if ((unsigned int )rb >= size) {
      break;
    } else {
      if (rb > 0) {
        buf = (void *)((char *)buf + rb);
        size -= (unsigned int )rb;
        off += (long )rb;
      } else {
        if (rb == -1) {
          tmp___0 = __errno_location();
          if (*tmp___0 != 4) {
            tchdbsetecode(hdb, 13, "tchdb.c", 1938, "tchdbseekread");
            return ((_Bool)0);
          }
        } else {
          if (size > 0U) {
            tchdbsetecode(hdb, 13, "tchdb.c", 1943, "tchdbseekread");
            return ((_Bool)0);
          }
        }
      }
    }
  }
  return ((_Bool)1);
}
}
static _Bool tchdbseekreadtry(TCHDB *hdb , off_t off , void *buf , size_t size ) 
{ off_t end ;
  int rb ;
  ssize_t tmp ;

  {
  end = (long )((unsigned long )off + (unsigned long )size);
  if ((unsigned long long )end > hdb->fsiz) {
    return ((_Bool)0);
  }
  if ((unsigned long long )end <= hdb->xmsiz) {
    memcpy((void * __restrict  )buf, (void const   * __restrict  )(hdb->map + off),
           size);
    return ((_Bool)1);
  }
  tmp = pread(hdb->fd, buf, size, off);
  rb = tmp;
  if ((unsigned int )rb == size) {
    return ((_Bool)1);
  }
  if (rb == -1) {
    tchdbsetecode(hdb, 13, "tchdb.c", 1975, "tchdbseekreadtry");
  }
  return ((_Bool)0);
}
}
static void tchdbdumpmeta(TCHDB *hdb , char *hbuf ) 
{ uint64_t llnum ;

  {
  memset((void *)hbuf, 0, 256U);
  sprintf((char * __restrict  )hbuf, (char const   * __restrict  )"%s\n%s:%d\n", "ToKyO CaBiNeT",
          "1.0", 824);
  memcpy((void * __restrict  )(hbuf + 32), (void const   * __restrict  )(& hdb->type),
         (unsigned int )((int )sizeof(hdb->type)));
  memcpy((void * __restrict  )(hbuf + 33), (void const   * __restrict  )(& hdb->flags),
         (unsigned int )((int )sizeof(hdb->flags)));
  memcpy((void * __restrict  )(hbuf + 34), (void const   * __restrict  )(& hdb->apow),
         (unsigned int )((int )sizeof(hdb->apow)));
  memcpy((void * __restrict  )(hbuf + 35), (void const   * __restrict  )(& hdb->fpow),
         (unsigned int )((int )sizeof(hdb->fpow)));
  memcpy((void * __restrict  )(hbuf + 36), (void const   * __restrict  )(& hdb->opts),
         (unsigned int )((int )sizeof(hdb->opts)));
  llnum = hdb->bnum;
  llnum = llnum;
  memcpy((void * __restrict  )(hbuf + 40), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  llnum = hdb->rnum;
  llnum = llnum;
  memcpy((void * __restrict  )(hbuf + 48), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  llnum = hdb->fsiz;
  llnum = llnum;
  memcpy((void * __restrict  )(hbuf + 56), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  llnum = hdb->frec;
  llnum = llnum;
  memcpy((void * __restrict  )(hbuf + 64), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  return;
}
}
static void tchdbloadmeta(TCHDB *hdb , char const   *hbuf ) 
{ uint64_t llnum ;

  {
  memcpy((void * __restrict  )(& hdb->type), (void const   * __restrict  )(hbuf + 32),
         (unsigned int )((int )sizeof(hdb->type)));
  memcpy((void * __restrict  )(& hdb->flags), (void const   * __restrict  )(hbuf + 33),
         (unsigned int )((int )sizeof(hdb->flags)));
  memcpy((void * __restrict  )(& hdb->apow), (void const   * __restrict  )(hbuf + 34),
         (unsigned int )((int )sizeof(hdb->apow)));
  memcpy((void * __restrict  )(& hdb->fpow), (void const   * __restrict  )(hbuf + 35),
         (unsigned int )((int )sizeof(hdb->fpow)));
  memcpy((void * __restrict  )(& hdb->opts), (void const   * __restrict  )(hbuf + 36),
         (unsigned int )((int )sizeof(hdb->opts)));
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )(hbuf + 40),
         (unsigned int )((int )sizeof(llnum)));
  hdb->bnum = llnum;
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )(hbuf + 48),
         (unsigned int )((int )sizeof(llnum)));
  hdb->rnum = llnum;
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )(hbuf + 56),
         (unsigned int )((int )sizeof(llnum)));
  hdb->fsiz = llnum;
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )(hbuf + 64),
         (unsigned int )((int )sizeof(llnum)));
  hdb->frec = llnum;
  return;
}
}
static void tchdbclear(TCHDB *hdb ) 
{ 

  {
  hdb->mmtx = (void *)0;
  hdb->rmtxs = (void *)0;
  hdb->dmtx = (void *)0;
  hdb->tmtx = (void *)0;
  hdb->wmtx = (void *)0;
  hdb->eckey = (void *)0;
  hdb->rpath = (char *)((void *)0);
  hdb->type = (unsigned char)0;
  hdb->flags = (unsigned char)0;
  hdb->bnum = 131071ULL;
  hdb->apow = (unsigned char)4;
  hdb->fpow = (unsigned char)10;
  hdb->opts = (unsigned char)0;
  hdb->path = (char *)((void *)0);
  hdb->fd = -1;
  hdb->omode = 0U;
  hdb->rnum = 0ULL;
  hdb->fsiz = 0ULL;
  hdb->frec = 0ULL;
  hdb->dfcur = 0ULL;
  hdb->iter = 0ULL;
  hdb->map = (char *)((void *)0);
  hdb->msiz = 0ULL;
  hdb->xmsiz = (unsigned long long )(64LL << 20);
  hdb->xfsiz = 0ULL;
  hdb->ba32 = (uint32_t *)((void *)0);
  hdb->ba64 = (uint64_t *)((void *)0);
  hdb->align = 0U;
  hdb->runit = 0U;
  hdb->zmode = (_Bool)0;
  hdb->fbpmax = 0;
  hdb->fbpool = (void *)0;
  hdb->fbpnum = 0;
  hdb->fbpmis = 0;
  hdb->async = (_Bool)0;
  hdb->drpool = (TCXSTR *)((void *)0);
  hdb->drpdef = (TCXSTR *)((void *)0);
  hdb->drpoff = 0ULL;
  hdb->recc = (TCMDB *)((void *)0);
  hdb->rcnum = 0U;
  hdb->enc = (void *(*)(void const   *ptr , int size , int *sp , void *op ))((void *)0);
  hdb->encop = (void *)0;
  hdb->dec = (void *(*)(void const   *ptr , int size , int *sp , void *op ))((void *)0);
  hdb->decop = (void *)0;
  hdb->ecode = 0;
  hdb->fatal = (_Bool)0;
  hdb->inode = 0ULL;
  hdb->mtime = 0L;
  hdb->dfunit = 0U;
  hdb->dfcnt = 0U;
  hdb->tran = (_Bool)0;
  hdb->walfd = -1;
  hdb->walend = 0ULL;
  hdb->dbgfd = -1;
  hdb->cnt_writerec = -1LL;
  hdb->cnt_reuserec = -1LL;
  hdb->cnt_moverec = -1LL;
  hdb->cnt_readrec = -1LL;
  hdb->cnt_searchfbp = -1LL;
  hdb->cnt_insertfbp = -1LL;
  hdb->cnt_splicefbp = -1LL;
  hdb->cnt_dividefbp = -1LL;
  hdb->cnt_mergefbp = -1LL;
  hdb->cnt_reducefbp = -1LL;
  hdb->cnt_appenddrp = -1LL;
  hdb->cnt_deferdrp = -1LL;
  hdb->cnt_flushdrp = -1LL;
  hdb->cnt_adjrecc = -1LL;
  hdb->cnt_defrag = -1LL;
  hdb->cnt_shiftrec = -1LL;
  hdb->cnt_trunc = -1LL;
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  return;
}
}
static int32_t tchdbpadsize(TCHDB *hdb , uint64_t off ) 
{ int32_t diff ;
  uint32_t tmp ;

  {
  diff = (int )(off & (unsigned long long )(hdb->align - 1U));
  if (diff > 0) {
    tmp = hdb->align - (unsigned int )diff;
  } else {
    tmp = 0U;
  }
  return ((int )tmp);
}
}
static void tchdbsetflag(TCHDB *hdb , int flag , _Bool sign ) 
{ char *fp ;

  {
  fp = hdb->map + 33;
  if (sign) {
    *fp = (char )((int )*fp | (int )((unsigned char )flag));
  } else {
    *fp = (char )((int )*fp & ~ ((int )((unsigned char )flag)));
  }
  hdb->flags = (unsigned char )*fp;
  return;
}
}
static uint64_t tchdbbidx(TCHDB *hdb , char const   *kbuf , int ksiz , uint8_t *hp ) 
{ uint64_t idx ;
  uint32_t hash ;
  char const   *rp ;
  char const   *tmp ;
  int tmp___0 ;

  {
  idx = 19780211ULL;
  hash = 751U;
  rp = kbuf + ksiz;
  while (1) {
    tmp___0 = ksiz;
    ksiz --;
    if (! tmp___0) {
      break;
    }
    tmp = kbuf;
    kbuf ++;
    idx = idx * 37ULL + (unsigned long long )*((uint8_t *)tmp);
    rp --;
    hash = hash * 31U ^ (unsigned int )*((uint8_t *)rp);
  }
  *hp = (unsigned char )hash;
  return (idx % hdb->bnum);
}
}
static off_t tchdbgetbucket(TCHDB *hdb , uint64_t bidx ) 
{ uint64_t llnum ;
  uint32_t lnum ;

  {
  if (hdb->ba64) {
    llnum = *(hdb->ba64 + bidx);
    return ((long )(llnum << (int )hdb->apow));
  }
  lnum = *(hdb->ba32 + bidx);
  return ((long )lnum << (int )hdb->apow);
}
}
static void tchdbsetbucket(TCHDB *hdb , uint64_t bidx , uint64_t off ) 
{ uint64_t llnum ;
  uint32_t lnum ;

  {
  if (hdb->ba64) {
    llnum = off >> (int )hdb->apow;
    if (hdb->tran) {
      tchdbwalwrite(hdb, 256ULL + bidx * (unsigned long long )((int )sizeof(llnum)),
                    (long long )((int )sizeof(llnum)));
    }
    *(hdb->ba64 + bidx) = llnum;
  } else {
    lnum = (unsigned int )(off >> (int )hdb->apow);
    if (hdb->tran) {
      tchdbwalwrite(hdb, 256ULL + bidx * (unsigned long long )((int )sizeof(lnum)),
                    (long long )((int )sizeof(lnum)));
    }
    *(hdb->ba32 + bidx) = lnum;
  }
  return;
}
}
static _Bool tchdbsavefbp(TCHDB *hdb ) 
{ int bsiz ;
  char *buf ;
  void *tmp ;
  char *wp ;
  HDBFB *cur ;
  HDBFB *end ;
  uint64_t base ;
  uint64_t noff ;
  int step ;
  uint64_t llnum ;
  long long _TC_num ;
  int _TC_rem ;
  uint32_t lnum ;
  int _TC_num___0 ;
  int _TC_rem___0 ;
  char *tmp___0 ;
  char *tmp___1 ;
  _Bool tmp___2 ;

  {
  if (hdb->fbpnum > hdb->fbpmax) {
    tchdbfbpmerge(hdb);
  } else {
    if (hdb->fbpnum > 1) {
      tcfbpsortbyoff((HDBFB *)hdb->fbpool, hdb->fbpnum);
    }
  }
  bsiz = (int )(hdb->frec - hdb->msiz);
  while (1) {
    tmp = malloc((unsigned int )bsiz);
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  wp = buf;
  cur = (HDBFB *)hdb->fbpool;
  end = cur + hdb->fbpnum;
  base = 0ULL;
  bsiz -= ((int )sizeof(HDBFB ) + (int )sizeof(uint8_t )) + (int )sizeof(uint8_t );
  while (1) {
    if ((unsigned int )cur < (unsigned int )end) {
      if (! (bsiz > 0)) {
        break;
      }
    } else {
      break;
    }
    noff = cur->off >> (int )hdb->apow;
    llnum = noff - base;
    while (1) {
      _TC_num = (long long )llnum;
      if (_TC_num == 0LL) {
        *((signed char *)wp + 0) = (signed char)0;
        step = 1;
      } else {
        step = 0;
        while (_TC_num > 0LL) {
          _TC_rem = (int )(_TC_num & 127LL);
          _TC_num >>= 7;
          if (_TC_num > 0LL) {
            *((signed char *)wp + step) = (signed char )(- _TC_rem - 1);
          } else {
            *((signed char *)wp + step) = (signed char )_TC_rem;
          }
          step ++;
        }
      }
      break;
    }
    wp += step;
    bsiz -= step;
    lnum = cur->rsiz >> (int )hdb->apow;
    while (1) {
      _TC_num___0 = (int )lnum;
      if (_TC_num___0 == 0) {
        *((signed char *)wp + 0) = (signed char)0;
        step = 1;
      } else {
        step = 0;
        while (_TC_num___0 > 0) {
          _TC_rem___0 = _TC_num___0 & 127;
          _TC_num___0 >>= 7;
          if (_TC_num___0 > 0) {
            *((signed char *)wp + step) = (signed char )(- _TC_rem___0 - 1);
          } else {
            *((signed char *)wp + step) = (signed char )_TC_rem___0;
          }
          step ++;
        }
      }
      break;
    }
    wp += step;
    bsiz -= step;
    base = noff;
    cur ++;
  }
  tmp___0 = wp;
  wp ++;
  *tmp___0 = (char )'\000';
  tmp___1 = wp;
  wp ++;
  *tmp___1 = (char )'\000';
  tmp___2 = tchdbseekwrite(hdb, (long )hdb->msiz, (void const   *)buf, (unsigned int )(wp - buf));
  if (! tmp___2) {
    while (1) {
      free((void *)buf);
      break;
    }
    return ((_Bool)0);
  }
  while (1) {
    free((void *)buf);
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tchdbloadfbp(TCHDB *hdb ) 
{ int bsiz ;
  char *buf ;
  void *tmp ;
  _Bool tmp___0 ;
  char const   *rp ;
  HDBFB *cur ;
  HDBFB *end ;
  uint64_t base ;
  int step ;
  uint64_t llnum ;
  long long _TC_base ;
  int _TC_i ;
  uint32_t lnum ;
  int _TC_base___0 ;
  int _TC_i___0 ;

  {
  bsiz = (int )(hdb->frec - hdb->msiz);
  while (1) {
    tmp = malloc((unsigned int )bsiz);
    buf = (char *)tmp;
    if (! buf) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tmp___0 = tchdbseekread(hdb, (long )hdb->msiz, (void *)buf, (unsigned int )bsiz);
  if (! tmp___0) {
    while (1) {
      free((void *)buf);
      break;
    }
    return ((_Bool)0);
  }
  rp = (char const   *)buf;
  cur = (HDBFB *)hdb->fbpool;
  end = cur + hdb->fbpmax * 2;
  base = 0ULL;
  while (1) {
    if ((unsigned int )cur < (unsigned int )end) {
      if (! ((int const   )*rp != 0)) {
        break;
      }
    } else {
      break;
    }
    while (1) {
      llnum = 0ULL;
      _TC_base = 1LL;
      _TC_i = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i) >= 0) {
          llnum += (unsigned long long )((long long )*((signed char *)rp + _TC_i) * _TC_base);
          break;
        }
        llnum += (unsigned long long )((_TC_base * (long long )((int )*((signed char *)rp + _TC_i) + 1)) * -1LL);
        _TC_base <<= 7;
        _TC_i ++;
      }
      step = _TC_i + 1;
      break;
    }
    base += llnum << (int )hdb->apow;
    cur->off = base;
    rp += step;
    while (1) {
      lnum = 0U;
      _TC_base___0 = 1;
      _TC_i___0 = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i___0) >= 0) {
          lnum += (unsigned int )((int )*((signed char *)rp + _TC_i___0) * _TC_base___0);
          break;
        }
        lnum += (unsigned int )((_TC_base___0 * ((int )*((signed char *)rp + _TC_i___0) + 1)) * -1);
        _TC_base___0 <<= 7;
        _TC_i___0 ++;
      }
      step = _TC_i___0 + 1;
      break;
    }
    cur->rsiz = lnum << (int )hdb->apow;
    rp += step;
    cur ++;
  }
  hdb->fbpnum = cur - (HDBFB *)hdb->fbpool;
  while (1) {
    free((void *)buf);
    break;
  }
  tcfbpsortbyrsiz((HDBFB *)hdb->fbpool, hdb->fbpnum);
  return ((_Bool)1);
}
}
static void tcfbpsortbyoff(HDBFB *fbpool , int fbpnum ) 
{ int bottom ;
  int top ;
  int mybot ;
  int i ;
  HDBFB swap ;
  HDBFB swap___0 ;
  int mybot___0 ;
  int i___0 ;

  {
  fbpnum --;
  bottom = fbpnum / 2 + 1;
  top = fbpnum;
  while (bottom > 0) {
    bottom --;
    mybot = bottom;
    i = mybot * 2;
    while (i <= top) {
      if (i < top) {
        if ((fbpool + (i + 1))->off > (fbpool + i)->off) {
          i ++;
        }
      }
      if ((fbpool + mybot)->off >= (fbpool + i)->off) {
        break;
      }
      swap = *(fbpool + mybot);
      *(fbpool + mybot) = *(fbpool + i);
      *(fbpool + i) = swap;
      mybot = i;
      i = mybot * 2;
    }
  }
  while (top > 0) {
    swap___0 = *(fbpool + 0);
    *(fbpool + 0) = *(fbpool + top);
    *(fbpool + top) = swap___0;
    top --;
    mybot___0 = bottom;
    i___0 = mybot___0 * 2;
    while (i___0 <= top) {
      if (i___0 < top) {
        if ((fbpool + (i___0 + 1))->off > (fbpool + i___0)->off) {
          i___0 ++;
        }
      }
      if ((fbpool + mybot___0)->off >= (fbpool + i___0)->off) {
        break;
      }
      swap___0 = *(fbpool + mybot___0);
      *(fbpool + mybot___0) = *(fbpool + i___0);
      *(fbpool + i___0) = swap___0;
      mybot___0 = i___0;
      i___0 = mybot___0 * 2;
    }
  }
  return;
}
}
static void tcfbpsortbyrsiz(HDBFB *fbpool , int fbpnum ) 
{ int bottom ;
  int top ;
  int mybot ;
  int i ;
  HDBFB swap ;
  HDBFB swap___0 ;
  int mybot___0 ;
  int i___0 ;

  {
  fbpnum --;
  bottom = fbpnum / 2 + 1;
  top = fbpnum;
  while (bottom > 0) {
    bottom --;
    mybot = bottom;
    i = mybot * 2;
    while (i <= top) {
      if (i < top) {
        if ((fbpool + (i + 1))->rsiz > (fbpool + i)->rsiz) {
          i ++;
        }
      }
      if ((fbpool + mybot)->rsiz >= (fbpool + i)->rsiz) {
        break;
      }
      swap = *(fbpool + mybot);
      *(fbpool + mybot) = *(fbpool + i);
      *(fbpool + i) = swap;
      mybot = i;
      i = mybot * 2;
    }
  }
  while (top > 0) {
    swap___0 = *(fbpool + 0);
    *(fbpool + 0) = *(fbpool + top);
    *(fbpool + top) = swap___0;
    top --;
    mybot___0 = bottom;
    i___0 = mybot___0 * 2;
    while (i___0 <= top) {
      if (i___0 < top) {
        if ((fbpool + (i___0 + 1))->rsiz > (fbpool + i___0)->rsiz) {
          i___0 ++;
        }
      }
      if ((fbpool + mybot___0)->rsiz >= (fbpool + i___0)->rsiz) {
        break;
      }
      swap___0 = *(fbpool + mybot___0);
      *(fbpool + mybot___0) = *(fbpool + i___0);
      *(fbpool + i___0) = swap___0;
      mybot___0 = i___0;
      i___0 = mybot___0 * 2;
    }
  }
  return;
}
}
static void tchdbfbpmerge(TCHDB *hdb ) 
{ HDBFB *wp ;
  HDBFB *cur ;
  HDBFB *end ;
  HDBFB *next ;
  HDBFB *tmp ;
  HDBFB *tmp___0 ;

  {
  while (1) {
    break;
  }
  tcfbpsortbyoff((HDBFB *)hdb->fbpool, hdb->fbpnum);
  wp = (HDBFB *)hdb->fbpool;
  cur = wp;
  end = (wp + hdb->fbpnum) - 1;
  while ((unsigned int )cur < (unsigned int )end) {
    if (cur->off > 0ULL) {
      next = cur + 1;
      if (cur->off + (unsigned long long )cur->rsiz == next->off) {
        if (hdb->dfcur == next->off) {
          hdb->dfcur += (unsigned long long )next->rsiz;
        }
        if (hdb->iter == next->off) {
          hdb->iter += (unsigned long long )next->rsiz;
        }
        cur->rsiz += next->rsiz;
        next->off = 0ULL;
      }
      tmp = wp;
      wp ++;
      *tmp = *cur;
    }
    cur ++;
  }
  if (end->off > 0ULL) {
    tmp___0 = wp;
    wp ++;
    *tmp___0 = *end;
  }
  hdb->fbpnum = wp - (HDBFB *)hdb->fbpool;
  hdb->fbpmis = hdb->fbpnum * -1;
  return;
}
}
static void tchdbfbpinsert(TCHDB *hdb , uint64_t off , uint32_t rsiz ) 
{ HDBFB *pv ;
  int diff ;
  int num ;
  int left ;
  int right ;
  int i ;
  int cand ;
  int rv ;

  {
  while (1) {
    break;
  }
  (hdb->dfcnt) ++;
  if ((int )hdb->fpow < 1) {
    return;
  }
  pv = (HDBFB *)hdb->fbpool;
  if (hdb->fbpnum >= hdb->fbpmax * 2) {
    tchdbfbpmerge(hdb);
    tcfbpsortbyrsiz((HDBFB *)hdb->fbpool, hdb->fbpnum);
    diff = hdb->fbpnum - hdb->fbpmax;
    if (diff > 0) {
      while (1) {
        break;
      }
      memmove((void *)pv, (void const   *)(pv + diff), (unsigned int )((hdb->fbpnum - diff) * (int )sizeof(*pv)));
      hdb->fbpnum -= diff;
    }
    hdb->fbpmis = 0;
  }
  num = hdb->fbpnum;
  left = 0;
  right = num;
  i = (left + right) / 2;
  cand = -1;
  while (1) {
    if (right >= left) {
      if (! (i < num)) {
        break;
      }
    } else {
      break;
    }
    rv = (int )rsiz - (int )(pv + i)->rsiz;
    if (rv == 0) {
      cand = i;
      break;
    } else {
      if (rv <= 0) {
        cand = i;
        right = i - 1;
      } else {
        left = i + 1;
      }
    }
    i = (left + right) / 2;
  }
  if (cand >= 0) {
    pv += cand;
    memmove((void *)(pv + 1), (void const   *)pv, (unsigned int )((int )sizeof(*pv) * (num - cand)));
  } else {
    pv += num;
  }
  pv->off = off;
  pv->rsiz = rsiz;
  (hdb->fbpnum) ++;
  return;
}
}
static _Bool tchdbfbpsearch(TCHDB *hdb , TCHREC *rec ) 
{ uint32_t rsiz ;
  HDBFB *pv ;
  int num ;
  int left ;
  int right ;
  int i ;
  int cand ;
  int rv ;
  uint32_t psiz ;
  int32_t tmp ;
  uint64_t noff ;
  _Bool tmp___0 ;

  {
  while (1) {
    break;
  }
  if (hdb->fbpnum < 1) {
    rec->off = hdb->fsiz;
    rec->rsiz = 0U;
    return ((_Bool)1);
  }
  rsiz = rec->rsiz;
  pv = (HDBFB *)hdb->fbpool;
  num = hdb->fbpnum;
  left = 0;
  right = num;
  i = (left + right) / 2;
  cand = -1;
  while (1) {
    if (right >= left) {
      if (! (i < num)) {
        break;
      }
    } else {
      break;
    }
    rv = (int )rsiz - (int )(pv + i)->rsiz;
    if (rv == 0) {
      cand = i;
      break;
    } else {
      if (rv <= 0) {
        cand = i;
        right = i - 1;
      } else {
        left = i + 1;
      }
    }
    i = (left + right) / 2;
  }
  if (cand >= 0) {
    pv += cand;
    if (pv->rsiz > rsiz * 2U) {
      tmp = tchdbpadsize(hdb, pv->off + (unsigned long long )rsiz);
      psiz = (unsigned int )tmp;
      noff = (pv->off + (unsigned long long )rsiz) + (unsigned long long )psiz;
      if ((unsigned long long )pv->rsiz >= (noff - pv->off) * 2ULL) {
        while (1) {
          break;
        }
        rec->off = pv->off;
        rec->rsiz = (unsigned int )(noff - pv->off);
        pv->off = noff;
        pv->rsiz -= rec->rsiz;
        tmp___0 = tchdbwritefb(hdb, pv->off, pv->rsiz);
        return (tmp___0);
      }
    }
    rec->off = pv->off;
    rec->rsiz = pv->rsiz;
    memmove((void *)pv, (void const   *)(pv + 1), (unsigned int )((int )sizeof(*pv) * ((num - cand) - 1)));
    (hdb->fbpnum) --;
    return ((_Bool)1);
  }
  rec->off = hdb->fsiz;
  rec->rsiz = 0U;
  (hdb->fbpmis) ++;
  if (hdb->fbpmis >= 4096) {
    tchdbfbpmerge(hdb);
    tcfbpsortbyrsiz((HDBFB *)hdb->fbpool, hdb->fbpnum);
  }
  return ((_Bool)1);
}
}
static _Bool tchdbfbpsplice(TCHDB *hdb , TCHREC *rec , uint32_t nsiz ) 
{ uint64_t off ;
  uint32_t rsiz ;
  uint8_t magic ;
  _Bool tmp ;
  HDBFB *pv ;
  HDBFB *ep ;
  uint64_t off___0 ;
  TCHREC nrec ;
  char nbuf[8192] ;
  _Bool tmp___0 ;
  uint32_t jsiz ;
  uint64_t base ;
  HDBFB *wp ;
  HDBFB *cur ;
  HDBFB *end ;
  HDBFB *tmp___1 ;
  uint32_t psiz ;
  int32_t tmp___2 ;
  uint64_t noff ;
  _Bool tmp___3 ;

  {
  if (hdb->mmtx) {
    if (hdb->fbpnum < 1) {
      return ((_Bool)0);
    }
    off = rec->off + (unsigned long long )rec->rsiz;
    rsiz = rec->rsiz;
    tmp = tchdbseekreadtry(hdb, (long )off, (void *)(& magic), (unsigned int )((int )sizeof(magic)));
    if (tmp) {
      if ((int )magic != 176) {
        return ((_Bool)0);
      }
    }
    pv = (HDBFB *)hdb->fbpool;
    ep = pv + hdb->fbpnum;
    while ((unsigned int )pv < (unsigned int )ep) {
      if (pv->off == off) {
        if (rsiz + pv->rsiz >= nsiz) {
          if (hdb->dfcur == pv->off) {
            hdb->dfcur += (unsigned long long )pv->rsiz;
          }
          if (hdb->iter == pv->off) {
            hdb->iter += (unsigned long long )pv->rsiz;
          }
          rec->rsiz += pv->rsiz;
          memmove((void *)pv, (void const   *)(pv + 1), (unsigned int )((int )sizeof(*pv) * ((ep - pv) - 1)));
          (hdb->fbpnum) --;
          return ((_Bool)1);
        }
      }
      pv ++;
    }
    return ((_Bool)0);
  }
  off___0 = rec->off + (unsigned long long )rec->rsiz;
  while (off___0 < hdb->fsiz) {
    nrec.off = off___0;
    tmp___0 = tchdbreadrec(hdb, & nrec, nbuf);
    if (! tmp___0) {
      return ((_Bool)0);
    }
    if ((int )nrec.magic != 176) {
      break;
    }
    if (hdb->dfcur == off___0) {
      hdb->dfcur += (unsigned long long )nrec.rsiz;
    }
    if (hdb->iter == off___0) {
      hdb->iter += (unsigned long long )nrec.rsiz;
    }
    off___0 += (unsigned long long )nrec.rsiz;
  }
  jsiz = (unsigned int )(off___0 - rec->off);
  if (jsiz < nsiz) {
    return ((_Bool)0);
  }
  rec->rsiz = jsiz;
  base = rec->off;
  wp = (HDBFB *)hdb->fbpool;
  cur = wp;
  end = wp + hdb->fbpnum;
  while ((unsigned int )cur < (unsigned int )end) {
    if (cur->off < base) {
      tmp___1 = wp;
      wp ++;
      *tmp___1 = *cur;
    } else {
      if (cur->off > off___0) {
        tmp___1 = wp;
        wp ++;
        *tmp___1 = *cur;
      }
    }
    cur ++;
  }
  hdb->fbpnum = wp - (HDBFB *)hdb->fbpool;
  if (jsiz > nsiz * 2U) {
    tmp___2 = tchdbpadsize(hdb, rec->off + (unsigned long long )nsiz);
    psiz = (unsigned int )tmp___2;
    noff = (rec->off + (unsigned long long )nsiz) + (unsigned long long )psiz;
    if ((unsigned long long )jsiz >= (noff - rec->off) * 2ULL) {
      while (1) {
        break;
      }
      nsiz = (unsigned int )(off___0 - noff);
      tmp___3 = tchdbwritefb(hdb, noff, nsiz);
      if (! tmp___3) {
        return ((_Bool)0);
      }
      rec->rsiz = (unsigned int )(noff - rec->off);
      tchdbfbpinsert(hdb, noff, nsiz);
    }
  }
  return ((_Bool)1);
}
}
static void tchdbfbptrim(TCHDB *hdb , uint64_t base , uint64_t next , uint64_t off ,
                         uint32_t rsiz ) 
{ HDBFB *fbpool ;
  HDBFB *wp ;
  HDBFB *cur ;
  HDBFB *end ;
  HDBFB *tmp ;

  {
  if ((int )hdb->fpow < 1) {
    return;
  }
  if (hdb->fbpnum < 1) {
    if (off > 0ULL) {
      fbpool = (HDBFB *)hdb->fbpool;
      fbpool->off = off;
      fbpool->rsiz = rsiz;
      hdb->fbpnum = 1;
    }
    return;
  }
  wp = (HDBFB *)hdb->fbpool;
  cur = wp;
  end = wp + hdb->fbpnum;
  if (hdb->fbpnum >= hdb->fbpmax * 2) {
    cur ++;
  }
  while ((unsigned int )cur < (unsigned int )end) {
    if (cur->rsiz >= rsiz) {
      if (off > 0ULL) {
        while (1) {
          break;
        }
        wp->off = off;
        wp->rsiz = rsiz;
        wp ++;
        off = 0ULL;
      } else {
        goto _L;
      }
    } else {
      _L: 
      if (cur->off < base) {
        tmp = wp;
        wp ++;
        *tmp = *cur;
      } else {
        if (cur->off >= next) {
          tmp = wp;
          wp ++;
          *tmp = *cur;
        }
      }
    }
    cur ++;
  }
  if (off > 0ULL) {
    while (1) {
      break;
    }
    wp->off = off;
    wp->rsiz = rsiz;
    wp ++;
    off = 0ULL;
  }
  hdb->fbpnum = wp - (HDBFB *)hdb->fbpool;
  return;
}
}
static _Bool tchdbwritefb(TCHDB *hdb , uint64_t off , uint32_t rsiz ) 
{ char rbuf[32] ;
  char *wp ;
  char *tmp ;
  uint32_t lnum ;
  _Bool tmp___0 ;

  {
  wp = rbuf;
  tmp = wp;
  wp ++;
  *((uint8_t *)tmp) = (unsigned char)176;
  lnum = rsiz;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
  wp += (int )sizeof(lnum);
  tmp___0 = tchdbseekwrite(hdb, (long )off, (void const   *)(rbuf), (unsigned int )(wp - rbuf));
  if (! tmp___0) {
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static _Bool tchdbwriterec(TCHDB *hdb , TCHREC *rec , uint64_t bidx , off_t entoff ) 
{ char stack[8192] ;
  int bsiz ;
  uint32_t tmp ;
  char *rbuf ;
  void *tmp___0 ;
  char *wp ;
  char *tmp___1 ;
  char *tmp___2 ;
  uint64_t llnum ;
  uint32_t lnum ;
  uint16_t snum ;
  char *pwp ;
  int step ;
  int _TC_num ;
  int _TC_rem ;
  int _TC_num___0 ;
  int _TC_rem___0 ;
  int32_t hsiz ;
  int32_t rsiz ;
  int32_t finc ;
  uint16_t psiz ;
  int32_t tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  _Bool rv ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool rv___0 ;
  _Bool tmp___10 ;
  uint32_t psiz___0 ;
  int32_t tmp___11 ;
  uint64_t noff ;
  uint32_t nsiz ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  uint64_t llnum___0 ;
  uint64_t llnum___1 ;
  _Bool tmp___16 ;
  uint32_t lnum___0 ;
  _Bool tmp___17 ;

  {
  while (1) {
    break;
  }
  if (rec->rsiz > 0U) {
    tmp = rec->rsiz;
  } else {
    tmp = ((32U + rec->ksiz) + rec->vsiz) + hdb->align;
  }
  bsiz = (int )tmp;
  if (bsiz <= 8192) {
    rbuf = stack;
  } else {
    while (1) {
      tmp___0 = malloc((unsigned int )bsiz);
      rbuf = (char *)tmp___0;
      if (! rbuf) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  wp = rbuf;
  tmp___1 = wp;
  wp ++;
  *((uint8_t *)tmp___1) = (unsigned char)200;
  tmp___2 = wp;
  wp ++;
  *((uint8_t *)tmp___2) = rec->hash;
  if (hdb->ba64) {
    llnum = rec->left >> (int )hdb->apow;
    llnum = llnum;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
    wp += (int )sizeof(llnum);
    llnum = rec->right >> (int )hdb->apow;
    llnum = llnum;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
    wp += (int )sizeof(llnum);
  } else {
    lnum = (unsigned int )(rec->left >> (int )hdb->apow);
    lnum = lnum;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    lnum = (unsigned int )(rec->right >> (int )hdb->apow);
    lnum = lnum;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
  }
  pwp = wp;
  wp += (int )sizeof(snum);
  while (1) {
    _TC_num = (int )rec->ksiz;
    if (_TC_num == 0) {
      *((signed char *)wp + 0) = (signed char)0;
      step = 1;
    } else {
      step = 0;
      while (_TC_num > 0) {
        _TC_rem = _TC_num & 127;
        _TC_num >>= 7;
        if (_TC_num > 0) {
          *((signed char *)wp + step) = (signed char )(- _TC_rem - 1);
        } else {
          *((signed char *)wp + step) = (signed char )_TC_rem;
        }
        step ++;
      }
    }
    break;
  }
  wp += step;
  while (1) {
    _TC_num___0 = (int )rec->vsiz;
    if (_TC_num___0 == 0) {
      *((signed char *)wp + 0) = (signed char)0;
      step = 1;
    } else {
      step = 0;
      while (_TC_num___0 > 0) {
        _TC_rem___0 = _TC_num___0 & 127;
        _TC_num___0 >>= 7;
        if (_TC_num___0 > 0) {
          *((signed char *)wp + step) = (signed char )(- _TC_rem___0 - 1);
        } else {
          *((signed char *)wp + step) = (signed char )_TC_rem___0;
        }
        step ++;
      }
    }
    break;
  }
  wp += step;
  hsiz = wp - rbuf;
  rsiz = (int )(((unsigned int )hsiz + rec->ksiz) + rec->vsiz);
  finc = 0;
  if (rec->rsiz < 1U) {
    tmp___3 = tchdbpadsize(hdb, hdb->fsiz + (unsigned long long )rsiz);
    psiz = (unsigned short )tmp___3;
    rec->rsiz = (unsigned int )(rsiz + (int )psiz);
    rec->psiz = psiz;
    finc = (int )rec->rsiz;
  } else {
    if ((unsigned int )rsiz > rec->rsiz) {
      if ((unsigned int )rbuf != (unsigned int )(stack)) {
        while (1) {
          free((void *)rbuf);
          break;
        }
      }
      if (hdb->mmtx) {
        tmp___4 = tchdblockdb(hdb);
        tmp___5 = (int )tmp___4;
      } else {
        tmp___5 = 1;
      }
      if (! tmp___5) {
        return ((_Bool)0);
      }
      tmp___7 = tchdbfbpsplice(hdb, rec, (unsigned int )rsiz);
      if (tmp___7) {
        while (1) {
          break;
        }
        tmp___6 = tchdbwriterec(hdb, rec, bidx, entoff);
        rv = tmp___6;
        if (hdb->mmtx) {
          tchdbunlockdb(hdb);
        }
        return (rv);
      }
      while (1) {
        break;
      }
      tmp___8 = tchdbwritefb(hdb, rec->off, rec->rsiz);
      if (! tmp___8) {
        if (hdb->mmtx) {
          tchdbunlockdb(hdb);
        }
        return ((_Bool)0);
      }
      tchdbfbpinsert(hdb, rec->off, rec->rsiz);
      rec->rsiz = (unsigned int )rsiz;
      tmp___9 = tchdbfbpsearch(hdb, rec);
      if (! tmp___9) {
        if (hdb->mmtx) {
          tchdbunlockdb(hdb);
        }
        return ((_Bool)0);
      }
      tmp___10 = tchdbwriterec(hdb, rec, bidx, entoff);
      rv___0 = tmp___10;
      if (hdb->mmtx) {
        tchdbunlockdb(hdb);
      }
      return (rv___0);
    } else {
      while (1) {
        break;
      }
      psiz___0 = rec->rsiz - (unsigned int )rsiz;
      if (psiz___0 > 65535U) {
        while (1) {
          break;
        }
        tmp___11 = tchdbpadsize(hdb, rec->off + (unsigned long long )rsiz);
        psiz___0 = (unsigned int )tmp___11;
        noff = (rec->off + (unsigned long long )rsiz) + (unsigned long long )psiz___0;
        nsiz = (rec->rsiz - (unsigned int )rsiz) - psiz___0;
        rec->rsiz = (unsigned int )(noff - rec->off);
        rec->psiz = (unsigned short )psiz___0;
        tmp___12 = tchdbwritefb(hdb, noff, nsiz);
        if (! tmp___12) {
          if ((unsigned int )rbuf != (unsigned int )(stack)) {
            while (1) {
              free((void *)rbuf);
              break;
            }
          }
          return ((_Bool)0);
        }
        if (hdb->mmtx) {
          tmp___13 = tchdblockdb(hdb);
          tmp___14 = (int )tmp___13;
        } else {
          tmp___14 = 1;
        }
        if (! tmp___14) {
          if ((unsigned int )rbuf != (unsigned int )(stack)) {
            while (1) {
              free((void *)rbuf);
              break;
            }
          }
          return ((_Bool)0);
        }
        tchdbfbpinsert(hdb, noff, nsiz);
        if (hdb->mmtx) {
          tchdbunlockdb(hdb);
        }
      }
      rec->psiz = (unsigned short )psiz___0;
    }
  }
  snum = rec->psiz;
  snum = snum;
  memcpy((void * __restrict  )pwp, (void const   * __restrict  )(& snum), (unsigned int )((int )sizeof(snum)));
  rsiz = (int )rec->rsiz;
  rsiz -= hsiz;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )rec->kbuf, rec->ksiz);
  wp += rec->ksiz;
  rsiz = (int )((unsigned int )rsiz - rec->ksiz);
  memcpy((void * __restrict  )wp, (void const   * __restrict  )rec->vbuf, rec->vsiz);
  wp += rec->vsiz;
  rsiz = (int )((unsigned int )rsiz - rec->vsiz);
  memset((void *)wp, 0, (unsigned int )rsiz);
  tmp___15 = tchdbseekwrite(hdb, (long )rec->off, (void const   *)rbuf, rec->rsiz);
  if (! tmp___15) {
    if ((unsigned int )rbuf != (unsigned int )(stack)) {
      while (1) {
        free((void *)rbuf);
        break;
      }
    }
    return ((_Bool)0);
  }
  if (finc != 0) {
    hdb->fsiz += (unsigned long long )finc;
    llnum___0 = hdb->fsiz;
    llnum___0 = llnum___0;
    memcpy((void * __restrict  )(hdb->map + 56), (void const   * __restrict  )(& llnum___0),
           (unsigned int )((int )sizeof(llnum___0)));
  }
  if ((unsigned int )rbuf != (unsigned int )(stack)) {
    while (1) {
      free((void *)rbuf);
      break;
    }
  }
  if (entoff > 0L) {
    if (hdb->ba64) {
      llnum___1 = rec->off >> (int )hdb->apow;
      llnum___1 = llnum___1;
      tmp___16 = tchdbseekwrite(hdb, entoff, (void const   *)(& llnum___1), (unsigned int )((int )sizeof(uint64_t )));
      if (! tmp___16) {
        return ((_Bool)0);
      }
    } else {
      lnum___0 = (unsigned int )(rec->off >> (int )hdb->apow);
      lnum___0 = lnum___0;
      tmp___17 = tchdbseekwrite(hdb, entoff, (void const   *)(& lnum___0), (unsigned int )((int )sizeof(uint32_t )));
      if (! tmp___17) {
        return ((_Bool)0);
      }
    }
  } else {
    tchdbsetbucket(hdb, bidx, rec->off);
  }
  return ((_Bool)1);
}
}
static _Bool tchdbreadrec(TCHDB *hdb , TCHREC *rec , char *rbuf ) 
{ int rsiz ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  char const   *rp ;
  char const   *tmp___3 ;
  uint32_t lnum ;
  char const   *tmp___4 ;
  uint64_t llnum ;
  uint32_t lnum___0 ;
  uint16_t snum ;
  uint32_t lnum___1 ;
  int step ;
  int _TC_base ;
  int _TC_i ;
  int _TC_base___0 ;
  int _TC_i___0 ;
  int32_t hsiz ;

  {
  while (1) {
    break;
  }
  rsiz = (int )hdb->runit;
  tmp___2 = tchdbseekreadtry(hdb, (long )rec->off, (void *)rbuf, (unsigned int )rsiz);
  if (! tmp___2) {
    if (hdb->mmtx) {
      tmp = tchdblockdb(hdb);
      tmp___0 = (int )tmp;
    } else {
      tmp___0 = 1;
    }
    if (! tmp___0) {
      return ((_Bool)0);
    }
    rsiz = (int )(hdb->fsiz - rec->off);
    if ((unsigned int )rsiz > hdb->runit) {
      rsiz = (int )hdb->runit;
    } else {
      if (rsiz < (int )sizeof(uint8_t ) + (int )sizeof(uint32_t )) {
        tchdbsetecode(hdb, 6, "tchdb.c", 2792, "tchdbreadrec");
        if (hdb->mmtx) {
          tchdbunlockdb(hdb);
        }
        return ((_Bool)0);
      }
    }
    tmp___1 = tchdbseekread(hdb, (long )rec->off, (void *)rbuf, (unsigned int )rsiz);
    if (! tmp___1) {
      if (hdb->mmtx) {
        tchdbunlockdb(hdb);
      }
      return ((_Bool)0);
    }
    if (hdb->mmtx) {
      tchdbunlockdb(hdb);
    }
  }
  rp = (char const   *)rbuf;
  tmp___3 = rp;
  rp ++;
  rec->magic = *((uint8_t *)tmp___3);
  if ((int )rec->magic == 176) {
    memcpy((void * __restrict  )(& lnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(lnum)));
    rec->rsiz = lnum;
    return ((_Bool)1);
  } else {
    if ((int )rec->magic != 200) {
      tchdbsetecode(hdb, 6, "tchdb.c", 2810, "tchdbreadrec");
      return ((_Bool)0);
    }
  }
  tmp___4 = rp;
  rp ++;
  rec->hash = *((uint8_t *)tmp___4);
  if (hdb->ba64) {
    memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(llnum)));
    rec->left = llnum << (int )hdb->apow;
    rp += (int )sizeof(llnum);
    memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(llnum)));
    rec->right = llnum << (int )hdb->apow;
    rp += (int )sizeof(llnum);
  } else {
    memcpy((void * __restrict  )(& lnum___0), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(lnum___0)));
    rec->left = (unsigned long long )lnum___0 << (int )hdb->apow;
    rp += (int )sizeof(lnum___0);
    memcpy((void * __restrict  )(& lnum___0), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(lnum___0)));
    rec->right = (unsigned long long )lnum___0 << (int )hdb->apow;
    rp += (int )sizeof(lnum___0);
  }
  memcpy((void * __restrict  )(& snum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(snum)));
  rec->psiz = snum;
  rp += (int )sizeof(snum);
  while (1) {
    lnum___1 = 0U;
    _TC_base = 1;
    _TC_i = 0;
    while (1) {
      if ((int )*((signed char *)rp + _TC_i) >= 0) {
        lnum___1 += (unsigned int )((int )*((signed char *)rp + _TC_i) * _TC_base);
        break;
      }
      lnum___1 += (unsigned int )((_TC_base * ((int )*((signed char *)rp + _TC_i) + 1)) * -1);
      _TC_base <<= 7;
      _TC_i ++;
    }
    step = _TC_i + 1;
    break;
  }
  rec->ksiz = lnum___1;
  rp += step;
  while (1) {
    lnum___1 = 0U;
    _TC_base___0 = 1;
    _TC_i___0 = 0;
    while (1) {
      if ((int )*((signed char *)rp + _TC_i___0) >= 0) {
        lnum___1 += (unsigned int )((int )*((signed char *)rp + _TC_i___0) * _TC_base___0);
        break;
      }
      lnum___1 += (unsigned int )((_TC_base___0 * ((int )*((signed char *)rp + _TC_i___0) + 1)) * -1);
      _TC_base___0 <<= 7;
      _TC_i___0 ++;
    }
    step = _TC_i___0 + 1;
    break;
  }
  rec->vsiz = lnum___1;
  rp += step;
  hsiz = rp - (char const   *)rbuf;
  rec->rsiz = (((unsigned int )hsiz + rec->ksiz) + rec->vsiz) + (unsigned int )rec->psiz;
  rec->kbuf = (char const   *)((void *)0);
  rec->vbuf = (char const   *)((void *)0);
  rec->boff = rec->off + (unsigned long long )hsiz;
  rec->bbuf = (char *)((void *)0);
  rsiz -= hsiz;
  if ((unsigned int )rsiz >= rec->ksiz) {
    rec->kbuf = rp;
    rsiz = (int )((unsigned int )rsiz - rec->ksiz);
    rp += rec->ksiz;
    if ((unsigned int )rsiz >= rec->vsiz) {
      rec->vbuf = rp;
    }
  }
  return ((_Bool)1);
}
}
static _Bool tchdbreadrecbody(TCHDB *hdb , TCHREC *rec ) 
{ int32_t bsiz ;
  char *tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
  bsiz = (int )(rec->ksiz + rec->vsiz);
  while (1) {
    tmp___0 = malloc((unsigned int )(bsiz + 1));
    tmp = (char *)tmp___0;
    rec->bbuf = tmp;
    if (! tmp) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tmp___1 = tchdbseekread(hdb, (long )rec->boff, (void *)rec->bbuf, (unsigned int )bsiz);
  if (! tmp___1) {
    return ((_Bool)0);
  }
  rec->kbuf = (char const   *)rec->bbuf;
  rec->vbuf = (char const   *)(rec->bbuf + rec->ksiz);
  return ((_Bool)1);
}
}
static _Bool tchdbremoverec(TCHDB *hdb , TCHREC *rec , char *rbuf , uint64_t bidx ,
                            off_t entoff ) 
{ _Bool tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  uint64_t child ;
  uint64_t right ;
  _Bool tmp___2 ;
  off_t toff ;
  uint64_t llnum ;
  _Bool tmp___3 ;
  off_t toff___0 ;
  uint32_t lnum ;
  _Bool tmp___4 ;
  uint64_t llnum___0 ;
  _Bool tmp___5 ;
  uint32_t lnum___0 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  uint64_t llnum___1 ;

  {
  tmp = tchdbwritefb(hdb, rec->off, rec->rsiz);
  if (! tmp) {
    return ((_Bool)0);
  }
  if (hdb->mmtx) {
    tmp___0 = tchdblockdb(hdb);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    return ((_Bool)0);
  }
  tchdbfbpinsert(hdb, rec->off, rec->rsiz);
  if (hdb->mmtx) {
    tchdbunlockdb(hdb);
  }
  if (rec->left > 0ULL) {
    if (rec->right < 1ULL) {
      child = rec->left;
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if (rec->left < 1ULL) {
      if (rec->right > 0ULL) {
        child = rec->right;
      } else {
        goto _L;
      }
    } else {
      _L: 
      if (rec->left < 1ULL) {
        child = 0ULL;
      } else {
        child = rec->left;
        right = rec->right;
        rec->right = child;
        while (rec->right > 0ULL) {
          rec->off = rec->right;
          tmp___2 = tchdbreadrec(hdb, rec, rbuf);
          if (! tmp___2) {
            return ((_Bool)0);
          }
        }
        if (hdb->ba64) {
          toff = (long )(rec->off + (unsigned long long )(((int )sizeof(uint8_t ) + (int )sizeof(uint8_t )) + (int )sizeof(uint64_t )));
          llnum = right >> (int )hdb->apow;
          llnum = llnum;
          tmp___3 = tchdbseekwrite(hdb, toff, (void const   *)(& llnum), (unsigned int )((int )sizeof(uint64_t )));
          if (! tmp___3) {
            return ((_Bool)0);
          }
        } else {
          toff___0 = (long )(rec->off + (unsigned long long )(((int )sizeof(uint8_t ) + (int )sizeof(uint8_t )) + (int )sizeof(uint32_t )));
          lnum = (unsigned int )(right >> (int )hdb->apow);
          lnum = lnum;
          tmp___4 = tchdbseekwrite(hdb, toff___0, (void const   *)(& lnum), (unsigned int )((int )sizeof(uint32_t )));
          if (! tmp___4) {
            return ((_Bool)0);
          }
        }
      }
    }
  }
  if (entoff > 0L) {
    if (hdb->ba64) {
      llnum___0 = child >> (int )hdb->apow;
      llnum___0 = llnum___0;
      tmp___5 = tchdbseekwrite(hdb, entoff, (void const   *)(& llnum___0), (unsigned int )((int )sizeof(uint64_t )));
      if (! tmp___5) {
        return ((_Bool)0);
      }
    } else {
      lnum___0 = (unsigned int )(child >> (int )hdb->apow);
      lnum___0 = lnum___0;
      tmp___6 = tchdbseekwrite(hdb, entoff, (void const   *)(& lnum___0), (unsigned int )((int )sizeof(uint32_t )));
      if (! tmp___6) {
        return ((_Bool)0);
      }
    }
  } else {
    tchdbsetbucket(hdb, bidx, child);
  }
  if (hdb->mmtx) {
    tmp___7 = tchdblockdb(hdb);
    tmp___8 = (int )tmp___7;
  } else {
    tmp___8 = 1;
  }
  if (! tmp___8) {
    return ((_Bool)0);
  }
  (hdb->rnum) --;
  llnum___1 = hdb->rnum;
  llnum___1 = llnum___1;
  memcpy((void * __restrict  )(hdb->map + 48), (void const   * __restrict  )(& llnum___1),
         (unsigned int )((int )sizeof(llnum___1)));
  if (hdb->mmtx) {
    tchdbunlockdb(hdb);
  }
  return ((_Bool)1);
}
}
static _Bool tchdbshiftrec(TCHDB *hdb , TCHREC *rec , char *rbuf , off_t destoff ) 
{ _Bool tmp ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___0 ;
  off_t off ;
  off_t tmp___1 ;
  _Bool err ;
  _Bool tmp___2 ;
  TCHREC trec ;
  char tbuf[8192] ;
  char *bbuf ;
  char const   *kbuf ;
  int ksiz ;
  char const   *vbuf ;
  int vsiz ;
  off_t entoff ;
  _Bool tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int kcmp ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool err___0 ;
  _Bool tmp___8 ;

  {
  while (1) {
    break;
  }
  if (! rec->vbuf) {
    tmp = tchdbreadrecbody(hdb, rec);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  tmp___0 = tchdbbidx(hdb, rec->kbuf, (int )rec->ksiz, & hash);
  bidx = tmp___0;
  tmp___1 = tchdbgetbucket(hdb, bidx);
  off = tmp___1;
  if (rec->off == (unsigned long long )off) {
    err = (_Bool)0;
    rec->off = (unsigned long long )destoff;
    tmp___2 = tchdbwriterec(hdb, rec, bidx, 0L);
    if (! tmp___2) {
      err = (_Bool)1;
    }
    while (1) {
      free((void *)rec->bbuf);
      break;
    }
    rec->kbuf = (char const   *)((void *)0);
    rec->vbuf = (char const   *)((void *)0);
    rec->bbuf = (char *)((void *)0);
    return ((_Bool )(! err));
  }
  bbuf = rec->bbuf;
  kbuf = rec->kbuf;
  ksiz = (int )rec->ksiz;
  vbuf = rec->vbuf;
  vsiz = (int )rec->vsiz;
  rec->kbuf = (char const   *)((void *)0);
  rec->vbuf = (char const   *)((void *)0);
  rec->bbuf = (char *)((void *)0);
  entoff = 0L;
  while (off > 0L) {
    trec.off = (unsigned long long )off;
    tmp___3 = tchdbreadrec(hdb, & trec, tbuf);
    if (! tmp___3) {
      while (1) {
        free((void *)bbuf);
        break;
      }
      return ((_Bool)0);
    }
    if ((int )hash > (int )trec.hash) {
      off = (long )trec.left;
      entoff = (long )(trec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t )));
    } else {
      if ((int )hash < (int )trec.hash) {
        off = (long )trec.right;
        if (hdb->ba64) {
          tmp___4 = (int )sizeof(uint64_t );
        } else {
          tmp___4 = (int )sizeof(uint32_t );
        }
        entoff = (long )((trec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t ))) + (unsigned long long )tmp___4);
      } else {
        if (! trec.kbuf) {
          tmp___5 = tchdbreadrecbody(hdb, & trec);
          if (! tmp___5) {
            while (1) {
              free((void *)bbuf);
              break;
            }
            return ((_Bool)0);
          }
        }
        tmp___6 = tcreckeycmp(kbuf, ksiz, trec.kbuf, (int )trec.ksiz);
        kcmp = tmp___6;
        if (kcmp > 0) {
          off = (long )trec.left;
          while (1) {
            free((void *)trec.bbuf);
            break;
          }
          trec.kbuf = (char const   *)((void *)0);
          trec.bbuf = (char *)((void *)0);
          entoff = (long )(trec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t )));
        } else {
          if (kcmp < 0) {
            off = (long )trec.right;
            while (1) {
              free((void *)trec.bbuf);
              break;
            }
            trec.kbuf = (char const   *)((void *)0);
            trec.bbuf = (char *)((void *)0);
            if (hdb->ba64) {
              tmp___7 = (int )sizeof(uint64_t );
            } else {
              tmp___7 = (int )sizeof(uint32_t );
            }
            entoff = (long )((trec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t ))) + (unsigned long long )tmp___7);
          } else {
            while (1) {
              free((void *)trec.bbuf);
              break;
            }
            trec.bbuf = (char *)((void *)0);
            err___0 = (_Bool)0;
            rec->off = (unsigned long long )destoff;
            rec->kbuf = kbuf;
            rec->ksiz = (unsigned int )ksiz;
            rec->vbuf = vbuf;
            rec->vsiz = (unsigned int )vsiz;
            tmp___8 = tchdbwriterec(hdb, rec, bidx, entoff);
            if (! tmp___8) {
              err___0 = (_Bool)1;
            }
            while (1) {
              free((void *)bbuf);
              break;
            }
            return ((_Bool )(! err___0));
          }
        }
      }
    }
  }
  while (1) {
    free((void *)bbuf);
    break;
  }
  tchdbsetecode(hdb, 22, "tchdb.c", 3020, "tchdbshiftrec");
  return ((_Bool)0);
}
}
static int tcreckeycmp(char const   *abuf , int asiz , char const   *bbuf , int bsiz ) 
{ int tmp ;

  {
  if (asiz > bsiz) {
    return (1);
  }
  if (asiz < bsiz) {
    return (-1);
  }
  tmp = memcmp((void const   *)abuf, (void const   *)bbuf, (unsigned int )asiz);
  return (tmp);
}
}
static _Bool tchdbflushdrp(TCHDB *hdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  char const   *rp ;
  int size ;
  int ksiz ;
  int vsiz ;
  char const   *kbuf ;
  char const   *vbuf ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___2 ;
  _Bool tmp___3 ;
  uint64_t llnum ;

  {
  if (hdb->mmtx) {
    tmp = tchdblockdb(hdb);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! hdb->drpool) {
    if (hdb->mmtx) {
      tchdbunlockdb(hdb);
    }
    return ((_Bool)1);
  }
  while (1) {
    break;
  }
  tmp___1 = tchdbseekwrite(hdb, (long )hdb->drpoff, (void const   *)(hdb->drpool)->ptr,
                           (unsigned int )(hdb->drpool)->size);
  if (! tmp___1) {
    if (hdb->mmtx) {
      tchdbunlockdb(hdb);
    }
    return ((_Bool)0);
  }
  rp = (char const   *)(hdb->drpdef)->ptr;
  size = (hdb->drpdef)->size;
  while (size > 0) {
    memcpy((void * __restrict  )(& ksiz), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(int )));
    rp += (int )sizeof(int );
    memcpy((void * __restrict  )(& vsiz), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(int )));
    rp += (int )sizeof(int );
    kbuf = rp;
    rp += ksiz;
    vbuf = rp;
    rp += vsiz;
    tmp___2 = tchdbbidx(hdb, kbuf, ksiz, & hash);
    bidx = tmp___2;
    tmp___3 = tchdbputimpl(hdb, kbuf, ksiz, bidx, hash, vbuf, vsiz, 0);
    if (! tmp___3) {
      tcxstrdel(hdb->drpdef);
      tcxstrdel(hdb->drpool);
      hdb->drpool = (TCXSTR *)((void *)0);
      hdb->drpdef = (TCXSTR *)((void *)0);
      hdb->drpoff = 0ULL;
      if (hdb->mmtx) {
        tchdbunlockdb(hdb);
      }
      return ((_Bool)0);
    }
    size -= ((int )sizeof(int ) * 2 + ksiz) + vsiz;
  }
  tcxstrdel(hdb->drpdef);
  tcxstrdel(hdb->drpool);
  hdb->drpool = (TCXSTR *)((void *)0);
  hdb->drpdef = (TCXSTR *)((void *)0);
  hdb->drpoff = 0ULL;
  llnum = hdb->rnum;
  llnum = llnum;
  memcpy((void * __restrict  )(hdb->map + 48), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  llnum = hdb->fsiz;
  llnum = llnum;
  memcpy((void * __restrict  )(hdb->map + 56), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  if (hdb->mmtx) {
    tchdbunlockdb(hdb);
  }
  return ((_Bool)1);
}
}
static void tchdbcacheadjust(TCHDB *hdb ) 
{ 

  {
  while (1) {
    break;
  }
  tcmdbcutfront(hdb->recc, 128);
  return;
}
}
static _Bool tchdbwalinit(TCHDB *hdb ) 
{ __off_t tmp ;
  int tmp___0 ;
  uint64_t llnum ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  tmp = lseek(hdb->walfd, 0L, 0);
  if (tmp == -1L) {
    tchdbsetecode(hdb, 12, "tchdb.c", 3111, "tchdbwalinit");
    return ((_Bool)0);
  }
  tmp___0 = ftruncate(hdb->walfd, 0L);
  if (tmp___0 == -1) {
    tchdbsetecode(hdb, 9, "tchdb.c", 3115, "tchdbwalinit");
    return ((_Bool)0);
  }
  llnum = hdb->fsiz;
  llnum = llnum;
  tmp___1 = tcwrite(hdb->walfd, (void const   *)(& llnum), (unsigned int )((int )sizeof(llnum)));
  if (! tmp___1) {
    tchdbsetecode(hdb, 14, "tchdb.c", 3121, "tchdbwalinit");
    return ((_Bool)0);
  }
  hdb->walend = hdb->fsiz;
  tmp___2 = tchdbwalwrite(hdb, 0ULL, 256LL);
  if (! tmp___2) {
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static _Bool tchdbwalwrite(TCHDB *hdb , uint64_t off , int64_t size ) 
{ char stack[8192] ;
  char *buf ;
  void *tmp ;
  char *wp ;
  uint64_t llnum ;
  uint32_t lnum ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;

  {
  if (off + (unsigned long long )size > hdb->walend) {
    size = (long long )(hdb->walend - off);
  }
  if (size < 1LL) {
    return ((_Bool)1);
  }
  if ((size + (long long )((int )sizeof(off))) + (long long )((int )sizeof(size)) <= 8192LL) {
    buf = stack;
  } else {
    while (1) {
      tmp = malloc((unsigned int )((size + (long long )((int )sizeof(off))) + (long long )((int )sizeof(size))));
      buf = (char *)tmp;
      if (! buf) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  wp = buf;
  llnum = off;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
  wp += (int )sizeof(llnum);
  lnum = (unsigned int )size;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
  wp += (int )sizeof(lnum);
  tmp___0 = tchdbseekread(hdb, (long )off, (void *)wp, (unsigned int )size);
  if (! tmp___0) {
    if ((unsigned int )buf != (unsigned int )(stack)) {
      while (1) {
        free((void *)buf);
        break;
      }
    }
    return ((_Bool)0);
  }
  wp += size;
  if (hdb->mmtx) {
    tmp___1 = tchdblockwal(hdb);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    return ((_Bool)0);
  }
  tmp___3 = tcwrite(hdb->walfd, (void const   *)buf, (unsigned int )(wp - buf));
  if (! tmp___3) {
    tchdbsetecode(hdb, 14, "tchdb.c", 3160, "tchdbwalwrite");
    if ((unsigned int )buf != (unsigned int )(stack)) {
      while (1) {
        free((void *)buf);
        break;
      }
    }
    if (hdb->mmtx) {
      tchdbunlockwal(hdb);
    }
    return ((_Bool)0);
  }
  if ((unsigned int )buf != (unsigned int )(stack)) {
    while (1) {
      free((void *)buf);
      break;
    }
  }
  if (hdb->omode & 64U) {
    tmp___4 = fsync(hdb->walfd);
    if (tmp___4 == -1) {
      tchdbsetecode(hdb, 10, "tchdb.c", 3167, "tchdbwalwrite");
      if (hdb->mmtx) {
        tchdbunlockwal(hdb);
      }
      return ((_Bool)0);
    }
  }
  if (hdb->mmtx) {
    tchdbunlockwal(hdb);
  }
  return ((_Bool)1);
}
}
static int tchdbwalrestore(TCHDB *hdb , char const   *path ) 
{ char *tpath ;
  char *tmp ;
  int walfd ;
  int tmp___0 ;
  _Bool err ;
  uint64_t walsiz ;
  struct stat sbuf ;
  int tmp___1 ;
  int dbfd ;
  int tfd ;
  int ecode ;
  int *tmp___2 ;
  uint64_t fsiz ;
  _Bool tmp___3 ;
  TCLIST *list ;
  TCLIST *tmp___4 ;
  uint64_t waloff ;
  char stack[8192] ;
  uint64_t off ;
  uint32_t size ;
  _Bool tmp___5 ;
  char *buf ;
  void *tmp___6 ;
  _Bool tmp___7 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___8 ;
  void *tmp___9 ;
  TCLISTDATUM *array ;
  char *tmp___10 ;
  void *tmp___11 ;
  size_t xmsiz ;
  int i ;
  char const   *rec ;
  int size___0 ;
  uint64_t off___0 ;
  __off_t tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  tmp = tcsprintf("%s%c%s", path, '.', "wal");
  tpath = tmp;
  tmp___0 = open((char const   *)tpath, 0, 420);
  walfd = tmp___0;
  while (1) {
    free((void *)tpath);
    break;
  }
  if (walfd < 0) {
    return (0);
  }
  err = (_Bool)0;
  walsiz = 0ULL;
  tmp___1 = fstat(walfd, & sbuf);
  if (tmp___1 == 0) {
    walsiz = (unsigned long long )sbuf.st_size;
  } else {
    tchdbsetecode(hdb, 11, "tchdb.c", 3192, "tchdbwalrestore");
    err = (_Bool)1;
  }
  if (walsiz >= (unsigned long long )((int )sizeof(walsiz) + 256)) {
    dbfd = hdb->fd;
    tfd = -1;
    if (! (hdb->omode & 2U)) {
      tfd = open(path, 1, 420);
      if (tfd >= 0) {
        dbfd = tfd;
      } else {
        ecode = 7;
        tmp___2 = __errno_location();
        switch (*tmp___2) {
        case 13: 
        ecode = 4;
        break;
        case 2: 
        ecode = 3;
        break;
        case 20: 
        ecode = 3;
        break;
        }
        tchdbsetecode(hdb, ecode, "tchdb.c", 3209, "tchdbwalrestore");
        err = (_Bool)1;
      }
    }
    fsiz = 0ULL;
    tmp___3 = tcread(walfd, (void *)(& fsiz), (unsigned int )((int )sizeof(fsiz)));
    if (tmp___3) {
      fsiz = fsiz;
    } else {
      tchdbsetecode(hdb, 13, "tchdb.c", 3217, "tchdbwalrestore");
      err = (_Bool)1;
    }
    tmp___4 = tclistnew();
    list = tmp___4;
    waloff = (unsigned long long )((int )sizeof(fsiz));
    while (waloff < walsiz) {
      tmp___5 = tcread(walfd, (void *)(stack), (unsigned int )((int )sizeof(off) + (int )sizeof(size)));
      if (! tmp___5) {
        tchdbsetecode(hdb, 13, "tchdb.c", 3227, "tchdbwalrestore");
        err = (_Bool)1;
        break;
      }
      memcpy((void * __restrict  )(& off), (void const   * __restrict  )(stack), (unsigned int )((int )sizeof(off)));
      off = off;
      memcpy((void * __restrict  )(& size), (void const   * __restrict  )(stack + (int )sizeof(off)),
             (unsigned int )((int )sizeof(size)));
      size = size;
      if ((unsigned int )((int )sizeof(off)) + size <= 8192U) {
        buf = stack;
      } else {
        while (1) {
          tmp___6 = malloc((unsigned int )((int )sizeof(off)) + size);
          buf = (char *)tmp___6;
          if (! buf) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      *((uint64_t *)buf) = off;
      tmp___7 = tcread(walfd, (void *)(buf + (int )sizeof(off)), size);
      if (! tmp___7) {
        tchdbsetecode(hdb, 13, "tchdb.c", 3243, "tchdbwalrestore");
        err = (_Bool)1;
        if ((unsigned int )buf != (unsigned int )(stack)) {
          while (1) {
            free((void *)buf);
            break;
          }
        }
        break;
      }
      while (1) {
        TC_mysize = (int )((unsigned int )((int )sizeof(off)) + size);
        TC_index = list->start + list->num;
        if (TC_index >= list->anum) {
          list->anum += list->num + 1;
          while (1) {
            tmp___9 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
            tmp___8 = (TCLISTDATUM *)tmp___9;
            list->array = tmp___8;
            if (! tmp___8) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        array = list->array;
        while (1) {
          tmp___11 = malloc((unsigned int )(TC_mysize + 1));
          tmp___10 = (char *)tmp___11;
          (array + TC_index)->ptr = tmp___10;
          if (! tmp___10) {
            tcmyfatal("out of memory");
          }
          break;
        }
        memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )buf,
               (unsigned int )TC_mysize);
        *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
        (array + TC_index)->size = TC_mysize;
        (list->num) ++;
        break;
      }
      if ((unsigned int )buf != (unsigned int )(stack)) {
        while (1) {
          free((void *)buf);
          break;
        }
      }
      waloff += (unsigned long long )((unsigned int )((int )sizeof(off) + (int )sizeof(size)) + size);
    }
    xmsiz = 0U;
    if (hdb->fd >= 0) {
      if (hdb->map) {
        if (hdb->xmsiz > hdb->msiz) {
          xmsiz = (unsigned int )hdb->xmsiz;
        } else {
          xmsiz = (unsigned int )hdb->msiz;
        }
      }
    }
    i = list->num - 1;
    while (i >= 0) {
      while (1) {
        rec = (char const   *)(list->array + (i + list->start))->ptr;
        size___0 = (list->array + (i + list->start))->size;
        break;
      }
      off___0 = *((uint64_t *)rec);
      rec += (int )sizeof(off___0);
      size___0 -= (int )sizeof(off___0);
      tmp___12 = lseek(dbfd, (long )off___0, 0);
      if (tmp___12 == -1L) {
        tchdbsetecode(hdb, 12, "tchdb.c", 3262, "tchdbwalrestore");
        err = (_Bool)1;
        break;
      }
      tmp___13 = tcwrite(dbfd, (void const   *)rec, (unsigned int )size___0);
      if (! tmp___13) {
        tchdbsetecode(hdb, 14, "tchdb.c", 3267, "tchdbwalrestore");
        err = (_Bool)1;
        break;
      }
      i --;
    }
    tclistdel(list);
    tmp___14 = ftruncate(dbfd, (long )fsiz);
    if (tmp___14 == -1) {
      tchdbsetecode(hdb, 9, "tchdb.c", 3278, "tchdbwalrestore");
      err = (_Bool)1;
    }
    if (hdb->omode & 64U) {
      tmp___15 = fsync(dbfd);
      if (tmp___15 == -1) {
        tchdbsetecode(hdb, 10, "tchdb.c", 3282, "tchdbwalrestore");
        err = (_Bool)1;
      }
    }
    if (tfd >= 0) {
      tmp___16 = close(tfd);
      if (tmp___16 == -1) {
        tchdbsetecode(hdb, 8, "tchdb.c", 3286, "tchdbwalrestore");
        err = (_Bool)1;
      }
    }
  } else {
    err = (_Bool)1;
  }
  tmp___17 = close(walfd);
  if (tmp___17 == -1) {
    tchdbsetecode(hdb, 8, "tchdb.c", 3293, "tchdbwalrestore");
    err = (_Bool)1;
  }
  return (! err);
}
}
static _Bool tchdbwalremove(TCHDB *hdb , char const   *path ) 
{ char *tpath ;
  char *tmp ;
  _Bool err ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  tmp = tcsprintf("%s%c%s", path, '.', "wal");
  tpath = tmp;
  err = (_Bool)0;
  tmp___0 = unlink((char const   *)tpath);
  if (tmp___0 == -1) {
    tmp___1 = __errno_location();
    if (*tmp___1 != 2) {
      tchdbsetecode(hdb, 17, "tchdb.c", 3309, "tchdbwalremove");
      err = (_Bool)1;
    }
  }
  while (1) {
    free((void *)tpath);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tchdbopenimpl(TCHDB *hdb , char const   *path , int omode ) 
{ int mode ;
  int fd ;
  int tmp ;
  int ecode ;
  int *tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  struct stat sbuf ;
  int tmp___4 ;
  char hbuf[256] ;
  uint32_t fbpmax ;
  uint32_t fbpsiz ;
  int besiz ;
  int tmp___5 ;
  int32_t tmp___6 ;
  _Bool err ;
  _Bool tmp___7 ;
  char pbuf[8192] ;
  uint64_t psiz ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  __off_t tmp___10 ;
  _Bool tmp___11 ;
  int type ;
  __off_t tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  int tmp___15 ;
  int besiz___0 ;
  int tmp___16 ;
  size_t msiz ;
  size_t tmp___17 ;
  int tmp___18 ;
  size_t xmsiz ;
  uint64_t tmp___19 ;
  void *map ;
  int tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  TCMDB *tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  int tmp___26 ;
  _Bool err___0 ;
  _Bool tmp___27 ;
  _Bool tmp___28 ;

  {
  mode = 0;
  if (omode & 2) {
    mode = 2;
    if (omode & 4) {
      mode |= 64;
    }
  }
  tmp = open(path, mode, 420);
  fd = tmp;
  if (fd < 0) {
    ecode = 7;
    tmp___0 = __errno_location();
    switch (*tmp___0) {
    case 13: 
    ecode = 4;
    break;
    case 2: 
    ecode = 3;
    break;
    case 20: 
    ecode = 3;
    break;
    }
    tchdbsetecode(hdb, ecode, "tchdb.c", 3337, "tchdbopenimpl");
    return ((_Bool)0);
  }
  if (! (omode & 16)) {
    tmp___1 = tclock(fd, (_Bool )(omode & 2), (_Bool )(omode & 32));
    if (! tmp___1) {
      tchdbsetecode(hdb, 16, "tchdb.c", 3342, "tchdbopenimpl");
      close(fd);
      return ((_Bool)0);
    }
  }
  if (omode & 2) {
    if (omode & 8) {
      tmp___2 = ftruncate(fd, 0L);
      if (tmp___2 == -1) {
        tchdbsetecode(hdb, 9, "tchdb.c", 3349, "tchdbopenimpl");
        close(fd);
        return ((_Bool)0);
      }
      tmp___3 = tchdbwalremove(hdb, path);
      if (! tmp___3) {
        close(fd);
        return ((_Bool)0);
      }
    }
  }
  tmp___4 = fstat(fd, & sbuf);
  if (tmp___4 == -1) {
    tchdbsetecode(hdb, 11, "tchdb.c", 3360, "tchdbopenimpl");
    close(fd);
    return ((_Bool)0);
  } else {
    if (! ((sbuf.st_mode & 61440U) == 32768U)) {
      tchdbsetecode(hdb, 11, "tchdb.c", 3360, "tchdbopenimpl");
      close(fd);
      return ((_Bool)0);
    }
  }
  if (omode & 2) {
    if (sbuf.st_size < 1L) {
      hdb->flags = (unsigned char)0;
      hdb->rnum = 0ULL;
      fbpmax = (unsigned int )(1 << (int )hdb->fpow);
      fbpsiz = 64U + fbpmax * 4U;
      if ((int )hdb->opts & 1) {
        tmp___5 = (int )sizeof(int64_t );
      } else {
        tmp___5 = (int )sizeof(int32_t );
      }
      besiz = tmp___5;
      hdb->align = (unsigned int )(1 << (int )hdb->apow);
      hdb->fsiz = (256ULL + (unsigned long long )besiz * hdb->bnum) + (unsigned long long )fbpsiz;
      tmp___6 = tchdbpadsize(hdb, hdb->fsiz);
      hdb->fsiz += (unsigned long long )tmp___6;
      hdb->frec = hdb->fsiz;
      tchdbdumpmeta(hdb, hbuf);
      err = (_Bool)0;
      tmp___7 = tcwrite(fd, (void const   *)(hbuf), 256U);
      if (! tmp___7) {
        err = (_Bool)1;
      }
      memset((void *)(pbuf), 0, 8192U);
      psiz = hdb->fsiz - 256ULL;
      while (psiz > 0ULL) {
        if (psiz > 8192ULL) {
          tmp___8 = tcwrite(fd, (void const   *)(pbuf), 8192U);
          if (! tmp___8) {
            err = (_Bool)1;
          }
          psiz -= 8192ULL;
        } else {
          tmp___9 = tcwrite(fd, (void const   *)(pbuf), (unsigned int )psiz);
          if (! tmp___9) {
            err = (_Bool)1;
          }
          psiz = 0ULL;
        }
      }
      if (err) {
        tchdbsetecode(hdb, 14, "tchdb.c", 3391, "tchdbopenimpl");
        close(fd);
        return ((_Bool)0);
      }
      sbuf.st_size = (long )hdb->fsiz;
    }
  }
  tmp___10 = lseek(fd, 0L, 0);
  if (tmp___10 == -1L) {
    tchdbsetecode(hdb, 12, "tchdb.c", 3398, "tchdbopenimpl");
    close(fd);
    return ((_Bool)0);
  }
  tmp___11 = tcread(fd, (void *)(hbuf), 256U);
  if (! tmp___11) {
    tchdbsetecode(hdb, 13, "tchdb.c", 3403, "tchdbopenimpl");
    close(fd);
    return ((_Bool)0);
  }
  type = (int )hdb->type;
  tchdbloadmeta(hdb, (char const   *)(hbuf));
  if ((int )hdb->flags & 1) {
    tmp___15 = tchdbwalrestore(hdb, path);
    if (tmp___15) {
      tmp___12 = lseek(fd, 0L, 0);
      if (tmp___12 == -1L) {
        tchdbsetecode(hdb, 12, "tchdb.c", 3411, "tchdbopenimpl");
        close(fd);
        return ((_Bool)0);
      }
      tmp___13 = tcread(fd, (void *)(hbuf), 256U);
      if (! tmp___13) {
        tchdbsetecode(hdb, 13, "tchdb.c", 3416, "tchdbopenimpl");
        close(fd);
        return ((_Bool)0);
      }
      tchdbloadmeta(hdb, (char const   *)(hbuf));
      tmp___14 = tchdbwalremove(hdb, path);
      if (! tmp___14) {
        close(fd);
        return ((_Bool)0);
      }
    }
  }
  if ((int )hdb->opts & 1) {
    tmp___16 = (int )sizeof(int64_t );
  } else {
    tmp___16 = (int )sizeof(int32_t );
  }
  besiz___0 = tmp___16;
  msiz = (unsigned int )(256ULL + hdb->bnum * (unsigned long long )besiz___0);
  if (! (omode & 16)) {
    tmp___17 = strlen("ToKyO CaBiNeT");
    tmp___18 = memcmp((void const   *)(hbuf), (void const   *)"ToKyO CaBiNeT", tmp___17);
    if (tmp___18) {
      tchdbsetecode(hdb, 5, "tchdb.c", 3431, "tchdbopenimpl");
      close(fd);
      return ((_Bool)0);
    } else {
      if ((int )hdb->type != type) {
        tchdbsetecode(hdb, 5, "tchdb.c", 3431, "tchdbopenimpl");
        close(fd);
        return ((_Bool)0);
      } else {
        if (hdb->frec < (unsigned long long )(msiz + 64U)) {
          tchdbsetecode(hdb, 5, "tchdb.c", 3431, "tchdbopenimpl");
          close(fd);
          return ((_Bool)0);
        } else {
          if (hdb->frec > hdb->fsiz) {
            tchdbsetecode(hdb, 5, "tchdb.c", 3431, "tchdbopenimpl");
            close(fd);
            return ((_Bool)0);
          } else {
            if ((unsigned long long )sbuf.st_size < hdb->fsiz) {
              tchdbsetecode(hdb, 5, "tchdb.c", 3431, "tchdbopenimpl");
              close(fd);
              return ((_Bool)0);
            }
          }
        }
      }
    }
  }
  if ((int )hdb->opts & 2) {
    if (! _tc_deflate) {
      tchdbsetecode(hdb, 2, "tchdb.c", 3438, "tchdbopenimpl");
      close(fd);
      return ((_Bool)0);
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    if ((int )hdb->opts & 4) {
      if (! _tc_bzcompress) {
        tchdbsetecode(hdb, 2, "tchdb.c", 3438, "tchdbopenimpl");
        close(fd);
        return ((_Bool)0);
      } else {
        goto _L;
      }
    } else {
      _L: 
      if ((int )hdb->opts & 16) {
        if (! hdb->enc) {
          tchdbsetecode(hdb, 2, "tchdb.c", 3438, "tchdbopenimpl");
          close(fd);
          return ((_Bool)0);
        }
      }
    }
  }
  if (hdb->xmsiz > (unsigned long long )msiz) {
    tmp___19 = hdb->xmsiz;
  } else {
    tmp___19 = (unsigned long long )msiz;
  }
  xmsiz = (unsigned int )tmp___19;
  if (! (omode & 2)) {
    if ((unsigned long long )xmsiz > hdb->fsiz) {
      xmsiz = (unsigned int )hdb->fsiz;
    }
  }
  if (omode & 2) {
    tmp___20 = 2;
  } else {
    tmp___20 = 0;
  }
  tmp___21 = mmap((void *)0, xmsiz, 1 | tmp___20, 1, fd, 0L);
  map = tmp___21;
  if ((unsigned int )map == (unsigned int )((void *)-1)) {
    tchdbsetecode(hdb, 15, "tchdb.c", 3447, "tchdbopenimpl");
    close(fd);
    return ((_Bool)0);
  }
  hdb->fbpmax = 1 << (int )hdb->fpow;
  if (omode & 2) {
    while (1) {
      tmp___22 = malloc((unsigned int )((hdb->fbpmax * 2) * (int )sizeof(HDBFB )));
      hdb->fbpool = tmp___22;
      if (! tmp___22) {
        tcmyfatal("out of memory");
      }
      break;
    }
  } else {
    hdb->fbpool = (void *)0;
  }
  hdb->fbpnum = 0;
  hdb->fbpmis = 0;
  hdb->async = (_Bool)0;
  hdb->drpool = (TCXSTR *)((void *)0);
  hdb->drpdef = (TCXSTR *)((void *)0);
  hdb->drpoff = 0ULL;
  if (hdb->rcnum > 0U) {
    tmp___23 = tcmdbnew2(hdb->rcnum * 2U + 1U);
    hdb->recc = tmp___23;
  } else {
    hdb->recc = (TCMDB *)((void *)0);
  }
  hdb->path = tcstrdup((void const   *)path);
  hdb->fd = fd;
  hdb->omode = (unsigned int )omode;
  hdb->dfcur = hdb->frec;
  hdb->iter = 0ULL;
  hdb->map = (char *)map;
  hdb->msiz = (unsigned long long )msiz;
  hdb->xfsiz = 0ULL;
  if ((int )hdb->opts & 1) {
    hdb->ba32 = (uint32_t *)((void *)0);
    hdb->ba64 = (uint64_t *)((char *)map + 256);
  } else {
    hdb->ba32 = (uint32_t *)((char *)map + 256);
    hdb->ba64 = (uint64_t *)((void *)0);
  }
  hdb->align = (unsigned int )(1 << (int )hdb->apow);
  tmp___24 = tclmax((long )hdb->align, 48L);
  tmp___25 = tclmin(tmp___24, 8192L);
  hdb->runit = (unsigned int )tmp___25;
  if ((int )hdb->opts & 2) {
    tmp___26 = 1;
  } else {
    if ((int )hdb->opts & 4) {
      tmp___26 = 1;
    } else {
      if ((int )hdb->opts & 8) {
        tmp___26 = 1;
      } else {
        if ((int )hdb->opts & 16) {
          tmp___26 = 1;
        } else {
          tmp___26 = 0;
        }
      }
    }
  }
  hdb->zmode = (_Bool )tmp___26;
  hdb->ecode = 0;
  hdb->fatal = (_Bool)0;
  hdb->inode = (unsigned long long )sbuf.st_ino;
  hdb->mtime = sbuf.st_mtim.tv_sec;
  hdb->dfcnt = 0U;
  hdb->tran = (_Bool)0;
  hdb->walfd = -1;
  hdb->walend = 0ULL;
  if (hdb->omode & 2U) {
    err___0 = (_Bool)0;
    if (! ((int )hdb->flags & 1)) {
      tmp___27 = tchdbloadfbp(hdb);
      if (! tmp___27) {
        err___0 = (_Bool)1;
      }
    }
    memset((void *)(hbuf), 0, 2U);
    tmp___28 = tchdbseekwrite(hdb, (long )hdb->msiz, (void const   *)(hbuf), 2U);
    if (! tmp___28) {
      err___0 = (_Bool)1;
    }
    if (err___0) {
      while (1) {
        free((void *)hdb->path);
        break;
      }
      while (1) {
        free(hdb->fbpool);
        break;
      }
      munmap((void *)hdb->map, xmsiz);
      close(fd);
      hdb->fd = -1;
      return ((_Bool)0);
    }
    tchdbsetflag(hdb, 1, (_Bool)1);
  }
  return ((_Bool)1);
}
}
static _Bool tchdbcloseimpl(TCHDB *hdb ) 
{ _Bool err ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  size_t xmsiz ;
  uint64_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;

  {
  err = (_Bool)0;
  if (hdb->recc) {
    tcmdbdel(hdb->recc);
    hdb->recc = (TCMDB *)((void *)0);
  }
  if (hdb->omode & 2U) {
    tmp = tchdbflushdrp(hdb);
    if (! tmp) {
      err = (_Bool)1;
    }
    if (hdb->tran) {
      hdb->fbpnum = 0;
    }
    tmp___0 = tchdbsavefbp(hdb);
    if (! tmp___0) {
      err = (_Bool)1;
    }
    while (1) {
      free(hdb->fbpool);
      break;
    }
    tchdbsetflag(hdb, 1, (_Bool)0);
  }
  if (hdb->omode & 2U) {
    tmp___1 = tchdbmemsync(hdb, (_Bool)0);
    if (! tmp___1) {
      err = (_Bool)1;
    }
  }
  if (hdb->xmsiz > hdb->msiz) {
    tmp___2 = hdb->xmsiz;
  } else {
    tmp___2 = hdb->msiz;
  }
  xmsiz = (unsigned int )tmp___2;
  if (! (hdb->omode & 2U)) {
    if ((unsigned long long )xmsiz > hdb->fsiz) {
      xmsiz = (unsigned int )hdb->fsiz;
    }
  }
  tmp___3 = munmap((void *)hdb->map, xmsiz);
  if (tmp___3 == -1) {
    tchdbsetecode(hdb, 15, "tchdb.c", 3531, "tchdbcloseimpl");
    err = (_Bool)1;
  }
  hdb->map = (char *)((void *)0);
  if (hdb->omode & 2U) {
    tmp___4 = ftruncate(hdb->fd, (long )hdb->fsiz);
    if (tmp___4 == -1) {
      tchdbsetecode(hdb, 9, "tchdb.c", 3536, "tchdbcloseimpl");
      err = (_Bool)1;
    }
  }
  if (hdb->tran) {
    tmp___5 = tchdbwalrestore(hdb, (char const   *)hdb->path);
    if (! tmp___5) {
      err = (_Bool)1;
    }
    hdb->tran = (_Bool)0;
  }
  if (hdb->walfd >= 0) {
    tmp___6 = close(hdb->walfd);
    if (tmp___6 == -1) {
      tchdbsetecode(hdb, 8, "tchdb.c", 3545, "tchdbcloseimpl");
      err = (_Bool)1;
    }
    if (! hdb->fatal) {
      tmp___7 = tchdbwalremove(hdb, (char const   *)hdb->path);
      if (! tmp___7) {
        err = (_Bool)1;
      }
    }
  }
  tmp___8 = close(hdb->fd);
  if (tmp___8 == -1) {
    tchdbsetecode(hdb, 8, "tchdb.c", 3551, "tchdbcloseimpl");
    err = (_Bool)1;
  }
  while (1) {
    free((void *)hdb->path);
    break;
  }
  hdb->path = (char *)((void *)0);
  hdb->fd = -1;
  return ((_Bool )(! err));
}
}
static _Bool tchdbputimpl(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                          uint8_t hash , char const   *vbuf , int vsiz , int dmode ) 
{ off_t off ;
  off_t tmp ;
  off_t entoff ;
  TCHREC rec ;
  char rbuf[8192] ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool rv ;
  int nvsiz ;
  char *nvbuf ;
  HDBPDPROCOP *procptr ;
  _Bool tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  _Bool tmp___8 ;
  int lnum ;
  _Bool tmp___9 ;
  double dnum ;
  _Bool tmp___10 ;
  void *tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  int tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  uint64_t llnum ;

  {
  if (hdb->recc) {
    tcmdbout(hdb->recc, (void const   *)kbuf, ksiz);
  }
  tmp = tchdbgetbucket(hdb, bidx);
  off = tmp;
  entoff = 0L;
  while (off > 0L) {
    rec.off = (unsigned long long )off;
    tmp___0 = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp___0) {
      return ((_Bool)0);
    }
    if ((int )hash > (int )rec.hash) {
      off = (long )rec.left;
      entoff = (long )(rec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t )));
    } else {
      if ((int )hash < (int )rec.hash) {
        off = (long )rec.right;
        if (hdb->ba64) {
          tmp___1 = (int )sizeof(uint64_t );
        } else {
          tmp___1 = (int )sizeof(uint32_t );
        }
        entoff = (long )((rec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t ))) + (unsigned long long )tmp___1);
      } else {
        if (! rec.kbuf) {
          tmp___2 = tchdbreadrecbody(hdb, & rec);
          if (! tmp___2) {
            return ((_Bool)0);
          }
        }
        tmp___3 = tcreckeycmp(kbuf, ksiz, rec.kbuf, (int )rec.ksiz);
        kcmp = tmp___3;
        if (kcmp > 0) {
          off = (long )rec.left;
          while (1) {
            free((void *)rec.bbuf);
            break;
          }
          rec.kbuf = (char const   *)((void *)0);
          rec.bbuf = (char *)((void *)0);
          entoff = (long )(rec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t )));
        } else {
          if (kcmp < 0) {
            off = (long )rec.right;
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            rec.kbuf = (char const   *)((void *)0);
            rec.bbuf = (char *)((void *)0);
            if (hdb->ba64) {
              tmp___4 = (int )sizeof(uint64_t );
            } else {
              tmp___4 = (int )sizeof(uint32_t );
            }
            entoff = (long )((rec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t ))) + (unsigned long long )tmp___4);
          } else {
            switch (dmode) {
            case 1: 
            tchdbsetecode(hdb, 21, "tchdb.c", 3612, "tchdbputimpl");
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            return ((_Bool)0);
            case 2: 
            if (vsiz < 1) {
              while (1) {
                free((void *)rec.bbuf);
                break;
              }
              return ((_Bool)1);
            }
            if (! rec.vbuf) {
              tmp___5 = tchdbreadrecbody(hdb, & rec);
              if (! tmp___5) {
                while (1) {
                  free((void *)rec.bbuf);
                  break;
                }
                return ((_Bool)0);
              }
            }
            nvsiz = (int )(rec.vsiz + (unsigned int )vsiz);
            if (rec.bbuf) {
              while (1) {
                tmp___6 = realloc((void *)rec.bbuf, rec.ksiz + (unsigned int )nvsiz);
                rec.bbuf = (char *)tmp___6;
                if (! rec.bbuf) {
                  tcmyfatal("out of memory");
                }
                break;
              }
              memcpy((void * __restrict  )((rec.bbuf + rec.ksiz) + rec.vsiz), (void const   * __restrict  )vbuf,
                     (unsigned int )vsiz);
              rec.kbuf = (char const   *)rec.bbuf;
              rec.vbuf = rec.kbuf + rec.ksiz;
              rec.vsiz = (unsigned int )nvsiz;
            } else {
              while (1) {
                tmp___7 = malloc((unsigned int )(nvsiz + 1));
                rec.bbuf = (char *)tmp___7;
                if (! rec.bbuf) {
                  tcmyfatal("out of memory");
                }
                break;
              }
              memcpy((void * __restrict  )rec.bbuf, (void const   * __restrict  )rec.vbuf,
                     rec.vsiz);
              memcpy((void * __restrict  )(rec.bbuf + rec.vsiz), (void const   * __restrict  )vbuf,
                     (unsigned int )vsiz);
              rec.vbuf = (char const   *)rec.bbuf;
              rec.vsiz = (unsigned int )nvsiz;
            }
            rv = tchdbwriterec(hdb, & rec, bidx, entoff);
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            return (rv);
            case 3: 
            if (rec.vsiz != (unsigned int )((int )sizeof(int ))) {
              tchdbsetecode(hdb, 21, "tchdb.c", 3643, "tchdbputimpl");
              while (1) {
                free((void *)rec.bbuf);
                break;
              }
              return ((_Bool)0);
            }
            if (! rec.vbuf) {
              tmp___8 = tchdbreadrecbody(hdb, & rec);
              if (! tmp___8) {
                while (1) {
                  free((void *)rec.bbuf);
                  break;
                }
                return ((_Bool)0);
              }
            }
            memcpy((void * __restrict  )(& lnum), (void const   * __restrict  )rec.vbuf,
                   (unsigned int )((int )sizeof(lnum)));
            if (*((int *)vbuf) == 0) {
              while (1) {
                free((void *)rec.bbuf);
                break;
              }
              *((int *)vbuf) = lnum;
              return ((_Bool)1);
            }
            lnum += *((int *)vbuf);
            rec.vbuf = (char const   *)((char *)(& lnum));
            *((int *)vbuf) = lnum;
            rv = tchdbwriterec(hdb, & rec, bidx, entoff);
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            return (rv);
            case 4: 
            if (rec.vsiz != (unsigned int )((int )sizeof(double ))) {
              tchdbsetecode(hdb, 21, "tchdb.c", 3666, "tchdbputimpl");
              while (1) {
                free((void *)rec.bbuf);
                break;
              }
              return ((_Bool)0);
            }
            if (! rec.vbuf) {
              tmp___9 = tchdbreadrecbody(hdb, & rec);
              if (! tmp___9) {
                while (1) {
                  free((void *)rec.bbuf);
                  break;
                }
                return ((_Bool)0);
              }
            }
            memcpy((void * __restrict  )(& dnum), (void const   * __restrict  )rec.vbuf,
                   (unsigned int )((int )sizeof(dnum)));
            if (*((double *)vbuf) == 0.0) {
              while (1) {
                free((void *)rec.bbuf);
                break;
              }
              *((double *)vbuf) = dnum;
              return ((_Bool)1);
            }
            dnum += *((double *)vbuf);
            rec.vbuf = (char const   *)((char *)(& dnum));
            *((double *)vbuf) = dnum;
            rv = tchdbwriterec(hdb, & rec, bidx, entoff);
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            return (rv);
            case 5: 
            if (! rec.vbuf) {
              tmp___10 = tchdbreadrecbody(hdb, & rec);
              if (! tmp___10) {
                while (1) {
                  free((void *)rec.bbuf);
                  break;
                }
                return ((_Bool)0);
              }
            }
            procptr = *((HDBPDPROCOP **)((char *)kbuf - (int )sizeof(procptr)));
            tmp___11 = (*(procptr->proc))((void const   *)rec.vbuf, (int )rec.vsiz,
                                          & nvsiz, procptr->op);
            nvbuf = (char *)tmp___11;
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            if ((unsigned int )nvbuf == (unsigned int )((void *)-1)) {
              tmp___12 = tchdbremoverec(hdb, & rec, rbuf, bidx, entoff);
              return (tmp___12);
            } else {
              if (nvbuf) {
                rec.kbuf = kbuf;
                rec.ksiz = (unsigned int )ksiz;
                rec.vbuf = (char const   *)nvbuf;
                rec.vsiz = (unsigned int )nvsiz;
                rv = tchdbwriterec(hdb, & rec, bidx, entoff);
                while (1) {
                  free((void *)nvbuf);
                  break;
                }
                return (rv);
              }
            }
            tchdbsetecode(hdb, 21, "tchdb.c", 3706, "tchdbputimpl");
            return ((_Bool)0);
            default: ;
            break;
            }
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            rec.ksiz = (unsigned int )ksiz;
            rec.vsiz = (unsigned int )vsiz;
            rec.kbuf = kbuf;
            rec.vbuf = vbuf;
            tmp___13 = tchdbwriterec(hdb, & rec, bidx, entoff);
            return (tmp___13);
          }
        }
      }
    }
  }
  if (! vbuf) {
    tchdbsetecode(hdb, 22, "tchdb.c", 3721, "tchdbputimpl");
    return ((_Bool)0);
  }
  if (hdb->mmtx) {
    tmp___14 = tchdblockdb(hdb);
    tmp___15 = (int )tmp___14;
  } else {
    tmp___15 = 1;
  }
  if (! tmp___15) {
    return ((_Bool)0);
  }
  rec.rsiz = (unsigned int )((32 + ksiz) + vsiz);
  tmp___16 = tchdbfbpsearch(hdb, & rec);
  if (! tmp___16) {
    if (hdb->mmtx) {
      tchdbunlockdb(hdb);
    }
    return ((_Bool)0);
  }
  rec.hash = hash;
  rec.left = 0ULL;
  rec.right = 0ULL;
  rec.ksiz = (unsigned int )ksiz;
  rec.vsiz = (unsigned int )vsiz;
  rec.psiz = (unsigned short)0;
  rec.kbuf = kbuf;
  rec.vbuf = vbuf;
  tmp___17 = tchdbwriterec(hdb, & rec, bidx, entoff);
  if (! tmp___17) {
    if (hdb->mmtx) {
      tchdbunlockdb(hdb);
    }
    return ((_Bool)0);
  }
  (hdb->rnum) ++;
  llnum = hdb->rnum;
  llnum = llnum;
  memcpy((void * __restrict  )(hdb->map + 48), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  if (hdb->mmtx) {
    tchdbunlockdb(hdb);
  }
  return ((_Bool)1);
}
}
static void tchdbdrpappend(TCHDB *hdb , char const   *kbuf , int ksiz , char const   *vbuf ,
                           int vsiz , uint8_t hash ) 
{ char rbuf[8192] ;
  char *wp ;
  char *tmp ;
  char *tmp___0 ;
  uint16_t snum ;
  char *pwp ;
  int step ;
  int _TC_num ;
  int _TC_rem ;
  int _TC_num___0 ;
  int _TC_rem___0 ;
  int32_t hsiz ;
  int32_t rsiz ;
  uint16_t psiz ;
  int32_t tmp___1 ;
  TCXSTR *drpool ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___2 ;
  void *tmp___3 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___4 ;
  void *tmp___5 ;
  int TC_mysize___1 ;
  int TC_nsize___1 ;
  char *tmp___6 ;
  void *tmp___7 ;
  char *pbuf ;
  unsigned int __lengthofpbuf ;
  void *tmp___8 ;
  int TC_mysize___2 ;
  int TC_nsize___2 ;
  char *tmp___9 ;
  void *tmp___10 ;

  {
  while (1) {
    break;
  }
  wp = rbuf;
  tmp = wp;
  wp ++;
  *((uint8_t *)tmp) = (unsigned char)200;
  tmp___0 = wp;
  wp ++;
  *((uint8_t *)tmp___0) = hash;
  if (hdb->ba64) {
    memset((void *)wp, 0, (unsigned int )((int )sizeof(uint64_t ) * 2));
    wp += (int )sizeof(uint64_t ) * 2;
  } else {
    memset((void *)wp, 0, (unsigned int )((int )sizeof(uint32_t ) * 2));
    wp += (int )sizeof(uint32_t ) * 2;
  }
  pwp = wp;
  wp += (int )sizeof(snum);
  while (1) {
    _TC_num = ksiz;
    if (_TC_num == 0) {
      *((signed char *)wp + 0) = (signed char)0;
      step = 1;
    } else {
      step = 0;
      while (_TC_num > 0) {
        _TC_rem = _TC_num & 127;
        _TC_num >>= 7;
        if (_TC_num > 0) {
          *((signed char *)wp + step) = (signed char )(- _TC_rem - 1);
        } else {
          *((signed char *)wp + step) = (signed char )_TC_rem;
        }
        step ++;
      }
    }
    break;
  }
  wp += step;
  while (1) {
    _TC_num___0 = vsiz;
    if (_TC_num___0 == 0) {
      *((signed char *)wp + 0) = (signed char)0;
      step = 1;
    } else {
      step = 0;
      while (_TC_num___0 > 0) {
        _TC_rem___0 = _TC_num___0 & 127;
        _TC_num___0 >>= 7;
        if (_TC_num___0 > 0) {
          *((signed char *)wp + step) = (signed char )(- _TC_rem___0 - 1);
        } else {
          *((signed char *)wp + step) = (signed char )_TC_rem___0;
        }
        step ++;
      }
    }
    break;
  }
  wp += step;
  hsiz = wp - rbuf;
  rsiz = (hsiz + ksiz) + vsiz;
  tmp___1 = tchdbpadsize(hdb, hdb->fsiz + (unsigned long long )rsiz);
  psiz = (unsigned short )tmp___1;
  hdb->fsiz += (unsigned long long )(rsiz + (int )psiz);
  snum = psiz;
  memcpy((void * __restrict  )pwp, (void const   * __restrict  )(& snum), (unsigned int )((int )sizeof(snum)));
  drpool = hdb->drpool;
  while (1) {
    TC_mysize = hsiz;
    TC_nsize = (drpool->size + TC_mysize) + 1;
    if (drpool->asize < TC_nsize) {
      while (drpool->asize < TC_nsize) {
        drpool->asize *= 2;
        if (drpool->asize < TC_nsize) {
          drpool->asize = TC_nsize;
        }
      }
      while (1) {
        tmp___3 = realloc((void *)drpool->ptr, (unsigned int )drpool->asize);
        tmp___2 = (char *)tmp___3;
        drpool->ptr = tmp___2;
        if (! tmp___2) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    memcpy((void * __restrict  )(drpool->ptr + drpool->size), (void const   * __restrict  )(rbuf),
           (unsigned int )TC_mysize);
    drpool->size += TC_mysize;
    *(drpool->ptr + drpool->size) = (char )'\000';
    break;
  }
  while (1) {
    TC_mysize___0 = ksiz;
    TC_nsize___0 = (drpool->size + TC_mysize___0) + 1;
    if (drpool->asize < TC_nsize___0) {
      while (drpool->asize < TC_nsize___0) {
        drpool->asize *= 2;
        if (drpool->asize < TC_nsize___0) {
          drpool->asize = TC_nsize___0;
        }
      }
      while (1) {
        tmp___5 = realloc((void *)drpool->ptr, (unsigned int )drpool->asize);
        tmp___4 = (char *)tmp___5;
        drpool->ptr = tmp___4;
        if (! tmp___4) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    memcpy((void * __restrict  )(drpool->ptr + drpool->size), (void const   * __restrict  )kbuf,
           (unsigned int )TC_mysize___0);
    drpool->size += TC_mysize___0;
    *(drpool->ptr + drpool->size) = (char )'\000';
    break;
  }
  while (1) {
    TC_mysize___1 = vsiz;
    TC_nsize___1 = (drpool->size + TC_mysize___1) + 1;
    if (drpool->asize < TC_nsize___1) {
      while (drpool->asize < TC_nsize___1) {
        drpool->asize *= 2;
        if (drpool->asize < TC_nsize___1) {
          drpool->asize = TC_nsize___1;
        }
      }
      while (1) {
        tmp___7 = realloc((void *)drpool->ptr, (unsigned int )drpool->asize);
        tmp___6 = (char *)tmp___7;
        drpool->ptr = tmp___6;
        if (! tmp___6) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    memcpy((void * __restrict  )(drpool->ptr + drpool->size), (void const   * __restrict  )vbuf,
           (unsigned int )TC_mysize___1);
    drpool->size += TC_mysize___1;
    *(drpool->ptr + drpool->size) = (char )'\000';
    break;
  }
  if ((int )psiz > 0) {
    __lengthofpbuf = (unsigned int )psiz;
    tmp___8 = __builtin_alloca(sizeof(*pbuf) * __lengthofpbuf);
    pbuf = (char *)tmp___8;
    memset((void *)pbuf, 0, (unsigned int )psiz);
    while (1) {
      TC_mysize___2 = (int )psiz;
      TC_nsize___2 = (drpool->size + TC_mysize___2) + 1;
      if (drpool->asize < TC_nsize___2) {
        while (drpool->asize < TC_nsize___2) {
          drpool->asize *= 2;
          if (drpool->asize < TC_nsize___2) {
            drpool->asize = TC_nsize___2;
          }
        }
        while (1) {
          tmp___10 = realloc((void *)drpool->ptr, (unsigned int )drpool->asize);
          tmp___9 = (char *)tmp___10;
          drpool->ptr = tmp___9;
          if (! tmp___9) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(drpool->ptr + drpool->size), (void const   * __restrict  )pbuf,
             (unsigned int )TC_mysize___2);
      drpool->size += TC_mysize___2;
      *(drpool->ptr + drpool->size) = (char )'\000';
      break;
    }
  }
  return;
}
}
static _Bool tchdbputasyncimpl(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                               uint8_t hash , char const   *vbuf , int vsiz ) 
{ off_t off ;
  off_t tmp ;
  off_t entoff ;
  TCHREC rec ;
  char rbuf[8192] ;
  TCXSTR *drpdef ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___0 ;
  void *tmp___1 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int TC_mysize___1 ;
  int TC_nsize___1 ;
  char *tmp___4 ;
  void *tmp___5 ;
  int TC_mysize___2 ;
  int TC_nsize___2 ;
  char *tmp___6 ;
  void *tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;
  TCXSTR *drpdef___0 ;
  int TC_mysize___3 ;
  int TC_nsize___3 ;
  char *tmp___11 ;
  void *tmp___12 ;
  int TC_mysize___4 ;
  int TC_nsize___4 ;
  char *tmp___13 ;
  void *tmp___14 ;
  int TC_mysize___5 ;
  int TC_nsize___5 ;
  char *tmp___15 ;
  void *tmp___16 ;
  int TC_mysize___6 ;
  int TC_nsize___6 ;
  char *tmp___17 ;
  void *tmp___18 ;
  _Bool tmp___19 ;
  uint64_t llnum ;
  _Bool tmp___20 ;
  uint32_t lnum ;
  _Bool tmp___21 ;
  _Bool tmp___22 ;

  {
  if (hdb->recc) {
    tcmdbout(hdb->recc, (void const   *)kbuf, ksiz);
  }
  if (! hdb->drpool) {
    hdb->drpool = tcxstrnew3(67584);
    hdb->drpdef = tcxstrnew3(65536);
    hdb->drpoff = hdb->fsiz;
  }
  tmp = tchdbgetbucket(hdb, bidx);
  off = tmp;
  entoff = 0L;
  while (off > 0L) {
    if ((unsigned long long )off >= hdb->drpoff - (unsigned long long )hdb->runit) {
      while (1) {
        break;
      }
      drpdef = hdb->drpdef;
      while (1) {
        TC_mysize = (int )sizeof(ksiz);
        TC_nsize = (drpdef->size + TC_mysize) + 1;
        if (drpdef->asize < TC_nsize) {
          while (drpdef->asize < TC_nsize) {
            drpdef->asize *= 2;
            if (drpdef->asize < TC_nsize) {
              drpdef->asize = TC_nsize;
            }
          }
          while (1) {
            tmp___1 = realloc((void *)drpdef->ptr, (unsigned int )drpdef->asize);
            tmp___0 = (char *)tmp___1;
            drpdef->ptr = tmp___0;
            if (! tmp___0) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(drpdef->ptr + drpdef->size), (void const   * __restrict  )(& ksiz),
               (unsigned int )TC_mysize);
        drpdef->size += TC_mysize;
        *(drpdef->ptr + drpdef->size) = (char )'\000';
        break;
      }
      while (1) {
        TC_mysize___0 = (int )sizeof(vsiz);
        TC_nsize___0 = (drpdef->size + TC_mysize___0) + 1;
        if (drpdef->asize < TC_nsize___0) {
          while (drpdef->asize < TC_nsize___0) {
            drpdef->asize *= 2;
            if (drpdef->asize < TC_nsize___0) {
              drpdef->asize = TC_nsize___0;
            }
          }
          while (1) {
            tmp___3 = realloc((void *)drpdef->ptr, (unsigned int )drpdef->asize);
            tmp___2 = (char *)tmp___3;
            drpdef->ptr = tmp___2;
            if (! tmp___2) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(drpdef->ptr + drpdef->size), (void const   * __restrict  )(& vsiz),
               (unsigned int )TC_mysize___0);
        drpdef->size += TC_mysize___0;
        *(drpdef->ptr + drpdef->size) = (char )'\000';
        break;
      }
      while (1) {
        TC_mysize___1 = ksiz;
        TC_nsize___1 = (drpdef->size + TC_mysize___1) + 1;
        if (drpdef->asize < TC_nsize___1) {
          while (drpdef->asize < TC_nsize___1) {
            drpdef->asize *= 2;
            if (drpdef->asize < TC_nsize___1) {
              drpdef->asize = TC_nsize___1;
            }
          }
          while (1) {
            tmp___5 = realloc((void *)drpdef->ptr, (unsigned int )drpdef->asize);
            tmp___4 = (char *)tmp___5;
            drpdef->ptr = tmp___4;
            if (! tmp___4) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(drpdef->ptr + drpdef->size), (void const   * __restrict  )kbuf,
               (unsigned int )TC_mysize___1);
        drpdef->size += TC_mysize___1;
        *(drpdef->ptr + drpdef->size) = (char )'\000';
        break;
      }
      while (1) {
        TC_mysize___2 = vsiz;
        TC_nsize___2 = (drpdef->size + TC_mysize___2) + 1;
        if (drpdef->asize < TC_nsize___2) {
          while (drpdef->asize < TC_nsize___2) {
            drpdef->asize *= 2;
            if (drpdef->asize < TC_nsize___2) {
              drpdef->asize = TC_nsize___2;
            }
          }
          while (1) {
            tmp___7 = realloc((void *)drpdef->ptr, (unsigned int )drpdef->asize);
            tmp___6 = (char *)tmp___7;
            drpdef->ptr = tmp___6;
            if (! tmp___6) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(drpdef->ptr + drpdef->size), (void const   * __restrict  )vbuf,
               (unsigned int )TC_mysize___2);
        drpdef->size += TC_mysize___2;
        *(drpdef->ptr + drpdef->size) = (char )'\000';
        break;
      }
      if ((hdb->drpdef)->size > 65536) {
        tmp___8 = tchdbflushdrp(hdb);
        if (! tmp___8) {
          return ((_Bool)0);
        }
      }
      return ((_Bool)1);
    }
    rec.off = (unsigned long long )off;
    tmp___9 = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp___9) {
      return ((_Bool)0);
    }
    if ((int )hash > (int )rec.hash) {
      off = (long )rec.left;
      entoff = (long )(rec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t )));
    } else {
      if ((int )hash < (int )rec.hash) {
        off = (long )rec.right;
        if (hdb->ba64) {
          tmp___10 = (int )sizeof(uint64_t );
        } else {
          tmp___10 = (int )sizeof(uint32_t );
        }
        entoff = (long )((rec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t ))) + (unsigned long long )tmp___10);
      } else {
        while (1) {
          break;
        }
        drpdef___0 = hdb->drpdef;
        while (1) {
          TC_mysize___3 = (int )sizeof(ksiz);
          TC_nsize___3 = (drpdef___0->size + TC_mysize___3) + 1;
          if (drpdef___0->asize < TC_nsize___3) {
            while (drpdef___0->asize < TC_nsize___3) {
              drpdef___0->asize *= 2;
              if (drpdef___0->asize < TC_nsize___3) {
                drpdef___0->asize = TC_nsize___3;
              }
            }
            while (1) {
              tmp___12 = realloc((void *)drpdef___0->ptr, (unsigned int )drpdef___0->asize);
              tmp___11 = (char *)tmp___12;
              drpdef___0->ptr = tmp___11;
              if (! tmp___11) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(drpdef___0->ptr + drpdef___0->size), (void const   * __restrict  )(& ksiz),
                 (unsigned int )TC_mysize___3);
          drpdef___0->size += TC_mysize___3;
          *(drpdef___0->ptr + drpdef___0->size) = (char )'\000';
          break;
        }
        while (1) {
          TC_mysize___4 = (int )sizeof(vsiz);
          TC_nsize___4 = (drpdef___0->size + TC_mysize___4) + 1;
          if (drpdef___0->asize < TC_nsize___4) {
            while (drpdef___0->asize < TC_nsize___4) {
              drpdef___0->asize *= 2;
              if (drpdef___0->asize < TC_nsize___4) {
                drpdef___0->asize = TC_nsize___4;
              }
            }
            while (1) {
              tmp___14 = realloc((void *)drpdef___0->ptr, (unsigned int )drpdef___0->asize);
              tmp___13 = (char *)tmp___14;
              drpdef___0->ptr = tmp___13;
              if (! tmp___13) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(drpdef___0->ptr + drpdef___0->size), (void const   * __restrict  )(& vsiz),
                 (unsigned int )TC_mysize___4);
          drpdef___0->size += TC_mysize___4;
          *(drpdef___0->ptr + drpdef___0->size) = (char )'\000';
          break;
        }
        while (1) {
          TC_mysize___5 = ksiz;
          TC_nsize___5 = (drpdef___0->size + TC_mysize___5) + 1;
          if (drpdef___0->asize < TC_nsize___5) {
            while (drpdef___0->asize < TC_nsize___5) {
              drpdef___0->asize *= 2;
              if (drpdef___0->asize < TC_nsize___5) {
                drpdef___0->asize = TC_nsize___5;
              }
            }
            while (1) {
              tmp___16 = realloc((void *)drpdef___0->ptr, (unsigned int )drpdef___0->asize);
              tmp___15 = (char *)tmp___16;
              drpdef___0->ptr = tmp___15;
              if (! tmp___15) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(drpdef___0->ptr + drpdef___0->size), (void const   * __restrict  )kbuf,
                 (unsigned int )TC_mysize___5);
          drpdef___0->size += TC_mysize___5;
          *(drpdef___0->ptr + drpdef___0->size) = (char )'\000';
          break;
        }
        while (1) {
          TC_mysize___6 = vsiz;
          TC_nsize___6 = (drpdef___0->size + TC_mysize___6) + 1;
          if (drpdef___0->asize < TC_nsize___6) {
            while (drpdef___0->asize < TC_nsize___6) {
              drpdef___0->asize *= 2;
              if (drpdef___0->asize < TC_nsize___6) {
                drpdef___0->asize = TC_nsize___6;
              }
            }
            while (1) {
              tmp___18 = realloc((void *)drpdef___0->ptr, (unsigned int )drpdef___0->asize);
              tmp___17 = (char *)tmp___18;
              drpdef___0->ptr = tmp___17;
              if (! tmp___17) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(drpdef___0->ptr + drpdef___0->size), (void const   * __restrict  )vbuf,
                 (unsigned int )TC_mysize___6);
          drpdef___0->size += TC_mysize___6;
          *(drpdef___0->ptr + drpdef___0->size) = (char )'\000';
          break;
        }
        if ((hdb->drpdef)->size > 65536) {
          tmp___19 = tchdbflushdrp(hdb);
          if (! tmp___19) {
            return ((_Bool)0);
          }
        }
        return ((_Bool)1);
      }
    }
  }
  if (entoff > 0L) {
    if (hdb->ba64) {
      llnum = hdb->fsiz >> (int )hdb->apow;
      llnum = llnum;
      tmp___20 = tchdbseekwrite(hdb, entoff, (void const   *)(& llnum), (unsigned int )((int )sizeof(uint64_t )));
      if (! tmp___20) {
        return ((_Bool)0);
      }
    } else {
      lnum = (unsigned int )(hdb->fsiz >> (int )hdb->apow);
      lnum = lnum;
      tmp___21 = tchdbseekwrite(hdb, entoff, (void const   *)(& lnum), (unsigned int )((int )sizeof(uint32_t )));
      if (! tmp___21) {
        return ((_Bool)0);
      }
    }
  } else {
    tchdbsetbucket(hdb, bidx, hdb->fsiz);
  }
  tchdbdrpappend(hdb, kbuf, ksiz, vbuf, vsiz, hash);
  (hdb->rnum) ++;
  if ((hdb->drpool)->size > 65536) {
    tmp___22 = tchdbflushdrp(hdb);
    if (! tmp___22) {
      return ((_Bool)0);
    }
  }
  return ((_Bool)1);
}
}
static _Bool tchdboutimpl(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                          uint8_t hash ) 
{ off_t off ;
  off_t tmp ;
  off_t entoff ;
  TCHREC rec ;
  char rbuf[8192] ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  int kcmp ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;

  {
  if (hdb->recc) {
    tcmdbout(hdb->recc, (void const   *)kbuf, ksiz);
  }
  tmp = tchdbgetbucket(hdb, bidx);
  off = tmp;
  entoff = 0L;
  while (off > 0L) {
    rec.off = (unsigned long long )off;
    tmp___0 = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp___0) {
      return ((_Bool)0);
    }
    if ((int )hash > (int )rec.hash) {
      off = (long )rec.left;
      entoff = (long )(rec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t )));
    } else {
      if ((int )hash < (int )rec.hash) {
        off = (long )rec.right;
        if (hdb->ba64) {
          tmp___1 = (int )sizeof(uint64_t );
        } else {
          tmp___1 = (int )sizeof(uint32_t );
        }
        entoff = (long )((rec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t ))) + (unsigned long long )tmp___1);
      } else {
        if (! rec.kbuf) {
          tmp___2 = tchdbreadrecbody(hdb, & rec);
          if (! tmp___2) {
            return ((_Bool)0);
          }
        }
        tmp___3 = tcreckeycmp(kbuf, ksiz, rec.kbuf, (int )rec.ksiz);
        kcmp = tmp___3;
        if (kcmp > 0) {
          off = (long )rec.left;
          while (1) {
            free((void *)rec.bbuf);
            break;
          }
          rec.kbuf = (char const   *)((void *)0);
          rec.bbuf = (char *)((void *)0);
          entoff = (long )(rec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t )));
        } else {
          if (kcmp < 0) {
            off = (long )rec.right;
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            rec.kbuf = (char const   *)((void *)0);
            rec.bbuf = (char *)((void *)0);
            if (hdb->ba64) {
              tmp___4 = (int )sizeof(uint64_t );
            } else {
              tmp___4 = (int )sizeof(uint32_t );
            }
            entoff = (long )((rec.off + (unsigned long long )((int )sizeof(uint8_t ) + (int )sizeof(uint8_t ))) + (unsigned long long )tmp___4);
          } else {
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            rec.bbuf = (char *)((void *)0);
            tmp___5 = tchdbremoverec(hdb, & rec, rbuf, bidx, entoff);
            return (tmp___5);
          }
        }
      }
    }
  }
  tchdbsetecode(hdb, 22, "tchdb.c", 3919, "tchdboutimpl");
  return ((_Bool)0);
}
}
static char *tchdbgetimpl(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                          uint8_t hash , int *sp ) 
{ int tvsiz ;
  char *tvbuf ;
  void *tmp ;
  off_t off ;
  off_t tmp___0 ;
  TCHREC rec ;
  char rbuf[8192] ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int kcmp ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int zsiz ;
  char *zbuf ;
  void *tmp___5 ;
  uint64_t tmp___6 ;
  uint64_t tmp___7 ;
  char *rv ;
  void *tmp___8 ;
  uint64_t tmp___9 ;

  {
  if (hdb->recc) {
    tmp = tcmdbget(hdb->recc, (void const   *)kbuf, ksiz, & tvsiz);
    tvbuf = (char *)tmp;
    if (tvbuf) {
      if ((int )*tvbuf == 42) {
        tchdbsetecode(hdb, 22, "tchdb.c", 3942, "tchdbgetimpl");
        while (1) {
          free((void *)tvbuf);
          break;
        }
        return ((char *)((void *)0));
      }
      *sp = tvsiz - 1;
      memmove((void *)tvbuf, (void const   *)(tvbuf + 1), (unsigned int )tvsiz);
      return (tvbuf);
    }
  }
  tmp___0 = tchdbgetbucket(hdb, bidx);
  off = tmp___0;
  while (off > 0L) {
    rec.off = (unsigned long long )off;
    tmp___1 = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp___1) {
      return ((char *)((void *)0));
    }
    if ((int )hash > (int )rec.hash) {
      off = (long )rec.left;
    } else {
      if ((int )hash < (int )rec.hash) {
        off = (long )rec.right;
      } else {
        if (! rec.kbuf) {
          tmp___2 = tchdbreadrecbody(hdb, & rec);
          if (! tmp___2) {
            return ((char *)((void *)0));
          }
        }
        tmp___3 = tcreckeycmp(kbuf, ksiz, rec.kbuf, (int )rec.ksiz);
        kcmp = tmp___3;
        if (kcmp > 0) {
          off = (long )rec.left;
          while (1) {
            free((void *)rec.bbuf);
            break;
          }
          rec.kbuf = (char const   *)((void *)0);
          rec.bbuf = (char *)((void *)0);
        } else {
          if (kcmp < 0) {
            off = (long )rec.right;
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            rec.kbuf = (char const   *)((void *)0);
            rec.bbuf = (char *)((void *)0);
          } else {
            if (! rec.vbuf) {
              tmp___4 = tchdbreadrecbody(hdb, & rec);
              if (! tmp___4) {
                return ((char *)((void *)0));
              }
            }
            if (hdb->zmode) {
              if ((int )hdb->opts & 2) {
                zbuf = (*_tc_inflate)(rec.vbuf, (int )rec.vsiz, & zsiz, 1);
              } else {
                if ((int )hdb->opts & 4) {
                  zbuf = (*_tc_bzdecompress)(rec.vbuf, (int )rec.vsiz, & zsiz);
                } else {
                  if ((int )hdb->opts & 8) {
                    zbuf = tcbsdecode(rec.vbuf, (int )rec.vsiz, & zsiz);
                  } else {
                    tmp___5 = (*(hdb->dec))((void const   *)rec.vbuf, (int )rec.vsiz,
                                            & zsiz, hdb->decop);
                    zbuf = (char *)tmp___5;
                  }
                }
              }
              while (1) {
                free((void *)rec.bbuf);
                break;
              }
              if (! zbuf) {
                tchdbsetecode(hdb, 9999, "tchdb.c", 3990, "tchdbgetimpl");
                return ((char *)((void *)0));
              }
              if (hdb->recc) {
                tmp___6 = tcmdbrnum(hdb->recc);
                if (tmp___6 >= (unsigned long long )hdb->rcnum) {
                  tchdbcacheadjust(hdb);
                }
                tcmdbput4(hdb->recc, (void const   *)kbuf, ksiz, (void const   *)"=",
                          1, (void const   *)zbuf, zsiz);
              }
              *sp = zsiz;
              return (zbuf);
            }
            if (hdb->recc) {
              tmp___7 = tcmdbrnum(hdb->recc);
              if (tmp___7 >= (unsigned long long )hdb->rcnum) {
                tchdbcacheadjust(hdb);
              }
              tcmdbput4(hdb->recc, (void const   *)kbuf, ksiz, (void const   *)"=",
                        1, (void const   *)rec.vbuf, (int )rec.vsiz);
            }
            if (rec.bbuf) {
              memmove((void *)rec.bbuf, (void const   *)rec.vbuf, rec.vsiz);
              *(rec.bbuf + rec.vsiz) = (char )'\000';
              *sp = (int )rec.vsiz;
              return (rec.bbuf);
            }
            *sp = (int )rec.vsiz;
            while (1) {
              while (1) {
                tmp___8 = malloc(rec.vsiz + 1U);
                rv = (char *)tmp___8;
                if (! rv) {
                  tcmyfatal("out of memory");
                }
                break;
              }
              memcpy((void * __restrict  )rv, (void const   * __restrict  )rec.vbuf,
                     rec.vsiz);
              *(rv + rec.vsiz) = (char )'\000';
              break;
            }
            return (rv);
          }
        }
      }
    }
  }
  if (hdb->recc) {
    tmp___9 = tcmdbrnum(hdb->recc);
    if (tmp___9 >= (unsigned long long )hdb->rcnum) {
      tchdbcacheadjust(hdb);
    }
    tcmdbput(hdb->recc, (void const   *)kbuf, ksiz, (void const   *)"*", 1);
  }
  tchdbsetecode(hdb, 22, "tchdb.c", 4021, "tchdbgetimpl");
  return ((char *)((void *)0));
}
}
static int tchdbgetintobuf(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                           uint8_t hash , char *vbuf , int max ) 
{ int tvsiz ;
  char *tvbuf ;
  void *tmp ;
  long tmp___0 ;
  off_t off ;
  off_t tmp___1 ;
  TCHREC rec ;
  char rbuf[8192] ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int kcmp ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int zsiz ;
  char *zbuf ;
  void *tmp___6 ;
  uint64_t tmp___7 ;
  long tmp___8 ;
  uint64_t tmp___9 ;
  int vsiz ;
  long tmp___10 ;
  uint64_t tmp___11 ;

  {
  if (hdb->recc) {
    tmp = tcmdbget(hdb->recc, (void const   *)kbuf, ksiz, & tvsiz);
    tvbuf = (char *)tmp;
    if (tvbuf) {
      if ((int )*tvbuf == 42) {
        tchdbsetecode(hdb, 22, "tchdb.c", 4044, "tchdbgetintobuf");
        while (1) {
          free((void *)tvbuf);
          break;
        }
        return (-1);
      }
      tmp___0 = tclmin((long )(tvsiz - 1), (long )max);
      tvsiz = (int )tmp___0;
      memcpy((void * __restrict  )vbuf, (void const   * __restrict  )(tvbuf + 1),
             (unsigned int )tvsiz);
      while (1) {
        free((void *)tvbuf);
        break;
      }
      return (tvsiz);
    }
  }
  tmp___1 = tchdbgetbucket(hdb, bidx);
  off = tmp___1;
  while (off > 0L) {
    rec.off = (unsigned long long )off;
    tmp___2 = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp___2) {
      return (-1);
    }
    if ((int )hash > (int )rec.hash) {
      off = (long )rec.left;
    } else {
      if ((int )hash < (int )rec.hash) {
        off = (long )rec.right;
      } else {
        if (! rec.kbuf) {
          tmp___3 = tchdbreadrecbody(hdb, & rec);
          if (! tmp___3) {
            return (-1);
          }
        }
        tmp___4 = tcreckeycmp(kbuf, ksiz, rec.kbuf, (int )rec.ksiz);
        kcmp = tmp___4;
        if (kcmp > 0) {
          off = (long )rec.left;
          while (1) {
            free((void *)rec.bbuf);
            break;
          }
          rec.kbuf = (char const   *)((void *)0);
          rec.bbuf = (char *)((void *)0);
        } else {
          if (kcmp < 0) {
            off = (long )rec.right;
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            rec.kbuf = (char const   *)((void *)0);
            rec.bbuf = (char *)((void *)0);
          } else {
            if (! rec.vbuf) {
              tmp___5 = tchdbreadrecbody(hdb, & rec);
              if (! tmp___5) {
                return (-1);
              }
            }
            if (hdb->zmode) {
              if ((int )hdb->opts & 2) {
                zbuf = (*_tc_inflate)(rec.vbuf, (int )rec.vsiz, & zsiz, 1);
              } else {
                if ((int )hdb->opts & 4) {
                  zbuf = (*_tc_bzdecompress)(rec.vbuf, (int )rec.vsiz, & zsiz);
                } else {
                  if ((int )hdb->opts & 8) {
                    zbuf = tcbsdecode(rec.vbuf, (int )rec.vsiz, & zsiz);
                  } else {
                    tmp___6 = (*(hdb->dec))((void const   *)rec.vbuf, (int )rec.vsiz,
                                            & zsiz, hdb->decop);
                    zbuf = (char *)tmp___6;
                  }
                }
              }
              while (1) {
                free((void *)rec.bbuf);
                break;
              }
              if (! zbuf) {
                tchdbsetecode(hdb, 9999, "tchdb.c", 4093, "tchdbgetintobuf");
                return (-1);
              }
              if (hdb->recc) {
                tmp___7 = tcmdbrnum(hdb->recc);
                if (tmp___7 >= (unsigned long long )hdb->rcnum) {
                  tchdbcacheadjust(hdb);
                }
                tcmdbput4(hdb->recc, (void const   *)kbuf, ksiz, (void const   *)"=",
                          1, (void const   *)zbuf, zsiz);
              }
              tmp___8 = tclmin((long )zsiz, (long )max);
              zsiz = (int )tmp___8;
              memcpy((void * __restrict  )vbuf, (void const   * __restrict  )zbuf,
                     (unsigned int )zsiz);
              while (1) {
                free((void *)zbuf);
                break;
              }
              return (zsiz);
            }
            if (hdb->recc) {
              tmp___9 = tcmdbrnum(hdb->recc);
              if (tmp___9 >= (unsigned long long )hdb->rcnum) {
                tchdbcacheadjust(hdb);
              }
              tcmdbput4(hdb->recc, (void const   *)kbuf, ksiz, (void const   *)"=",
                        1, (void const   *)rec.vbuf, (int )rec.vsiz);
            }
            tmp___10 = tclmin((long )rec.vsiz, (long )max);
            vsiz = (int )tmp___10;
            memcpy((void * __restrict  )vbuf, (void const   * __restrict  )rec.vbuf,
                   (unsigned int )vsiz);
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            return (vsiz);
          }
        }
      }
    }
  }
  if (hdb->recc) {
    tmp___11 = tcmdbrnum(hdb->recc);
    if (tmp___11 >= (unsigned long long )hdb->rcnum) {
      tchdbcacheadjust(hdb);
    }
    tcmdbput(hdb->recc, (void const   *)kbuf, ksiz, (void const   *)"*", 1);
  }
  tchdbsetecode(hdb, 22, "tchdb.c", 4120, "tchdbgetintobuf");
  return (-1);
}
}
static char *tchdbgetnextimpl(TCHDB *hdb , char const   *kbuf , int ksiz , int *sp ,
                              char const   **vbp , int *vsp ) 
{ uint64_t iter ;
  TCHREC rec ;
  char rbuf[8192] ;
  _Bool tmp ;
  _Bool tmp___0 ;
  int zsiz ;
  char *zbuf ;
  void *tmp___1 ;
  char *rv ;
  void *tmp___2 ;
  char *rv___0 ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  char *rv___1 ;
  void *tmp___5 ;
  _Bool tmp___6 ;
  uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp___7 ;
  off_t off ;
  off_t tmp___8 ;
  TCHREC rec___0 ;
  char rbuf___0[8192] ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  int kcmp ;
  int tmp___11 ;
  uint64_t iter___0 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  int zsiz___0 ;
  char *zbuf___0 ;
  void *tmp___14 ;
  char *rv___2 ;
  void *tmp___15 ;
  char *rv___3 ;
  void *tmp___16 ;
  _Bool tmp___17 ;
  char *rv___4 ;
  void *tmp___18 ;
  _Bool tmp___19 ;

  {
  if (! kbuf) {
    iter = hdb->frec;
    while (iter < hdb->fsiz) {
      rec.off = iter;
      tmp = tchdbreadrec(hdb, & rec, rbuf);
      if (! tmp) {
        return ((char *)((void *)0));
      }
      iter += (unsigned long long )rec.rsiz;
      if ((int )rec.magic == 200) {
        if (vbp) {
          if (hdb->zmode) {
            tmp___0 = tchdbreadrecbody(hdb, & rec);
            if (! tmp___0) {
              return ((char *)((void *)0));
            }
            if ((int )hdb->opts & 2) {
              zbuf = (*_tc_inflate)(rec.vbuf, (int )rec.vsiz, & zsiz, 1);
            } else {
              if ((int )hdb->opts & 4) {
                zbuf = (*_tc_bzdecompress)(rec.vbuf, (int )rec.vsiz, & zsiz);
              } else {
                if ((int )hdb->opts & 8) {
                  zbuf = tcbsdecode(rec.vbuf, (int )rec.vsiz, & zsiz);
                } else {
                  tmp___1 = (*(hdb->dec))((void const   *)rec.vbuf, (int )rec.vsiz,
                                          & zsiz, hdb->decop);
                  zbuf = (char *)tmp___1;
                }
              }
            }
            if (! zbuf) {
              tchdbsetecode(hdb, 9999, "tchdb.c", 4162, "tchdbgetnextimpl");
              while (1) {
                free((void *)rec.bbuf);
                break;
              }
              return ((char *)((void *)0));
            }
            while (1) {
              tmp___2 = malloc((rec.ksiz + (unsigned int )zsiz) + 1U);
              rv = (char *)tmp___2;
              if (! rv) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )rv, (void const   * __restrict  )rec.kbuf,
                   rec.ksiz);
            memcpy((void * __restrict  )(rv + rec.ksiz), (void const   * __restrict  )zbuf,
                   (unsigned int )zsiz);
            *sp = (int )rec.ksiz;
            *vbp = (char const   *)(rv + rec.ksiz);
            *vsp = zsiz;
            while (1) {
              free((void *)zbuf);
              break;
            }
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            return (rv);
          }
          if (rec.vbuf) {
            while (1) {
              tmp___3 = malloc((rec.ksiz + rec.vsiz) + 1U);
              rv___0 = (char *)tmp___3;
              if (! rv___0) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )rv___0, (void const   * __restrict  )rec.kbuf,
                   rec.ksiz);
            memcpy((void * __restrict  )(rv___0 + rec.ksiz), (void const   * __restrict  )rec.vbuf,
                   rec.vsiz);
            *sp = (int )rec.ksiz;
            *vbp = (char const   *)(rv___0 + rec.ksiz);
            *vsp = (int )rec.vsiz;
            return (rv___0);
          }
          tmp___4 = tchdbreadrecbody(hdb, & rec);
          if (! tmp___4) {
            return ((char *)((void *)0));
          }
          *sp = (int )rec.ksiz;
          *vbp = rec.vbuf;
          *vsp = (int )rec.vsiz;
          return (rec.bbuf);
        }
        if (rec.kbuf) {
          *sp = (int )rec.ksiz;
          while (1) {
            while (1) {
              tmp___5 = malloc(rec.ksiz + 1U);
              rv___1 = (char *)tmp___5;
              if (! rv___1) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )rv___1, (void const   * __restrict  )rec.kbuf,
                   rec.ksiz);
            *(rv___1 + rec.ksiz) = (char )'\000';
            break;
          }
          return (rv___1);
        }
        tmp___6 = tchdbreadrecbody(hdb, & rec);
        if (! tmp___6) {
          return ((char *)((void *)0));
        }
        *(rec.bbuf + rec.ksiz) = (char )'\000';
        *sp = (int )rec.ksiz;
        return (rec.bbuf);
      }
    }
    tchdbsetecode(hdb, 22, "tchdb.c", 4205, "tchdbgetnextimpl");
    return ((char *)((void *)0));
  }
  tmp___7 = tchdbbidx(hdb, kbuf, ksiz, & hash);
  bidx = tmp___7;
  tmp___8 = tchdbgetbucket(hdb, bidx);
  off = tmp___8;
  while (off > 0L) {
    rec___0.off = (unsigned long long )off;
    tmp___9 = tchdbreadrec(hdb, & rec___0, rbuf___0);
    if (! tmp___9) {
      return ((char *)((void *)0));
    }
    if ((int )hash > (int )rec___0.hash) {
      off = (long )rec___0.left;
    } else {
      if ((int )hash < (int )rec___0.hash) {
        off = (long )rec___0.right;
      } else {
        if (! rec___0.kbuf) {
          tmp___10 = tchdbreadrecbody(hdb, & rec___0);
          if (! tmp___10) {
            return ((char *)((void *)0));
          }
        }
        tmp___11 = tcreckeycmp(kbuf, ksiz, rec___0.kbuf, (int )rec___0.ksiz);
        kcmp = tmp___11;
        if (kcmp > 0) {
          off = (long )rec___0.left;
          while (1) {
            free((void *)rec___0.bbuf);
            break;
          }
          rec___0.kbuf = (char const   *)((void *)0);
          rec___0.bbuf = (char *)((void *)0);
        } else {
          if (kcmp < 0) {
            off = (long )rec___0.right;
            while (1) {
              free((void *)rec___0.bbuf);
              break;
            }
            rec___0.kbuf = (char const   *)((void *)0);
            rec___0.bbuf = (char *)((void *)0);
          } else {
            iter___0 = rec___0.off + (unsigned long long )rec___0.rsiz;
            while (1) {
              free((void *)rec___0.bbuf);
              break;
            }
            rec___0.kbuf = (char const   *)((void *)0);
            rec___0.bbuf = (char *)((void *)0);
            while (iter___0 < hdb->fsiz) {
              rec___0.off = iter___0;
              tmp___12 = tchdbreadrec(hdb, & rec___0, rbuf___0);
              if (! tmp___12) {
                return ((char *)((void *)0));
              }
              iter___0 += (unsigned long long )rec___0.rsiz;
              if ((int )rec___0.magic == 200) {
                if (vbp) {
                  if (hdb->zmode) {
                    tmp___13 = tchdbreadrecbody(hdb, & rec___0);
                    if (! tmp___13) {
                      return ((char *)((void *)0));
                    }
                    if ((int )hdb->opts & 2) {
                      zbuf___0 = (*_tc_inflate)(rec___0.vbuf, (int )rec___0.vsiz,
                                                & zsiz___0, 1);
                    } else {
                      if ((int )hdb->opts & 4) {
                        zbuf___0 = (*_tc_bzdecompress)(rec___0.vbuf, (int )rec___0.vsiz,
                                                       & zsiz___0);
                      } else {
                        if ((int )hdb->opts & 8) {
                          zbuf___0 = tcbsdecode(rec___0.vbuf, (int )rec___0.vsiz,
                                                & zsiz___0);
                        } else {
                          tmp___14 = (*(hdb->dec))((void const   *)rec___0.vbuf, (int )rec___0.vsiz,
                                                   & zsiz___0, hdb->decop);
                          zbuf___0 = (char *)tmp___14;
                        }
                      }
                    }
                    if (! zbuf___0) {
                      tchdbsetecode(hdb, 9999, "tchdb.c", 4258, "tchdbgetnextimpl");
                      while (1) {
                        free((void *)rec___0.bbuf);
                        break;
                      }
                      return ((char *)((void *)0));
                    }
                    while (1) {
                      tmp___15 = malloc((rec___0.ksiz + (unsigned int )zsiz___0) + 1U);
                      rv___2 = (char *)tmp___15;
                      if (! rv___2) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )rv___2, (void const   * __restrict  )rec___0.kbuf,
                           rec___0.ksiz);
                    memcpy((void * __restrict  )(rv___2 + rec___0.ksiz), (void const   * __restrict  )zbuf___0,
                           (unsigned int )zsiz___0);
                    *sp = (int )rec___0.ksiz;
                    *vbp = (char const   *)(rv___2 + rec___0.ksiz);
                    *vsp = zsiz___0;
                    while (1) {
                      free((void *)zbuf___0);
                      break;
                    }
                    while (1) {
                      free((void *)rec___0.bbuf);
                      break;
                    }
                    return (rv___2);
                  }
                  if (rec___0.vbuf) {
                    while (1) {
                      tmp___16 = malloc((rec___0.ksiz + rec___0.vsiz) + 1U);
                      rv___3 = (char *)tmp___16;
                      if (! rv___3) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )rv___3, (void const   * __restrict  )rec___0.kbuf,
                           rec___0.ksiz);
                    memcpy((void * __restrict  )(rv___3 + rec___0.ksiz), (void const   * __restrict  )rec___0.vbuf,
                           rec___0.vsiz);
                    *sp = (int )rec___0.ksiz;
                    *vbp = (char const   *)(rv___3 + rec___0.ksiz);
                    *vsp = (int )rec___0.vsiz;
                    return (rv___3);
                  }
                  tmp___17 = tchdbreadrecbody(hdb, & rec___0);
                  if (! tmp___17) {
                    return ((char *)((void *)0));
                  }
                  *sp = (int )rec___0.ksiz;
                  *vbp = rec___0.vbuf;
                  *vsp = (int )rec___0.vsiz;
                  return (rec___0.bbuf);
                }
                if (rec___0.kbuf) {
                  *sp = (int )rec___0.ksiz;
                  while (1) {
                    while (1) {
                      tmp___18 = malloc(rec___0.ksiz + 1U);
                      rv___4 = (char *)tmp___18;
                      if (! rv___4) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )rv___4, (void const   * __restrict  )rec___0.kbuf,
                           rec___0.ksiz);
                    *(rv___4 + rec___0.ksiz) = (char )'\000';
                    break;
                  }
                  return (rv___4);
                }
                tmp___19 = tchdbreadrecbody(hdb, & rec___0);
                if (! tmp___19) {
                  return ((char *)((void *)0));
                }
                *(rec___0.bbuf + rec___0.ksiz) = (char )'\000';
                *sp = (int )rec___0.ksiz;
                return (rec___0.bbuf);
              }
            }
            tchdbsetecode(hdb, 22, "tchdb.c", 4301, "tchdbgetnextimpl");
            return ((char *)((void *)0));
          }
        }
      }
    }
  }
  tchdbsetecode(hdb, 22, "tchdb.c", 4306, "tchdbgetnextimpl");
  return ((char *)((void *)0));
}
}
static int tchdbvsizimpl(TCHDB *hdb , char const   *kbuf , int ksiz , uint64_t bidx ,
                         uint8_t hash ) 
{ int tvsiz ;
  char *tvbuf ;
  void *tmp ;
  off_t off ;
  off_t tmp___0 ;
  TCHREC rec ;
  char rbuf[8192] ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int kcmp ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int zsiz ;
  char *zbuf ;
  void *tmp___5 ;
  uint64_t tmp___6 ;
  uint64_t tmp___7 ;
  uint64_t tmp___8 ;

  {
  if (hdb->recc) {
    tmp = tcmdbget(hdb->recc, (void const   *)kbuf, ksiz, & tvsiz);
    tvbuf = (char *)tmp;
    if (tvbuf) {
      if ((int )*tvbuf == 42) {
        tchdbsetecode(hdb, 22, "tchdb.c", 4326, "tchdbvsizimpl");
        while (1) {
          free((void *)tvbuf);
          break;
        }
        return (-1);
      }
      while (1) {
        free((void *)tvbuf);
        break;
      }
      return (tvsiz - 1);
    }
  }
  tmp___0 = tchdbgetbucket(hdb, bidx);
  off = tmp___0;
  while (off > 0L) {
    rec.off = (unsigned long long )off;
    tmp___1 = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp___1) {
      return (-1);
    }
    if ((int )hash > (int )rec.hash) {
      off = (long )rec.left;
    } else {
      if ((int )hash < (int )rec.hash) {
        off = (long )rec.right;
      } else {
        if (! rec.kbuf) {
          tmp___2 = tchdbreadrecbody(hdb, & rec);
          if (! tmp___2) {
            return (-1);
          }
        }
        tmp___3 = tcreckeycmp(kbuf, ksiz, rec.kbuf, (int )rec.ksiz);
        kcmp = tmp___3;
        if (kcmp > 0) {
          off = (long )rec.left;
          while (1) {
            free((void *)rec.bbuf);
            break;
          }
          rec.kbuf = (char const   *)((void *)0);
          rec.bbuf = (char *)((void *)0);
        } else {
          if (kcmp < 0) {
            off = (long )rec.right;
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            rec.kbuf = (char const   *)((void *)0);
            rec.bbuf = (char *)((void *)0);
          } else {
            if (hdb->zmode) {
              if (! rec.vbuf) {
                tmp___4 = tchdbreadrecbody(hdb, & rec);
                if (! tmp___4) {
                  return (-1);
                }
              }
              if ((int )hdb->opts & 2) {
                zbuf = (*_tc_inflate)(rec.vbuf, (int )rec.vsiz, & zsiz, 1);
              } else {
                if ((int )hdb->opts & 4) {
                  zbuf = (*_tc_bzdecompress)(rec.vbuf, (int )rec.vsiz, & zsiz);
                } else {
                  if ((int )hdb->opts & 8) {
                    zbuf = tcbsdecode(rec.vbuf, (int )rec.vsiz, & zsiz);
                  } else {
                    tmp___5 = (*(hdb->dec))((void const   *)rec.vbuf, (int )rec.vsiz,
                                            & zsiz, hdb->decop);
                    zbuf = (char *)tmp___5;
                  }
                }
              }
              while (1) {
                free((void *)rec.bbuf);
                break;
              }
              if (! zbuf) {
                tchdbsetecode(hdb, 9999, "tchdb.c", 4373, "tchdbvsizimpl");
                return (-1);
              }
              if (hdb->recc) {
                tmp___6 = tcmdbrnum(hdb->recc);
                if (tmp___6 >= (unsigned long long )hdb->rcnum) {
                  tchdbcacheadjust(hdb);
                }
                tcmdbput4(hdb->recc, (void const   *)kbuf, ksiz, (void const   *)"=",
                          1, (void const   *)zbuf, zsiz);
              }
              while (1) {
                free((void *)zbuf);
                break;
              }
              return (zsiz);
            }
            if (hdb->recc) {
              if (rec.vbuf) {
                tmp___7 = tcmdbrnum(hdb->recc);
                if (tmp___7 >= (unsigned long long )hdb->rcnum) {
                  tchdbcacheadjust(hdb);
                }
                tcmdbput4(hdb->recc, (void const   *)kbuf, ksiz, (void const   *)"=",
                          1, (void const   *)rec.vbuf, (int )rec.vsiz);
              }
            }
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            return ((int )rec.vsiz);
          }
        }
      }
    }
  }
  if (hdb->recc) {
    tmp___8 = tcmdbrnum(hdb->recc);
    if (tmp___8 >= (unsigned long long )hdb->rcnum) {
      tchdbcacheadjust(hdb);
    }
    tcmdbput(hdb->recc, (void const   *)kbuf, ksiz, (void const   *)"*", 1);
  }
  tchdbsetecode(hdb, 22, "tchdb.c", 4396, "tchdbvsizimpl");
  return (-1);
}
}
static _Bool tchdbiterinitimpl(TCHDB *hdb ) 
{ 

  {
  hdb->iter = hdb->frec;
  return ((_Bool)1);
}
}
static char *tchdbiternextimpl(TCHDB *hdb , int *sp ) 
{ TCHREC rec ;
  char rbuf[8192] ;
  _Bool tmp ;
  char *rv ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
  while (hdb->iter < hdb->fsiz) {
    rec.off = hdb->iter;
    tmp = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp) {
      return ((char *)((void *)0));
    }
    hdb->iter += (unsigned long long )rec.rsiz;
    if ((int )rec.magic == 200) {
      if (rec.kbuf) {
        *sp = (int )rec.ksiz;
        while (1) {
          while (1) {
            tmp___0 = malloc(rec.ksiz + 1U);
            rv = (char *)tmp___0;
            if (! rv) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )rv, (void const   * __restrict  )rec.kbuf, rec.ksiz);
          *(rv + rec.ksiz) = (char )'\000';
          break;
        }
        return (rv);
      }
      tmp___1 = tchdbreadrecbody(hdb, & rec);
      if (! tmp___1) {
        return ((char *)((void *)0));
      }
      *(rec.bbuf + rec.ksiz) = (char )'\000';
      *sp = (int )rec.ksiz;
      return (rec.bbuf);
    }
  }
  tchdbsetecode(hdb, 22, "tchdb.c", 4438, "tchdbiternextimpl");
  return ((char *)((void *)0));
}
}
static _Bool tchdbiternextintoxstr(TCHDB *hdb , TCXSTR *kxstr , TCXSTR *vxstr ) 
{ TCHREC rec ;
  char rbuf[8192] ;
  _Bool tmp ;
  _Bool tmp___0 ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___1 ;
  void *tmp___2 ;
  int zsiz ;
  char *zbuf ;
  void *tmp___3 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___4 ;
  void *tmp___5 ;
  int TC_mysize___1 ;
  int TC_nsize___1 ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
  while (hdb->iter < hdb->fsiz) {
    rec.off = hdb->iter;
    tmp = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp) {
      return ((_Bool)0);
    }
    hdb->iter += (unsigned long long )rec.rsiz;
    if ((int )rec.magic == 200) {
      if (! rec.vbuf) {
        tmp___0 = tchdbreadrecbody(hdb, & rec);
        if (! tmp___0) {
          return ((_Bool)0);
        }
      }
      tcxstrclear(kxstr);
      while (1) {
        TC_mysize = (int )rec.ksiz;
        TC_nsize = (kxstr->size + TC_mysize) + 1;
        if (kxstr->asize < TC_nsize) {
          while (kxstr->asize < TC_nsize) {
            kxstr->asize *= 2;
            if (kxstr->asize < TC_nsize) {
              kxstr->asize = TC_nsize;
            }
          }
          while (1) {
            tmp___2 = realloc((void *)kxstr->ptr, (unsigned int )kxstr->asize);
            tmp___1 = (char *)tmp___2;
            kxstr->ptr = tmp___1;
            if (! tmp___1) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(kxstr->ptr + kxstr->size), (void const   * __restrict  )rec.kbuf,
               (unsigned int )TC_mysize);
        kxstr->size += TC_mysize;
        *(kxstr->ptr + kxstr->size) = (char )'\000';
        break;
      }
      tcxstrclear(vxstr);
      if (hdb->zmode) {
        if ((int )hdb->opts & 2) {
          zbuf = (*_tc_inflate)(rec.vbuf, (int )rec.vsiz, & zsiz, 1);
        } else {
          if ((int )hdb->opts & 4) {
            zbuf = (*_tc_bzdecompress)(rec.vbuf, (int )rec.vsiz, & zsiz);
          } else {
            if ((int )hdb->opts & 8) {
              zbuf = tcbsdecode(rec.vbuf, (int )rec.vsiz, & zsiz);
            } else {
              tmp___3 = (*(hdb->dec))((void const   *)rec.vbuf, (int )rec.vsiz, & zsiz,
                                      hdb->decop);
              zbuf = (char *)tmp___3;
            }
          }
        }
        if (! zbuf) {
          tchdbsetecode(hdb, 9999, "tchdb.c", 4470, "tchdbiternextintoxstr");
          while (1) {
            free((void *)rec.bbuf);
            break;
          }
          return ((_Bool)0);
        }
        while (1) {
          TC_mysize___0 = zsiz;
          TC_nsize___0 = (vxstr->size + TC_mysize___0) + 1;
          if (vxstr->asize < TC_nsize___0) {
            while (vxstr->asize < TC_nsize___0) {
              vxstr->asize *= 2;
              if (vxstr->asize < TC_nsize___0) {
                vxstr->asize = TC_nsize___0;
              }
            }
            while (1) {
              tmp___5 = realloc((void *)vxstr->ptr, (unsigned int )vxstr->asize);
              tmp___4 = (char *)tmp___5;
              vxstr->ptr = tmp___4;
              if (! tmp___4) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(vxstr->ptr + vxstr->size), (void const   * __restrict  )zbuf,
                 (unsigned int )TC_mysize___0);
          vxstr->size += TC_mysize___0;
          *(vxstr->ptr + vxstr->size) = (char )'\000';
          break;
        }
        while (1) {
          free((void *)zbuf);
          break;
        }
      } else {
        while (1) {
          TC_mysize___1 = (int )rec.vsiz;
          TC_nsize___1 = (vxstr->size + TC_mysize___1) + 1;
          if (vxstr->asize < TC_nsize___1) {
            while (vxstr->asize < TC_nsize___1) {
              vxstr->asize *= 2;
              if (vxstr->asize < TC_nsize___1) {
                vxstr->asize = TC_nsize___1;
              }
            }
            while (1) {
              tmp___7 = realloc((void *)vxstr->ptr, (unsigned int )vxstr->asize);
              tmp___6 = (char *)tmp___7;
              vxstr->ptr = tmp___6;
              if (! tmp___6) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memcpy((void * __restrict  )(vxstr->ptr + vxstr->size), (void const   * __restrict  )rec.vbuf,
                 (unsigned int )TC_mysize___1);
          vxstr->size += TC_mysize___1;
          *(vxstr->ptr + vxstr->size) = (char )'\000';
          break;
        }
      }
      while (1) {
        free((void *)rec.bbuf);
        break;
      }
      return ((_Bool)1);
    }
  }
  tchdbsetecode(hdb, 22, "tchdb.c", 4483, "tchdbiternextintoxstr");
  return ((_Bool)0);
}
}
static _Bool tchdboptimizeimpl(TCHDB *hdb , int64_t bnum , int8_t apow , int8_t fpow ,
                               uint8_t opts ) 
{ char *tpath ;
  char *tmp ;
  TCHDB *thdb ;
  TCHDB *tmp___0 ;
  _Bool tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  _Bool err ;
  uint64_t off ;
  TCHREC rec ;
  char rbuf[8192] ;
  _Bool tmp___4 ;
  int zsiz ;
  char *zbuf ;
  void *tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int omode ;
  _Bool tmp___12 ;
  _Bool rv ;
  _Bool tmp___13 ;

  {
  tmp = tcsprintf("%s%ctmp%c%llu", hdb->path, '.', '.', hdb->inode);
  tpath = tmp;
  tmp___0 = tchdbnew();
  thdb = tmp___0;
  thdb->dbgfd = hdb->dbgfd;
  thdb->enc = hdb->enc;
  thdb->encop = hdb->encop;
  thdb->dec = hdb->dec;
  thdb->decop = hdb->decop;
  if (bnum < 1LL) {
    bnum = (long long )(hdb->rnum * 2ULL + 1ULL);
    if (bnum < 131071LL) {
      bnum = 131071LL;
    }
  }
  if ((int )apow < 0) {
    apow = (signed char )hdb->apow;
  }
  if ((int )fpow < 0) {
    fpow = (signed char )hdb->fpow;
  }
  if ((int )opts == 255) {
    opts = hdb->opts;
  }
  tchdbtune(thdb, bnum, apow, fpow, opts);
  tmp___1 = tchdbopen(thdb, (char const   *)tpath, 14);
  if (! tmp___1) {
    tchdbsetecode(hdb, thdb->ecode, "tchdb.c", 4513, "tchdboptimizeimpl");
    tchdbdel(thdb);
    while (1) {
      free((void *)tpath);
      break;
    }
    return ((_Bool)0);
  }
  tmp___2 = tchdbopaque(hdb);
  tmp___3 = tchdbopaque(thdb);
  memcpy((void * __restrict  )tmp___3, (void const   * __restrict  )tmp___2, 128U);
  err = (_Bool)0;
  off = hdb->frec;
  while (off < hdb->fsiz) {
    rec.off = off;
    tmp___4 = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp___4) {
      err = (_Bool)1;
      break;
    }
    off += (unsigned long long )rec.rsiz;
    if ((int )rec.magic == 200) {
      if (! rec.vbuf) {
        tmp___8 = tchdbreadrecbody(hdb, & rec);
        if (tmp___8) {
          goto _L;
        } else {
          while (1) {
            free((void *)rec.bbuf);
            break;
          }
          err = (_Bool)1;
        }
      } else {
        _L: 
        if (hdb->zmode) {
          if ((int )hdb->opts & 2) {
            zbuf = (*_tc_inflate)(rec.vbuf, (int )rec.vsiz, & zsiz, 1);
          } else {
            if ((int )hdb->opts & 4) {
              zbuf = (*_tc_bzdecompress)(rec.vbuf, (int )rec.vsiz, & zsiz);
            } else {
              if ((int )hdb->opts & 8) {
                zbuf = tcbsdecode(rec.vbuf, (int )rec.vsiz, & zsiz);
              } else {
                tmp___5 = (*(hdb->dec))((void const   *)rec.vbuf, (int )rec.vsiz,
                                        & zsiz, hdb->decop);
                zbuf = (char *)tmp___5;
              }
            }
          }
          if (zbuf) {
            tmp___6 = tchdbput(thdb, (void const   *)rec.kbuf, (int )rec.ksiz, (void const   *)zbuf,
                               zsiz);
            if (! tmp___6) {
              tchdbsetecode(hdb, thdb->ecode, "tchdb.c", 4549, "tchdboptimizeimpl");
              err = (_Bool)1;
            }
            while (1) {
              free((void *)zbuf);
              break;
            }
          } else {
            tchdbsetecode(hdb, 9999, "tchdb.c", 4554, "tchdboptimizeimpl");
            err = (_Bool)1;
          }
        } else {
          tmp___7 = tchdbput(thdb, (void const   *)rec.kbuf, (int )rec.ksiz, (void const   *)rec.vbuf,
                             (int )rec.vsiz);
          if (! tmp___7) {
            tchdbsetecode(hdb, thdb->ecode, "tchdb.c", 4559, "tchdboptimizeimpl");
            err = (_Bool)1;
          }
        }
      }
      while (1) {
        free((void *)rec.bbuf);
        break;
      }
    }
  }
  tmp___9 = tchdbclose(thdb);
  if (! tmp___9) {
    tchdbsetecode(hdb, thdb->ecode, "tchdb.c", 4568, "tchdboptimizeimpl");
    err = (_Bool)1;
  }
  tchdbdel(thdb);
  if (err) {
    while (1) {
      free((void *)tpath);
      break;
    }
    return ((_Bool)0);
  }
  tmp___10 = unlink((char const   *)hdb->path);
  if (tmp___10 == -1) {
    tchdbsetecode(hdb, 17, "tchdb.c", 4577, "tchdboptimizeimpl");
    err = (_Bool)1;
  }
  tmp___11 = rename((char const   *)tpath, (char const   *)hdb->path);
  if (tmp___11 == -1) {
    tchdbsetecode(hdb, 18, "tchdb.c", 4581, "tchdboptimizeimpl");
    err = (_Bool)1;
  }
  while (1) {
    free((void *)tpath);
    break;
  }
  if (err) {
    return ((_Bool)0);
  }
  tpath = tcstrdup((void const   *)hdb->path);
  omode = (int )((hdb->omode & 4294967291U) & 4294967287U);
  tmp___12 = tchdbcloseimpl(hdb);
  if (! tmp___12) {
    while (1) {
      free((void *)tpath);
      break;
    }
    return ((_Bool)0);
  }
  tmp___13 = tchdbopenimpl(hdb, (char const   *)tpath, omode);
  rv = tmp___13;
  while (1) {
    free((void *)tpath);
    break;
  }
  return (rv);
}
}
static _Bool tchdbvanishimpl(TCHDB *hdb ) 
{ char *path ;
  char *tmp ;
  int omode ;
  _Bool err ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = tcstrdup((void const   *)hdb->path);
  path = tmp;
  omode = (int )hdb->omode;
  err = (_Bool)0;
  tmp___0 = tchdbcloseimpl(hdb);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  tmp___1 = tchdbopenimpl(hdb, (char const   *)path, 8 | omode);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  while (1) {
    free((void *)path);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tchdbcopyimpl(TCHDB *hdb , char const   *path ) 
{ _Bool err ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char tsbuf[32] ;
  double tmp___1 ;
  char const   *args[3] ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  err = (_Bool)0;
  if (hdb->omode & 2U) {
    tmp = tchdbsavefbp(hdb);
    if (! tmp) {
      err = (_Bool)1;
    }
    tmp___0 = tchdbmemsync(hdb, (_Bool)0);
    if (! tmp___0) {
      err = (_Bool)1;
    }
    tchdbsetflag(hdb, 1, (_Bool)0);
  }
  if ((int const   )*path == 64) {
    tmp___1 = tctime();
    sprintf((char * __restrict  )(tsbuf), (char const   * __restrict  )"%llu", (unsigned long long )(tmp___1 * (double )1000000));
    args[0] = path + 1;
    args[1] = (char const   *)hdb->path;
    args[2] = (char const   *)(tsbuf);
    tmp___2 = tcsystem(args, (int )sizeof(args) / (int )sizeof(args[0]));
    if (tmp___2 != 0) {
      err = (_Bool)1;
    }
  } else {
    tmp___3 = tccopyfile((char const   *)hdb->path, path);
    if (! tmp___3) {
      tchdbsetecode(hdb, 9999, "tchdb.c", 4635, "tchdbcopyimpl");
      err = (_Bool)1;
    }
  }
  if (hdb->omode & 2U) {
    tchdbsetflag(hdb, 1, (_Bool)1);
  }
  return ((_Bool )(! err));
}
}
static _Bool tchdbdefragimpl(TCHDB *hdb , int64_t step ) 
{ TCHREC rec ;
  char rbuf[8192] ;
  int64_t tmp ;
  _Bool tmp___0 ;
  uint32_t align ;
  uint64_t base ;
  uint64_t dest ;
  uint64_t cur ;
  uint64_t fbsiz ;
  _Bool tmp___1 ;
  uint32_t rsiz ;
  int diff ;
  _Bool tmp___2 ;
  uint64_t off ;
  uint64_t size ;
  uint32_t rsiz___0 ;
  uint64_t tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  uint64_t llnum ;
  int tmp___7 ;

  {
  while (1) {
    break;
  }
  hdb->dfcnt = 0U;
  while (1) {
    if (hdb->dfcur >= hdb->fsiz) {
      hdb->dfcur = hdb->frec;
      return ((_Bool)1);
    }
    tmp = step;
    step --;
    if (tmp < 1LL) {
      return ((_Bool)1);
    }
    rec.off = hdb->dfcur;
    tmp___0 = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp___0) {
      return ((_Bool)0);
    }
    if ((int )rec.magic == 176) {
      break;
    }
    hdb->dfcur += (unsigned long long )rec.rsiz;
  }
  align = hdb->align;
  base = hdb->dfcur;
  dest = base;
  cur = base;
  if (hdb->iter == cur) {
    hdb->iter += (unsigned long long )rec.rsiz;
  }
  cur += (unsigned long long )rec.rsiz;
  fbsiz = cur - dest;
  step ++;
  while (1) {
    if (step > 0LL) {
      if (! (cur < hdb->fsiz)) {
        break;
      }
    } else {
      break;
    }
    rec.off = cur;
    tmp___1 = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp___1) {
      return ((_Bool)0);
    }
    rsiz = rec.rsiz;
    if ((int )rec.magic == 200) {
      if ((unsigned int )rec.psiz >= align) {
        diff = (int )((unsigned int )rec.psiz - (unsigned int )rec.psiz % align);
        rec.psiz = (unsigned short )((int )rec.psiz - diff);
        rec.rsiz -= (unsigned int )diff;
        fbsiz += (unsigned long long )diff;
      }
      tmp___2 = tchdbshiftrec(hdb, & rec, rbuf, (long )dest);
      if (! tmp___2) {
        return ((_Bool)0);
      }
      if (hdb->iter == cur) {
        hdb->iter = dest;
      }
      dest += (unsigned long long )rec.rsiz;
      step --;
    } else {
      if (hdb->iter == cur) {
        hdb->iter += (unsigned long long )rec.rsiz;
      }
      fbsiz += (unsigned long long )rec.rsiz;
    }
    cur += (unsigned long long )rsiz;
  }
  if (cur < hdb->fsiz) {
    if (fbsiz > 536870911ULL) {
      tchdbfbptrim(hdb, base, cur, 0ULL, 0U);
      off = dest;
      size = fbsiz;
      while (size > 0ULL) {
        if (size > 536870911ULL) {
          tmp___3 = 536870911ULL;
        } else {
          tmp___3 = size;
        }
        rsiz___0 = (unsigned int )tmp___3;
        if (size - (unsigned long long )rsiz___0 < 48ULL) {
          rsiz___0 = (unsigned int )size;
        }
        tchdbfbpinsert(hdb, off, rsiz___0);
        tmp___4 = tchdbwritefb(hdb, off, rsiz___0);
        if (! tmp___4) {
          return ((_Bool)0);
        }
        off += (unsigned long long )rsiz___0;
        size -= (unsigned long long )rsiz___0;
      }
    } else {
      tchdbfbptrim(hdb, base, cur, dest, (unsigned int )fbsiz);
      tmp___5 = tchdbwritefb(hdb, dest, (unsigned int )fbsiz);
      if (! tmp___5) {
        return ((_Bool)0);
      }
    }
    hdb->dfcur = cur - fbsiz;
  } else {
    while (1) {
      break;
    }
    if (hdb->tran) {
      tmp___6 = tchdbwalwrite(hdb, dest, (long long )fbsiz);
      if (! tmp___6) {
        return ((_Bool)0);
      }
    }
    tchdbfbptrim(hdb, base, cur, 0ULL, 0U);
    hdb->dfcur = hdb->frec;
    hdb->fsiz = dest;
    llnum = hdb->fsiz;
    llnum = llnum;
    memcpy((void * __restrict  )(hdb->map + 56), (void const   * __restrict  )(& llnum),
           (unsigned int )((int )sizeof(llnum)));
    if (hdb->iter >= hdb->fsiz) {
      hdb->iter = 0xffffffffffffffffULL;
    }
    if (! hdb->tran) {
      tmp___7 = ftruncate(hdb->fd, (long )hdb->fsiz);
      if (tmp___7 == -1) {
        tchdbsetecode(hdb, 9, "tchdb.c", 4724, "tchdbdefragimpl");
        return ((_Bool)0);
      }
      hdb->xfsiz = 0ULL;
    }
  }
  return ((_Bool)1);
}
}
static _Bool tchdbiterjumpimpl(TCHDB *hdb , char const   *kbuf , int ksiz ) 
{ uint8_t hash ;
  uint64_t bidx ;
  uint64_t tmp ;
  off_t off ;
  off_t tmp___0 ;
  TCHREC rec ;
  char rbuf[8192] ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int kcmp ;
  int tmp___3 ;

  {
  tmp = tchdbbidx(hdb, kbuf, ksiz, & hash);
  bidx = tmp;
  tmp___0 = tchdbgetbucket(hdb, bidx);
  off = tmp___0;
  while (off > 0L) {
    rec.off = (unsigned long long )off;
    tmp___1 = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp___1) {
      return ((_Bool)0);
    }
    if ((int )hash > (int )rec.hash) {
      off = (long )rec.left;
    } else {
      if ((int )hash < (int )rec.hash) {
        off = (long )rec.right;
      } else {
        if (! rec.kbuf) {
          tmp___2 = tchdbreadrecbody(hdb, & rec);
          if (! tmp___2) {
            return ((_Bool)0);
          }
        }
        tmp___3 = tcreckeycmp(kbuf, ksiz, rec.kbuf, (int )rec.ksiz);
        kcmp = tmp___3;
        if (kcmp > 0) {
          off = (long )rec.left;
          while (1) {
            free((void *)rec.bbuf);
            break;
          }
          rec.kbuf = (char const   *)((void *)0);
          rec.bbuf = (char *)((void *)0);
        } else {
          if (kcmp < 0) {
            off = (long )rec.right;
            while (1) {
              free((void *)rec.bbuf);
              break;
            }
            rec.kbuf = (char const   *)((void *)0);
            rec.bbuf = (char *)((void *)0);
          } else {
            hdb->iter = (unsigned long long )off;
            return ((_Bool)1);
          }
        }
      }
    }
  }
  tchdbsetecode(hdb, 22, "tchdb.c", 4772, "tchdbiterjumpimpl");
  return ((_Bool)0);
}
}
static _Bool tchdbforeachimpl(TCHDB *hdb , _Bool (*iter)(void const   *kbuf , int ksiz ,
                                                         void const   *vbuf , int vsiz ,
                                                         void *op ) , void *op ) 
{ _Bool err ;
  uint64_t off ;
  TCHREC rec ;
  char rbuf[8192] ;
  _Bool cont ;
  _Bool tmp ;
  int zsiz ;
  char *zbuf ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
  err = (_Bool)0;
  off = hdb->frec;
  cont = (_Bool)1;
  while (1) {
    if (cont) {
      if (! (off < hdb->fsiz)) {
        break;
      }
    } else {
      break;
    }
    rec.off = off;
    tmp = tchdbreadrec(hdb, & rec, rbuf);
    if (! tmp) {
      err = (_Bool)1;
      break;
    }
    off += (unsigned long long )rec.rsiz;
    if ((int )rec.magic == 200) {
      if (! rec.vbuf) {
        tmp___1 = tchdbreadrecbody(hdb, & rec);
        if (tmp___1) {
          goto _L;
        } else {
          while (1) {
            free((void *)rec.bbuf);
            break;
          }
          err = (_Bool)1;
        }
      } else {
        _L: 
        if (hdb->zmode) {
          if ((int )hdb->opts & 2) {
            zbuf = (*_tc_inflate)(rec.vbuf, (int )rec.vsiz, & zsiz, 1);
          } else {
            if ((int )hdb->opts & 4) {
              zbuf = (*_tc_bzdecompress)(rec.vbuf, (int )rec.vsiz, & zsiz);
            } else {
              if ((int )hdb->opts & 8) {
                zbuf = tcbsdecode(rec.vbuf, (int )rec.vsiz, & zsiz);
              } else {
                tmp___0 = (*(hdb->dec))((void const   *)rec.vbuf, (int )rec.vsiz,
                                        & zsiz, hdb->decop);
                zbuf = (char *)tmp___0;
              }
            }
          }
          if (zbuf) {
            cont = (*iter)((void const   *)rec.kbuf, (int )rec.ksiz, (void const   *)zbuf,
                           zsiz, op);
            while (1) {
              free((void *)zbuf);
              break;
            }
          } else {
            tchdbsetecode(hdb, 9999, "tchdb.c", 4817, "tchdbforeachimpl");
            err = (_Bool)1;
          }
        } else {
          cont = (*iter)((void const   *)rec.kbuf, (int )rec.ksiz, (void const   *)rec.vbuf,
                         (int )rec.vsiz, op);
        }
      }
      while (1) {
        free((void *)rec.bbuf);
        break;
      }
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tchdblockmethod(TCHDB *hdb , _Bool wr ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (wr) {
    tmp = pthread_rwlock_wrlock((pthread_rwlock_t *)hdb->mmtx);
    tmp___1 = tmp != 0;
  } else {
    tmp___0 = pthread_rwlock_rdlock((pthread_rwlock_t *)hdb->mmtx);
    tmp___1 = tmp___0 != 0;
  }
  if (tmp___1) {
    tchdbsetecode(hdb, 1, "tchdb.c", 4838, "tchdblockmethod");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tchdbunlockmethod(TCHDB *hdb ) 
{ int tmp ;

  {
  tmp = pthread_rwlock_unlock((pthread_rwlock_t *)hdb->mmtx);
  if (tmp != 0) {
    tchdbsetecode(hdb, 1, "tchdb.c", 4852, "tchdbunlockmethod");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tchdblockrecord(TCHDB *hdb , uint8_t bidx , _Bool wr ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (wr) {
    tmp = pthread_rwlock_wrlock((pthread_rwlock_t *)hdb->rmtxs + (int )bidx);
    tmp___1 = tmp != 0;
  } else {
    tmp___0 = pthread_rwlock_rdlock((pthread_rwlock_t *)hdb->rmtxs + (int )bidx);
    tmp___1 = tmp___0 != 0;
  }
  if (tmp___1) {
    tchdbsetecode(hdb, 1, "tchdb.c", 4869, "tchdblockrecord");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tchdbunlockrecord(TCHDB *hdb , uint8_t bidx ) 
{ int tmp ;

  {
  tmp = pthread_rwlock_unlock((pthread_rwlock_t *)hdb->rmtxs + (int )bidx);
  if (tmp != 0) {
    tchdbsetecode(hdb, 1, "tchdb.c", 4884, "tchdbunlockrecord");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tchdblockallrecords(TCHDB *hdb , _Bool wr ) 
{ int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  i = 0;
  while (i <= 255) {
    if (wr) {
      tmp = pthread_rwlock_wrlock((pthread_rwlock_t *)hdb->rmtxs + i);
      tmp___1 = tmp != 0;
    } else {
      tmp___0 = pthread_rwlock_rdlock((pthread_rwlock_t *)hdb->rmtxs + i);
      tmp___1 = tmp___0 != 0;
    }
    if (tmp___1) {
      tchdbsetecode(hdb, 1, "tchdb.c", 4901, "tchdblockallrecords");
      while (1) {
        i --;
        if (! (i >= 0)) {
          break;
        }
        pthread_rwlock_unlock((pthread_rwlock_t *)hdb->rmtxs + i);
      }
      return ((_Bool)0);
    }
    i ++;
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tchdbunlockallrecords(TCHDB *hdb ) 
{ _Bool err ;
  int i ;
  int tmp ;

  {
  err = (_Bool)0;
  i = 255;
  while (i >= 0) {
    tmp = pthread_rwlock_unlock((pthread_rwlock_t *)hdb->rmtxs + i);
    if (tmp) {
      err = (_Bool)1;
    }
    i --;
  }
  while (1) {
    break;
  }
  if (err) {
    tchdbsetecode(hdb, 1, "tchdb.c", 4924, "tchdbunlockallrecords");
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static _Bool tchdblockdb(TCHDB *hdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)hdb->dmtx);
  if (tmp != 0) {
    tchdbsetecode(hdb, 1, "tchdb.c", 4937, "tchdblockdb");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tchdbunlockdb(TCHDB *hdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_unlock((pthread_mutex_t *)hdb->dmtx);
  if (tmp != 0) {
    tchdbsetecode(hdb, 1, "tchdb.c", 4951, "tchdbunlockdb");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tchdblockwal(TCHDB *hdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)hdb->wmtx);
  if (tmp != 0) {
    tchdbsetecode(hdb, 1, "tchdb.c", 4965, "tchdblockwal");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tchdbunlockwal(TCHDB *hdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_unlock((pthread_mutex_t *)hdb->wmtx);
  if (tmp != 0) {
    tchdbsetecode(hdb, 1, "tchdb.c", 4979, "tchdbunlockwal");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
void tchdbprintmeta(TCHDB *hdb ) 
{ int dbgfd ;
  int tmp ;
  char buf[8192] ;
  char *wp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  char *tmp___67 ;

  {
  if (hdb->dbgfd < 0) {
    return;
  }
  if (hdb->dbgfd == 65535) {
    tmp = 1;
  } else {
    tmp = hdb->dbgfd;
  }
  dbgfd = tmp;
  wp = buf;
  tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"META:");
  wp += tmp___0;
  tmp___1 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" mmtx=%p",
                    hdb->mmtx);
  wp += tmp___1;
  tmp___2 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rmtxs=%p",
                    hdb->rmtxs);
  wp += tmp___2;
  tmp___3 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" dmtx=%p",
                    hdb->dmtx);
  wp += tmp___3;
  tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" tmtx=%p",
                    hdb->tmtx);
  wp += tmp___4;
  tmp___5 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" wmtx=%p",
                    hdb->wmtx);
  wp += tmp___5;
  tmp___6 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" eckey=%p",
                    hdb->eckey);
  wp += tmp___6;
  if (hdb->rpath) {
    tmp___7 = (char const   *)hdb->rpath;
  } else {
    tmp___7 = "-";
  }
  tmp___8 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rpath=%s",
                    tmp___7);
  wp += tmp___8;
  tmp___9 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" type=%02X",
                    hdb->type);
  wp += tmp___9;
  tmp___10 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" flags=%02X",
                     hdb->flags);
  wp += tmp___10;
  tmp___11 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" bnum=%llu",
                     hdb->bnum);
  wp += tmp___11;
  tmp___12 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" apow=%u",
                     hdb->apow);
  wp += tmp___12;
  tmp___13 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" fpow=%u",
                     hdb->fpow);
  wp += tmp___13;
  tmp___14 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" opts=%u",
                     hdb->opts);
  wp += tmp___14;
  if (hdb->path) {
    tmp___15 = (char const   *)hdb->path;
  } else {
    tmp___15 = "-";
  }
  tmp___16 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" path=%s",
                     tmp___15);
  wp += tmp___16;
  tmp___17 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" fd=%d",
                     hdb->fd);
  wp += tmp___17;
  tmp___18 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" omode=%u",
                     hdb->omode);
  wp += tmp___18;
  tmp___19 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rnum=%llu",
                     hdb->rnum);
  wp += tmp___19;
  tmp___20 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" fsiz=%llu",
                     hdb->fsiz);
  wp += tmp___20;
  tmp___21 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" frec=%llu",
                     hdb->frec);
  wp += tmp___21;
  tmp___22 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" dfcur=%llu",
                     hdb->dfcur);
  wp += tmp___22;
  tmp___23 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" iter=%llu",
                     hdb->iter);
  wp += tmp___23;
  tmp___24 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" map=%p",
                     (void *)hdb->map);
  wp += tmp___24;
  tmp___25 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" msiz=%llu",
                     hdb->msiz);
  wp += tmp___25;
  tmp___26 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" ba32=%p",
                     (void *)hdb->ba32);
  wp += tmp___26;
  tmp___27 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" ba64=%p",
                     (void *)hdb->ba64);
  wp += tmp___27;
  tmp___28 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" align=%u",
                     hdb->align);
  wp += tmp___28;
  tmp___29 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" runit=%u",
                     hdb->runit);
  wp += tmp___29;
  tmp___30 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" zmode=%u",
                     hdb->zmode);
  wp += tmp___30;
  tmp___31 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" fbpmax=%d",
                     hdb->fbpmax);
  wp += tmp___31;
  tmp___32 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" fbpool=%p",
                     hdb->fbpool);
  wp += tmp___32;
  tmp___33 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" fbpnum=%d",
                     hdb->fbpnum);
  wp += tmp___33;
  tmp___34 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" fbpmis=%d",
                     hdb->fbpmis);
  wp += tmp___34;
  tmp___35 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" drpool=%p",
                     (void *)hdb->drpool);
  wp += tmp___35;
  tmp___36 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" drpdef=%p",
                     (void *)hdb->drpdef);
  wp += tmp___36;
  tmp___37 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" drpoff=%llu",
                     hdb->drpoff);
  wp += tmp___37;
  tmp___38 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" recc=%p",
                     (void *)hdb->recc);
  wp += tmp___38;
  tmp___39 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rcnum=%u",
                     hdb->rcnum);
  wp += tmp___39;
  tmp___40 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" ecode=%d",
                     hdb->ecode);
  wp += tmp___40;
  tmp___41 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" fatal=%u",
                     hdb->fatal);
  wp += tmp___41;
  tmp___42 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" inode=%llu",
                     hdb->inode);
  wp += tmp___42;
  tmp___43 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" mtime=%llu",
                     (unsigned long long )hdb->mtime);
  wp += tmp___43;
  tmp___44 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" dfunit=%u",
                     hdb->dfunit);
  wp += tmp___44;
  tmp___45 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" dfcnt=%u",
                     hdb->dfcnt);
  wp += tmp___45;
  tmp___46 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" tran=%d",
                     hdb->tran);
  wp += tmp___46;
  tmp___47 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" walfd=%d",
                     hdb->walfd);
  wp += tmp___47;
  tmp___48 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" walend=%llu",
                     hdb->walend);
  wp += tmp___48;
  tmp___49 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" dbgfd=%d",
                     hdb->dbgfd);
  wp += tmp___49;
  tmp___50 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_writerec=%lld",
                     hdb->cnt_writerec);
  wp += tmp___50;
  tmp___51 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_reuserec=%lld",
                     hdb->cnt_reuserec);
  wp += tmp___51;
  tmp___52 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_moverec=%lld",
                     hdb->cnt_moverec);
  wp += tmp___52;
  tmp___53 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_readrec=%lld",
                     hdb->cnt_readrec);
  wp += tmp___53;
  tmp___54 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_searchfbp=%lld",
                     hdb->cnt_searchfbp);
  wp += tmp___54;
  tmp___55 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_insertfbp=%lld",
                     hdb->cnt_insertfbp);
  wp += tmp___55;
  tmp___56 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_splicefbp=%lld",
                     hdb->cnt_splicefbp);
  wp += tmp___56;
  tmp___57 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_dividefbp=%lld",
                     hdb->cnt_dividefbp);
  wp += tmp___57;
  tmp___58 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_mergefbp=%lld",
                     hdb->cnt_mergefbp);
  wp += tmp___58;
  tmp___59 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_reducefbp=%lld",
                     hdb->cnt_reducefbp);
  wp += tmp___59;
  tmp___60 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_appenddrp=%lld",
                     hdb->cnt_appenddrp);
  wp += tmp___60;
  tmp___61 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_deferdrp=%lld",
                     hdb->cnt_deferdrp);
  wp += tmp___61;
  tmp___62 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_flushdrp=%lld",
                     hdb->cnt_flushdrp);
  wp += tmp___62;
  tmp___63 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_adjrecc=%lld",
                     hdb->cnt_adjrecc);
  wp += tmp___63;
  tmp___64 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_defrag=%lld",
                     hdb->cnt_defrag);
  wp += tmp___64;
  tmp___65 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_shiftrec=%lld",
                     hdb->cnt_shiftrec);
  wp += tmp___65;
  tmp___66 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_trunc=%lld",
                     hdb->cnt_trunc);
  wp += tmp___66;
  tmp___67 = wp;
  wp ++;
  *tmp___67 = (char )'\n';
  tcwrite(dbgfd, (void const   *)(buf), (unsigned int )(wp - buf));
  return;
}
}
void tchdbprintrec(TCHDB *hdb , TCHREC *rec ) 
{ int dbgfd ;
  int tmp ;
  char buf[8192] ;
  char *wp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;

  {
  if (hdb->dbgfd < 0) {
    return;
  }
  if (hdb->dbgfd == 65535) {
    tmp = 1;
  } else {
    tmp = hdb->dbgfd;
  }
  dbgfd = tmp;
  wp = buf;
  tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"REC:");
  wp += tmp___0;
  tmp___1 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" off=%llu",
                    rec->off);
  wp += tmp___1;
  tmp___2 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rsiz=%u",
                    rec->rsiz);
  wp += tmp___2;
  tmp___3 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" magic=%02X",
                    rec->magic);
  wp += tmp___3;
  tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" hash=%02X",
                    rec->hash);
  wp += tmp___4;
  tmp___5 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" left=%llu",
                    rec->left);
  wp += tmp___5;
  tmp___6 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" right=%llu",
                    rec->right);
  wp += tmp___6;
  tmp___7 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" ksiz=%u",
                    rec->ksiz);
  wp += tmp___7;
  tmp___8 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" vsiz=%u",
                    rec->vsiz);
  wp += tmp___8;
  tmp___9 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" psiz=%u",
                    rec->psiz);
  wp += tmp___9;
  tmp___10 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" kbuf=%p",
                     (void *)rec->kbuf);
  wp += tmp___10;
  tmp___11 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" vbuf=%p",
                     (void *)rec->vbuf);
  wp += tmp___11;
  tmp___12 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" boff=%llu",
                     rec->boff);
  wp += tmp___12;
  tmp___13 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" bbuf=%p",
                     (void *)rec->bbuf);
  wp += tmp___13;
  tmp___14 = wp;
  wp ++;
  *tmp___14 = (char )'\n';
  tcwrite(dbgfd, (void const   *)(buf), (unsigned int )(wp - buf));
  return;
}
}
#pragma merger(0,"/tmp/cil-fd3UlqpR.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
char const   *tcbdberrmsg(int ecode ) ;
TCBDB *tcbdbnew(void) ;
void tcbdbdel(TCBDB *bdb ) ;
int tcbdbecode(TCBDB *bdb ) ;
_Bool tcbdbsetmutex(TCBDB *bdb ) ;
_Bool tcbdbsetcmpfunc(TCBDB *bdb , int (*cmp)(char const   *aptr , int asiz , char const   *bptr ,
                                              int bsiz , void *op ) , void *cmpop ) ;
_Bool tcbdbtune(TCBDB *bdb , int32_t lmemb , int32_t nmemb , int64_t bnum , int8_t apow ,
                int8_t fpow , uint8_t opts ) ;
_Bool tcbdbsetcache(TCBDB *bdb , int32_t lcnum , int32_t ncnum ) ;
_Bool tcbdbsetxmsiz(TCBDB *bdb , int64_t xmsiz ) ;
_Bool tcbdbsetdfunit(TCBDB *bdb , int32_t dfunit ) ;
_Bool tcbdbopen(TCBDB *bdb , char const   *path , int omode ) ;
_Bool tcbdbclose(TCBDB *bdb ) ;
_Bool tcbdbput(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) ;
_Bool tcbdbput2(TCBDB *bdb , char const   *kstr , char const   *vstr ) ;
_Bool tcbdbputkeep(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) ;
_Bool tcbdbputkeep2(TCBDB *bdb , char const   *kstr , char const   *vstr ) ;
_Bool tcbdbputcat(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) ;
_Bool tcbdbputcat2(TCBDB *bdb , char const   *kstr , char const   *vstr ) ;
_Bool tcbdbputdup(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) ;
_Bool tcbdbputdup2(TCBDB *bdb , char const   *kstr , char const   *vstr ) ;
_Bool tcbdbputdup3(TCBDB *bdb , void const   *kbuf , int ksiz , TCLIST const   *vals ) ;
_Bool tcbdbout(TCBDB *bdb , void const   *kbuf , int ksiz ) ;
_Bool tcbdbout2(TCBDB *bdb , char const   *kstr ) ;
_Bool tcbdbout3(TCBDB *bdb , void const   *kbuf , int ksiz ) ;
void *tcbdbget(TCBDB *bdb , void const   *kbuf , int ksiz , int *sp ) ;
char *tcbdbget2(TCBDB *bdb , char const   *kstr ) ;
void const   *tcbdbget3(TCBDB *bdb , void const   *kbuf , int ksiz , int *sp ) ;
TCLIST *tcbdbget4(TCBDB *bdb , void const   *kbuf , int ksiz ) ;
int tcbdbvnum(TCBDB *bdb , void const   *kbuf , int ksiz ) ;
int tcbdbvnum2(TCBDB *bdb , char const   *kstr ) ;
int tcbdbvsiz(TCBDB *bdb , void const   *kbuf , int ksiz ) ;
int tcbdbvsiz2(TCBDB *bdb , char const   *kstr ) ;
TCLIST *tcbdbrange(TCBDB *bdb , void const   *bkbuf , int bksiz , _Bool binc , void const   *ekbuf ,
                   int eksiz , _Bool einc , int max ) ;
TCLIST *tcbdbrange2(TCBDB *bdb , char const   *bkstr , _Bool binc , char const   *ekstr ,
                    _Bool einc , int max ) ;
TCLIST *tcbdbfwmkeys(TCBDB *bdb , void const   *pbuf , int psiz , int max ) ;
TCLIST *tcbdbfwmkeys2(TCBDB *bdb , char const   *pstr , int max ) ;
int tcbdbaddint(TCBDB *bdb , void const   *kbuf , int ksiz , int num ) ;
double tcbdbadddouble(TCBDB *bdb , void const   *kbuf , int ksiz , double num ) ;
_Bool tcbdbsync(TCBDB *bdb ) ;
_Bool tcbdboptimize(TCBDB *bdb , int32_t lmemb , int32_t nmemb , int64_t bnum , int8_t apow ,
                    int8_t fpow , uint8_t opts ) ;
_Bool tcbdbvanish(TCBDB *bdb ) ;
_Bool tcbdbcopy(TCBDB *bdb , char const   *path ) ;
_Bool tcbdbtranbegin(TCBDB *bdb ) ;
_Bool tcbdbtrancommit(TCBDB *bdb ) ;
_Bool tcbdbtranabort(TCBDB *bdb ) ;
char const   *tcbdbpath(TCBDB *bdb ) ;
uint64_t tcbdbrnum(TCBDB *bdb ) ;
uint64_t tcbdbfsiz(TCBDB *bdb ) ;
BDBCUR *tcbdbcurnew(TCBDB *bdb ) ;
void tcbdbcurdel(BDBCUR *cur ) ;
_Bool tcbdbcurfirst(BDBCUR *cur ) ;
_Bool tcbdbcurlast(BDBCUR *cur ) ;
_Bool tcbdbcurjump(BDBCUR *cur , void const   *kbuf , int ksiz ) ;
_Bool tcbdbcurjump2(BDBCUR *cur , char const   *kstr ) ;
_Bool tcbdbcurprev(BDBCUR *cur ) ;
_Bool tcbdbcurnext(BDBCUR *cur ) ;
_Bool tcbdbcurput(BDBCUR *cur , void const   *vbuf , int vsiz , int cpmode ) ;
_Bool tcbdbcurput2(BDBCUR *cur , char const   *vstr , int cpmode ) ;
_Bool tcbdbcurout(BDBCUR *cur ) ;
void *tcbdbcurkey(BDBCUR *cur , int *sp ) ;
char *tcbdbcurkey2(BDBCUR *cur ) ;
void const   *tcbdbcurkey3(BDBCUR *cur , int *sp ) ;
void *tcbdbcurval(BDBCUR *cur , int *sp ) ;
char *tcbdbcurval2(BDBCUR *cur ) ;
void const   *tcbdbcurval3(BDBCUR *cur , int *sp ) ;
_Bool tcbdbcurrec(BDBCUR *cur , TCXSTR *kxstr , TCXSTR *vxstr ) ;
void tcbdbsetecode(TCBDB *bdb , int ecode , char const   *filename , int line , char const   *func ) ;
void tcbdbsetdbgfd(TCBDB *bdb , int fd ) ;
int tcbdbdbgfd(TCBDB *bdb ) ;
_Bool tcbdbhasmutex(TCBDB *bdb ) ;
_Bool tcbdbmemsync(TCBDB *bdb , _Bool phys ) ;
_Bool tcbdbcacheclear(TCBDB *bdb ) ;
TCCMP tcbdbcmpfunc(TCBDB *bdb ) ;
void *tcbdbcmpop(TCBDB *bdb ) ;
uint32_t tcbdblmemb(TCBDB *bdb ) ;
uint32_t tcbdbnmemb(TCBDB *bdb ) ;
uint64_t tcbdblnum(TCBDB *bdb ) ;
uint64_t tcbdbnnum(TCBDB *bdb ) ;
uint64_t tcbdbbnum(TCBDB *bdb ) ;
uint32_t tcbdbalign(TCBDB *bdb ) ;
uint32_t tcbdbfbpmax(TCBDB *bdb ) ;
uint64_t tcbdbinode(TCBDB *bdb ) ;
time_t tcbdbmtime(TCBDB *bdb ) ;
uint8_t tcbdbflags(TCBDB *bdb ) ;
uint8_t tcbdbopts(TCBDB *bdb ) ;
char *tcbdbopaque(TCBDB *bdb ) ;
uint64_t tcbdbbnumused(TCBDB *bdb ) ;
_Bool tcbdbsetlsmax(TCBDB *bdb , uint32_t lsmax ) ;
_Bool tcbdbsetcapnum(TCBDB *bdb , uint64_t capnum ) ;
_Bool tcbdbsetcodecfunc(TCBDB *bdb , void *(*enc)(void const   *ptr , int size , int *sp ,
                                                  void *op ) , void *encop , void *(*dec)(void const   *ptr ,
                                                                                          int size ,
                                                                                          int *sp ,
                                                                                          void *op ) ,
                        void *decop ) ;
uint32_t tcbdbdfunit(TCBDB *bdb ) ;
_Bool tcbdbdefrag(TCBDB *bdb , int64_t step ) ;
_Bool tcbdbputdupback(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                      int vsiz ) ;
_Bool tcbdbputdupback2(TCBDB *bdb , char const   *kstr , char const   *vstr ) ;
_Bool tcbdbputproc(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) ;
_Bool tcbdbcurjumpback(BDBCUR *cur , void const   *kbuf , int ksiz ) ;
_Bool tcbdbcurjumpback2(BDBCUR *cur , char const   *kstr ) ;
_Bool tcbdbforeach(TCBDB *bdb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                              int vsiz , void *op ) , void *op ) ;
static void tcbdbclear(TCBDB *bdb ) ;
static void tcbdbdumpmeta(TCBDB *bdb ) ;
static void tcbdbloadmeta(TCBDB *bdb ) ;
static BDBLEAF *tcbdbleafnew(TCBDB *bdb , uint64_t prev , uint64_t next ) ;
static _Bool tcbdbleafcacheout(TCBDB *bdb , BDBLEAF *leaf ) ;
static _Bool tcbdbleafsave(TCBDB *bdb , BDBLEAF *leaf ) ;
static BDBLEAF *tcbdbleafload(TCBDB *bdb , uint64_t id ) ;
static _Bool tcbdbleafcheck(TCBDB *bdb , uint64_t id ) ;
static BDBLEAF *tcbdbgethistleaf(TCBDB *bdb , char const   *kbuf , int ksiz , uint64_t id ) ;
static _Bool tcbdbleafaddrec(TCBDB *bdb , BDBLEAF *leaf , int dmode , char const   *kbuf ,
                             int ksiz , char const   *vbuf , int vsiz ) ;
static BDBLEAF *tcbdbleafdivide(TCBDB *bdb , BDBLEAF *leaf ) ;
static _Bool tcbdbleafkill(TCBDB *bdb , BDBLEAF *leaf ) ;
static BDBNODE *tcbdbnodenew(TCBDB *bdb , uint64_t heir ) ;
static _Bool tcbdbnodecacheout(TCBDB *bdb , BDBNODE *node ) ;
static _Bool tcbdbnodesave(TCBDB *bdb , BDBNODE *node ) ;
static BDBNODE *tcbdbnodeload(TCBDB *bdb , uint64_t id ) ;
static void tcbdbnodeaddidx(TCBDB *bdb , BDBNODE *node , _Bool order , uint64_t pid ,
                            char const   *kbuf , int ksiz ) ;
static _Bool tcbdbnodesubidx(TCBDB *bdb , BDBNODE *node , uint64_t pid ) ;
static uint64_t tcbdbsearchleaf(TCBDB *bdb , char const   *kbuf , int ksiz ) ;
static BDBREC *tcbdbsearchrec(TCBDB *bdb , BDBLEAF *leaf , char const   *kbuf , int ksiz ,
                              int *ip ) ;
static void tcbdbremoverec(TCBDB *bdb , BDBLEAF *leaf , BDBREC *rec , int ri ) ;
static _Bool tcbdbcacheadjust(TCBDB *bdb ) ;
static void tcbdbcachepurge(TCBDB *bdb ) ;
static _Bool tcbdbopenimpl(TCBDB *bdb , char const   *path , int omode ) ;
static _Bool tcbdbcloseimpl(TCBDB *bdb ) ;
static _Bool tcbdbputimpl(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                          int vsiz , int dmode ) ;
static _Bool tcbdboutimpl(TCBDB *bdb , char const   *kbuf , int ksiz ) ;
static _Bool tcbdboutlist(TCBDB *bdb , char const   *kbuf , int ksiz ) ;
static char const   *tcbdbgetimpl(TCBDB *bdb , char const   *kbuf , int ksiz , int *sp ) ;
static int tcbdbgetnum(TCBDB *bdb , char const   *kbuf , int ksiz ) ;
static TCLIST *tcbdbgetlist(TCBDB *bdb , char const   *kbuf , int ksiz ) ;
static _Bool tcbdbrangeimpl(TCBDB *bdb , char const   *bkbuf , int bksiz , _Bool binc ,
                            char const   *ekbuf , int eksiz , _Bool einc , int max ,
                            TCLIST *keys ) ;
static _Bool tcbdbrangefwm(TCBDB *bdb , char const   *pbuf , int psiz , int max ,
                           TCLIST *keys ) ;
static _Bool tcbdboptimizeimpl(TCBDB *bdb , int32_t lmemb , int32_t nmemb , int64_t bnum ,
                               int8_t apow , int8_t fpow , uint8_t opts ) ;
static _Bool tcbdbvanishimpl(TCBDB *bdb ) ;
static _Bool tcbdblockmethod(TCBDB *bdb , _Bool wr ) ;
static _Bool tcbdbunlockmethod(TCBDB *bdb ) ;
static _Bool tcbdblockcache(TCBDB *bdb ) ;
static _Bool tcbdbunlockcache(TCBDB *bdb ) ;
static _Bool tcbdbcurfirstimpl(BDBCUR *cur ) ;
static _Bool tcbdbcurlastimpl(BDBCUR *cur ) ;
static _Bool tcbdbcurjumpimpl(BDBCUR *cur , char const   *kbuf , int ksiz , _Bool forward ) ;
static _Bool tcbdbcuradjust(BDBCUR *cur , _Bool forward ) ;
static _Bool tcbdbcurprevimpl(BDBCUR *cur ) ;
static _Bool tcbdbcurnextimpl(BDBCUR *cur ) ;
static _Bool tcbdbcurputimpl(BDBCUR *cur , char const   *vbuf , int vsiz , int cpmode ) ;
static _Bool tcbdbcuroutimpl(BDBCUR *cur ) ;
static _Bool tcbdbcurrecimpl(BDBCUR *cur , char const   **kbp , int *ksp , char const   **vbp ,
                             int *vsp ) ;
static _Bool tcbdbforeachimpl(TCBDB *bdb , _Bool (*iter)(void const   *kbuf , int ksiz ,
                                                         void const   *vbuf , int vsiz ,
                                                         void *op ) , void *op ) ;
void tcbdbprintmeta(TCBDB *bdb ) ;
void tcbdbprintleaf(TCBDB *bdb , BDBLEAF *leaf ) ;
void tcbdbprintnode(TCBDB *bdb , BDBNODE *node ) ;
char const   *tcbdberrmsg(int ecode ) 
{ char const   *tmp ;

  {
  tmp = tcerrmsg(ecode);
  return (tmp);
}
}
TCBDB *tcbdbnew(void) 
{ TCBDB *bdb ;
  void *tmp ;
  uint64_t *tmp___0 ;
  void *tmp___1 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*bdb)));
    bdb = (TCBDB *)tmp;
    if (! bdb) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tcbdbclear(bdb);
  bdb->hdb = tchdbnew();
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(*(bdb->hist)) * 64));
    tmp___0 = (uint64_t *)tmp___1;
    bdb->hist = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tchdbtune(bdb->hdb, 32749LL, (signed char)8, (signed char)10, (unsigned char)0);
  tchdbsetxmsiz(bdb->hdb, 0LL);
  return (bdb);
}
}
void tcbdbdel(TCBDB *bdb ) 
{ 

  {
  if (bdb->open) {
    tcbdbclose(bdb);
  }
  while (1) {
    free((void *)bdb->hist);
    break;
  }
  tchdbdel(bdb->hdb);
  if (bdb->mmtx) {
    pthread_mutex_destroy((pthread_mutex_t *)bdb->cmtx);
    pthread_rwlock_destroy((pthread_rwlock_t *)bdb->mmtx);
    while (1) {
      free(bdb->cmtx);
      break;
    }
    while (1) {
      free(bdb->mmtx);
      break;
    }
  }
  while (1) {
    free((void *)bdb);
    break;
  }
  return;
}
}
int tcbdbecode(TCBDB *bdb ) 
{ int tmp ;

  {
  tmp = tchdbecode(bdb->hdb);
  return (tmp);
}
}
_Bool tcbdbsetmutex(TCBDB *bdb ) 
{ void *tmp ;
  void *tmp___0 ;
  _Bool err ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  if (bdb->mmtx) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 216, "tcbdbsetmutex");
    return ((_Bool)0);
  } else {
    if (bdb->open) {
      tcbdbsetecode(bdb, 2, "tcbdb.c", 216, "tcbdbsetmutex");
      return ((_Bool)0);
    }
  }
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(pthread_rwlock_t )));
    bdb->mmtx = tmp;
    if (! tmp) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___0 = malloc((unsigned int )((int )sizeof(pthread_mutex_t )));
    bdb->cmtx = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  err = (_Bool)0;
  tmp___1 = pthread_rwlock_init((pthread_rwlock_t * __restrict  )bdb->mmtx, (pthread_rwlockattr_t const   * __restrict  )((void *)0));
  if (tmp___1 != 0) {
    err = (_Bool)1;
  }
  tmp___2 = pthread_mutex_init((pthread_mutex_t *)bdb->cmtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___2 != 0) {
    err = (_Bool)1;
  }
  if (err) {
    while (1) {
      free(bdb->cmtx);
      break;
    }
    while (1) {
      free(bdb->mmtx);
      break;
    }
    bdb->cmtx = (void *)0;
    bdb->mmtx = (void *)0;
    return ((_Bool)0);
  }
  tmp___3 = tchdbsetmutex(bdb->hdb);
  return (tmp___3);
}
}
_Bool tcbdbsetcmpfunc(TCBDB *bdb , int (*cmp)(char const   *aptr , int asiz , char const   *bptr ,
                                              int bsiz , void *op ) , void *cmpop ) 
{ 

  {
  if (bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 239, "tcbdbsetcmpfunc");
    return ((_Bool)0);
  }
  bdb->cmp = cmp;
  bdb->cmpop = cmpop;
  return ((_Bool)1);
}
}
_Bool tcbdbtune(TCBDB *bdb , int32_t lmemb , int32_t nmemb , int64_t bnum , int8_t apow ,
                int8_t fpow , uint8_t opts ) 
{ long tmp ;
  long tmp___0 ;
  uint8_t hopts ;
  _Bool tmp___1 ;

  {
  if (bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 253, "tcbdbtune");
    return ((_Bool)0);
  }
  if (lmemb > 0) {
    tmp = tclmax((long )lmemb, 4L);
    bdb->lmemb = (unsigned int )tmp;
  } else {
    bdb->lmemb = 128U;
  }
  if (nmemb > 0) {
    tmp___0 = tclmax((long )nmemb, 4L);
    bdb->nmemb = (unsigned int )tmp___0;
  } else {
    bdb->nmemb = 256U;
  }
  bdb->opts = opts;
  hopts = (unsigned char)0;
  if ((int )opts & 1) {
    hopts = (unsigned char )((int )hopts | 1);
  }
  if ((int )opts & 2) {
    hopts = (unsigned char )((int )hopts | 2);
  }
  if ((int )opts & 4) {
    hopts = (unsigned char )((int )hopts | 4);
  }
  if ((int )opts & 8) {
    hopts = (unsigned char )((int )hopts | 8);
  }
  if ((int )opts & 16) {
    hopts = (unsigned char )((int )hopts | 16);
  }
  if (bnum > 0LL) {
    bnum = bnum;
  } else {
    bnum = 32749LL;
  }
  if ((int )apow >= 0) {
    apow = apow;
  } else {
    apow = (signed char)8;
  }
  if ((int )fpow >= 0) {
    fpow = fpow;
  } else {
    fpow = (signed char)10;
  }
  tmp___1 = tchdbtune(bdb->hdb, bnum, apow, fpow, hopts);
  return (tmp___1);
}
}
_Bool tcbdbsetcache(TCBDB *bdb , int32_t lcnum , int32_t ncnum ) 
{ long tmp ;
  long tmp___0 ;

  {
  if (bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 276, "tcbdbsetcache");
    return ((_Bool)0);
  }
  if (lcnum > 0) {
    tmp = tclmax((long )lcnum, 64L);
    bdb->lcnum = (unsigned int )tmp;
  }
  if (ncnum > 0) {
    tmp___0 = tclmax((long )ncnum, 64L);
    bdb->ncnum = (unsigned int )tmp___0;
  }
  return ((_Bool)1);
}
}
_Bool tcbdbsetxmsiz(TCBDB *bdb , int64_t xmsiz ) 
{ _Bool tmp ;

  {
  if (bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 289, "tcbdbsetxmsiz");
    return ((_Bool)0);
  }
  tmp = tchdbsetxmsiz(bdb->hdb, xmsiz);
  return (tmp);
}
}
_Bool tcbdbsetdfunit(TCBDB *bdb , int32_t dfunit ) 
{ _Bool tmp ;

  {
  if (bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 300, "tcbdbsetdfunit");
    return ((_Bool)0);
  }
  tmp = tchdbsetdfunit(bdb->hdb, dfunit);
  return (tmp);
}
}
_Bool tcbdbopen(TCBDB *bdb , char const   *path , int omode ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 312, "tcbdbopen");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcbdbopenimpl(bdb, path, omode);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbclose(TCBDB *bdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 327, "tcbdbclose");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcbdbcloseimpl(bdb);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbput(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 342, "tcbdbput");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___1 = tcbdbputimpl(bdb, kbuf, ksiz, vbuf, vsiz, 0);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbput2(TCBDB *bdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcbdbput(bdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                     (int )tmp);
  return (tmp___1);
}
}
_Bool tcbdbputkeep(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 364, "tcbdbputkeep");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___1 = tcbdbputimpl(bdb, kbuf, ksiz, vbuf, vsiz, 1);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbputkeep2(TCBDB *bdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcbdbputkeep(bdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                         (int )tmp);
  return (tmp___1);
}
}
_Bool tcbdbputcat(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 386, "tcbdbputcat");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___1 = tcbdbputimpl(bdb, kbuf, ksiz, vbuf, vsiz, 2);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbputcat2(TCBDB *bdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcbdbputcat(bdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                        (int )tmp);
  return (tmp___1);
}
}
_Bool tcbdbputdup(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 408, "tcbdbputdup");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___1 = tcbdbputimpl(bdb, kbuf, ksiz, vbuf, vsiz, 3);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbputdup2(TCBDB *bdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcbdbputdup(bdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                        (int )tmp);
  return (tmp___1);
}
}
_Bool tcbdbputdup3(TCBDB *bdb , void const   *kbuf , int ksiz , TCLIST const   *vals ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  int ln ;
  int i ;
  char const   *vbuf ;
  int vsiz ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 430, "tcbdbputdup3");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  ln = (int )vals->num;
  i = 0;
  while (i < ln) {
    while (1) {
      vbuf = (char const   *)(vals->array + (i + (int )vals->start))->ptr;
      vsiz = (vals->array + (i + (int )vals->start))->size;
      break;
    }
    tmp___1 = tcbdbputimpl(bdb, kbuf, ksiz, (void const   *)vbuf, vsiz, 3);
    if (! tmp___1) {
      err = (_Bool)1;
    }
    i ++;
  }
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return ((_Bool )(! err));
}
}
_Bool tcbdbout(TCBDB *bdb , void const   *kbuf , int ksiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 452, "tcbdbout");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___1 = tcbdboutimpl(bdb, (char const   *)kbuf, ksiz);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbout2(TCBDB *bdb , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcbdbout(bdb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
_Bool tcbdbout3(TCBDB *bdb , void const   *kbuf , int ksiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 474, "tcbdbout3");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___1 = tcbdboutlist(bdb, (char const   *)kbuf, ksiz);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
void *tcbdbget(TCBDB *bdb , void const   *kbuf , int ksiz , int *sp ) 
{ _Bool tmp ;
  int tmp___0 ;
  char const   *vbuf ;
  char const   *tmp___1 ;
  char *rv ;
  void *tmp___2 ;
  _Bool adj ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((void *)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 489, "tcbdbget");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((void *)0);
  }
  tmp___1 = tcbdbgetimpl(bdb, (char const   *)kbuf, ksiz, sp);
  vbuf = tmp___1;
  if (vbuf) {
    while (1) {
      while (1) {
        tmp___2 = malloc((unsigned int )(*sp + 1));
        rv = (char *)tmp___2;
        if (! rv) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )rv, (void const   * __restrict  )vbuf, (unsigned int )*sp);
      *(rv + *sp) = (char )'\000';
      break;
    }
  } else {
    rv = (char *)((void *)0);
  }
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    tmp___3 = 1;
  } else {
    if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  }
  adj = (_Bool )tmp___3;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (adj) {
    if (bdb->mmtx) {
      tmp___5 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___6 = (int )tmp___5;
    } else {
      tmp___6 = 1;
    }
    if (tmp___6) {
      if (! bdb->tran) {
        tmp___4 = tcbdbcacheadjust(bdb);
        if (! tmp___4) {
          while (1) {
            free((void *)rv);
            break;
          }
          rv = (char *)((void *)0);
        }
      }
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    }
  }
  return ((void *)rv);
}
}
char *tcbdbget2(TCBDB *bdb , char const   *kstr ) 
{ int vsiz ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcbdbget(bdb, (void const   *)kstr, (int )tmp, & vsiz);
  return ((char *)tmp___0);
}
}
void const   *tcbdbget3(TCBDB *bdb , void const   *kbuf , int ksiz , int *sp ) 
{ _Bool tmp ;
  int tmp___0 ;
  char const   *rv ;
  char const   *tmp___1 ;
  _Bool adj ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((void const   *)((void *)0));
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 526, "tcbdbget3");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((void const   *)((void *)0));
  }
  tmp___1 = tcbdbgetimpl(bdb, (char const   *)kbuf, ksiz, sp);
  rv = tmp___1;
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    tmp___2 = 1;
  } else {
    if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  adj = (_Bool )tmp___2;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (adj) {
    if (bdb->mmtx) {
      tmp___4 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___5 = (int )tmp___4;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      if (! bdb->tran) {
        tmp___3 = tcbdbcacheadjust(bdb);
        if (! tmp___3) {
          rv = (char const   *)((void *)0);
        }
      }
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    }
  }
  return ((void const   *)rv);
}
}
TCLIST *tcbdbget4(TCBDB *bdb , void const   *kbuf , int ksiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  TCLIST *rv ;
  TCLIST *tmp___1 ;
  _Bool adj ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((TCLIST *)((void *)0));
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 546, "tcbdbget4");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((TCLIST *)((void *)0));
  }
  tmp___1 = tcbdbgetlist(bdb, (char const   *)kbuf, ksiz);
  rv = tmp___1;
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    tmp___2 = 1;
  } else {
    if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  adj = (_Bool )tmp___2;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (adj) {
    if (bdb->mmtx) {
      tmp___4 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___5 = (int )tmp___4;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      if (! bdb->tran) {
        tmp___3 = tcbdbcacheadjust(bdb);
        if (! tmp___3) {
          if (rv) {
            tclistdel(rv);
          }
          rv = (TCLIST *)((void *)0);
        }
      }
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    }
  }
  return (rv);
}
}
int tcbdbvnum(TCBDB *bdb , void const   *kbuf , int ksiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  int rv ;
  int tmp___1 ;
  _Bool adj ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 569, "tcbdbvnum");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return (0);
  }
  tmp___1 = tcbdbgetnum(bdb, (char const   *)kbuf, ksiz);
  rv = tmp___1;
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    tmp___2 = 1;
  } else {
    if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  adj = (_Bool )tmp___2;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (adj) {
    if (bdb->mmtx) {
      tmp___4 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___5 = (int )tmp___4;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      if (! bdb->tran) {
        tmp___3 = tcbdbcacheadjust(bdb);
        if (! tmp___3) {
          rv = 0;
        }
      }
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    }
  }
  return (rv);
}
}
int tcbdbvnum2(TCBDB *bdb , char const   *kstr ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcbdbvnum(bdb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
int tcbdbvsiz(TCBDB *bdb , void const   *kbuf , int ksiz ) 
{ int vsiz ;
  void const   *tmp ;

  {
  tmp = tcbdbget3(bdb, kbuf, ksiz, & vsiz);
  if (! tmp) {
    return (-1);
  }
  return (vsiz);
}
}
int tcbdbvsiz2(TCBDB *bdb , char const   *kstr ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcbdbvsiz(bdb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
TCLIST *tcbdbrange(TCBDB *bdb , void const   *bkbuf , int bksiz , _Bool binc , void const   *ekbuf ,
                   int eksiz , _Bool einc , int max ) 
{ TCLIST *keys ;
  TCLIST *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool adj ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;

  {
  tmp = tclistnew();
  keys = tmp;
  if (bdb->mmtx) {
    tmp___0 = tcbdblockmethod(bdb, (_Bool)0);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    return (keys);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 614, "tcbdbrange");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return (keys);
  }
  tcbdbrangeimpl(bdb, (char const   *)bkbuf, bksiz, binc, (char const   *)ekbuf, eksiz,
                 einc, max, keys);
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    tmp___2 = 1;
  } else {
    if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  adj = (_Bool )tmp___2;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (adj) {
    if (bdb->mmtx) {
      tmp___3 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___4 = (int )tmp___3;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      tcbdbcacheadjust(bdb);
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    }
  }
  return (keys);
}
}
TCLIST *tcbdbrange2(TCBDB *bdb , char const   *bkstr , _Bool binc , char const   *ekstr ,
                    _Bool einc , int max ) 
{ size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  TCLIST *tmp___3 ;

  {
  if (ekstr) {
    tmp = strlen(ekstr);
    tmp___0 = tmp;
  } else {
    tmp___0 = 0U;
  }
  if (bkstr) {
    tmp___1 = strlen(bkstr);
    tmp___2 = tmp___1;
  } else {
    tmp___2 = 0U;
  }
  tmp___3 = tcbdbrange(bdb, (void const   *)bkstr, (int )tmp___2, binc, (void const   *)ekstr,
                       (int )tmp___0, einc, max);
  return (tmp___3);
}
}
TCLIST *tcbdbfwmkeys(TCBDB *bdb , void const   *pbuf , int psiz , int max ) 
{ TCLIST *keys ;
  TCLIST *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool adj ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;

  {
  tmp = tclistnew();
  keys = tmp;
  if (bdb->mmtx) {
    tmp___0 = tcbdblockmethod(bdb, (_Bool)0);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    return (keys);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 644, "tcbdbfwmkeys");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return (keys);
  }
  tcbdbrangefwm(bdb, (char const   *)pbuf, psiz, max, keys);
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    tmp___2 = 1;
  } else {
    if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  adj = (_Bool )tmp___2;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (adj) {
    if (bdb->mmtx) {
      tmp___3 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___4 = (int )tmp___3;
    } else {
      tmp___4 = 1;
    }
    if (tmp___4) {
      tcbdbcacheadjust(bdb);
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    }
  }
  return (keys);
}
}
TCLIST *tcbdbfwmkeys2(TCBDB *bdb , char const   *pstr , int max ) 
{ size_t tmp ;
  TCLIST *tmp___0 ;

  {
  tmp = strlen(pstr);
  tmp___0 = tcbdbfwmkeys(bdb, (void const   *)pstr, (int )tmp, max);
  return (tmp___0);
}
}
int tcbdbaddint(TCBDB *bdb , void const   *kbuf , int ksiz , int num ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((-0x7FFFFFFF-1));
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 671, "tcbdbaddint");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((-0x7FFFFFFF-1));
    }
  }
  tmp___1 = tcbdbputimpl(bdb, kbuf, ksiz, (void const   *)((char *)(& num)), (int )sizeof(num),
                         5);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (rv) {
    tmp___2 = num;
  } else {
    tmp___2 = (-0x7FFFFFFF-1);
  }
  return (tmp___2);
}
}
double tcbdbadddouble(TCBDB *bdb , void const   *kbuf , int ksiz , double num ) 
{ double tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  _Bool rv ;
  _Bool tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
  if (bdb->mmtx) {
    tmp___0 = tcbdblockmethod(bdb, (_Bool)1);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    tmp = nan("");
    return (tmp);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 686, "tcbdbadddouble");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      tmp___2 = nan("");
      return (tmp___2);
    }
  }
  tmp___3 = tcbdbputimpl(bdb, kbuf, ksiz, (void const   *)((char *)(& num)), (int )sizeof(num),
                         6);
  rv = tmp___3;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (rv) {
    tmp___5 = num;
  } else {
    tmp___4 = nan("");
    tmp___5 = tmp___4;
  }
  return (tmp___5);
}
}
_Bool tcbdbsync(TCBDB *bdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      goto _L;
    } else {
      if (bdb->tran) {
        _L: 
        tcbdbsetecode(bdb, 2, "tcbdb.c", 701, "tcbdbsync");
        if (bdb->mmtx) {
          tcbdbunlockmethod(bdb);
        }
        return ((_Bool)0);
      }
    }
  }
  tmp___1 = tcbdbmemsync(bdb, (_Bool)1);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdboptimize(TCBDB *bdb , int32_t lmemb , int32_t nmemb , int64_t bnum , int8_t apow ,
                    int8_t fpow , uint8_t opts ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      goto _L;
    } else {
      if (bdb->tran) {
        _L: 
        tcbdbsetecode(bdb, 2, "tcbdb.c", 717, "tcbdboptimize");
        if (bdb->mmtx) {
          tcbdbunlockmethod(bdb);
        }
        return ((_Bool)0);
      }
    }
  }
  while (1) {
    if (bdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___1 = tcbdboptimizeimpl(bdb, lmemb, nmemb, bnum, apow, fpow, opts);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbvanish(TCBDB *bdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      goto _L;
    } else {
      if (bdb->tran) {
        _L: 
        tcbdbsetecode(bdb, 2, "tcbdb.c", 733, "tcbdbvanish");
        if (bdb->mmtx) {
          tcbdbunlockmethod(bdb);
        }
        return ((_Bool)0);
      }
    }
  }
  while (1) {
    if (bdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___1 = tcbdbvanishimpl(bdb);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbcopy(TCBDB *bdb , char const   *path ) 
{ _Bool tmp ;
  int tmp___0 ;
  TCLIST *lids ;
  TCLIST *tmp___1 ;
  TCLIST *nids ;
  TCLIST *tmp___2 ;
  char const   *vbuf ;
  int vsiz ;
  TCMAP *leafc ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___3 ;
  void *tmp___4 ;
  TCLISTDATUM *array ;
  char *tmp___5 ;
  void *tmp___6 ;
  void const   *tmp___7 ;
  TCMAP *nodec ;
  int TC_mysize___0 ;
  int TC_index___0 ;
  TCLISTDATUM *tmp___8 ;
  void *tmp___9 ;
  TCLISTDATUM *array___0 ;
  char *tmp___10 ;
  void *tmp___11 ;
  void const   *tmp___12 ;
  _Bool err ;
  int ln ;
  int i ;
  int rsiz ;
  BDBLEAF *leaf ;
  void const   *tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  int i___0 ;
  int rsiz___0 ;
  BDBNODE *node ;
  void const   *tmp___17 ;
  _Bool tmp___18 ;
  _Bool tmp___19 ;
  int tmp___20 ;
  _Bool tmp___21 ;
  _Bool tmp___22 ;
  _Bool tmp___23 ;
  int tmp___24 ;
  _Bool tmp___25 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 749, "tcbdbcopy");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  while (1) {
    if (bdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___1 = tclistnew();
  lids = tmp___1;
  tmp___2 = tclistnew();
  nids = tmp___2;
  leafc = bdb->leafc;
  tcmapiterinit(leafc);
  while (1) {
    tmp___7 = tcmapiternext(leafc, & vsiz);
    vbuf = (char const   *)tmp___7;
    if (! ((unsigned int )vbuf != (unsigned int )((void *)0))) {
      break;
    }
    while (1) {
      TC_mysize = vsiz;
      TC_index = lids->start + lids->num;
      if (TC_index >= lids->anum) {
        lids->anum += lids->num + 1;
        while (1) {
          tmp___4 = realloc((void *)lids->array, (unsigned int )(lids->anum * (int )sizeof(*(lids->array + 0))));
          tmp___3 = (TCLISTDATUM *)tmp___4;
          lids->array = tmp___3;
          if (! tmp___3) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array = lids->array;
      while (1) {
        tmp___6 = malloc((unsigned int )(TC_mysize + 1));
        tmp___5 = (char *)tmp___6;
        (array + TC_index)->ptr = tmp___5;
        if (! tmp___5) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )vbuf,
             (unsigned int )TC_mysize);
      *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
      (array + TC_index)->size = TC_mysize;
      (lids->num) ++;
      break;
    }
  }
  nodec = bdb->nodec;
  tcmapiterinit(nodec);
  while (1) {
    tmp___12 = tcmapiternext(nodec, & vsiz);
    vbuf = (char const   *)tmp___12;
    if (! ((unsigned int )vbuf != (unsigned int )((void *)0))) {
      break;
    }
    while (1) {
      TC_mysize___0 = vsiz;
      TC_index___0 = nids->start + nids->num;
      if (TC_index___0 >= nids->anum) {
        nids->anum += nids->num + 1;
        while (1) {
          tmp___9 = realloc((void *)nids->array, (unsigned int )(nids->anum * (int )sizeof(*(nids->array + 0))));
          tmp___8 = (TCLISTDATUM *)tmp___9;
          nids->array = tmp___8;
          if (! tmp___8) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array___0 = nids->array;
      while (1) {
        tmp___11 = malloc((unsigned int )(TC_mysize___0 + 1));
        tmp___10 = (char *)tmp___11;
        (array___0 + TC_index___0)->ptr = tmp___10;
        if (! tmp___10) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array___0 + TC_index___0)->ptr, (void const   * __restrict  )vbuf,
             (unsigned int )TC_mysize___0);
      *((array___0 + TC_index___0)->ptr + TC_mysize___0) = (char )'\000';
      (array___0 + TC_index___0)->size = TC_mysize___0;
      (nids->num) ++;
      break;
    }
  }
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  err = (_Bool)0;
  ln = lids->num;
  i = 0;
  while (i < ln) {
    vbuf = (char const   *)((void *)(lids->array + (i + lids->start))->ptr);
    if (bdb->mmtx) {
      tmp___15 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___16 = (int )tmp___15;
    } else {
      tmp___16 = 1;
    }
    if (tmp___16) {
      while (1) {
        if (bdb->mmtx) {
          sched_yield();
        }
        break;
      }
      if (bdb->open) {
        tmp___13 = tcmapget((TCMAP const   *)bdb->leafc, (void const   *)vbuf, (int )sizeof(leaf->id),
                            & rsiz);
        leaf = (BDBLEAF *)tmp___13;
        if (leaf) {
          if (leaf->dirty) {
            tmp___14 = tcbdbleafsave(bdb, leaf);
            if (! tmp___14) {
              err = (_Bool)1;
            }
          }
        }
      } else {
        err = (_Bool)1;
      }
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    } else {
      err = (_Bool)1;
    }
    i ++;
  }
  ln = nids->num;
  i___0 = 0;
  while (i___0 < ln) {
    vbuf = (char const   *)((void *)(nids->array + (i___0 + nids->start))->ptr);
    if (bdb->mmtx) {
      tmp___19 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___20 = (int )tmp___19;
    } else {
      tmp___20 = 1;
    }
    if (tmp___20) {
      if (bdb->open) {
        tmp___17 = tcmapget((TCMAP const   *)bdb->nodec, (void const   *)vbuf, (int )sizeof(node->id),
                            & rsiz___0);
        node = (BDBNODE *)tmp___17;
        if (node) {
          if (node->dirty) {
            tmp___18 = tcbdbnodesave(bdb, node);
            if (! tmp___18) {
              err = (_Bool)1;
            }
          }
        }
      } else {
        err = (_Bool)1;
      }
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    } else {
      err = (_Bool)1;
    }
    i___0 ++;
  }
  tclistdel(nids);
  tclistdel(lids);
  tmp___21 = tcbdbtranbegin(bdb);
  if (! tmp___21) {
    err = (_Bool)1;
  }
  if (bdb->mmtx) {
    tmp___23 = tcbdblockmethod(bdb, (_Bool)0);
    tmp___24 = (int )tmp___23;
  } else {
    tmp___24 = 1;
  }
  if (tmp___24) {
    while (1) {
      if (bdb->mmtx) {
        sched_yield();
      }
      break;
    }
    tmp___22 = tchdbcopy(bdb->hdb, path);
    if (! tmp___22) {
      err = (_Bool)1;
    }
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
  } else {
    err = (_Bool)1;
  }
  tmp___25 = tcbdbtrancommit(bdb);
  if (! tmp___25) {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
_Bool tcbdbtranbegin(TCBDB *bdb ) 
{ double wsec ;
  long tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;

  {
  tmp = sysconf(2);
  wsec = 1.0 / (double )tmp;
  while (1) {
    if (bdb->mmtx) {
      tmp___0 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___1 = (int )tmp___0;
    } else {
      tmp___1 = 1;
    }
    if (! tmp___1) {
      return ((_Bool)0);
    }
    if (! bdb->open) {
      goto _L;
    } else {
      if (! bdb->wmode) {
        _L: 
        tcbdbsetecode(bdb, 2, "tcbdb.c", 824, "tcbdbtranbegin");
        if (bdb->mmtx) {
          tcbdbunlockmethod(bdb);
        }
        return ((_Bool)0);
      }
    }
    if (! bdb->tran) {
      break;
    }
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    if (wsec > 1.0) {
      wsec = 1.0;
    }
    tcsleep(wsec);
    wsec *= (double )2;
  }
  tmp___2 = tcbdbmemsync(bdb, (_Bool)0);
  if (! tmp___2) {
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___3 = tchdbtranbegin(bdb->hdb);
  if (! tmp___3) {
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  bdb->tran = (_Bool)1;
  while (1) {
    while (1) {
      tmp___5 = malloc(65U);
      tmp___4 = (char *)tmp___5;
      bdb->rbopaque = tmp___4;
      if (! tmp___4) {
        tcmyfatal("out of memory");
      }
      break;
    }
    memcpy((void * __restrict  )bdb->rbopaque, (void const   * __restrict  )bdb->opaque,
           64U);
    *(bdb->rbopaque + 64) = (char )'\000';
    break;
  }
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return ((_Bool)1);
}
}
_Bool tcbdbtrancommit(TCBDB *bdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      goto _L;
    } else {
      if (! bdb->tran) {
        _L: 
        tcbdbsetecode(bdb, 2, "tcbdb.c", 853, "tcbdbtrancommit");
        if (bdb->mmtx) {
          tcbdbunlockmethod(bdb);
        }
        return ((_Bool)0);
      }
    }
  }
  while (1) {
    free((void *)bdb->rbopaque);
    break;
  }
  bdb->tran = (_Bool)0;
  bdb->rbopaque = (char *)((void *)0);
  err = (_Bool)0;
  tmp___1 = tcbdbmemsync(bdb, (_Bool)0);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  tmp___2 = tcbdbcacheadjust(bdb);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  if (err) {
    tchdbtranabort(bdb->hdb);
  } else {
    tmp___3 = tchdbtrancommit(bdb->hdb);
    if (! tmp___3) {
      err = (_Bool)1;
    }
  }
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return ((_Bool )(! err));
}
}
_Bool tcbdbtranabort(TCBDB *bdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      goto _L;
    } else {
      if (! bdb->tran) {
        _L: 
        tcbdbsetecode(bdb, 2, "tcbdb.c", 878, "tcbdbtranabort");
        if (bdb->mmtx) {
          tcbdbunlockmethod(bdb);
        }
        return ((_Bool)0);
      }
    }
  }
  tcbdbcachepurge(bdb);
  memcpy((void * __restrict  )bdb->opaque, (void const   * __restrict  )bdb->rbopaque,
         64U);
  tcbdbloadmeta(bdb);
  while (1) {
    free((void *)bdb->rbopaque);
    break;
  }
  bdb->tran = (_Bool)0;
  bdb->rbopaque = (char *)((void *)0);
  bdb->hleaf = 0ULL;
  bdb->lleaf = 0ULL;
  (bdb->clock) ++;
  err = (_Bool)0;
  tmp___1 = tcbdbcacheadjust(bdb);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  tmp___2 = tchdbtranvoid(bdb->hdb);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return ((_Bool )(! err));
}
}
char const   *tcbdbpath(TCBDB *bdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  char const   *rv ;
  char const   *tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((char const   *)((void *)0));
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 904, "tcbdbpath");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((char const   *)((void *)0));
  }
  tmp___1 = tchdbpath(bdb->hdb);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
uint64_t tcbdbrnum(TCBDB *bdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint64_t rv ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0ULL);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 919, "tcbdbrnum");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return (0ULL);
  }
  rv = bdb->rnum;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
uint64_t tcbdbfsiz(TCBDB *bdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint64_t rv ;
  uint64_t tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0ULL);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 934, "tcbdbfsiz");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return (0ULL);
  }
  tmp___1 = tchdbfsiz(bdb->hdb);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
BDBCUR *tcbdbcurnew(TCBDB *bdb ) 
{ BDBCUR *cur ;
  void *tmp ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*cur)));
    cur = (BDBCUR *)tmp;
    if (! cur) {
      tcmyfatal("out of memory");
    }
    break;
  }
  cur->bdb = bdb;
  cur->clock = 0ULL;
  cur->id = 0ULL;
  cur->kidx = 0;
  cur->vidx = 0;
  return (cur);
}
}
void tcbdbcurdel(BDBCUR *cur ) 
{ 

  {
  while (1) {
    free((void *)cur);
    break;
  }
  return;
}
}
_Bool tcbdbcurfirst(BDBCUR *cur ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;
  _Bool adj ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 971, "tcbdbcurfirst");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcbdbcurfirstimpl(cur);
  rv = tmp___1;
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    tmp___2 = 1;
  } else {
    if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  adj = (_Bool )tmp___2;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (adj) {
    if (bdb->mmtx) {
      tmp___4 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___5 = (int )tmp___4;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      if (! bdb->tran) {
        tmp___3 = tcbdbcacheadjust(bdb);
        if (! tmp___3) {
          rv = (_Bool)0;
        }
      }
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    }
  }
  return (rv);
}
}
_Bool tcbdbcurlast(BDBCUR *cur ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;
  _Bool adj ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 992, "tcbdbcurlast");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcbdbcurlastimpl(cur);
  rv = tmp___1;
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    tmp___2 = 1;
  } else {
    if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  adj = (_Bool )tmp___2;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (adj) {
    if (bdb->mmtx) {
      tmp___4 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___5 = (int )tmp___4;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      if (! bdb->tran) {
        tmp___3 = tcbdbcacheadjust(bdb);
        if (! tmp___3) {
          rv = (_Bool)0;
        }
      }
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    }
  }
  return (rv);
}
}
_Bool tcbdbcurjump(BDBCUR *cur , void const   *kbuf , int ksiz ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;
  _Bool adj ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1013, "tcbdbcurjump");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcbdbcurjumpimpl(cur, (char const   *)kbuf, ksiz, (_Bool)1);
  rv = tmp___1;
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    tmp___2 = 1;
  } else {
    if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  adj = (_Bool )tmp___2;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (adj) {
    if (bdb->mmtx) {
      tmp___4 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___5 = (int )tmp___4;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      if (! bdb->tran) {
        tmp___3 = tcbdbcacheadjust(bdb);
        if (! tmp___3) {
          rv = (_Bool)0;
        }
      }
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    }
  }
  return (rv);
}
}
_Bool tcbdbcurjump2(BDBCUR *cur , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcbdbcurjump(cur, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
_Bool tcbdbcurprev(BDBCUR *cur ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;
  _Bool adj ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1041, "tcbdbcurprev");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  if (cur->id < 1ULL) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 1046, "tcbdbcurprev");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcbdbcurprevimpl(cur);
  rv = tmp___1;
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    tmp___2 = 1;
  } else {
    if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  adj = (_Bool )tmp___2;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (adj) {
    if (bdb->mmtx) {
      tmp___4 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___5 = (int )tmp___4;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      if (! bdb->tran) {
        tmp___3 = tcbdbcacheadjust(bdb);
        if (! tmp___3) {
          rv = (_Bool)0;
        }
      }
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    }
  }
  return (rv);
}
}
_Bool tcbdbcurnext(BDBCUR *cur ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;
  _Bool adj ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1067, "tcbdbcurnext");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  if (cur->id < 1ULL) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 1072, "tcbdbcurnext");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcbdbcurnextimpl(cur);
  rv = tmp___1;
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    tmp___2 = 1;
  } else {
    if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  }
  adj = (_Bool )tmp___2;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  if (adj) {
    if (bdb->mmtx) {
      tmp___4 = tcbdblockmethod(bdb, (_Bool)1);
      tmp___5 = (int )tmp___4;
    } else {
      tmp___5 = 1;
    }
    if (tmp___5) {
      if (! bdb->tran) {
        tmp___3 = tcbdbcacheadjust(bdb);
        if (! tmp___3) {
          rv = (_Bool)0;
        }
      }
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
    }
  }
  return (rv);
}
}
_Bool tcbdbcurput(BDBCUR *cur , void const   *vbuf , int vsiz , int cpmode ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 1093, "tcbdbcurput");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  if (cur->id < 1ULL) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 1098, "tcbdbcurput");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcbdbcurputimpl(cur, (char const   *)vbuf, vsiz, cpmode);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbcurput2(BDBCUR *cur , char const   *vstr , int cpmode ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(vstr);
  tmp___0 = tcbdbcurput(cur, (void const   *)vstr, (int )tmp, cpmode);
  return (tmp___0);
}
}
_Bool tcbdbcurout(BDBCUR *cur ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 1121, "tcbdbcurout");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  if (cur->id < 1ULL) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 1126, "tcbdbcurout");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcbdbcuroutimpl(cur);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
void *tcbdbcurkey(BDBCUR *cur , int *sp ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  char const   *kbuf ;
  char const   *vbuf ;
  int ksiz ;
  int vsiz ;
  char *rv ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((void *)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1142, "tcbdbcurkey");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((void *)0);
  }
  if (cur->id < 1ULL) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 1147, "tcbdbcurkey");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((void *)0);
  }
  tmp___2 = tcbdbcurrecimpl(cur, & kbuf, & ksiz, & vbuf, & vsiz);
  if (tmp___2) {
    while (1) {
      while (1) {
        tmp___1 = malloc((unsigned int )(ksiz + 1));
        rv = (char *)tmp___1;
        if (! rv) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )rv, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      *(rv + ksiz) = (char )'\000';
      break;
    }
    *sp = ksiz;
  } else {
    rv = (char *)((void *)0);
  }
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return ((void *)rv);
}
}
char *tcbdbcurkey2(BDBCUR *cur ) 
{ int ksiz ;
  void *tmp ;

  {
  tmp = tcbdbcurkey(cur, & ksiz);
  return ((char *)tmp);
}
}
void const   *tcbdbcurkey3(BDBCUR *cur , int *sp ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  char const   *kbuf ;
  char const   *vbuf ;
  int ksiz ;
  int vsiz ;
  char const   *rv ;
  _Bool tmp___1 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((void const   *)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1179, "tcbdbcurkey3");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((void const   *)0);
  }
  if (cur->id < 1ULL) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 1184, "tcbdbcurkey3");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((void const   *)0);
  }
  tmp___1 = tcbdbcurrecimpl(cur, & kbuf, & ksiz, & vbuf, & vsiz);
  if (tmp___1) {
    rv = kbuf;
    *sp = ksiz;
  } else {
    rv = (char const   *)((void *)0);
  }
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return ((void const   *)rv);
}
}
void *tcbdbcurval(BDBCUR *cur , int *sp ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  char const   *kbuf ;
  char const   *vbuf ;
  int ksiz ;
  int vsiz ;
  char *rv ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((void *)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1208, "tcbdbcurval");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((void *)0);
  }
  if (cur->id < 1ULL) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 1213, "tcbdbcurval");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((void *)0);
  }
  tmp___2 = tcbdbcurrecimpl(cur, & kbuf, & ksiz, & vbuf, & vsiz);
  if (tmp___2) {
    while (1) {
      while (1) {
        tmp___1 = malloc((unsigned int )(vsiz + 1));
        rv = (char *)tmp___1;
        if (! rv) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )rv, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      *(rv + vsiz) = (char )'\000';
      break;
    }
    *sp = vsiz;
  } else {
    rv = (char *)((void *)0);
  }
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return ((void *)rv);
}
}
char *tcbdbcurval2(BDBCUR *cur ) 
{ int vsiz ;
  void *tmp ;

  {
  tmp = tcbdbcurval(cur, & vsiz);
  return ((char *)tmp);
}
}
void const   *tcbdbcurval3(BDBCUR *cur , int *sp ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  char const   *kbuf ;
  char const   *vbuf ;
  int ksiz ;
  int vsiz ;
  char const   *rv ;
  _Bool tmp___1 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((void const   *)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1245, "tcbdbcurval3");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((void const   *)0);
  }
  if (cur->id < 1ULL) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 1250, "tcbdbcurval3");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((void const   *)0);
  }
  tmp___1 = tcbdbcurrecimpl(cur, & kbuf, & ksiz, & vbuf, & vsiz);
  if (tmp___1) {
    rv = vbuf;
    *sp = vsiz;
  } else {
    rv = (char const   *)((void *)0);
  }
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return ((void const   *)rv);
}
}
_Bool tcbdbcurrec(BDBCUR *cur , TCXSTR *kxstr , TCXSTR *vxstr ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  char const   *kbuf ;
  char const   *vbuf ;
  int ksiz ;
  int vsiz ;
  _Bool rv ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___1 ;
  void *tmp___2 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___3 ;
  void *tmp___4 ;
  _Bool tmp___5 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1274, "tcbdbcurrec");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  if (cur->id < 1ULL) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 1279, "tcbdbcurrec");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___5 = tcbdbcurrecimpl(cur, & kbuf, & ksiz, & vbuf, & vsiz);
  if (tmp___5) {
    tcxstrclear(kxstr);
    while (1) {
      TC_mysize = ksiz;
      TC_nsize = (kxstr->size + TC_mysize) + 1;
      if (kxstr->asize < TC_nsize) {
        while (kxstr->asize < TC_nsize) {
          kxstr->asize *= 2;
          if (kxstr->asize < TC_nsize) {
            kxstr->asize = TC_nsize;
          }
        }
        while (1) {
          tmp___2 = realloc((void *)kxstr->ptr, (unsigned int )kxstr->asize);
          tmp___1 = (char *)tmp___2;
          kxstr->ptr = tmp___1;
          if (! tmp___1) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(kxstr->ptr + kxstr->size), (void const   * __restrict  )kbuf,
             (unsigned int )TC_mysize);
      kxstr->size += TC_mysize;
      *(kxstr->ptr + kxstr->size) = (char )'\000';
      break;
    }
    tcxstrclear(vxstr);
    while (1) {
      TC_mysize___0 = vsiz;
      TC_nsize___0 = (vxstr->size + TC_mysize___0) + 1;
      if (vxstr->asize < TC_nsize___0) {
        while (vxstr->asize < TC_nsize___0) {
          vxstr->asize *= 2;
          if (vxstr->asize < TC_nsize___0) {
            vxstr->asize = TC_nsize___0;
          }
        }
        while (1) {
          tmp___4 = realloc((void *)vxstr->ptr, (unsigned int )vxstr->asize);
          tmp___3 = (char *)tmp___4;
          vxstr->ptr = tmp___3;
          if (! tmp___3) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(vxstr->ptr + vxstr->size), (void const   * __restrict  )vbuf,
             (unsigned int )TC_mysize___0);
      vxstr->size += TC_mysize___0;
      *(vxstr->ptr + vxstr->size) = (char )'\000';
      break;
    }
    rv = (_Bool)1;
  } else {
    rv = (_Bool)0;
  }
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
void tcbdbsetecode(TCBDB *bdb , int ecode , char const   *filename , int line , char const   *func ) 
{ 

  {
  tchdbsetecode(bdb->hdb, ecode, filename, line, func);
  return;
}
}
void tcbdbsetdbgfd(TCBDB *bdb , int fd ) 
{ 

  {
  tchdbsetdbgfd(bdb->hdb, fd);
  return;
}
}
int tcbdbdbgfd(TCBDB *bdb ) 
{ int tmp ;

  {
  tmp = tchdbdbgfd(bdb->hdb);
  return (tmp);
}
}
_Bool tcbdbhasmutex(TCBDB *bdb ) 
{ 

  {
  return ((_Bool )((unsigned int )bdb->mmtx != (unsigned int )((void *)0)));
}
}
_Bool tcbdbmemsync(TCBDB *bdb , _Bool phys ) 
{ _Bool err ;
  _Bool clk ;
  _Bool tmp ;
  int tmp___0 ;
  char const   *vbuf ;
  int vsiz ;
  TCMAP *leafc ;
  int rsiz ;
  BDBLEAF *leaf ;
  void const   *tmp___1 ;
  _Bool tmp___2 ;
  void const   *tmp___3 ;
  TCMAP *nodec ;
  int rsiz___0 ;
  BDBNODE *node ;
  void const   *tmp___4 ;
  _Bool tmp___5 ;
  void const   *tmp___6 ;
  _Bool tmp___7 ;

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1338, "tcbdbmemsync");
    return ((_Bool)0);
  } else {
    if (! bdb->wmode) {
      tcbdbsetecode(bdb, 2, "tcbdb.c", 1338, "tcbdbmemsync");
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  if (bdb->mmtx) {
    tmp = tcbdblockcache(bdb);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  clk = (_Bool )tmp___0;
  leafc = bdb->leafc;
  tcmapiterinit(leafc);
  while (1) {
    tmp___3 = tcmapiternext(leafc, & vsiz);
    vbuf = (char const   *)tmp___3;
    if (! ((unsigned int )vbuf != (unsigned int )((void *)0))) {
      break;
    }
    tmp___1 = tcmapiterval((void const   *)vbuf, & rsiz);
    leaf = (BDBLEAF *)tmp___1;
    if (leaf->dirty) {
      tmp___2 = tcbdbleafsave(bdb, leaf);
      if (! tmp___2) {
        err = (_Bool)1;
      }
    }
  }
  nodec = bdb->nodec;
  tcmapiterinit(nodec);
  while (1) {
    tmp___6 = tcmapiternext(nodec, & vsiz);
    vbuf = (char const   *)tmp___6;
    if (! ((unsigned int )vbuf != (unsigned int )((void *)0))) {
      break;
    }
    tmp___4 = tcmapiterval((void const   *)vbuf, & rsiz___0);
    node = (BDBNODE *)tmp___4;
    if (node->dirty) {
      tmp___5 = tcbdbnodesave(bdb, node);
      if (! tmp___5) {
        err = (_Bool)1;
      }
    }
  }
  if (clk) {
    if (bdb->mmtx) {
      tcbdbunlockcache(bdb);
    }
  }
  tcbdbdumpmeta(bdb);
  tmp___7 = tchdbmemsync(bdb->hdb, phys);
  if (! tmp___7) {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
_Bool tcbdbcacheclear(TCBDB *bdb ) 
{ _Bool err ;
  _Bool clk ;
  _Bool tmp ;
  int tmp___0 ;
  TCMAP *leafc ;
  int rsiz ;
  void const   *buf ;
  void const   *tmp___1 ;
  _Bool tmp___2 ;
  _Bool clk___0 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  TCMAP *nodec ;
  int rsiz___0 ;
  void const   *buf___0 ;
  void const   *tmp___5 ;
  _Bool tmp___6 ;

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1370, "tcbdbcacheclear");
    return ((_Bool)0);
  }
  err = (_Bool)0;
  if ((bdb->leafc)->rnum > 0ULL) {
    if (bdb->mmtx) {
      tmp = tcbdblockcache(bdb);
      tmp___0 = (int )tmp;
    } else {
      tmp___0 = 1;
    }
    clk = (_Bool )tmp___0;
    leafc = bdb->leafc;
    tcmapiterinit(leafc);
    while (1) {
      buf = tcmapiternext(leafc, & rsiz);
      if (! ((unsigned int )buf != (unsigned int )((void *)0))) {
        break;
      }
      tmp___1 = tcmapiterval(buf, & rsiz);
      tmp___2 = tcbdbleafcacheout(bdb, (BDBLEAF *)tmp___1);
      if (! tmp___2) {
        err = (_Bool)1;
      }
    }
    if (clk) {
      if (bdb->mmtx) {
        tcbdbunlockcache(bdb);
      }
    }
  }
  if ((bdb->nodec)->rnum > 0ULL) {
    if (bdb->mmtx) {
      tmp___3 = tcbdblockcache(bdb);
      tmp___4 = (int )tmp___3;
    } else {
      tmp___4 = 1;
    }
    clk___0 = (_Bool )tmp___4;
    nodec = bdb->nodec;
    tcmapiterinit(nodec);
    while (1) {
      buf___0 = tcmapiternext(nodec, & rsiz___0);
      if (! ((unsigned int )buf___0 != (unsigned int )((void *)0))) {
        break;
      }
      tmp___5 = tcmapiterval(buf___0, & rsiz___0);
      tmp___6 = tcbdbnodecacheout(bdb, (BDBNODE *)tmp___5);
      if (! tmp___6) {
        err = (_Bool)1;
      }
    }
    if (clk___0) {
      if (bdb->mmtx) {
        tcbdbunlockcache(bdb);
      }
    }
  }
  return ((_Bool )(! err));
}
}
TCCMP tcbdbcmpfunc(TCBDB *bdb ) 
{ 

  {
  return (bdb->cmp);
}
}
void *tcbdbcmpop(TCBDB *bdb ) 
{ 

  {
  return (bdb->cmpop);
}
}
uint32_t tcbdblmemb(TCBDB *bdb ) 
{ 

  {
  return (bdb->lmemb);
}
}
uint32_t tcbdbnmemb(TCBDB *bdb ) 
{ 

  {
  return (bdb->nmemb);
}
}
uint64_t tcbdblnum(TCBDB *bdb ) 
{ 

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1432, "tcbdblnum");
    return (0ULL);
  }
  return (bdb->lnum);
}
}
uint64_t tcbdbnnum(TCBDB *bdb ) 
{ 

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1443, "tcbdbnnum");
    return (0ULL);
  }
  return (bdb->nnum);
}
}
uint64_t tcbdbbnum(TCBDB *bdb ) 
{ uint64_t tmp ;

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1454, "tcbdbbnum");
    return (0ULL);
  }
  tmp = tchdbbnum(bdb->hdb);
  return (tmp);
}
}
uint32_t tcbdbalign(TCBDB *bdb ) 
{ uint32_t tmp ;

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1465, "tcbdbalign");
    return (0U);
  }
  tmp = tchdbalign(bdb->hdb);
  return (tmp);
}
}
uint32_t tcbdbfbpmax(TCBDB *bdb ) 
{ uint32_t tmp ;

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1476, "tcbdbfbpmax");
    return (0U);
  }
  tmp = tchdbfbpmax(bdb->hdb);
  return (tmp);
}
}
uint64_t tcbdbinode(TCBDB *bdb ) 
{ uint64_t tmp ;

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1487, "tcbdbinode");
    return (0ULL);
  }
  tmp = tchdbinode(bdb->hdb);
  return (tmp);
}
}
time_t tcbdbmtime(TCBDB *bdb ) 
{ time_t tmp ;

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1498, "tcbdbmtime");
    return (0L);
  }
  tmp = tchdbmtime(bdb->hdb);
  return (tmp);
}
}
uint8_t tcbdbflags(TCBDB *bdb ) 
{ uint8_t tmp ;

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1509, "tcbdbflags");
    return ((unsigned char)0);
  }
  tmp = tchdbflags(bdb->hdb);
  return (tmp);
}
}
uint8_t tcbdbopts(TCBDB *bdb ) 
{ 

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1520, "tcbdbopts");
    return ((unsigned char)0);
  }
  return (bdb->opts);
}
}
char *tcbdbopaque(TCBDB *bdb ) 
{ 

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1531, "tcbdbopaque");
    return ((char *)((void *)0));
  }
  return (bdb->opaque + 64);
}
}
uint64_t tcbdbbnumused(TCBDB *bdb ) 
{ uint64_t tmp ;

  {
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1542, "tcbdbbnumused");
    return (0ULL);
  }
  tmp = tchdbbnumused(bdb->hdb);
  return (tmp);
}
}
_Bool tcbdbsetlsmax(TCBDB *bdb , uint32_t lsmax ) 
{ long tmp ;

  {
  if (bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1553, "tcbdbsetlsmax");
    return ((_Bool)0);
  }
  if (lsmax > 0U) {
    tmp = tclmax((long )lsmax, 512L);
    bdb->lsmax = (unsigned int )tmp;
  } else {
    bdb->lsmax = 16384U;
  }
  return ((_Bool)1);
}
}
_Bool tcbdbsetcapnum(TCBDB *bdb , uint64_t capnum ) 
{ 

  {
  if (bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1565, "tcbdbsetcapnum");
    return ((_Bool)0);
  }
  bdb->capnum = capnum;
  return ((_Bool)1);
}
}
_Bool tcbdbsetcodecfunc(TCBDB *bdb , void *(*enc)(void const   *ptr , int size , int *sp ,
                                                  void *op ) , void *encop , void *(*dec)(void const   *ptr ,
                                                                                          int size ,
                                                                                          int *sp ,
                                                                                          void *op ) ,
                        void *decop ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1578, "tcbdbsetcodecfunc");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tchdbsetcodecfunc(bdb->hdb, enc, encop, dec, decop);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
uint32_t tcbdbdfunit(TCBDB *bdb ) 
{ uint32_t tmp ;

  {
  tmp = tchdbdfunit(bdb->hdb);
  return (tmp);
}
}
_Bool tcbdbdefrag(TCBDB *bdb , int64_t step ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 1600, "tcbdbdefrag");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___1 = tchdbdefrag(bdb->hdb, step);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbputdupback(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                      int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 1615, "tcbdbputdupback");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___1 = tcbdbputimpl(bdb, kbuf, ksiz, vbuf, vsiz, 4);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbputproc(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) 
{ _Bool tmp ;
  int tmp___0 ;
  BDBPDPROCOP procop ;
  BDBPDPROCOP *procptr ;
  char stack[64] ;
  char *rbuf ;
  void *tmp___1 ;
  char *wp ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    goto _L;
  } else {
    if (! bdb->wmode) {
      _L: 
      tcbdbsetecode(bdb, 2, "tcbdb.c", 1631, "tcbdbputproc");
      if (bdb->mmtx) {
        tcbdbunlockmethod(bdb);
      }
      return ((_Bool)0);
    }
  }
  procop.proc = proc___0;
  procop.op = op;
  procptr = & procop;
  if (ksiz <= (int )sizeof(stack) - (int )sizeof(procptr)) {
    rbuf = stack;
  } else {
    while (1) {
      tmp___1 = malloc((unsigned int )(ksiz + (int )sizeof(procptr)));
      rbuf = (char *)tmp___1;
      if (! rbuf) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  wp = rbuf;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& procptr), (unsigned int )((int )sizeof(procptr)));
  wp += (int )sizeof(procptr);
  memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  kbuf = (void const   *)(rbuf + (int )sizeof(procptr));
  tmp___2 = tcbdbputimpl(bdb, kbuf, ksiz, vbuf, vsiz, 7);
  rv = tmp___2;
  if ((unsigned int )rbuf != (unsigned int )(stack)) {
    while (1) {
      free((void *)rbuf);
      break;
    }
  }
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbputdupback2(TCBDB *bdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcbdbputdupback(bdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                            (int )tmp);
  return (tmp___1);
}
}
_Bool tcbdbcurjumpback(BDBCUR *cur , void const   *kbuf , int ksiz ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  bdb = cur->bdb;
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1671, "tcbdbcurjumpback");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcbdbcurjumpimpl(cur, (char const   *)kbuf, ksiz, (_Bool)0);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
_Bool tcbdbcurjumpback2(BDBCUR *cur , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcbdbcurjumpback(cur, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
_Bool tcbdbforeach(TCBDB *bdb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                              int vsiz , void *op ) , void *op ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockmethod(bdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! bdb->open) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 1693, "tcbdbforeach");
    if (bdb->mmtx) {
      tcbdbunlockmethod(bdb);
    }
    return ((_Bool)0);
  }
  while (1) {
    if (bdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___1 = tcbdbforeachimpl(bdb, iter, op);
  rv = tmp___1;
  if (bdb->mmtx) {
    tcbdbunlockmethod(bdb);
  }
  return (rv);
}
}
static void tcbdbclear(TCBDB *bdb ) 
{ 

  {
  bdb->mmtx = (void *)0;
  bdb->cmtx = (void *)0;
  bdb->hdb = (TCHDB *)((void *)0);
  bdb->opaque = (char *)((void *)0);
  bdb->open = (_Bool)0;
  bdb->wmode = (_Bool)0;
  bdb->lmemb = 128U;
  bdb->nmemb = 256U;
  bdb->opts = (unsigned char)0;
  bdb->root = 0ULL;
  bdb->first = 0ULL;
  bdb->last = 0ULL;
  bdb->lnum = 0ULL;
  bdb->nnum = 0ULL;
  bdb->rnum = 0ULL;
  bdb->leafc = (TCMAP *)((void *)0);
  bdb->nodec = (TCMAP *)((void *)0);
  bdb->cmp = (int (*)(char const   *aptr , int asiz , char const   *bptr , int bsiz ,
                      void *op ))((void *)0);
  bdb->cmpop = (void *)0;
  bdb->lcnum = 1024U;
  bdb->ncnum = 512U;
  bdb->lsmax = 16384U;
  bdb->lschk = 0U;
  bdb->capnum = 0ULL;
  bdb->hist = (uint64_t *)((void *)0);
  bdb->hnum = 0;
  bdb->hleaf = 0ULL;
  bdb->lleaf = 0ULL;
  bdb->tran = (_Bool)0;
  bdb->rbopaque = (char *)((void *)0);
  bdb->clock = 0ULL;
  bdb->cnt_saveleaf = -1LL;
  bdb->cnt_loadleaf = -1LL;
  bdb->cnt_killleaf = -1LL;
  bdb->cnt_adjleafc = -1LL;
  bdb->cnt_savenode = -1LL;
  bdb->cnt_loadnode = -1LL;
  bdb->cnt_adjnodec = -1LL;
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  return;
}
}
static void tcbdbdumpmeta(TCBDB *bdb ) 
{ char *wp ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  uint32_t lnum ;
  uint64_t llnum ;

  {
  memset((void *)bdb->opaque, 0, 64U);
  wp = bdb->opaque;
  if ((unsigned int )bdb->cmp == (unsigned int )(& tccmplexical)) {
    tmp = wp;
    wp ++;
    *((uint8_t *)tmp) = (unsigned char)0;
  } else {
    if ((unsigned int )bdb->cmp == (unsigned int )(& tccmpdecimal)) {
      tmp___0 = wp;
      wp ++;
      *((uint8_t *)tmp___0) = (unsigned char)1;
    } else {
      if ((unsigned int )bdb->cmp == (unsigned int )(& tccmpint32)) {
        tmp___1 = wp;
        wp ++;
        *((uint8_t *)tmp___1) = (unsigned char)2;
      } else {
        if ((unsigned int )bdb->cmp == (unsigned int )(& tccmpint64)) {
          tmp___2 = wp;
          wp ++;
          *((uint8_t *)tmp___2) = (unsigned char)3;
        } else {
          tmp___3 = wp;
          wp ++;
          *((uint8_t *)tmp___3) = (unsigned char)255;
        }
      }
    }
  }
  wp += 7;
  lnum = bdb->lmemb;
  lnum = lnum;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
  wp += (int )sizeof(lnum);
  lnum = bdb->nmemb;
  lnum = lnum;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
  wp += (int )sizeof(lnum);
  llnum = bdb->root;
  llnum = llnum;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
  wp += (int )sizeof(llnum);
  llnum = bdb->first;
  llnum = llnum;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
  wp += (int )sizeof(llnum);
  llnum = bdb->last;
  llnum = llnum;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
  wp += (int )sizeof(llnum);
  llnum = bdb->lnum;
  llnum = llnum;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
  wp += (int )sizeof(llnum);
  llnum = bdb->nnum;
  llnum = llnum;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
  wp += (int )sizeof(llnum);
  llnum = bdb->rnum;
  llnum = llnum;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
  wp += (int )sizeof(llnum);
  return;
}
}
static void tcbdbloadmeta(TCBDB *bdb ) 
{ char const   *rp ;
  uint8_t cnum ;
  char const   *tmp ;
  uint32_t lnum ;
  uint64_t llnum ;

  {
  rp = (char const   *)bdb->opaque;
  tmp = rp;
  rp ++;
  cnum = *((uint8_t *)tmp);
  if ((int )cnum == 0) {
    bdb->cmp = & tccmplexical;
  } else {
    if ((int )cnum == 1) {
      bdb->cmp = & tccmpdecimal;
    } else {
      if ((int )cnum == 2) {
        bdb->cmp = & tccmpint32;
      } else {
        if ((int )cnum == 3) {
          bdb->cmp = & tccmpint64;
        }
      }
    }
  }
  rp += 7;
  memcpy((void * __restrict  )(& lnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(lnum)));
  rp += (int )sizeof(lnum);
  bdb->lmemb = lnum;
  memcpy((void * __restrict  )(& lnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(lnum)));
  rp += (int )sizeof(lnum);
  bdb->nmemb = lnum;
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(llnum)));
  bdb->root = llnum;
  rp += (int )sizeof(llnum);
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(llnum)));
  bdb->first = llnum;
  rp += (int )sizeof(llnum);
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(llnum)));
  bdb->last = llnum;
  rp += (int )sizeof(llnum);
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(llnum)));
  bdb->lnum = llnum;
  rp += (int )sizeof(llnum);
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(llnum)));
  bdb->nnum = llnum;
  rp += (int )sizeof(llnum);
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(llnum)));
  bdb->rnum = llnum;
  rp += (int )sizeof(llnum);
  return;
}
}
static BDBLEAF *tcbdbleafnew(TCBDB *bdb , uint64_t prev , uint64_t next ) 
{ BDBLEAF lent ;
  int rsiz ;
  void const   *tmp ;

  {
  (bdb->lnum) ++;
  lent.id = bdb->lnum;
  lent.recs = tcptrlistnew2((int )(bdb->lmemb + 1U));
  lent.size = 0;
  lent.prev = prev;
  lent.next = next;
  lent.dirty = (_Bool)1;
  lent.dead = (_Bool)0;
  tcmapputkeep(bdb->leafc, (void const   *)(& lent.id), (int )sizeof(lent.id), (void const   *)(& lent),
               (int )sizeof(lent));
  tmp = tcmapget((TCMAP const   *)bdb->leafc, (void const   *)(& lent.id), (int )sizeof(lent.id),
                 & rsiz);
  return ((BDBLEAF *)tmp);
}
}
static _Bool tcbdbleafcacheout(TCBDB *bdb , BDBLEAF *leaf ) 
{ _Bool err ;
  _Bool tmp ;
  TCPTRLIST *recs ;
  int ln ;
  int i ;
  BDBREC *rec ;

  {
  err = (_Bool)0;
  if (leaf->dirty) {
    tmp = tcbdbleafsave(bdb, leaf);
    if (! tmp) {
      err = (_Bool)1;
    }
  }
  recs = leaf->recs;
  ln = recs->num;
  i = 0;
  while (i < ln) {
    rec = (BDBREC *)*(recs->array + (i + recs->start));
    if (rec->rest) {
      tclistdel(rec->rest);
    }
    while (1) {
      free((void *)rec);
      break;
    }
    i ++;
  }
  tcptrlistdel(recs);
  tcmapout(bdb->leafc, (void const   *)(& leaf->id), (int )sizeof(leaf->id));
  return ((_Bool )(! err));
}
}
static _Bool tcbdbleafsave(TCBDB *bdb , BDBLEAF *leaf ) 
{ TCXSTR *rbuf ;
  TCXSTR *tmp ;
  char hbuf[((int )sizeof(uint64_t ) + 1) * 3] ;
  char *wp ;
  uint64_t llnum ;
  int step ;
  long long _TC_num ;
  int _TC_rem ;
  long long _TC_num___0 ;
  int _TC_rem___0 ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___0 ;
  void *tmp___1 ;
  TCPTRLIST *recs ;
  int ln ;
  int i ;
  BDBREC *rec ;
  char *dbuf ;
  int lnum ;
  int _TC_num___1 ;
  int _TC_rem___1 ;
  int _TC_num___2 ;
  int _TC_rem___2 ;
  TCLIST *rest ;
  int rnum ;
  int tmp___2 ;
  int _TC_num___3 ;
  int _TC_rem___3 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___3 ;
  void *tmp___4 ;
  int TC_mysize___1 ;
  int TC_nsize___1 ;
  char *tmp___5 ;
  void *tmp___6 ;
  int TC_mysize___2 ;
  int TC_nsize___2 ;
  char *tmp___7 ;
  void *tmp___8 ;
  int j ;
  char const   *vbuf ;
  int vsiz ;
  int _TC_num___4 ;
  int _TC_rem___4 ;
  int TC_mysize___3 ;
  int TC_nsize___3 ;
  char *tmp___9 ;
  void *tmp___10 ;
  int TC_mysize___4 ;
  int TC_nsize___4 ;
  char *tmp___11 ;
  void *tmp___12 ;
  _Bool err ;
  _Bool tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;

  {
  while (1) {
    break;
  }
  tmp = tcxstrnew3(32768);
  rbuf = tmp;
  wp = hbuf;
  llnum = leaf->prev;
  while (1) {
    _TC_num = (long long )llnum;
    if (_TC_num == 0LL) {
      *((signed char *)wp + 0) = (signed char)0;
      step = 1;
    } else {
      step = 0;
      while (_TC_num > 0LL) {
        _TC_rem = (int )(_TC_num & 127LL);
        _TC_num >>= 7;
        if (_TC_num > 0LL) {
          *((signed char *)wp + step) = (signed char )(- _TC_rem - 1);
        } else {
          *((signed char *)wp + step) = (signed char )_TC_rem;
        }
        step ++;
      }
    }
    break;
  }
  wp += step;
  llnum = leaf->next;
  while (1) {
    _TC_num___0 = (long long )llnum;
    if (_TC_num___0 == 0LL) {
      *((signed char *)wp + 0) = (signed char)0;
      step = 1;
    } else {
      step = 0;
      while (_TC_num___0 > 0LL) {
        _TC_rem___0 = (int )(_TC_num___0 & 127LL);
        _TC_num___0 >>= 7;
        if (_TC_num___0 > 0LL) {
          *((signed char *)wp + step) = (signed char )(- _TC_rem___0 - 1);
        } else {
          *((signed char *)wp + step) = (signed char )_TC_rem___0;
        }
        step ++;
      }
    }
    break;
  }
  wp += step;
  while (1) {
    TC_mysize = wp - hbuf;
    TC_nsize = (rbuf->size + TC_mysize) + 1;
    if (rbuf->asize < TC_nsize) {
      while (rbuf->asize < TC_nsize) {
        rbuf->asize *= 2;
        if (rbuf->asize < TC_nsize) {
          rbuf->asize = TC_nsize;
        }
      }
      while (1) {
        tmp___1 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
        tmp___0 = (char *)tmp___1;
        rbuf->ptr = tmp___0;
        if (! tmp___0) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )(hbuf),
           (unsigned int )TC_mysize);
    rbuf->size += TC_mysize;
    *(rbuf->ptr + rbuf->size) = (char )'\000';
    break;
  }
  recs = leaf->recs;
  ln = recs->num;
  i = 0;
  while (i < ln) {
    rec = (BDBREC *)*(recs->array + (i + recs->start));
    dbuf = (char *)rec + (int )sizeof(*rec);
    wp = hbuf;
    lnum = rec->ksiz;
    while (1) {
      _TC_num___1 = lnum;
      if (_TC_num___1 == 0) {
        *((signed char *)wp + 0) = (signed char)0;
        step = 1;
      } else {
        step = 0;
        while (_TC_num___1 > 0) {
          _TC_rem___1 = _TC_num___1 & 127;
          _TC_num___1 >>= 7;
          if (_TC_num___1 > 0) {
            *((signed char *)wp + step) = (signed char )(- _TC_rem___1 - 1);
          } else {
            *((signed char *)wp + step) = (signed char )_TC_rem___1;
          }
          step ++;
        }
      }
      break;
    }
    wp += step;
    lnum = rec->vsiz;
    while (1) {
      _TC_num___2 = lnum;
      if (_TC_num___2 == 0) {
        *((signed char *)wp + 0) = (signed char)0;
        step = 1;
      } else {
        step = 0;
        while (_TC_num___2 > 0) {
          _TC_rem___2 = _TC_num___2 & 127;
          _TC_num___2 >>= 7;
          if (_TC_num___2 > 0) {
            *((signed char *)wp + step) = (signed char )(- _TC_rem___2 - 1);
          } else {
            *((signed char *)wp + step) = (signed char )_TC_rem___2;
          }
          step ++;
        }
      }
      break;
    }
    wp += step;
    rest = rec->rest;
    if (rest) {
      tmp___2 = rest->num;
    } else {
      tmp___2 = 0;
    }
    rnum = tmp___2;
    while (1) {
      _TC_num___3 = rnum;
      if (_TC_num___3 == 0) {
        *((signed char *)wp + 0) = (signed char)0;
        step = 1;
      } else {
        step = 0;
        while (_TC_num___3 > 0) {
          _TC_rem___3 = _TC_num___3 & 127;
          _TC_num___3 >>= 7;
          if (_TC_num___3 > 0) {
            *((signed char *)wp + step) = (signed char )(- _TC_rem___3 - 1);
          } else {
            *((signed char *)wp + step) = (signed char )_TC_rem___3;
          }
          step ++;
        }
      }
      break;
    }
    wp += step;
    while (1) {
      TC_mysize___0 = wp - hbuf;
      TC_nsize___0 = (rbuf->size + TC_mysize___0) + 1;
      if (rbuf->asize < TC_nsize___0) {
        while (rbuf->asize < TC_nsize___0) {
          rbuf->asize *= 2;
          if (rbuf->asize < TC_nsize___0) {
            rbuf->asize = TC_nsize___0;
          }
        }
        while (1) {
          tmp___4 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
          tmp___3 = (char *)tmp___4;
          rbuf->ptr = tmp___3;
          if (! tmp___3) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )(hbuf),
             (unsigned int )TC_mysize___0);
      rbuf->size += TC_mysize___0;
      *(rbuf->ptr + rbuf->size) = (char )'\000';
      break;
    }
    while (1) {
      TC_mysize___1 = rec->ksiz;
      TC_nsize___1 = (rbuf->size + TC_mysize___1) + 1;
      if (rbuf->asize < TC_nsize___1) {
        while (rbuf->asize < TC_nsize___1) {
          rbuf->asize *= 2;
          if (rbuf->asize < TC_nsize___1) {
            rbuf->asize = TC_nsize___1;
          }
        }
        while (1) {
          tmp___6 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
          tmp___5 = (char *)tmp___6;
          rbuf->ptr = tmp___5;
          if (! tmp___5) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )dbuf,
             (unsigned int )TC_mysize___1);
      rbuf->size += TC_mysize___1;
      *(rbuf->ptr + rbuf->size) = (char )'\000';
      break;
    }
    while (1) {
      TC_mysize___2 = rec->vsiz;
      TC_nsize___2 = (rbuf->size + TC_mysize___2) + 1;
      if (rbuf->asize < TC_nsize___2) {
        while (rbuf->asize < TC_nsize___2) {
          rbuf->asize *= 2;
          if (rbuf->asize < TC_nsize___2) {
            rbuf->asize = TC_nsize___2;
          }
        }
        while (1) {
          tmp___8 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
          tmp___7 = (char *)tmp___8;
          rbuf->ptr = tmp___7;
          if (! tmp___7) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )((dbuf + rec->ksiz) + (((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz)),
             (unsigned int )TC_mysize___2);
      rbuf->size += TC_mysize___2;
      *(rbuf->ptr + rbuf->size) = (char )'\000';
      break;
    }
    j = 0;
    while (j < rnum) {
      while (1) {
        vbuf = (char const   *)(rest->array + (j + rest->start))->ptr;
        vsiz = (rest->array + (j + rest->start))->size;
        break;
      }
      while (1) {
        _TC_num___4 = vsiz;
        if (_TC_num___4 == 0) {
          *((signed char *)(hbuf) + 0) = (signed char)0;
          step = 1;
        } else {
          step = 0;
          while (_TC_num___4 > 0) {
            _TC_rem___4 = _TC_num___4 & 127;
            _TC_num___4 >>= 7;
            if (_TC_num___4 > 0) {
              *((signed char *)(hbuf) + step) = (signed char )(- _TC_rem___4 - 1);
            } else {
              *((signed char *)(hbuf) + step) = (signed char )_TC_rem___4;
            }
            step ++;
          }
        }
        break;
      }
      while (1) {
        TC_mysize___3 = step;
        TC_nsize___3 = (rbuf->size + TC_mysize___3) + 1;
        if (rbuf->asize < TC_nsize___3) {
          while (rbuf->asize < TC_nsize___3) {
            rbuf->asize *= 2;
            if (rbuf->asize < TC_nsize___3) {
              rbuf->asize = TC_nsize___3;
            }
          }
          while (1) {
            tmp___10 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
            tmp___9 = (char *)tmp___10;
            rbuf->ptr = tmp___9;
            if (! tmp___9) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )(hbuf),
               (unsigned int )TC_mysize___3);
        rbuf->size += TC_mysize___3;
        *(rbuf->ptr + rbuf->size) = (char )'\000';
        break;
      }
      while (1) {
        TC_mysize___4 = vsiz;
        TC_nsize___4 = (rbuf->size + TC_mysize___4) + 1;
        if (rbuf->asize < TC_nsize___4) {
          while (rbuf->asize < TC_nsize___4) {
            rbuf->asize *= 2;
            if (rbuf->asize < TC_nsize___4) {
              rbuf->asize = TC_nsize___4;
            }
          }
          while (1) {
            tmp___12 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
            tmp___11 = (char *)tmp___12;
            rbuf->ptr = tmp___11;
            if (! tmp___11) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )vbuf,
               (unsigned int )TC_mysize___4);
        rbuf->size += TC_mysize___4;
        *(rbuf->ptr + rbuf->size) = (char )'\000';
        break;
      }
      j ++;
    }
    i ++;
  }
  err = (_Bool)0;
  step = sprintf((char * __restrict  )(hbuf), (char const   * __restrict  )"%llx",
                 leaf->id);
  if (ln < 1) {
    tmp___13 = tchdbout(bdb->hdb, (void const   *)(hbuf), step);
    if (! tmp___13) {
      tmp___14 = tchdbecode(bdb->hdb);
      if (tmp___14 != 22) {
        err = (_Bool)1;
      }
    }
  }
  if (! leaf->dead) {
    tmp___15 = tchdbput(bdb->hdb, (void const   *)(hbuf), step, (void const   *)rbuf->ptr,
                        rbuf->size);
    if (! tmp___15) {
      err = (_Bool)1;
    }
  }
  tcxstrdel(rbuf);
  leaf->dirty = (_Bool)0;
  leaf->dead = (_Bool)0;
  return ((_Bool )(! err));
}
}
static BDBLEAF *tcbdbleafload(TCBDB *bdb , uint64_t id ) 
{ _Bool clk ;
  _Bool tmp ;
  int tmp___0 ;
  int rsiz ;
  BDBLEAF *leaf ;
  void const   *tmp___1 ;
  char hbuf[((int )sizeof(uint64_t ) + 1) * 3] ;
  int step ;
  char *rbuf ;
  char wbuf[32768] ;
  char const   *rp ;
  void *tmp___2 ;
  BDBLEAF lent ;
  uint64_t llnum ;
  long long _TC_base ;
  int _TC_i ;
  long long _TC_base___0 ;
  int _TC_i___0 ;
  _Bool err ;
  int ksiz ;
  int _TC_base___1 ;
  int _TC_i___1 ;
  int vsiz ;
  int _TC_base___2 ;
  int _TC_i___2 ;
  int rnum ;
  int _TC_base___3 ;
  int _TC_i___3 ;
  int psiz ;
  BDBREC *nrec ;
  void *tmp___3 ;
  char *dbuf ;
  int _TC_base___4 ;
  int _TC_i___4 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___4 ;
  void *tmp___5 ;
  TCLISTDATUM *array ;
  char *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  int TC_index___0 ;
  void **tmp___9 ;
  void *tmp___10 ;
  _Bool tmp___11 ;
  int ln ;
  int i ;
  BDBREC *rec ;
  _Bool tmp___12 ;
  void const   *tmp___13 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockcache(bdb);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  clk = (_Bool )tmp___0;
  tmp___1 = tcmapget3(bdb->leafc, (void const   *)(& id), (int )sizeof(id), & rsiz);
  leaf = (BDBLEAF *)tmp___1;
  if (leaf) {
    if (clk) {
      if (bdb->mmtx) {
        tcbdbunlockcache(bdb);
      }
    }
    return (leaf);
  }
  if (clk) {
    if (bdb->mmtx) {
      tcbdbunlockcache(bdb);
    }
  }
  while (1) {
    break;
  }
  step = sprintf((char * __restrict  )(hbuf), (char const   * __restrict  )"%llx",
                 id);
  rbuf = (char *)((void *)0);
  rp = (char const   *)((void *)0);
  rsiz = tchdbget3(bdb->hdb, (void const   *)(hbuf), step, (void *)(wbuf), 32768);
  if (rsiz < 1) {
    tcbdbsetecode(bdb, 9999, "tcbdb.c", 1987, "tcbdbleafload");
    return ((BDBLEAF *)0);
  } else {
    if (rsiz < 32768) {
      rp = (char const   *)(wbuf);
    } else {
      tmp___2 = tchdbget(bdb->hdb, (void const   *)(hbuf), step, & rsiz);
      rbuf = (char *)tmp___2;
      if (! rbuf) {
        tcbdbsetecode(bdb, 9999, "tcbdb.c", 1993, "tcbdbleafload");
        return ((BDBLEAF *)0);
      }
      rp = (char const   *)rbuf;
    }
  }
  lent.id = id;
  while (1) {
    llnum = 0ULL;
    _TC_base = 1LL;
    _TC_i = 0;
    while (1) {
      if ((int )*((signed char *)rp + _TC_i) >= 0) {
        llnum += (unsigned long long )((long long )*((signed char *)rp + _TC_i) * _TC_base);
        break;
      }
      llnum += (unsigned long long )((_TC_base * (long long )((int )*((signed char *)rp + _TC_i) + 1)) * -1LL);
      _TC_base <<= 7;
      _TC_i ++;
    }
    step = _TC_i + 1;
    break;
  }
  lent.prev = llnum;
  rp += step;
  rsiz -= step;
  while (1) {
    llnum = 0ULL;
    _TC_base___0 = 1LL;
    _TC_i___0 = 0;
    while (1) {
      if ((int )*((signed char *)rp + _TC_i___0) >= 0) {
        llnum += (unsigned long long )((long long )*((signed char *)rp + _TC_i___0) * _TC_base___0);
        break;
      }
      llnum += (unsigned long long )((_TC_base___0 * (long long )((int )*((signed char *)rp + _TC_i___0) + 1)) * -1LL);
      _TC_base___0 <<= 7;
      _TC_i___0 ++;
    }
    step = _TC_i___0 + 1;
    break;
  }
  lent.next = llnum;
  rp += step;
  rsiz -= step;
  lent.dirty = (_Bool)0;
  lent.dead = (_Bool)0;
  lent.recs = tcptrlistnew2((int )(bdb->lmemb + 1U));
  lent.size = 0;
  err = (_Bool)0;
  while (rsiz >= 3) {
    while (1) {
      ksiz = 0;
      _TC_base___1 = 1;
      _TC_i___1 = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i___1) >= 0) {
          ksiz += (int )*((signed char *)rp + _TC_i___1) * _TC_base___1;
          break;
        }
        ksiz += (_TC_base___1 * ((int )*((signed char *)rp + _TC_i___1) + 1)) * -1;
        _TC_base___1 <<= 7;
        _TC_i___1 ++;
      }
      step = _TC_i___1 + 1;
      break;
    }
    rp += step;
    rsiz -= step;
    while (1) {
      vsiz = 0;
      _TC_base___2 = 1;
      _TC_i___2 = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i___2) >= 0) {
          vsiz += (int )*((signed char *)rp + _TC_i___2) * _TC_base___2;
          break;
        }
        vsiz += (_TC_base___2 * ((int )*((signed char *)rp + _TC_i___2) + 1)) * -1;
        _TC_base___2 <<= 7;
        _TC_i___2 ++;
      }
      step = _TC_i___2 + 1;
      break;
    }
    rp += step;
    rsiz -= step;
    while (1) {
      rnum = 0;
      _TC_base___3 = 1;
      _TC_i___3 = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i___3) >= 0) {
          rnum += (int )*((signed char *)rp + _TC_i___3) * _TC_base___3;
          break;
        }
        rnum += (_TC_base___3 * ((int )*((signed char *)rp + _TC_i___3) + 1)) * -1;
        _TC_base___3 <<= 7;
        _TC_i___3 ++;
      }
      step = _TC_i___3 + 1;
      break;
    }
    rp += step;
    rsiz -= step;
    if (rsiz < (ksiz + vsiz) + rnum) {
      err = (_Bool)1;
      break;
    }
    psiz = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___3 = malloc((unsigned int )(((((int )sizeof(*nrec) + ksiz) + psiz) + vsiz) + 1));
      nrec = (BDBREC *)tmp___3;
      if (! nrec) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf = (char *)nrec + (int )sizeof(*nrec);
    memcpy((void * __restrict  )dbuf, (void const   * __restrict  )rp, (unsigned int )ksiz);
    *(dbuf + ksiz) = (char )'\000';
    nrec->ksiz = ksiz;
    rp += ksiz;
    rsiz -= ksiz;
    memcpy((void * __restrict  )((dbuf + ksiz) + psiz), (void const   * __restrict  )rp,
           (unsigned int )vsiz);
    *(dbuf + ((ksiz + psiz) + vsiz)) = (char )'\000';
    nrec->vsiz = vsiz;
    rp += vsiz;
    rsiz -= vsiz;
    lent.size += ksiz;
    lent.size += vsiz;
    if (rnum > 0) {
      nrec->rest = tclistnew2(rnum);
      while (1) {
        tmp___8 = rnum;
        rnum --;
        if (tmp___8 > 0) {
          if (! (rsiz > 0)) {
            break;
          }
        } else {
          break;
        }
        while (1) {
          vsiz = 0;
          _TC_base___4 = 1;
          _TC_i___4 = 0;
          while (1) {
            if ((int )*((signed char *)rp + _TC_i___4) >= 0) {
              vsiz += (int )*((signed char *)rp + _TC_i___4) * _TC_base___4;
              break;
            }
            vsiz += (_TC_base___4 * ((int )*((signed char *)rp + _TC_i___4) + 1)) * -1;
            _TC_base___4 <<= 7;
            _TC_i___4 ++;
          }
          step = _TC_i___4 + 1;
          break;
        }
        rp += step;
        rsiz -= step;
        if (rsiz < vsiz) {
          err = (_Bool)1;
          break;
        }
        while (1) {
          TC_mysize = vsiz;
          TC_index = (nrec->rest)->start + (nrec->rest)->num;
          if (TC_index >= (nrec->rest)->anum) {
            (nrec->rest)->anum += (nrec->rest)->num + 1;
            while (1) {
              tmp___5 = realloc((void *)(nrec->rest)->array, (unsigned int )((nrec->rest)->anum * (int )sizeof(*((nrec->rest)->array + 0))));
              tmp___4 = (TCLISTDATUM *)tmp___5;
              (nrec->rest)->array = tmp___4;
              if (! tmp___4) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          array = (nrec->rest)->array;
          while (1) {
            tmp___7 = malloc((unsigned int )(TC_mysize + 1));
            tmp___6 = (char *)tmp___7;
            (array + TC_index)->ptr = tmp___6;
            if (! tmp___6) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )rp,
                 (unsigned int )TC_mysize);
          *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
          (array + TC_index)->size = TC_mysize;
          ((nrec->rest)->num) ++;
          break;
        }
        rp += vsiz;
        rsiz -= vsiz;
        lent.size += vsiz;
      }
    } else {
      nrec->rest = (TCLIST *)((void *)0);
    }
    while (1) {
      TC_index___0 = (lent.recs)->start + (lent.recs)->num;
      if (TC_index___0 >= (lent.recs)->anum) {
        (lent.recs)->anum += (lent.recs)->num + 1;
        while (1) {
          tmp___10 = realloc((void *)(lent.recs)->array, (unsigned int )((lent.recs)->anum * (int )sizeof(*((lent.recs)->array + 0))));
          tmp___9 = (void **)tmp___10;
          (lent.recs)->array = tmp___9;
          if (! tmp___9) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      *((lent.recs)->array + TC_index___0) = (void *)nrec;
      ((lent.recs)->num) ++;
      break;
    }
  }
  while (1) {
    free((void *)rbuf);
    break;
  }
  if (err) {
    tcbdbsetecode(bdb, 9999, "tcbdb.c", 2069, "tcbdbleafload");
    return ((BDBLEAF *)((void *)0));
  } else {
    if (rsiz != 0) {
      tcbdbsetecode(bdb, 9999, "tcbdb.c", 2069, "tcbdbleafload");
      return ((BDBLEAF *)((void *)0));
    }
  }
  if (bdb->mmtx) {
    tmp___11 = tcbdblockcache(bdb);
    clk = tmp___11;
  } else {
    clk = (_Bool)1;
  }
  tmp___12 = tcmapputkeep(bdb->leafc, (void const   *)(& lent.id), (int )sizeof(lent.id),
                          (void const   *)(& lent), (int )sizeof(lent));
  if (! tmp___12) {
    ln = (lent.recs)->num;
    i = 0;
    while (i < ln) {
      rec = (BDBREC *)*((lent.recs)->array + (i + (lent.recs)->start));
      if (rec->rest) {
        tclistdel(rec->rest);
      }
      while (1) {
        free((void *)rec);
        break;
      }
      i ++;
    }
    tcptrlistdel(lent.recs);
  }
  tmp___13 = tcmapget((TCMAP const   *)bdb->leafc, (void const   *)(& lent.id), (int )sizeof(lent.id),
                      & rsiz);
  leaf = (BDBLEAF *)tmp___13;
  if (clk) {
    if (bdb->mmtx) {
      tcbdbunlockcache(bdb);
    }
  }
  return (leaf);
}
}
static _Bool tcbdbleafcheck(TCBDB *bdb , uint64_t id ) 
{ _Bool clk ;
  _Bool tmp ;
  int tmp___0 ;
  int rsiz ;
  BDBLEAF *leaf ;
  void const   *tmp___1 ;
  char hbuf[((int )sizeof(uint64_t ) + 1) * 3] ;
  int step ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockcache(bdb);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  clk = (_Bool )tmp___0;
  tmp___1 = tcmapget((TCMAP const   *)bdb->leafc, (void const   *)(& id), (int )sizeof(id),
                     & rsiz);
  leaf = (BDBLEAF *)tmp___1;
  if (clk) {
    if (bdb->mmtx) {
      tcbdbunlockcache(bdb);
    }
  }
  if (leaf) {
    return ((_Bool)1);
  }
  tmp___2 = sprintf((char * __restrict  )(hbuf), (char const   * __restrict  )"%llx",
                    id);
  step = tmp___2;
  tmp___3 = tchdbvsiz(bdb->hdb, (void const   *)(hbuf), step);
  return ((_Bool )(tmp___3 > 0));
}
}
static BDBLEAF *tcbdbgethistleaf(TCBDB *bdb , char const   *kbuf , int ksiz , uint64_t id ) 
{ BDBLEAF *leaf ;
  BDBLEAF *tmp ;
  int ln ;
  BDBREC *rec ;
  char *dbuf ;
  int rv ;
  int _TC_min ;
  int tmp___0 ;
  int _TC_i ;
  int _TC_min___0 ;
  int tmp___1 ;
  int _TC_i___0 ;

  {
  tmp = tcbdbleafload(bdb, id);
  leaf = tmp;
  if (! leaf) {
    return ((BDBLEAF *)((void *)0));
  }
  ln = (leaf->recs)->num;
  if (ln < 2) {
    return ((BDBLEAF *)((void *)0));
  }
  rec = (BDBREC *)*((leaf->recs)->array + (leaf->recs)->start);
  dbuf = (char *)rec + (int )sizeof(*rec);
  if ((unsigned int )bdb->cmp == (unsigned int )(& tccmplexical)) {
    while (1) {
      rv = 0;
      if (ksiz < rec->ksiz) {
        tmp___0 = ksiz;
      } else {
        tmp___0 = rec->ksiz;
      }
      _TC_min = tmp___0;
      _TC_i = 0;
      while (_TC_i < _TC_min) {
        if ((int )*((unsigned char *)kbuf + _TC_i) != (int )*((unsigned char *)dbuf + _TC_i)) {
          rv = (int )*((unsigned char *)kbuf + _TC_i) - (int )*((unsigned char *)dbuf + _TC_i);
          break;
        }
        _TC_i ++;
      }
      if (rv == 0) {
        rv = ksiz - rec->ksiz;
      }
      break;
    }
  } else {
    rv = (*(bdb->cmp))(kbuf, ksiz, (char const   *)dbuf, rec->ksiz, bdb->cmpop);
  }
  if (rv == 0) {
    return (leaf);
  }
  if (rv < 0) {
    return ((BDBLEAF *)((void *)0));
  }
  rec = (BDBREC *)*((leaf->recs)->array + ((ln - 1) + (leaf->recs)->start));
  dbuf = (char *)rec + (int )sizeof(*rec);
  if ((unsigned int )bdb->cmp == (unsigned int )(& tccmplexical)) {
    while (1) {
      rv = 0;
      if (ksiz < rec->ksiz) {
        tmp___1 = ksiz;
      } else {
        tmp___1 = rec->ksiz;
      }
      _TC_min___0 = tmp___1;
      _TC_i___0 = 0;
      while (_TC_i___0 < _TC_min___0) {
        if ((int )*((unsigned char *)kbuf + _TC_i___0) != (int )*((unsigned char *)dbuf + _TC_i___0)) {
          rv = (int )*((unsigned char *)kbuf + _TC_i___0) - (int )*((unsigned char *)dbuf + _TC_i___0);
          break;
        }
        _TC_i___0 ++;
      }
      if (rv == 0) {
        rv = ksiz - rec->ksiz;
      }
      break;
    }
  } else {
    rv = (*(bdb->cmp))(kbuf, ksiz, (char const   *)dbuf, rec->ksiz, bdb->cmpop);
  }
  if (rv <= 0) {
    return (leaf);
  } else {
    if (leaf->next < 1ULL) {
      return (leaf);
    }
  }
  return ((BDBLEAF *)((void *)0));
}
}
static _Bool tcbdbleafaddrec(TCBDB *bdb , BDBLEAF *leaf , int dmode , char const   *kbuf ,
                             int ksiz , char const   *vbuf , int vsiz ) 
{ int (*cmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
  void *cmpop ;
  TCPTRLIST *recs ;
  int ln ;
  int left ;
  int right ;
  int i ;
  BDBREC *rec ;
  char *dbuf ;
  int rv ;
  int _TC_min ;
  int tmp ;
  int _TC_i ;
  BDBREC *rec___0 ;
  char *dbuf___0 ;
  int rv___0 ;
  int _TC_min___0 ;
  int tmp___0 ;
  int _TC_i___0 ;
  int psiz ;
  BDBREC *orec ;
  BDBPDPROCOP *procptr ;
  int nvsiz ;
  char *nvbuf ;
  void *tmp___1 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___2 ;
  void *tmp___3 ;
  TCLISTDATUM *array ;
  char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int psiz___0 ;
  BDBREC *nrec ;
  void *tmp___10 ;
  char *dbuf___1 ;
  int TC_myindex ;
  void **tmp___11 ;
  void *tmp___12 ;
  int psiz___1 ;
  BDBREC *nrec___0 ;
  void *tmp___13 ;
  char *dbuf___2 ;
  int TC_index___0 ;
  void **tmp___14 ;
  void *tmp___15 ;

  {
  cmp = bdb->cmp;
  cmpop = bdb->cmpop;
  recs = leaf->recs;
  ln = recs->num;
  left = 0;
  right = ln;
  i = (left + right) / 2;
  while (1) {
    if (right >= left) {
      if (! (i < ln)) {
        break;
      }
    } else {
      break;
    }
    rec = (BDBREC *)*(recs->array + (i + recs->start));
    dbuf = (char *)rec + (int )sizeof(*rec);
    if ((unsigned int )cmp == (unsigned int )(& tccmplexical)) {
      while (1) {
        rv = 0;
        if (ksiz < rec->ksiz) {
          tmp = ksiz;
        } else {
          tmp = rec->ksiz;
        }
        _TC_min = tmp;
        _TC_i = 0;
        while (_TC_i < _TC_min) {
          if ((int )*((unsigned char *)kbuf + _TC_i) != (int )*((unsigned char *)dbuf + _TC_i)) {
            rv = (int )*((unsigned char *)kbuf + _TC_i) - (int )*((unsigned char *)dbuf + _TC_i);
            break;
          }
          _TC_i ++;
        }
        if (rv == 0) {
          rv = ksiz - rec->ksiz;
        }
        break;
      }
    } else {
      rv = (*cmp)(kbuf, ksiz, (char const   *)dbuf, rec->ksiz, cmpop);
    }
    if (rv == 0) {
      break;
    } else {
      if (rv <= 0) {
        right = i - 1;
      } else {
        left = i + 1;
      }
    }
    i = (left + right) / 2;
  }
  while (i < ln) {
    rec___0 = (BDBREC *)*(recs->array + (i + recs->start));
    dbuf___0 = (char *)rec___0 + (int )sizeof(*rec___0);
    if ((unsigned int )cmp == (unsigned int )(& tccmplexical)) {
      while (1) {
        rv___0 = 0;
        if (ksiz < rec___0->ksiz) {
          tmp___0 = ksiz;
        } else {
          tmp___0 = rec___0->ksiz;
        }
        _TC_min___0 = tmp___0;
        _TC_i___0 = 0;
        while (_TC_i___0 < _TC_min___0) {
          if ((int )*((unsigned char *)kbuf + _TC_i___0) != (int )*((unsigned char *)dbuf___0 + _TC_i___0)) {
            rv___0 = (int )*((unsigned char *)kbuf + _TC_i___0) - (int )*((unsigned char *)dbuf___0 + _TC_i___0);
            break;
          }
          _TC_i___0 ++;
        }
        if (rv___0 == 0) {
          rv___0 = ksiz - rec___0->ksiz;
        }
        break;
      }
    } else {
      rv___0 = (*cmp)(kbuf, ksiz, (char const   *)dbuf___0, rec___0->ksiz, cmpop);
    }
    if (rv___0 == 0) {
      psiz = ((rec___0->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec___0->ksiz;
      orec = rec___0;
      switch (dmode) {
      case 1: 
      tcbdbsetecode(bdb, 21, "tcbdb.c", 2193, "tcbdbleafaddrec");
      return ((_Bool)0);
      case 2: 
      leaf->size += vsiz;
      while (1) {
        tmp___1 = realloc((void *)rec___0, (unsigned int )((((((int )sizeof(*rec___0) + rec___0->ksiz) + psiz) + rec___0->vsiz) + vsiz) + 1));
        rec___0 = (BDBREC *)tmp___1;
        if (! rec___0) {
          tcmyfatal("out of memory");
        }
        break;
      }
      if ((unsigned int )rec___0 != (unsigned int )orec) {
        tcptrlistover(recs, i, (void *)rec___0);
        dbuf___0 = (char *)rec___0 + (int )sizeof(*rec___0);
      }
      memcpy((void * __restrict  )(((dbuf___0 + rec___0->ksiz) + psiz) + rec___0->vsiz),
             (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      rec___0->vsiz += vsiz;
      *(dbuf___0 + ((rec___0->ksiz + psiz) + rec___0->vsiz)) = (char )'\000';
      break;
      case 3: 
      leaf->size += vsiz;
      if (! rec___0->rest) {
        rec___0->rest = tclistnew2(1);
      }
      while (1) {
        TC_mysize = vsiz;
        TC_index = (rec___0->rest)->start + (rec___0->rest)->num;
        if (TC_index >= (rec___0->rest)->anum) {
          (rec___0->rest)->anum += (rec___0->rest)->num + 1;
          while (1) {
            tmp___3 = realloc((void *)(rec___0->rest)->array, (unsigned int )((rec___0->rest)->anum * (int )sizeof(*((rec___0->rest)->array + 0))));
            tmp___2 = (TCLISTDATUM *)tmp___3;
            (rec___0->rest)->array = tmp___2;
            if (! tmp___2) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        array = (rec___0->rest)->array;
        while (1) {
          tmp___5 = malloc((unsigned int )(TC_mysize + 1));
          tmp___4 = (char *)tmp___5;
          (array + TC_index)->ptr = tmp___4;
          if (! tmp___4) {
            tcmyfatal("out of memory");
          }
          break;
        }
        memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )vbuf,
               (unsigned int )TC_mysize);
        *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
        (array + TC_index)->size = TC_mysize;
        ((rec___0->rest)->num) ++;
        break;
      }
      (bdb->rnum) ++;
      break;
      case 4: 
      leaf->size += vsiz;
      if (! rec___0->rest) {
        rec___0->rest = tclistnew2(1);
      }
      tclistunshift(rec___0->rest, (void const   *)((dbuf___0 + rec___0->ksiz) + psiz),
                    rec___0->vsiz);
      if (vsiz > rec___0->vsiz) {
        while (1) {
          tmp___6 = realloc((void *)rec___0, (unsigned int )(((((int )sizeof(*rec___0) + rec___0->ksiz) + psiz) + vsiz) + 1));
          rec___0 = (BDBREC *)tmp___6;
          if (! rec___0) {
            tcmyfatal("out of memory");
          }
          break;
        }
        if ((unsigned int )rec___0 != (unsigned int )orec) {
          tcptrlistover(recs, i, (void *)rec___0);
          dbuf___0 = (char *)rec___0 + (int )sizeof(*rec___0);
        }
      }
      memcpy((void * __restrict  )((dbuf___0 + rec___0->ksiz) + psiz), (void const   * __restrict  )vbuf,
             (unsigned int )vsiz);
      *(dbuf___0 + ((rec___0->ksiz + psiz) + vsiz)) = (char )'\000';
      rec___0->vsiz = vsiz;
      (bdb->rnum) ++;
      break;
      case 5: 
      if (rec___0->vsiz != (int )sizeof(int )) {
        tcbdbsetecode(bdb, 21, "tcbdb.c", 2230, "tcbdbleafaddrec");
        return ((_Bool)0);
      }
      if (*((int *)vbuf) == 0) {
        *((int *)vbuf) = *((int *)((dbuf___0 + rec___0->ksiz) + psiz));
        return ((_Bool)1);
      }
      *((int *)((dbuf___0 + rec___0->ksiz) + psiz)) += *((int *)vbuf);
      *((int *)vbuf) = *((int *)((dbuf___0 + rec___0->ksiz) + psiz));
      break;
      case 6: 
      if (rec___0->vsiz != (int )sizeof(double )) {
        tcbdbsetecode(bdb, 21, "tcbdb.c", 2242, "tcbdbleafaddrec");
        return ((_Bool)0);
      }
      if (*((double *)vbuf) == 0.0) {
        *((double *)vbuf) = *((double *)((dbuf___0 + rec___0->ksiz) + psiz));
        return ((_Bool)1);
      }
      *((double *)((dbuf___0 + rec___0->ksiz) + psiz)) += *((double *)vbuf);
      *((double *)vbuf) = *((double *)((dbuf___0 + rec___0->ksiz) + psiz));
      break;
      case 7: 
      procptr = *((BDBPDPROCOP **)((char *)kbuf - (int )sizeof(procptr)));
      tmp___7 = (*(procptr->proc))((void const   *)((dbuf___0 + rec___0->ksiz) + psiz),
                                   rec___0->vsiz, & nvsiz, procptr->op);
      nvbuf = (char *)tmp___7;
      if ((unsigned int )nvbuf == (unsigned int )((void *)-1)) {
        tcbdbremoverec(bdb, leaf, rec___0, i);
      } else {
        if (nvbuf) {
          leaf->size += nvsiz - rec___0->vsiz;
          if (nvsiz > rec___0->vsiz) {
            while (1) {
              tmp___8 = realloc((void *)rec___0, (unsigned int )(((((int )sizeof(*rec___0) + rec___0->ksiz) + psiz) + nvsiz) + 1));
              rec___0 = (BDBREC *)tmp___8;
              if (! rec___0) {
                tcmyfatal("out of memory");
              }
              break;
            }
            if ((unsigned int )rec___0 != (unsigned int )orec) {
              tcptrlistover(recs, i, (void *)rec___0);
              dbuf___0 = (char *)rec___0 + (int )sizeof(*rec___0);
            }
          }
          memcpy((void * __restrict  )((dbuf___0 + rec___0->ksiz) + psiz), (void const   * __restrict  )nvbuf,
                 (unsigned int )nvsiz);
          *(dbuf___0 + ((rec___0->ksiz + psiz) + nvsiz)) = (char )'\000';
          rec___0->vsiz = nvsiz;
          while (1) {
            free((void *)nvbuf);
            break;
          }
        } else {
          tcbdbsetecode(bdb, 21, "tcbdb.c", 2271, "tcbdbleafaddrec");
          return ((_Bool)0);
        }
      }
      break;
      default: 
      leaf->size += vsiz - rec___0->vsiz;
      if (vsiz > rec___0->vsiz) {
        while (1) {
          tmp___9 = realloc((void *)rec___0, (unsigned int )(((((int )sizeof(*rec___0) + rec___0->ksiz) + psiz) + vsiz) + 1));
          rec___0 = (BDBREC *)tmp___9;
          if (! rec___0) {
            tcmyfatal("out of memory");
          }
          break;
        }
        if ((unsigned int )rec___0 != (unsigned int )orec) {
          tcptrlistover(recs, i, (void *)rec___0);
          dbuf___0 = (char *)rec___0 + (int )sizeof(*rec___0);
        }
      }
      memcpy((void * __restrict  )((dbuf___0 + rec___0->ksiz) + psiz), (void const   * __restrict  )vbuf,
             (unsigned int )vsiz);
      *(dbuf___0 + ((rec___0->ksiz + psiz) + vsiz)) = (char )'\000';
      rec___0->vsiz = vsiz;
      break;
      }
      break;
    } else {
      if (rv___0 < 0) {
        if (! vbuf) {
          tcbdbsetecode(bdb, 22, "tcbdb.c", 2292, "tcbdbleafaddrec");
          return ((_Bool)0);
        }
        leaf->size += ksiz + vsiz;
        psiz___0 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
        while (1) {
          tmp___10 = malloc((unsigned int )(((((int )sizeof(*nrec) + ksiz) + psiz___0) + vsiz) + 1));
          nrec = (BDBREC *)tmp___10;
          if (! nrec) {
            tcmyfatal("out of memory");
          }
          break;
        }
        dbuf___1 = (char *)nrec + (int )sizeof(*nrec);
        memcpy((void * __restrict  )dbuf___1, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
        *(dbuf___1 + ksiz) = (char )'\000';
        nrec->ksiz = ksiz;
        memcpy((void * __restrict  )((dbuf___1 + ksiz) + psiz___0), (void const   * __restrict  )vbuf,
               (unsigned int )vsiz);
        *(dbuf___1 + ((ksiz + psiz___0) + vsiz)) = (char )'\000';
        nrec->vsiz = vsiz;
        nrec->rest = (TCLIST *)((void *)0);
        while (1) {
          TC_myindex = i;
          TC_myindex += recs->start;
          if (recs->start + recs->num >= recs->anum) {
            recs->anum += recs->num + 1;
            while (1) {
              tmp___12 = realloc((void *)recs->array, (unsigned int )(recs->anum * (int )sizeof(*(recs->array + 0))));
              tmp___11 = (void **)tmp___12;
              recs->array = tmp___11;
              if (! tmp___11) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memmove((void *)((recs->array + TC_myindex) + 1), (void const   *)(recs->array + TC_myindex),
                  (unsigned int )((int )sizeof(*(recs->array + 0)) * ((recs->start + recs->num) - TC_myindex)));
          *(recs->array + TC_myindex) = (void *)nrec;
          (recs->num) ++;
          break;
        }
        (bdb->rnum) ++;
        break;
      }
    }
    i ++;
  }
  if (i >= ln) {
    if (! vbuf) {
      tcbdbsetecode(bdb, 22, "tcbdb.c", 2315, "tcbdbleafaddrec");
      return ((_Bool)0);
    }
    leaf->size += ksiz + vsiz;
    psiz___1 = ((ksiz | ~ (- ((int )sizeof(void *)))) + 1) - ksiz;
    while (1) {
      tmp___13 = malloc((unsigned int )(((((int )sizeof(*nrec___0) + ksiz) + psiz___1) + vsiz) + 1));
      nrec___0 = (BDBREC *)tmp___13;
      if (! nrec___0) {
        tcmyfatal("out of memory");
      }
      break;
    }
    dbuf___2 = (char *)nrec___0 + (int )sizeof(*nrec___0);
    memcpy((void * __restrict  )dbuf___2, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    *(dbuf___2 + ksiz) = (char )'\000';
    nrec___0->ksiz = ksiz;
    memcpy((void * __restrict  )((dbuf___2 + ksiz) + psiz___1), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf___2 + ((ksiz + psiz___1) + vsiz)) = (char )'\000';
    nrec___0->vsiz = vsiz;
    nrec___0->rest = (TCLIST *)((void *)0);
    while (1) {
      TC_index___0 = recs->start + recs->num;
      if (TC_index___0 >= recs->anum) {
        recs->anum += recs->num + 1;
        while (1) {
          tmp___15 = realloc((void *)recs->array, (unsigned int )(recs->anum * (int )sizeof(*(recs->array + 0))));
          tmp___14 = (void **)tmp___15;
          recs->array = tmp___14;
          if (! tmp___14) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      *(recs->array + TC_index___0) = (void *)nrec___0;
      (recs->num) ++;
      break;
    }
    (bdb->rnum) ++;
  }
  leaf->dirty = (_Bool)1;
  return ((_Bool)1);
}
}
static BDBLEAF *tcbdbleafdivide(TCBDB *bdb , BDBLEAF *leaf ) 
{ TCPTRLIST *recs ;
  int mid ;
  BDBLEAF *newleaf ;
  BDBLEAF *tmp ;
  BDBLEAF *nextleaf ;
  BDBLEAF *tmp___0 ;
  int ln ;
  TCPTRLIST *newrecs ;
  int nsiz ;
  int i ;
  BDBREC *rec ;
  TCLIST *rest ;
  int rnum ;
  int j ;
  int TC_index ;
  void **tmp___1 ;
  void *tmp___2 ;

  {
  bdb->hleaf = 0ULL;
  recs = leaf->recs;
  mid = recs->num / 2;
  tmp = tcbdbleafnew(bdb, leaf->id, leaf->next);
  newleaf = tmp;
  if (newleaf->next > 0ULL) {
    tmp___0 = tcbdbleafload(bdb, newleaf->next);
    nextleaf = tmp___0;
    if (! nextleaf) {
      return ((BDBLEAF *)((void *)0));
    }
    nextleaf->prev = newleaf->id;
    nextleaf->dirty = (_Bool)1;
  }
  leaf->next = newleaf->id;
  leaf->dirty = (_Bool)1;
  ln = recs->num;
  newrecs = newleaf->recs;
  nsiz = 0;
  i = mid;
  while (i < ln) {
    rec = (BDBREC *)*(recs->array + (i + recs->start));
    nsiz += rec->ksiz + rec->vsiz;
    if (rec->rest) {
      rest = rec->rest;
      rnum = rest->num;
      j = 0;
      while (j < rnum) {
        nsiz += (rest->array + (j + rest->start))->size;
        j ++;
      }
    }
    while (1) {
      TC_index = newrecs->start + newrecs->num;
      if (TC_index >= newrecs->anum) {
        newrecs->anum += newrecs->num + 1;
        while (1) {
          tmp___2 = realloc((void *)newrecs->array, (unsigned int )(newrecs->anum * (int )sizeof(*(newrecs->array + 0))));
          tmp___1 = (void **)tmp___2;
          newrecs->array = tmp___1;
          if (! tmp___1) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      *(newrecs->array + TC_index) = (void *)rec;
      (newrecs->num) ++;
      break;
    }
    i ++;
  }
  while (1) {
    recs->num -= newrecs->num;
    break;
  }
  leaf->size -= nsiz;
  newleaf->size = nsiz;
  return (newleaf);
}
}
static _Bool tcbdbleafkill(TCBDB *bdb , BDBLEAF *leaf ) 
{ BDBNODE *node ;
  BDBNODE *tmp ;
  BDBLEAF *tleaf ;
  BDBLEAF *tmp___0 ;
  BDBLEAF *tleaf___0 ;
  BDBLEAF *tmp___1 ;
  _Bool tmp___2 ;

  {
  (bdb->hnum) --;
  tmp = tcbdbnodeload(bdb, *(bdb->hist + bdb->hnum));
  node = tmp;
  if (! node) {
    return ((_Bool)0);
  }
  tmp___2 = tcbdbnodesubidx(bdb, node, leaf->id);
  if (tmp___2) {
    while (1) {
      break;
    }
    if (bdb->hleaf == leaf->id) {
      bdb->hleaf = 0ULL;
    }
    if (leaf->prev > 0ULL) {
      tmp___0 = tcbdbleafload(bdb, leaf->prev);
      tleaf = tmp___0;
      if (! tleaf) {
        return ((_Bool)0);
      }
      tleaf->next = leaf->next;
      tleaf->dirty = (_Bool)1;
      if (bdb->last == leaf->id) {
        bdb->last = leaf->prev;
      }
    }
    if (leaf->next > 0ULL) {
      tmp___1 = tcbdbleafload(bdb, leaf->next);
      tleaf___0 = tmp___1;
      if (! tleaf___0) {
        return ((_Bool)0);
      }
      tleaf___0->prev = leaf->prev;
      tleaf___0->dirty = (_Bool)1;
      if (bdb->first == leaf->id) {
        bdb->first = leaf->next;
      }
    }
    leaf->dead = (_Bool)1;
  }
  (bdb->clock) ++;
  return ((_Bool)1);
}
}
static BDBNODE *tcbdbnodenew(TCBDB *bdb , uint64_t heir ) 
{ BDBNODE nent ;
  int rsiz ;
  void const   *tmp ;

  {
  (bdb->nnum) ++;
  nent.id = bdb->nnum + (unsigned long long )((1LL << 48) + 1LL);
  nent.idxs = tcptrlistnew2((int )(bdb->nmemb + 1U));
  nent.heir = heir;
  nent.dirty = (_Bool)1;
  nent.dead = (_Bool)0;
  tcmapputkeep(bdb->nodec, (void const   *)(& nent.id), (int )sizeof(nent.id), (void const   *)(& nent),
               (int )sizeof(nent));
  tmp = tcmapget((TCMAP const   *)bdb->nodec, (void const   *)(& nent.id), (int )sizeof(nent.id),
                 & rsiz);
  return ((BDBNODE *)tmp);
}
}
static _Bool tcbdbnodecacheout(TCBDB *bdb , BDBNODE *node ) 
{ _Bool err ;
  _Bool tmp ;
  TCPTRLIST *idxs ;
  int ln ;
  int i ;
  BDBIDX *idx ;

  {
  err = (_Bool)0;
  if (node->dirty) {
    tmp = tcbdbnodesave(bdb, node);
    if (! tmp) {
      err = (_Bool)1;
    }
  }
  idxs = node->idxs;
  ln = idxs->num;
  i = 0;
  while (i < ln) {
    idx = (BDBIDX *)*(idxs->array + (i + idxs->start));
    while (1) {
      free((void *)idx);
      break;
    }
    i ++;
  }
  tcptrlistdel(idxs);
  tcmapout(bdb->nodec, (void const   *)(& node->id), (int )sizeof(node->id));
  return ((_Bool )(! err));
}
}
static _Bool tcbdbnodesave(TCBDB *bdb , BDBNODE *node ) 
{ TCXSTR *rbuf ;
  TCXSTR *tmp ;
  char hbuf[((int )sizeof(uint64_t ) + 1) * 2] ;
  uint64_t llnum ;
  int step ;
  long long _TC_num ;
  int _TC_rem ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___0 ;
  void *tmp___1 ;
  TCPTRLIST *idxs ;
  int ln ;
  int i ;
  BDBIDX *idx ;
  char *ebuf ;
  char *wp ;
  long long _TC_num___0 ;
  int _TC_rem___0 ;
  uint32_t lnum ;
  int _TC_num___1 ;
  int _TC_rem___1 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___2 ;
  void *tmp___3 ;
  int TC_mysize___1 ;
  int TC_nsize___1 ;
  char *tmp___4 ;
  void *tmp___5 ;
  _Bool err ;
  _Bool tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
  while (1) {
    break;
  }
  tmp = tcxstrnew3(32768);
  rbuf = tmp;
  llnum = node->heir;
  while (1) {
    _TC_num = (long long )llnum;
    if (_TC_num == 0LL) {
      *((signed char *)(hbuf) + 0) = (signed char)0;
      step = 1;
    } else {
      step = 0;
      while (_TC_num > 0LL) {
        _TC_rem = (int )(_TC_num & 127LL);
        _TC_num >>= 7;
        if (_TC_num > 0LL) {
          *((signed char *)(hbuf) + step) = (signed char )(- _TC_rem - 1);
        } else {
          *((signed char *)(hbuf) + step) = (signed char )_TC_rem;
        }
        step ++;
      }
    }
    break;
  }
  while (1) {
    TC_mysize = step;
    TC_nsize = (rbuf->size + TC_mysize) + 1;
    if (rbuf->asize < TC_nsize) {
      while (rbuf->asize < TC_nsize) {
        rbuf->asize *= 2;
        if (rbuf->asize < TC_nsize) {
          rbuf->asize = TC_nsize;
        }
      }
      while (1) {
        tmp___1 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
        tmp___0 = (char *)tmp___1;
        rbuf->ptr = tmp___0;
        if (! tmp___0) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )(hbuf),
           (unsigned int )TC_mysize);
    rbuf->size += TC_mysize;
    *(rbuf->ptr + rbuf->size) = (char )'\000';
    break;
  }
  idxs = node->idxs;
  ln = idxs->num;
  i = 0;
  while (i < ln) {
    idx = (BDBIDX *)*(idxs->array + (i + idxs->start));
    ebuf = (char *)idx + (int )sizeof(*idx);
    wp = hbuf;
    llnum = idx->pid;
    while (1) {
      _TC_num___0 = (long long )llnum;
      if (_TC_num___0 == 0LL) {
        *((signed char *)wp + 0) = (signed char)0;
        step = 1;
      } else {
        step = 0;
        while (_TC_num___0 > 0LL) {
          _TC_rem___0 = (int )(_TC_num___0 & 127LL);
          _TC_num___0 >>= 7;
          if (_TC_num___0 > 0LL) {
            *((signed char *)wp + step) = (signed char )(- _TC_rem___0 - 1);
          } else {
            *((signed char *)wp + step) = (signed char )_TC_rem___0;
          }
          step ++;
        }
      }
      break;
    }
    wp += step;
    lnum = (unsigned int )idx->ksiz;
    while (1) {
      _TC_num___1 = (int )lnum;
      if (_TC_num___1 == 0) {
        *((signed char *)wp + 0) = (signed char)0;
        step = 1;
      } else {
        step = 0;
        while (_TC_num___1 > 0) {
          _TC_rem___1 = _TC_num___1 & 127;
          _TC_num___1 >>= 7;
          if (_TC_num___1 > 0) {
            *((signed char *)wp + step) = (signed char )(- _TC_rem___1 - 1);
          } else {
            *((signed char *)wp + step) = (signed char )_TC_rem___1;
          }
          step ++;
        }
      }
      break;
    }
    wp += step;
    while (1) {
      TC_mysize___0 = wp - hbuf;
      TC_nsize___0 = (rbuf->size + TC_mysize___0) + 1;
      if (rbuf->asize < TC_nsize___0) {
        while (rbuf->asize < TC_nsize___0) {
          rbuf->asize *= 2;
          if (rbuf->asize < TC_nsize___0) {
            rbuf->asize = TC_nsize___0;
          }
        }
        while (1) {
          tmp___3 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
          tmp___2 = (char *)tmp___3;
          rbuf->ptr = tmp___2;
          if (! tmp___2) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )(hbuf),
             (unsigned int )TC_mysize___0);
      rbuf->size += TC_mysize___0;
      *(rbuf->ptr + rbuf->size) = (char )'\000';
      break;
    }
    while (1) {
      TC_mysize___1 = idx->ksiz;
      TC_nsize___1 = (rbuf->size + TC_mysize___1) + 1;
      if (rbuf->asize < TC_nsize___1) {
        while (rbuf->asize < TC_nsize___1) {
          rbuf->asize *= 2;
          if (rbuf->asize < TC_nsize___1) {
            rbuf->asize = TC_nsize___1;
          }
        }
        while (1) {
          tmp___5 = realloc((void *)rbuf->ptr, (unsigned int )rbuf->asize);
          tmp___4 = (char *)tmp___5;
          rbuf->ptr = tmp___4;
          if (! tmp___4) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memcpy((void * __restrict  )(rbuf->ptr + rbuf->size), (void const   * __restrict  )ebuf,
             (unsigned int )TC_mysize___1);
      rbuf->size += TC_mysize___1;
      *(rbuf->ptr + rbuf->size) = (char )'\000';
      break;
    }
    i ++;
  }
  err = (_Bool)0;
  step = sprintf((char * __restrict  )(hbuf), (char const   * __restrict  )"#%llx",
                 node->id - (unsigned long long )((1LL << 48) + 1LL));
  if (ln < 1) {
    tmp___6 = tchdbout(bdb->hdb, (void const   *)(hbuf), step);
    if (! tmp___6) {
      tmp___7 = tchdbecode(bdb->hdb);
      if (tmp___7 != 22) {
        err = (_Bool)1;
      }
    }
  }
  if (! node->dead) {
    tmp___8 = tchdbput(bdb->hdb, (void const   *)(hbuf), step, (void const   *)rbuf->ptr,
                       rbuf->size);
    if (! tmp___8) {
      err = (_Bool)1;
    }
  }
  tcxstrdel(rbuf);
  node->dirty = (_Bool)0;
  node->dead = (_Bool)0;
  return ((_Bool )(! err));
}
}
static BDBNODE *tcbdbnodeload(TCBDB *bdb , uint64_t id ) 
{ _Bool clk ;
  _Bool tmp ;
  int tmp___0 ;
  int rsiz ;
  BDBNODE *node ;
  void const   *tmp___1 ;
  char hbuf[((int )sizeof(uint64_t ) + 1) * 2] ;
  int step ;
  char *rbuf ;
  char wbuf[32768] ;
  char const   *rp ;
  void *tmp___2 ;
  BDBNODE nent ;
  uint64_t llnum ;
  long long _TC_base ;
  int _TC_i ;
  _Bool err ;
  uint64_t pid ;
  long long _TC_base___0 ;
  int _TC_i___0 ;
  int ksiz ;
  int _TC_base___1 ;
  int _TC_i___1 ;
  BDBIDX *nidx ;
  void *tmp___3 ;
  char *ebuf ;
  int TC_index ;
  void **tmp___4 ;
  void *tmp___5 ;
  _Bool tmp___6 ;
  int ln ;
  int i ;
  BDBIDX *idx ;
  _Bool tmp___7 ;
  void const   *tmp___8 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockcache(bdb);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  clk = (_Bool )tmp___0;
  tmp___1 = tcmapget3(bdb->nodec, (void const   *)(& id), (int )sizeof(id), & rsiz);
  node = (BDBNODE *)tmp___1;
  if (node) {
    if (clk) {
      if (bdb->mmtx) {
        tcbdbunlockcache(bdb);
      }
    }
    return (node);
  }
  if (clk) {
    if (bdb->mmtx) {
      tcbdbunlockcache(bdb);
    }
  }
  while (1) {
    break;
  }
  step = sprintf((char * __restrict  )(hbuf), (char const   * __restrict  )"#%llx",
                 id - (unsigned long long )((1LL << 48) + 1LL));
  rbuf = (char *)((void *)0);
  rp = (char const   *)((void *)0);
  rsiz = tchdbget3(bdb->hdb, (void const   *)(hbuf), step, (void *)(wbuf), 32768);
  if (rsiz < 1) {
    tcbdbsetecode(bdb, 9999, "tcbdb.c", 2513, "tcbdbnodeload");
    return ((BDBNODE *)((void *)0));
  } else {
    if (rsiz < 32768) {
      rp = (char const   *)(wbuf);
    } else {
      tmp___2 = tchdbget(bdb->hdb, (void const   *)(hbuf), step, & rsiz);
      rbuf = (char *)tmp___2;
      if (! rbuf) {
        tcbdbsetecode(bdb, 9999, "tcbdb.c", 2519, "tcbdbnodeload");
        return ((BDBNODE *)((void *)0));
      }
      rp = (char const   *)rbuf;
    }
  }
  nent.id = id;
  while (1) {
    llnum = 0ULL;
    _TC_base = 1LL;
    _TC_i = 0;
    while (1) {
      if ((int )*((signed char *)rp + _TC_i) >= 0) {
        llnum += (unsigned long long )((long long )*((signed char *)rp + _TC_i) * _TC_base);
        break;
      }
      llnum += (unsigned long long )((_TC_base * (long long )((int )*((signed char *)rp + _TC_i) + 1)) * -1LL);
      _TC_base <<= 7;
      _TC_i ++;
    }
    step = _TC_i + 1;
    break;
  }
  nent.heir = llnum;
  rp += step;
  rsiz -= step;
  nent.dirty = (_Bool)0;
  nent.dead = (_Bool)0;
  nent.idxs = tcptrlistnew2((int )(bdb->nmemb + 1U));
  err = (_Bool)0;
  while (rsiz >= 2) {
    while (1) {
      pid = 0ULL;
      _TC_base___0 = 1LL;
      _TC_i___0 = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i___0) >= 0) {
          pid += (unsigned long long )((long long )*((signed char *)rp + _TC_i___0) * _TC_base___0);
          break;
        }
        pid += (unsigned long long )((_TC_base___0 * (long long )((int )*((signed char *)rp + _TC_i___0) + 1)) * -1LL);
        _TC_base___0 <<= 7;
        _TC_i___0 ++;
      }
      step = _TC_i___0 + 1;
      break;
    }
    rp += step;
    rsiz -= step;
    while (1) {
      ksiz = 0;
      _TC_base___1 = 1;
      _TC_i___1 = 0;
      while (1) {
        if ((int )*((signed char *)rp + _TC_i___1) >= 0) {
          ksiz += (int )*((signed char *)rp + _TC_i___1) * _TC_base___1;
          break;
        }
        ksiz += (_TC_base___1 * ((int )*((signed char *)rp + _TC_i___1) + 1)) * -1;
        _TC_base___1 <<= 7;
        _TC_i___1 ++;
      }
      step = _TC_i___1 + 1;
      break;
    }
    rp += step;
    rsiz -= step;
    if (rsiz < ksiz) {
      err = (_Bool)1;
      break;
    }
    while (1) {
      tmp___3 = malloc((unsigned int )(((int )sizeof(*nidx) + ksiz) + 1));
      nidx = (BDBIDX *)tmp___3;
      if (! nidx) {
        tcmyfatal("out of memory");
      }
      break;
    }
    nidx->pid = pid;
    ebuf = (char *)nidx + (int )sizeof(*nidx);
    memcpy((void * __restrict  )ebuf, (void const   * __restrict  )rp, (unsigned int )ksiz);
    *(ebuf + ksiz) = (char )'\000';
    nidx->ksiz = ksiz;
    rp += ksiz;
    rsiz -= ksiz;
    while (1) {
      TC_index = (nent.idxs)->start + (nent.idxs)->num;
      if (TC_index >= (nent.idxs)->anum) {
        (nent.idxs)->anum += (nent.idxs)->num + 1;
        while (1) {
          tmp___5 = realloc((void *)(nent.idxs)->array, (unsigned int )((nent.idxs)->anum * (int )sizeof(*((nent.idxs)->array + 0))));
          tmp___4 = (void **)tmp___5;
          (nent.idxs)->array = tmp___4;
          if (! tmp___4) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      *((nent.idxs)->array + TC_index) = (void *)nidx;
      ((nent.idxs)->num) ++;
      break;
    }
  }
  while (1) {
    free((void *)rbuf);
    break;
  }
  if (err) {
    tcbdbsetecode(bdb, 9999, "tcbdb.c", 2561, "tcbdbnodeload");
    return ((BDBNODE *)((void *)0));
  } else {
    if (rsiz != 0) {
      tcbdbsetecode(bdb, 9999, "tcbdb.c", 2561, "tcbdbnodeload");
      return ((BDBNODE *)((void *)0));
    }
  }
  if (bdb->mmtx) {
    tmp___6 = tcbdblockcache(bdb);
    clk = tmp___6;
  } else {
    clk = (_Bool)1;
  }
  tmp___7 = tcmapputkeep(bdb->nodec, (void const   *)(& nent.id), (int )sizeof(nent.id),
                         (void const   *)(& nent), (int )sizeof(nent));
  if (! tmp___7) {
    ln = (nent.idxs)->num;
    i = 0;
    while (i < ln) {
      idx = (BDBIDX *)*((nent.idxs)->array + (i + (nent.idxs)->start));
      while (1) {
        free((void *)idx);
        break;
      }
      i ++;
    }
    tcptrlistdel(nent.idxs);
  }
  tmp___8 = tcmapget((TCMAP const   *)bdb->nodec, (void const   *)(& nent.id), (int )sizeof(nent.id),
                     & rsiz);
  node = (BDBNODE *)tmp___8;
  if (clk) {
    if (bdb->mmtx) {
      tcbdbunlockcache(bdb);
    }
  }
  return (node);
}
}
static void tcbdbnodeaddidx(TCBDB *bdb , BDBNODE *node , _Bool order , uint64_t pid ,
                            char const   *kbuf , int ksiz ) 
{ BDBIDX *nidx ;
  void *tmp ;
  char *ebuf ;
  int (*cmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
  void *cmpop ;
  TCPTRLIST *idxs ;
  int TC_index ;
  void **tmp___0 ;
  void *tmp___1 ;
  int ln ;
  int left ;
  int right ;
  int i ;
  BDBIDX *idx ;
  char *ebuf___0 ;
  int rv ;
  int _TC_min ;
  int tmp___2 ;
  int _TC_i ;
  BDBIDX *idx___0 ;
  char *ebuf___1 ;
  int rv___0 ;
  int _TC_min___0 ;
  int tmp___3 ;
  int _TC_i___0 ;
  int TC_myindex ;
  void **tmp___4 ;
  void *tmp___5 ;
  int TC_index___0 ;
  void **tmp___6 ;
  void *tmp___7 ;

  {
  while (1) {
    tmp = malloc((unsigned int )(((int )sizeof(*nidx) + ksiz) + 1));
    nidx = (BDBIDX *)tmp;
    if (! nidx) {
      tcmyfatal("out of memory");
    }
    break;
  }
  nidx->pid = pid;
  ebuf = (char *)nidx + (int )sizeof(*nidx);
  memcpy((void * __restrict  )ebuf, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  *(ebuf + ksiz) = (char )'\000';
  nidx->ksiz = ksiz;
  cmp = bdb->cmp;
  cmpop = bdb->cmpop;
  idxs = node->idxs;
  if (order) {
    while (1) {
      TC_index = idxs->start + idxs->num;
      if (TC_index >= idxs->anum) {
        idxs->anum += idxs->num + 1;
        while (1) {
          tmp___1 = realloc((void *)idxs->array, (unsigned int )(idxs->anum * (int )sizeof(*(idxs->array + 0))));
          tmp___0 = (void **)tmp___1;
          idxs->array = tmp___0;
          if (! tmp___0) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      *(idxs->array + TC_index) = (void *)nidx;
      (idxs->num) ++;
      break;
    }
  } else {
    ln = idxs->num;
    left = 0;
    right = ln;
    i = (left + right) / 2;
    while (1) {
      if (right >= left) {
        if (! (i < ln)) {
          break;
        }
      } else {
        break;
      }
      idx = (BDBIDX *)*(idxs->array + (i + idxs->start));
      ebuf___0 = (char *)idx + (int )sizeof(*idx);
      if ((unsigned int )cmp == (unsigned int )(& tccmplexical)) {
        while (1) {
          rv = 0;
          if (ksiz < idx->ksiz) {
            tmp___2 = ksiz;
          } else {
            tmp___2 = idx->ksiz;
          }
          _TC_min = tmp___2;
          _TC_i = 0;
          while (_TC_i < _TC_min) {
            if ((int )*((unsigned char *)kbuf + _TC_i) != (int )*((unsigned char *)ebuf___0 + _TC_i)) {
              rv = (int )*((unsigned char *)kbuf + _TC_i) - (int )*((unsigned char *)ebuf___0 + _TC_i);
              break;
            }
            _TC_i ++;
          }
          if (rv == 0) {
            rv = ksiz - idx->ksiz;
          }
          break;
        }
      } else {
        rv = (*cmp)(kbuf, ksiz, (char const   *)ebuf___0, idx->ksiz, cmpop);
      }
      if (rv == 0) {
        break;
      } else {
        if (rv <= 0) {
          right = i - 1;
        } else {
          left = i + 1;
        }
      }
      i = (left + right) / 2;
    }
    while (i < ln) {
      idx___0 = (BDBIDX *)*(idxs->array + (i + idxs->start));
      ebuf___1 = (char *)idx___0 + (int )sizeof(*idx___0);
      if ((unsigned int )cmp == (unsigned int )(& tccmplexical)) {
        while (1) {
          rv___0 = 0;
          if (ksiz < idx___0->ksiz) {
            tmp___3 = ksiz;
          } else {
            tmp___3 = idx___0->ksiz;
          }
          _TC_min___0 = tmp___3;
          _TC_i___0 = 0;
          while (_TC_i___0 < _TC_min___0) {
            if ((int )*((unsigned char *)kbuf + _TC_i___0) != (int )*((unsigned char *)ebuf___1 + _TC_i___0)) {
              rv___0 = (int )*((unsigned char *)kbuf + _TC_i___0) - (int )*((unsigned char *)ebuf___1 + _TC_i___0);
              break;
            }
            _TC_i___0 ++;
          }
          if (rv___0 == 0) {
            rv___0 = ksiz - idx___0->ksiz;
          }
          break;
        }
      } else {
        rv___0 = (*cmp)(kbuf, ksiz, (char const   *)ebuf___1, idx___0->ksiz, cmpop);
      }
      if (rv___0 < 0) {
        while (1) {
          TC_myindex = i;
          TC_myindex += idxs->start;
          if (idxs->start + idxs->num >= idxs->anum) {
            idxs->anum += idxs->num + 1;
            while (1) {
              tmp___5 = realloc((void *)idxs->array, (unsigned int )(idxs->anum * (int )sizeof(*(idxs->array + 0))));
              tmp___4 = (void **)tmp___5;
              idxs->array = tmp___4;
              if (! tmp___4) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          memmove((void *)((idxs->array + TC_myindex) + 1), (void const   *)(idxs->array + TC_myindex),
                  (unsigned int )((int )sizeof(*(idxs->array + 0)) * ((idxs->start + idxs->num) - TC_myindex)));
          *(idxs->array + TC_myindex) = (void *)nidx;
          (idxs->num) ++;
          break;
        }
        break;
      }
      i ++;
    }
    if (i >= ln) {
      while (1) {
        TC_index___0 = idxs->start + idxs->num;
        if (TC_index___0 >= idxs->anum) {
          idxs->anum += idxs->num + 1;
          while (1) {
            tmp___7 = realloc((void *)idxs->array, (unsigned int )(idxs->anum * (int )sizeof(*(idxs->array + 0))));
            tmp___6 = (void **)tmp___7;
            idxs->array = tmp___6;
            if (! tmp___6) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        *(idxs->array + TC_index___0) = (void *)nidx;
        (idxs->num) ++;
        break;
      }
    }
  }
  node->dirty = (_Bool)1;
  return;
}
}
static _Bool tcbdbnodesubidx(TCBDB *bdb , BDBNODE *node , uint64_t pid ) 
{ TCPTRLIST *idxs ;
  BDBIDX *idx ;
  void *tmp ;
  BDBNODE *pnode ;
  BDBNODE *tmp___0 ;
  _Bool tmp___1 ;
  int ln ;
  int i ;
  BDBIDX *idx___0 ;
  void *tmp___2 ;

  {
  node->dirty = (_Bool)1;
  idxs = node->idxs;
  if (node->heir == pid) {
    if (idxs->num > 0) {
      tmp = tcptrlistshift(idxs);
      idx = (BDBIDX *)tmp;
      node->heir = idx->pid;
      while (1) {
        free((void *)idx);
        break;
      }
      return ((_Bool)1);
    } else {
      if (bdb->hnum > 0) {
        (bdb->hnum) --;
        tmp___0 = tcbdbnodeload(bdb, *(bdb->hist + bdb->hnum));
        pnode = tmp___0;
        if (! pnode) {
          tcbdbsetecode(bdb, 9999, "tcbdb.c", 2664, "tcbdbnodesubidx");
          return ((_Bool)0);
        }
        node->dead = (_Bool)1;
        tmp___1 = tcbdbnodesubidx(bdb, pnode, node->id);
        return (tmp___1);
      }
    }
    node->dead = (_Bool)1;
    bdb->root = pid;
    while (pid > (unsigned long long )((1LL << 48) + 1LL)) {
      node = tcbdbnodeload(bdb, pid);
      if (! node) {
        tcbdbsetecode(bdb, 9999, "tcbdb.c", 2675, "tcbdbnodesubidx");
        return ((_Bool)0);
      }
      if (node->dead) {
        pid = node->heir;
        bdb->root = pid;
      } else {
        pid = 0ULL;
      }
    }
    return ((_Bool)0);
  }
  ln = idxs->num;
  i = 0;
  while (i < ln) {
    idx___0 = (BDBIDX *)*(idxs->array + (i + idxs->start));
    if (idx___0->pid == pid) {
      while (1) {
        tmp___2 = tcptrlistremove(idxs, i);
        free(tmp___2);
        break;
      }
      return ((_Bool)1);
    }
    i ++;
  }
  tcbdbsetecode(bdb, 9999, "tcbdb.c", 2695, "tcbdbnodesubidx");
  return ((_Bool)0);
}
}
static uint64_t tcbdbsearchleaf(TCBDB *bdb , char const   *kbuf , int ksiz ) 
{ int (*cmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
  void *cmpop ;
  uint64_t *hist ;
  uint64_t pid ;
  int hnum ;
  BDBNODE *node ;
  BDBNODE *tmp ;
  int tmp___0 ;
  TCPTRLIST *idxs ;
  int ln ;
  int left ;
  int right ;
  int i ;
  BDBIDX *idx ;
  char *ebuf ;
  int rv ;
  int _TC_min ;
  int tmp___1 ;
  int _TC_i ;
  char *ebuf___0 ;
  int rv___0 ;
  int _TC_min___0 ;
  int tmp___2 ;
  int _TC_i___0 ;

  {
  cmp = bdb->cmp;
  cmpop = bdb->cmpop;
  hist = bdb->hist;
  pid = bdb->root;
  hnum = 0;
  bdb->hleaf = 0ULL;
  while (pid > (unsigned long long )((1LL << 48) + 1LL)) {
    tmp = tcbdbnodeload(bdb, pid);
    node = tmp;
    if (! node) {
      tcbdbsetecode(bdb, 9999, "tcbdb.c", 2716, "tcbdbsearchleaf");
      return (0ULL);
    }
    tmp___0 = hnum;
    hnum ++;
    *(hist + tmp___0) = node->id;
    idxs = node->idxs;
    ln = idxs->num;
    if (ln > 0) {
      left = 0;
      right = ln;
      i = (left + right) / 2;
      idx = (BDBIDX *)((void *)0);
      while (1) {
        if (right >= left) {
          if (! (i < ln)) {
            break;
          }
        } else {
          break;
        }
        idx = (BDBIDX *)*(idxs->array + (i + idxs->start));
        ebuf = (char *)idx + (int )sizeof(*idx);
        if ((unsigned int )cmp == (unsigned int )(& tccmplexical)) {
          while (1) {
            rv = 0;
            if (ksiz < idx->ksiz) {
              tmp___1 = ksiz;
            } else {
              tmp___1 = idx->ksiz;
            }
            _TC_min = tmp___1;
            _TC_i = 0;
            while (_TC_i < _TC_min) {
              if ((int )*((unsigned char *)kbuf + _TC_i) != (int )*((unsigned char *)ebuf + _TC_i)) {
                rv = (int )*((unsigned char *)kbuf + _TC_i) - (int )*((unsigned char *)ebuf + _TC_i);
                break;
              }
              _TC_i ++;
            }
            if (rv == 0) {
              rv = ksiz - idx->ksiz;
            }
            break;
          }
        } else {
          rv = (*cmp)(kbuf, ksiz, (char const   *)ebuf, idx->ksiz, cmpop);
        }
        if (rv == 0) {
          break;
        } else {
          if (rv <= 0) {
            right = i - 1;
          } else {
            left = i + 1;
          }
        }
        i = (left + right) / 2;
      }
      if (i > 0) {
        i --;
      }
      while (i < ln) {
        idx = (BDBIDX *)*(idxs->array + (i + idxs->start));
        ebuf___0 = (char *)idx + (int )sizeof(*idx);
        if ((unsigned int )cmp == (unsigned int )(& tccmplexical)) {
          while (1) {
            rv___0 = 0;
            if (ksiz < idx->ksiz) {
              tmp___2 = ksiz;
            } else {
              tmp___2 = idx->ksiz;
            }
            _TC_min___0 = tmp___2;
            _TC_i___0 = 0;
            while (_TC_i___0 < _TC_min___0) {
              if ((int )*((unsigned char *)kbuf + _TC_i___0) != (int )*((unsigned char *)ebuf___0 + _TC_i___0)) {
                rv___0 = (int )*((unsigned char *)kbuf + _TC_i___0) - (int )*((unsigned char *)ebuf___0 + _TC_i___0);
                break;
              }
              _TC_i___0 ++;
            }
            if (rv___0 == 0) {
              rv___0 = ksiz - idx->ksiz;
            }
            break;
          }
        } else {
          rv___0 = (*cmp)(kbuf, ksiz, (char const   *)ebuf___0, idx->ksiz, cmpop);
        }
        if (rv___0 < 0) {
          if (i == 0) {
            pid = node->heir;
            break;
          }
          idx = (BDBIDX *)*(idxs->array + ((i - 1) + idxs->start));
          pid = idx->pid;
          break;
        }
        i ++;
      }
      if (i >= ln) {
        pid = idx->pid;
      }
    } else {
      pid = node->heir;
    }
  }
  if (bdb->lleaf == pid) {
    bdb->hleaf = pid;
  }
  bdb->lleaf = pid;
  bdb->hnum = hnum;
  return (pid);
}
}
static BDBREC *tcbdbsearchrec(TCBDB *bdb , BDBLEAF *leaf , char const   *kbuf , int ksiz ,
                              int *ip ) 
{ int (*cmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
  void *cmpop ;
  TCPTRLIST *recs ;
  int ln ;
  int left ;
  int right ;
  int i ;
  BDBREC *rec ;
  char *dbuf ;
  int rv ;
  int _TC_min ;
  int tmp ;
  int _TC_i ;

  {
  cmp = bdb->cmp;
  cmpop = bdb->cmpop;
  recs = leaf->recs;
  ln = recs->num;
  left = 0;
  right = ln;
  i = (left + right) / 2;
  while (1) {
    if (right >= left) {
      if (! (i < ln)) {
        break;
      }
    } else {
      break;
    }
    rec = (BDBREC *)*(recs->array + (i + recs->start));
    dbuf = (char *)rec + (int )sizeof(*rec);
    if ((unsigned int )cmp == (unsigned int )(& tccmplexical)) {
      while (1) {
        rv = 0;
        if (ksiz < rec->ksiz) {
          tmp = ksiz;
        } else {
          tmp = rec->ksiz;
        }
        _TC_min = tmp;
        _TC_i = 0;
        while (_TC_i < _TC_min) {
          if ((int )*((unsigned char *)kbuf + _TC_i) != (int )*((unsigned char *)dbuf + _TC_i)) {
            rv = (int )*((unsigned char *)kbuf + _TC_i) - (int )*((unsigned char *)dbuf + _TC_i);
            break;
          }
          _TC_i ++;
        }
        if (rv == 0) {
          rv = ksiz - rec->ksiz;
        }
        break;
      }
    } else {
      rv = (*cmp)(kbuf, ksiz, (char const   *)dbuf, rec->ksiz, cmpop);
    }
    if (rv == 0) {
      if (ip) {
        *ip = i;
      }
      return (rec);
    } else {
      if (rv <= 0) {
        right = i - 1;
      } else {
        left = i + 1;
      }
    }
    i = (left + right) / 2;
  }
  if (ip) {
    *ip = i;
  }
  return ((BDBREC *)((void *)0));
}
}
static void tcbdbremoverec(TCBDB *bdb , BDBLEAF *leaf , BDBREC *rec , int ri ) 
{ int vsiz ;
  char *vbuf ;
  void *tmp ;
  int psiz ;
  BDBREC *orec ;
  void *tmp___0 ;
  char *dbuf ;
  void *tmp___1 ;

  {
  if (rec->rest) {
    leaf->size -= rec->vsiz;
    tmp = tclistshift(rec->rest, & vsiz);
    vbuf = (char *)tmp;
    psiz = ((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz;
    if (vsiz > rec->vsiz) {
      orec = rec;
      while (1) {
        tmp___0 = realloc((void *)rec, (unsigned int )(((((int )sizeof(*rec) + rec->ksiz) + psiz) + vsiz) + 1));
        rec = (BDBREC *)tmp___0;
        if (! rec) {
          tcmyfatal("out of memory");
        }
        break;
      }
      if ((unsigned int )rec != (unsigned int )orec) {
        tcptrlistover(leaf->recs, ri, (void *)rec);
      }
    }
    dbuf = (char *)rec + (int )sizeof(*rec);
    memcpy((void * __restrict  )((dbuf + rec->ksiz) + psiz), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf + ((rec->ksiz + psiz) + vsiz)) = (char )'\000';
    rec->vsiz = vsiz;
    while (1) {
      free((void *)vbuf);
      break;
    }
    if ((rec->rest)->num < 1) {
      tclistdel(rec->rest);
      rec->rest = (TCLIST *)((void *)0);
    }
  } else {
    leaf->size -= rec->ksiz + rec->vsiz;
    while (1) {
      tmp___1 = tcptrlistremove(leaf->recs, ri);
      free(tmp___1);
      break;
    }
  }
  (bdb->rnum) --;
  return;
}
}
static _Bool tcbdbcacheadjust(TCBDB *bdb ) 
{ _Bool err ;
  int ecode ;
  int tmp ;
  _Bool clk ;
  _Bool tmp___0 ;
  int tmp___1 ;
  TCMAP *leafc ;
  int dnum ;
  long tmp___2 ;
  int i ;
  int rsiz ;
  void const   *tmp___3 ;
  void const   *tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  int ecode___0 ;
  int tmp___7 ;
  _Bool clk___0 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  TCMAP *nodec ;
  int dnum___0 ;
  long tmp___10 ;
  int i___0 ;
  int rsiz___0 ;
  void const   *tmp___11 ;
  void const   *tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;

  {
  err = (_Bool)0;
  if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
    while (1) {
      break;
    }
    tmp = tchdbecode(bdb->hdb);
    ecode = tmp;
    if (bdb->mmtx) {
      tmp___0 = tcbdblockcache(bdb);
      tmp___1 = (int )tmp___0;
    } else {
      tmp___1 = 1;
    }
    clk = (_Bool )tmp___1;
    leafc = bdb->leafc;
    tcmapiterinit(leafc);
    tmp___2 = tclmax((long )((bdb->leafc)->rnum - (unsigned long long )bdb->lcnum),
                     8L);
    dnum = (int )tmp___2;
    i = 0;
    while (i < dnum) {
      tmp___3 = tcmapiternext(leafc, & rsiz);
      tmp___4 = tcmapiterval(tmp___3, & rsiz);
      tmp___5 = tcbdbleafcacheout(bdb, (BDBLEAF *)tmp___4);
      if (! tmp___5) {
        err = (_Bool)1;
      }
      i ++;
    }
    if (clk) {
      if (bdb->mmtx) {
        tcbdbunlockcache(bdb);
      }
    }
    if (! err) {
      tmp___6 = tchdbecode(bdb->hdb);
      if (tmp___6 != ecode) {
        tcbdbsetecode(bdb, ecode, "tcbdb.c", 2870, "tcbdbcacheadjust");
      }
    }
  }
  if ((bdb->nodec)->rnum > (unsigned long long )bdb->ncnum) {
    while (1) {
      break;
    }
    tmp___7 = tchdbecode(bdb->hdb);
    ecode___0 = tmp___7;
    if (bdb->mmtx) {
      tmp___8 = tcbdblockcache(bdb);
      tmp___9 = (int )tmp___8;
    } else {
      tmp___9 = 1;
    }
    clk___0 = (_Bool )tmp___9;
    nodec = bdb->nodec;
    tcmapiterinit(nodec);
    tmp___10 = tclmax((long )((bdb->nodec)->rnum - (unsigned long long )bdb->ncnum),
                      8L);
    dnum___0 = (int )tmp___10;
    i___0 = 0;
    while (i___0 < dnum___0) {
      tmp___11 = tcmapiternext(nodec, & rsiz___0);
      tmp___12 = tcmapiterval(tmp___11, & rsiz___0);
      tmp___13 = tcbdbnodecacheout(bdb, (BDBNODE *)tmp___12);
      if (! tmp___13) {
        err = (_Bool)1;
      }
      i___0 ++;
    }
    if (clk___0) {
      if (bdb->mmtx) {
        tcbdbunlockcache(bdb);
      }
    }
    if (! err) {
      tmp___14 = tchdbecode(bdb->hdb);
      if (tmp___14 != ecode___0) {
        tcbdbsetecode(bdb, ecode___0, "tcbdb.c", 2886, "tcbdbcacheadjust");
      }
    }
  }
  return ((_Bool )(! err));
}
}
static void tcbdbcachepurge(TCBDB *bdb ) 
{ _Bool clk ;
  _Bool tmp ;
  int tmp___0 ;
  int tsiz ;
  char const   *tmp___1 ;
  int lsiz ;
  BDBLEAF *leaf ;
  void const   *tmp___2 ;
  TCPTRLIST *recs ;
  int ln ;
  int i ;
  BDBREC *rec ;
  void const   *tmp___3 ;
  int nsiz ;
  BDBNODE *node ;
  void const   *tmp___4 ;
  TCPTRLIST *idxs ;
  int ln___0 ;
  int i___0 ;
  BDBIDX *idx ;
  void const   *tmp___5 ;

  {
  if (bdb->mmtx) {
    tmp = tcbdblockcache(bdb);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  clk = (_Bool )tmp___0;
  tcmapiterinit(bdb->leafc);
  while (1) {
    tmp___3 = tcmapiternext(bdb->leafc, & tsiz);
    tmp___1 = (char const   *)tmp___3;
    if (! ((unsigned int )tmp___1 != (unsigned int )((void *)0))) {
      break;
    }
    tmp___2 = tcmapiterval((void const   *)tmp___1, & lsiz);
    leaf = (BDBLEAF *)tmp___2;
    if (! leaf->dirty) {
      continue;
    }
    recs = leaf->recs;
    ln = recs->num;
    i = 0;
    while (i < ln) {
      rec = (BDBREC *)*(recs->array + (i + recs->start));
      if (rec->rest) {
        tclistdel(rec->rest);
      }
      while (1) {
        free((void *)rec);
        break;
      }
      i ++;
    }
    tcptrlistdel(recs);
    tcmapout(bdb->leafc, (void const   *)tmp___1, tsiz);
  }
  tcmapiterinit(bdb->nodec);
  while (1) {
    tmp___5 = tcmapiternext(bdb->nodec, & tsiz);
    tmp___1 = (char const   *)tmp___5;
    if (! ((unsigned int )tmp___1 != (unsigned int )((void *)0))) {
      break;
    }
    tmp___4 = tcmapiterval((void const   *)tmp___1, & nsiz);
    node = (BDBNODE *)tmp___4;
    if (! node->dirty) {
      continue;
    }
    idxs = node->idxs;
    ln___0 = idxs->num;
    i___0 = 0;
    while (i___0 < ln___0) {
      idx = (BDBIDX *)*(idxs->array + (i___0 + idxs->start));
      while (1) {
        free((void *)idx);
        break;
      }
      i___0 ++;
    }
    tcptrlistdel(idxs);
    tcmapout(bdb->nodec, (void const   *)tmp___1, tsiz);
  }
  if (clk) {
    if (bdb->mmtx) {
      tcbdbunlockcache(bdb);
    }
  }
  return;
}
}
static _Bool tcbdbopenimpl(TCBDB *bdb , char const   *path , int omode ) 
{ int homode ;
  _Bool tmp ;
  BDBLEAF *leaf ;
  BDBLEAF *tmp___0 ;
  _Bool tmp___1 ;
  uint64_t tmp___2 ;
  uint8_t hopts ;
  uint8_t tmp___3 ;
  uint8_t opts ;

  {
  homode = 1;
  if (omode & 2) {
    homode = 2;
    if (omode & 4) {
      homode |= 4;
    }
    if (omode & 8) {
      homode |= 8;
    }
    bdb->wmode = (_Bool)1;
  } else {
    bdb->wmode = (_Bool)0;
  }
  if (omode & 16) {
    homode |= 16;
  }
  if (omode & 32) {
    homode |= 32;
  }
  if (omode & 64) {
    homode |= 64;
  }
  tchdbsettype(bdb->hdb, (unsigned char)1);
  tmp = tchdbopen(bdb->hdb, path, homode);
  if (! tmp) {
    return ((_Bool)0);
  }
  bdb->root = 0ULL;
  bdb->first = 0ULL;
  bdb->last = 0ULL;
  bdb->lnum = 0ULL;
  bdb->nnum = 0ULL;
  bdb->rnum = 0ULL;
  bdb->opaque = tchdbopaque(bdb->hdb);
  bdb->leafc = tcmapnew2(bdb->lcnum * 2U + 1U);
  bdb->nodec = tcmapnew2(bdb->ncnum * 2U + 1U);
  if (bdb->wmode) {
    tmp___2 = tchdbrnum(bdb->hdb);
    if (tmp___2 < 1ULL) {
      tmp___0 = tcbdbleafnew(bdb, 0ULL, 0ULL);
      leaf = tmp___0;
      bdb->root = leaf->id;
      bdb->first = leaf->id;
      bdb->last = leaf->id;
      bdb->lnum = 1ULL;
      bdb->nnum = 0ULL;
      bdb->rnum = 0ULL;
      if (! bdb->cmp) {
        bdb->cmp = & tccmplexical;
        bdb->cmpop = (void *)0;
      }
      tcbdbdumpmeta(bdb);
      tmp___1 = tcbdbleafsave(bdb, leaf);
      if (! tmp___1) {
        tcmapdel(bdb->nodec);
        tcmapdel(bdb->leafc);
        tchdbclose(bdb->hdb);
        return ((_Bool)0);
      }
    }
  }
  tcbdbloadmeta(bdb);
  if (! bdb->cmp) {
    tcbdbsetecode(bdb, 2, "tcbdb.c", 2983, "tcbdbopenimpl");
    tcmapdel(bdb->nodec);
    tcmapdel(bdb->leafc);
    tchdbclose(bdb->hdb);
    return ((_Bool)0);
  }
  if (bdb->lmemb < 4U) {
    tcbdbsetecode(bdb, 5, "tcbdb.c", 2992, "tcbdbopenimpl");
    tcmapdel(bdb->nodec);
    tcmapdel(bdb->leafc);
    tchdbclose(bdb->hdb);
    return ((_Bool)0);
  } else {
    if (bdb->nmemb < 4U) {
      tcbdbsetecode(bdb, 5, "tcbdb.c", 2992, "tcbdbopenimpl");
      tcmapdel(bdb->nodec);
      tcmapdel(bdb->leafc);
      tchdbclose(bdb->hdb);
      return ((_Bool)0);
    } else {
      if (bdb->root < 1ULL) {
        tcbdbsetecode(bdb, 5, "tcbdb.c", 2992, "tcbdbopenimpl");
        tcmapdel(bdb->nodec);
        tcmapdel(bdb->leafc);
        tchdbclose(bdb->hdb);
        return ((_Bool)0);
      } else {
        if (bdb->first < 1ULL) {
          tcbdbsetecode(bdb, 5, "tcbdb.c", 2992, "tcbdbopenimpl");
          tcmapdel(bdb->nodec);
          tcmapdel(bdb->leafc);
          tchdbclose(bdb->hdb);
          return ((_Bool)0);
        } else {
          if (bdb->last < 1ULL) {
            tcbdbsetecode(bdb, 5, "tcbdb.c", 2992, "tcbdbopenimpl");
            tcmapdel(bdb->nodec);
            tcmapdel(bdb->leafc);
            tchdbclose(bdb->hdb);
            return ((_Bool)0);
          } else {
            if (bdb->lnum < 0ULL) {
              tcbdbsetecode(bdb, 5, "tcbdb.c", 2992, "tcbdbopenimpl");
              tcmapdel(bdb->nodec);
              tcmapdel(bdb->leafc);
              tchdbclose(bdb->hdb);
              return ((_Bool)0);
            } else {
              if (bdb->nnum < 0ULL) {
                tcbdbsetecode(bdb, 5, "tcbdb.c", 2992, "tcbdbopenimpl");
                tcmapdel(bdb->nodec);
                tcmapdel(bdb->leafc);
                tchdbclose(bdb->hdb);
                return ((_Bool)0);
              } else {
                if (bdb->rnum < 0ULL) {
                  tcbdbsetecode(bdb, 5, "tcbdb.c", 2992, "tcbdbopenimpl");
                  tcmapdel(bdb->nodec);
                  tcmapdel(bdb->leafc);
                  tchdbclose(bdb->hdb);
                  return ((_Bool)0);
                }
              }
            }
          }
        }
      }
    }
  }
  bdb->open = (_Bool)1;
  tmp___3 = tchdbopts(bdb->hdb);
  hopts = tmp___3;
  opts = (unsigned char)0;
  if ((int )hopts & 1) {
    opts = (unsigned char )((int )opts | 1);
  }
  if ((int )hopts & 2) {
    opts = (unsigned char )((int )opts | 2);
  }
  if ((int )hopts & 4) {
    opts = (unsigned char )((int )opts | 4);
  }
  if ((int )hopts & 8) {
    opts = (unsigned char )((int )opts | 8);
  }
  if ((int )hopts & 16) {
    opts = (unsigned char )((int )opts | 16);
  }
  bdb->opts = opts;
  bdb->hleaf = 0ULL;
  bdb->lleaf = 0ULL;
  bdb->tran = (_Bool)0;
  bdb->rbopaque = (char *)((void *)0);
  bdb->clock = 1ULL;
  return ((_Bool)1);
}
}
static _Bool tcbdbcloseimpl(TCBDB *bdb ) 
{ _Bool err ;
  _Bool tmp ;
  char const   *vbuf ;
  int vsiz ;
  TCMAP *leafc ;
  void const   *tmp___0 ;
  _Bool tmp___1 ;
  void const   *tmp___2 ;
  TCMAP *nodec ;
  void const   *tmp___3 ;
  _Bool tmp___4 ;
  void const   *tmp___5 ;
  _Bool tmp___6 ;

  {
  err = (_Bool)0;
  if (bdb->tran) {
    tcbdbcachepurge(bdb);
    memcpy((void * __restrict  )bdb->opaque, (void const   * __restrict  )bdb->rbopaque,
           64U);
    tcbdbloadmeta(bdb);
    while (1) {
      free((void *)bdb->rbopaque);
      break;
    }
    bdb->tran = (_Bool)0;
    bdb->rbopaque = (char *)((void *)0);
    tmp = tchdbtranvoid(bdb->hdb);
    if (! tmp) {
      err = (_Bool)1;
    }
  }
  bdb->open = (_Bool)0;
  leafc = bdb->leafc;
  tcmapiterinit(leafc);
  while (1) {
    tmp___2 = tcmapiternext(leafc, & vsiz);
    vbuf = (char const   *)tmp___2;
    if (! ((unsigned int )vbuf != (unsigned int )((void *)0))) {
      break;
    }
    tmp___0 = tcmapiterval((void const   *)vbuf, & vsiz);
    tmp___1 = tcbdbleafcacheout(bdb, (BDBLEAF *)tmp___0);
    if (! tmp___1) {
      err = (_Bool)1;
    }
  }
  nodec = bdb->nodec;
  tcmapiterinit(nodec);
  while (1) {
    tmp___5 = tcmapiternext(nodec, & vsiz);
    vbuf = (char const   *)tmp___5;
    if (! ((unsigned int )vbuf != (unsigned int )((void *)0))) {
      break;
    }
    tmp___3 = tcmapiterval((void const   *)vbuf, & vsiz);
    tmp___4 = tcbdbnodecacheout(bdb, (BDBNODE *)tmp___3);
    if (! tmp___4) {
      err = (_Bool)1;
    }
  }
  if (bdb->wmode) {
    tcbdbdumpmeta(bdb);
  }
  tcmapdel(bdb->nodec);
  tcmapdel(bdb->leafc);
  tmp___6 = tchdbclose(bdb->hdb);
  if (! tmp___6) {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcbdbputimpl(TCBDB *bdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                          int vsiz , int dmode ) 
{ BDBLEAF *leaf ;
  uint64_t hlid ;
  uint64_t pid ;
  uint64_t tmp ;
  _Bool tmp___0 ;
  int rnum ;
  uint64_t tmp___1 ;
  BDBLEAF *newleaf ;
  BDBLEAF *tmp___2 ;
  uint64_t heir ;
  uint64_t pid___0 ;
  BDBREC *rec ;
  char *dbuf ;
  int ksiz___0 ;
  char *kbuf___0 ;
  void *tmp___3 ;
  BDBNODE *node ;
  uint64_t parent ;
  TCPTRLIST *idxs ;
  int ln ;
  int mid ;
  BDBIDX *idx ;
  BDBNODE *newnode ;
  BDBNODE *tmp___4 ;
  char *ebuf ;
  void *tmp___5 ;
  int i ;
  char *ebuf___0 ;
  int i___0 ;
  void *tmp___6 ;
  uint64_t xnum ;
  BDBCUR *cur ;
  BDBCUR *tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  uint64_t tmp___10 ;
  uint64_t tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;

  {
  leaf = (BDBLEAF *)((void *)0);
  hlid = bdb->hleaf;
  if (hlid < 1ULL) {
    goto _L;
  } else {
    leaf = tcbdbgethistleaf(bdb, (char const   *)kbuf, ksiz, hlid);
    if (! leaf) {
      _L: 
      tmp = tcbdbsearchleaf(bdb, (char const   *)kbuf, ksiz);
      pid = tmp;
      if (pid < 1ULL) {
        return ((_Bool)0);
      }
      leaf = tcbdbleafload(bdb, pid);
      if (! leaf) {
        return ((_Bool)0);
      }
      hlid = 0ULL;
    }
  }
  tmp___0 = tcbdbleafaddrec(bdb, leaf, dmode, (char const   *)kbuf, ksiz, (char const   *)vbuf,
                            vsiz);
  if (! tmp___0) {
    if (! bdb->tran) {
      tcbdbcacheadjust(bdb);
    }
    return ((_Bool)0);
  }
  rnum = (leaf->recs)->num;
  if ((unsigned int )rnum > bdb->lmemb) {
    goto _L___1;
  } else {
    if (rnum > 1) {
      if ((unsigned int )leaf->size > bdb->lsmax) {
        _L___1: 
        if (hlid > 0ULL) {
          tmp___1 = tcbdbsearchleaf(bdb, (char const   *)kbuf, ksiz);
          if (hlid != tmp___1) {
            return ((_Bool)0);
          }
        }
        bdb->lschk = 0U;
        tmp___2 = tcbdbleafdivide(bdb, leaf);
        newleaf = tmp___2;
        if (! newleaf) {
          return ((_Bool)0);
        }
        if (leaf->id == bdb->last) {
          bdb->last = newleaf->id;
        }
        heir = leaf->id;
        pid___0 = newleaf->id;
        rec = (BDBREC *)*((newleaf->recs)->array + (newleaf->recs)->start);
        dbuf = (char *)rec + (int )sizeof(*rec);
        ksiz___0 = rec->ksiz;
        while (1) {
          while (1) {
            tmp___3 = malloc((unsigned int )(ksiz___0 + 1));
            kbuf___0 = (char *)tmp___3;
            if (! kbuf___0) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )kbuf___0, (void const   * __restrict  )dbuf,
                 (unsigned int )ksiz___0);
          *(kbuf___0 + ksiz___0) = (char )'\000';
          break;
        }
        while (1) {
          if (bdb->hnum < 1) {
            node = tcbdbnodenew(bdb, heir);
            tcbdbnodeaddidx(bdb, node, (_Bool)1, pid___0, (char const   *)kbuf___0,
                            ksiz___0);
            bdb->root = node->id;
            while (1) {
              free((void *)kbuf___0);
              break;
            }
            break;
          }
          (bdb->hnum) --;
          parent = *(bdb->hist + bdb->hnum);
          node = tcbdbnodeload(bdb, parent);
          if (! node) {
            while (1) {
              free((void *)kbuf___0);
              break;
            }
            return ((_Bool)0);
          }
          tcbdbnodeaddidx(bdb, node, (_Bool)0, pid___0, (char const   *)kbuf___0,
                          ksiz___0);
          while (1) {
            free((void *)kbuf___0);
            break;
          }
          idxs = node->idxs;
          ln = idxs->num;
          if ((unsigned int )ln <= bdb->nmemb) {
            break;
          }
          mid = ln / 2;
          idx = (BDBIDX *)*(idxs->array + (mid + idxs->start));
          tmp___4 = tcbdbnodenew(bdb, idx->pid);
          newnode = tmp___4;
          heir = node->id;
          pid___0 = newnode->id;
          ebuf = (char *)idx + (int )sizeof(*idx);
          while (1) {
            while (1) {
              tmp___5 = malloc((unsigned int )(idx->ksiz + 1));
              kbuf___0 = (char *)tmp___5;
              if (! kbuf___0) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )kbuf___0, (void const   * __restrict  )ebuf,
                   (unsigned int )idx->ksiz);
            *(kbuf___0 + idx->ksiz) = (char )'\000';
            break;
          }
          ksiz___0 = idx->ksiz;
          i = mid + 1;
          while (i < ln) {
            idx = (BDBIDX *)*(idxs->array + (i + idxs->start));
            ebuf___0 = (char *)idx + (int )sizeof(*idx);
            tcbdbnodeaddidx(bdb, newnode, (_Bool)1, idx->pid, (char const   *)ebuf___0,
                            idx->ksiz);
            i ++;
          }
          ln = (newnode->idxs)->num;
          i___0 = 0;
          while (i___0 <= ln) {
            tmp___6 = tcptrlistpop(idxs);
            idx = (BDBIDX *)tmp___6;
            while (1) {
              free((void *)idx);
              break;
            }
            i___0 ++;
          }
          node->dirty = (_Bool)1;
        }
        if (bdb->capnum > 0ULL) {
          if (bdb->rnum > bdb->capnum) {
            xnum = bdb->rnum - bdb->capnum;
            tmp___7 = tcbdbcurnew(bdb);
            cur = tmp___7;
            while (1) {
              tmp___10 = xnum;
              xnum --;
              if (! (tmp___10 > 0ULL)) {
                break;
              }
              if (cur->id < 1ULL) {
                goto _L___0;
              } else {
                if (cur->clock != bdb->clock) {
                  _L___0: 
                  tmp___8 = tcbdbcurfirstimpl(cur);
                  if (! tmp___8) {
                    tcbdbcurdel(cur);
                    return ((_Bool)0);
                  }
                }
              }
              tmp___9 = tcbdbcuroutimpl(cur);
              if (! tmp___9) {
                tcbdbcurdel(cur);
                return ((_Bool)0);
              }
            }
            tcbdbcurdel(cur);
          }
        }
      } else {
        goto _L___2;
      }
    } else {
      _L___2: 
      if (rnum < 1) {
        if (hlid > 0ULL) {
          tmp___11 = tcbdbsearchleaf(bdb, (char const   *)kbuf, ksiz);
          if (hlid != tmp___11) {
            return ((_Bool)0);
          }
        }
        if (bdb->hnum > 0) {
          tmp___12 = tcbdbleafkill(bdb, leaf);
          if (! tmp___12) {
            return ((_Bool)0);
          }
        }
      }
    }
  }
  if (! bdb->tran) {
    tmp___13 = tcbdbcacheadjust(bdb);
    if (! tmp___13) {
      return ((_Bool)0);
    }
  }
  return ((_Bool)1);
}
}
static _Bool tcbdboutimpl(TCBDB *bdb , char const   *kbuf , int ksiz ) 
{ BDBLEAF *leaf ;
  uint64_t hlid ;
  uint64_t pid ;
  uint64_t tmp ;
  int ri ;
  BDBREC *rec ;
  BDBREC *tmp___0 ;
  uint64_t tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  leaf = (BDBLEAF *)((void *)0);
  hlid = bdb->hleaf;
  if (hlid < 1ULL) {
    goto _L;
  } else {
    leaf = tcbdbgethistleaf(bdb, kbuf, ksiz, hlid);
    if (! leaf) {
      _L: 
      tmp = tcbdbsearchleaf(bdb, kbuf, ksiz);
      pid = tmp;
      if (pid < 1ULL) {
        return ((_Bool)0);
      }
      leaf = tcbdbleafload(bdb, pid);
      if (! leaf) {
        return ((_Bool)0);
      }
      hlid = 0ULL;
    }
  }
  tmp___0 = tcbdbsearchrec(bdb, leaf, kbuf, ksiz, & ri);
  rec = tmp___0;
  if (! rec) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 3170, "tcbdboutimpl");
    return ((_Bool)0);
  }
  tcbdbremoverec(bdb, leaf, rec, ri);
  leaf->dirty = (_Bool)1;
  if ((leaf->recs)->num < 1) {
    if (hlid > 0ULL) {
      tmp___1 = tcbdbsearchleaf(bdb, kbuf, ksiz);
      if (hlid != tmp___1) {
        return ((_Bool)0);
      }
    }
    if (bdb->hnum > 0) {
      tmp___2 = tcbdbleafkill(bdb, leaf);
      if (! tmp___2) {
        return ((_Bool)0);
      }
    }
  }
  if (! bdb->tran) {
    tmp___3 = tcbdbcacheadjust(bdb);
    if (! tmp___3) {
      return ((_Bool)0);
    }
  }
  return ((_Bool)1);
}
}
static _Bool tcbdboutlist(TCBDB *bdb , char const   *kbuf , int ksiz ) 
{ BDBLEAF *leaf ;
  uint64_t hlid ;
  uint64_t pid ;
  uint64_t tmp ;
  int ri ;
  BDBREC *rec ;
  BDBREC *tmp___0 ;
  int rnum ;
  int rsiz ;
  TCLIST *rest ;
  int ln ;
  int i ;
  void *tmp___1 ;
  uint64_t tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  leaf = (BDBLEAF *)((void *)0);
  hlid = bdb->hleaf;
  if (hlid < 1ULL) {
    goto _L;
  } else {
    leaf = tcbdbgethistleaf(bdb, kbuf, ksiz, hlid);
    if (! leaf) {
      _L: 
      tmp = tcbdbsearchleaf(bdb, kbuf, ksiz);
      pid = tmp;
      if (pid < 1ULL) {
        return ((_Bool)0);
      }
      leaf = tcbdbleafload(bdb, pid);
      if (! leaf) {
        return ((_Bool)0);
      }
    }
  }
  tmp___0 = tcbdbsearchrec(bdb, leaf, kbuf, ksiz, & ri);
  rec = tmp___0;
  if (! rec) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 3201, "tcbdboutlist");
    return ((_Bool)0);
  }
  rnum = 1;
  rsiz = rec->ksiz + rec->vsiz;
  if (rec->rest) {
    rest = rec->rest;
    ln = (rec->rest)->num;
    rnum += ln;
    i = 0;
    while (i < ln) {
      rsiz += (rest->array + (i + rest->start))->size;
      i ++;
    }
    tclistdel(rest);
  }
  while (1) {
    tmp___1 = tcptrlistremove(leaf->recs, ri);
    free(tmp___1);
    break;
  }
  leaf->size -= rsiz;
  leaf->dirty = (_Bool)1;
  bdb->rnum -= (unsigned long long )rnum;
  if ((leaf->recs)->num < 1) {
    if (hlid > 0ULL) {
      tmp___2 = tcbdbsearchleaf(bdb, kbuf, ksiz);
      if (hlid != tmp___2) {
        return ((_Bool)0);
      }
    }
    if (bdb->hnum > 0) {
      tmp___3 = tcbdbleafkill(bdb, leaf);
      if (! tmp___3) {
        return ((_Bool)0);
      }
    }
  }
  if (! bdb->tran) {
    tmp___4 = tcbdbcacheadjust(bdb);
    if (! tmp___4) {
      return ((_Bool)0);
    }
  }
  return ((_Bool)1);
}
}
static char const   *tcbdbgetimpl(TCBDB *bdb , char const   *kbuf , int ksiz , int *sp ) 
{ BDBLEAF *leaf ;
  uint64_t hlid ;
  uint64_t pid ;
  uint64_t tmp ;
  BDBREC *rec ;
  BDBREC *tmp___0 ;

  {
  leaf = (BDBLEAF *)((void *)0);
  hlid = bdb->hleaf;
  if (hlid < 1ULL) {
    goto _L;
  } else {
    leaf = tcbdbgethistleaf(bdb, kbuf, ksiz, hlid);
    if (! leaf) {
      _L: 
      tmp = tcbdbsearchleaf(bdb, kbuf, ksiz);
      pid = tmp;
      if (pid < 1ULL) {
        return ((char const   *)((void *)0));
      }
      leaf = tcbdbleafload(bdb, pid);
      if (! leaf) {
        return ((char const   *)((void *)0));
      }
    }
  }
  tmp___0 = tcbdbsearchrec(bdb, leaf, kbuf, ksiz, (int *)((void *)0));
  rec = tmp___0;
  if (! rec) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 3247, "tcbdbgetimpl");
    return ((char const   *)((void *)0));
  }
  *sp = rec->vsiz;
  return ((char const   *)((((char *)rec + (int )sizeof(*rec)) + rec->ksiz) + (((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz)));
}
}
static int tcbdbgetnum(TCBDB *bdb , char const   *kbuf , int ksiz ) 
{ BDBLEAF *leaf ;
  uint64_t hlid ;
  uint64_t pid ;
  uint64_t tmp ;
  BDBREC *rec ;
  BDBREC *tmp___0 ;
  int tmp___1 ;

  {
  leaf = (BDBLEAF *)((void *)0);
  hlid = bdb->hleaf;
  if (hlid < 1ULL) {
    goto _L;
  } else {
    leaf = tcbdbgethistleaf(bdb, kbuf, ksiz, hlid);
    if (! leaf) {
      _L: 
      tmp = tcbdbsearchleaf(bdb, kbuf, ksiz);
      pid = tmp;
      if (pid < 1ULL) {
        return (0);
      }
      leaf = tcbdbleafload(bdb, pid);
      if (! leaf) {
        return (0);
      }
    }
  }
  tmp___0 = tcbdbsearchrec(bdb, leaf, kbuf, ksiz, (int *)((void *)0));
  rec = tmp___0;
  if (! rec) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 3271, "tcbdbgetnum");
    return (0);
  }
  if (rec->rest) {
    tmp___1 = (rec->rest)->num + 1;
  } else {
    tmp___1 = 1;
  }
  return (tmp___1);
}
}
static TCLIST *tcbdbgetlist(TCBDB *bdb , char const   *kbuf , int ksiz ) 
{ BDBLEAF *leaf ;
  uint64_t hlid ;
  uint64_t pid ;
  uint64_t tmp ;
  BDBREC *rec ;
  BDBREC *tmp___0 ;
  TCLIST *vals ;
  TCLIST *rest ;
  int ln ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___1 ;
  void *tmp___2 ;
  TCLISTDATUM *array ;
  char *tmp___3 ;
  void *tmp___4 ;
  int i ;
  char const   *vbuf ;
  int vsiz ;
  int TC_mysize___0 ;
  int TC_index___0 ;
  TCLISTDATUM *tmp___5 ;
  void *tmp___6 ;
  TCLISTDATUM *array___0 ;
  char *tmp___7 ;
  void *tmp___8 ;
  int TC_mysize___1 ;
  int TC_index___1 ;
  TCLISTDATUM *tmp___9 ;
  void *tmp___10 ;
  TCLISTDATUM *array___1 ;
  char *tmp___11 ;
  void *tmp___12 ;

  {
  leaf = (BDBLEAF *)((void *)0);
  hlid = bdb->hleaf;
  if (hlid < 1ULL) {
    goto _L;
  } else {
    leaf = tcbdbgethistleaf(bdb, kbuf, ksiz, hlid);
    if (! leaf) {
      _L: 
      tmp = tcbdbsearchleaf(bdb, kbuf, ksiz);
      pid = tmp;
      if (pid < 1ULL) {
        return ((TCLIST *)((void *)0));
      }
      leaf = tcbdbleafload(bdb, pid);
      if (! leaf) {
        return ((TCLIST *)((void *)0));
      }
    }
  }
  tmp___0 = tcbdbsearchrec(bdb, leaf, kbuf, ksiz, (int *)((void *)0));
  rec = tmp___0;
  if (! rec) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 3294, "tcbdbgetlist");
    return ((TCLIST *)((void *)0));
  }
  rest = rec->rest;
  if (rest) {
    ln = rest->num;
    vals = tclistnew2(ln + 1);
    while (1) {
      TC_mysize = rec->vsiz;
      TC_index = vals->start + vals->num;
      if (TC_index >= vals->anum) {
        vals->anum += vals->num + 1;
        while (1) {
          tmp___2 = realloc((void *)vals->array, (unsigned int )(vals->anum * (int )sizeof(*(vals->array + 0))));
          tmp___1 = (TCLISTDATUM *)tmp___2;
          vals->array = tmp___1;
          if (! tmp___1) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array = vals->array;
      while (1) {
        tmp___4 = malloc((unsigned int )(TC_mysize + 1));
        tmp___3 = (char *)tmp___4;
        (array + TC_index)->ptr = tmp___3;
        if (! tmp___3) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )((((char *)rec + (int )sizeof(*rec)) + rec->ksiz) + (((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz)),
             (unsigned int )TC_mysize);
      *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
      (array + TC_index)->size = TC_mysize;
      (vals->num) ++;
      break;
    }
    i = 0;
    while (i < ln) {
      while (1) {
        vbuf = (char const   *)(rest->array + (i + rest->start))->ptr;
        vsiz = (rest->array + (i + rest->start))->size;
        break;
      }
      while (1) {
        TC_mysize___0 = vsiz;
        TC_index___0 = vals->start + vals->num;
        if (TC_index___0 >= vals->anum) {
          vals->anum += vals->num + 1;
          while (1) {
            tmp___6 = realloc((void *)vals->array, (unsigned int )(vals->anum * (int )sizeof(*(vals->array + 0))));
            tmp___5 = (TCLISTDATUM *)tmp___6;
            vals->array = tmp___5;
            if (! tmp___5) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        array___0 = vals->array;
        while (1) {
          tmp___8 = malloc((unsigned int )(TC_mysize___0 + 1));
          tmp___7 = (char *)tmp___8;
          (array___0 + TC_index___0)->ptr = tmp___7;
          if (! tmp___7) {
            tcmyfatal("out of memory");
          }
          break;
        }
        memcpy((void * __restrict  )(array___0 + TC_index___0)->ptr, (void const   * __restrict  )vbuf,
               (unsigned int )TC_mysize___0);
        *((array___0 + TC_index___0)->ptr + TC_mysize___0) = (char )'\000';
        (array___0 + TC_index___0)->size = TC_mysize___0;
        (vals->num) ++;
        break;
      }
      i ++;
    }
  } else {
    vals = tclistnew2(1);
    while (1) {
      TC_mysize___1 = rec->vsiz;
      TC_index___1 = vals->start + vals->num;
      if (TC_index___1 >= vals->anum) {
        vals->anum += vals->num + 1;
        while (1) {
          tmp___10 = realloc((void *)vals->array, (unsigned int )(vals->anum * (int )sizeof(*(vals->array + 0))));
          tmp___9 = (TCLISTDATUM *)tmp___10;
          vals->array = tmp___9;
          if (! tmp___9) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array___1 = vals->array;
      while (1) {
        tmp___12 = malloc((unsigned int )(TC_mysize___1 + 1));
        tmp___11 = (char *)tmp___12;
        (array___1 + TC_index___1)->ptr = tmp___11;
        if (! tmp___11) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array___1 + TC_index___1)->ptr, (void const   * __restrict  )((((char *)rec + (int )sizeof(*rec)) + rec->ksiz) + (((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz)),
             (unsigned int )TC_mysize___1);
      *((array___1 + TC_index___1)->ptr + TC_mysize___1) = (char )'\000';
      (array___1 + TC_index___1)->size = TC_mysize___1;
      (vals->num) ++;
      break;
    }
  }
  return (vals);
}
}
static _Bool tcbdbrangeimpl(TCBDB *bdb , char const   *bkbuf , int bksiz , _Bool binc ,
                            char const   *ekbuf , int eksiz , _Bool einc , int max ,
                            TCLIST *keys ) 
{ _Bool err ;
  BDBCUR *cur ;
  BDBCUR *tmp ;
  int (*cmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
  void *cmpop ;
  char const   *lbuf ;
  int lsiz ;
  char const   *kbuf ;
  char const   *vbuf ;
  int ksiz ;
  int vsiz ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___6 ;
  void *tmp___7 ;
  TCLISTDATUM *array ;
  char *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;

  {
  err = (_Bool)0;
  tmp = tcbdbcurnew(bdb);
  cur = tmp;
  if (bkbuf) {
    tcbdbcurjumpimpl(cur, bkbuf, bksiz, (_Bool)1);
  } else {
    tcbdbcurfirstimpl(cur);
  }
  cmp = bdb->cmp;
  cmpop = bdb->cmpop;
  lbuf = (char const   *)((void *)0);
  lsiz = 0;
  while (cur->id > 0ULL) {
    tmp___2 = tcbdbcurrecimpl(cur, & kbuf, & ksiz, & vbuf, & vsiz);
    if (! tmp___2) {
      tmp___0 = tchdbecode(bdb->hdb);
      if (tmp___0 != 2) {
        tmp___1 = tchdbecode(bdb->hdb);
        if (tmp___1 != 22) {
          err = (_Bool)1;
        }
      }
      break;
    }
    if (bkbuf) {
      if (! binc) {
        tmp___3 = (*cmp)(kbuf, ksiz, bkbuf, bksiz, cmpop);
        if (tmp___3 == 0) {
          tcbdbcurnext(cur);
          continue;
        }
        bkbuf = (char const   *)((void *)0);
      }
    }
    if (ekbuf) {
      if (einc) {
        tmp___4 = (*cmp)(kbuf, ksiz, ekbuf, eksiz, cmpop);
        if (tmp___4 > 0) {
          break;
        }
      } else {
        tmp___5 = (*cmp)(kbuf, ksiz, ekbuf, eksiz, cmpop);
        if (tmp___5 >= 0) {
          break;
        }
      }
    }
    if (! lbuf) {
      goto _L;
    } else {
      if (lsiz != ksiz) {
        goto _L;
      } else {
        tmp___10 = memcmp((void const   *)kbuf, (void const   *)lbuf, (unsigned int )ksiz);
        if (tmp___10) {
          _L: 
          while (1) {
            TC_mysize = ksiz;
            TC_index = keys->start + keys->num;
            if (TC_index >= keys->anum) {
              keys->anum += keys->num + 1;
              while (1) {
                tmp___7 = realloc((void *)keys->array, (unsigned int )(keys->anum * (int )sizeof(*(keys->array + 0))));
                tmp___6 = (TCLISTDATUM *)tmp___7;
                keys->array = tmp___6;
                if (! tmp___6) {
                  tcmyfatal("out of memory");
                }
                break;
              }
            }
            array = keys->array;
            while (1) {
              tmp___9 = malloc((unsigned int )(TC_mysize + 1));
              tmp___8 = (char *)tmp___9;
              (array + TC_index)->ptr = tmp___8;
              if (! tmp___8) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )kbuf,
                   (unsigned int )TC_mysize);
            *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
            (array + TC_index)->size = TC_mysize;
            (keys->num) ++;
            break;
          }
          if (max >= 0) {
            if (keys->num >= max) {
              break;
            }
          }
          lbuf = kbuf;
          lsiz = ksiz;
        }
      }
    }
    tcbdbcurnextimpl(cur);
  }
  tcbdbcurdel(cur);
  return ((_Bool )(! err));
}
}
static _Bool tcbdbrangefwm(TCBDB *bdb , char const   *pbuf , int psiz , int max ,
                           TCLIST *keys ) 
{ _Bool err ;
  BDBCUR *cur ;
  BDBCUR *tmp ;
  char const   *lbuf ;
  int lsiz ;
  char const   *kbuf ;
  char const   *vbuf ;
  int ksiz ;
  int vsiz ;
  int tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___4 ;
  void *tmp___5 ;
  TCLISTDATUM *array ;
  char *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;

  {
  err = (_Bool)0;
  if (max < 0) {
    max = 2147483647;
  }
  tmp = tcbdbcurnew(bdb);
  cur = tmp;
  tcbdbcurjumpimpl(cur, pbuf, psiz, (_Bool)1);
  lbuf = (char const   *)((void *)0);
  lsiz = 0;
  while (cur->id > 0ULL) {
    tmp___2 = tcbdbcurrecimpl(cur, & kbuf, & ksiz, & vbuf, & vsiz);
    if (! tmp___2) {
      tmp___0 = tchdbecode(bdb->hdb);
      if (tmp___0 != 2) {
        tmp___1 = tchdbecode(bdb->hdb);
        if (tmp___1 != 22) {
          err = (_Bool)1;
        }
      }
      break;
    }
    if (ksiz < psiz) {
      break;
    } else {
      tmp___3 = memcmp((void const   *)kbuf, (void const   *)pbuf, (unsigned int )psiz);
      if (tmp___3) {
        break;
      }
    }
    if (! lbuf) {
      goto _L;
    } else {
      if (lsiz != ksiz) {
        goto _L;
      } else {
        tmp___8 = memcmp((void const   *)kbuf, (void const   *)lbuf, (unsigned int )ksiz);
        if (tmp___8) {
          _L: 
          while (1) {
            TC_mysize = ksiz;
            TC_index = keys->start + keys->num;
            if (TC_index >= keys->anum) {
              keys->anum += keys->num + 1;
              while (1) {
                tmp___5 = realloc((void *)keys->array, (unsigned int )(keys->anum * (int )sizeof(*(keys->array + 0))));
                tmp___4 = (TCLISTDATUM *)tmp___5;
                keys->array = tmp___4;
                if (! tmp___4) {
                  tcmyfatal("out of memory");
                }
                break;
              }
            }
            array = keys->array;
            while (1) {
              tmp___7 = malloc((unsigned int )(TC_mysize + 1));
              tmp___6 = (char *)tmp___7;
              (array + TC_index)->ptr = tmp___6;
              if (! tmp___6) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )kbuf,
                   (unsigned int )TC_mysize);
            *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
            (array + TC_index)->size = TC_mysize;
            (keys->num) ++;
            break;
          }
          if (keys->num >= max) {
            break;
          }
          lbuf = kbuf;
          lsiz = ksiz;
        }
      }
    }
    tcbdbcurnextimpl(cur);
  }
  tcbdbcurdel(cur);
  return ((_Bool )(! err));
}
}
static _Bool tcbdboptimizeimpl(TCBDB *bdb , int32_t lmemb , int32_t nmemb , int64_t bnum ,
                               int8_t apow , int8_t fpow , uint8_t opts ) 
{ char const   *path ;
  char const   *tmp ;
  char *tpath ;
  uint64_t tmp___0 ;
  char *tmp___1 ;
  TCBDB *tbdb ;
  TCBDB *tmp___2 ;
  int dbgfd ;
  int tmp___3 ;
  void *(*enc)(void const   *ptr , int size , int *sp , void *op ) ;
  void *(*dec)(void const   *ptr , int size , int *sp , void *op ) ;
  void *encop ;
  void *decop ;
  uint64_t tmp___4 ;
  uint32_t tmp___5 ;
  long tmp___6 ;
  uint32_t tmp___7 ;
  long tmp___8 ;
  uint32_t lcnum ;
  uint32_t ncnum ;
  int tmp___9 ;
  _Bool tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  _Bool err ;
  BDBCUR *cur ;
  BDBCUR *tmp___13 ;
  char const   *kbuf ;
  char const   *vbuf ;
  int ksiz ;
  int vsiz ;
  int cnt___0 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;
  _Bool tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int omode ;
  int tmp___22 ;
  _Bool tmp___23 ;
  _Bool rv ;
  _Bool tmp___24 ;

  {
  tmp = tchdbpath(bdb->hdb);
  path = tmp;
  tmp___0 = tchdbinode(bdb->hdb);
  tmp___1 = tcsprintf("%s%ctmp%c%llu", path, '.', '.', tmp___0);
  tpath = tmp___1;
  tmp___2 = tcbdbnew();
  tbdb = tmp___2;
  tmp___3 = tchdbdbgfd(bdb->hdb);
  dbgfd = tmp___3;
  if (dbgfd >= 0) {
    tcbdbsetdbgfd(tbdb, dbgfd);
  }
  tcbdbsetcmpfunc(tbdb, bdb->cmp, bdb->cmpop);
  tchdbcodecfunc(bdb->hdb, & enc, & encop, & dec, & decop);
  if (enc) {
    if (dec) {
      tcbdbsetcodecfunc(tbdb, enc, encop, dec, decop);
    }
  }
  if (lmemb < 1) {
    lmemb = (int )bdb->lmemb;
  }
  if (nmemb < 1) {
    nmemb = (int )bdb->nmemb;
  }
  if (bnum < 1LL) {
    tmp___4 = tchdbrnum(bdb->hdb);
    bnum = (long long )(tmp___4 * 2ULL + 1ULL);
  }
  if ((int )apow < 0) {
    tmp___5 = tchdbalign(bdb->hdb);
    tmp___6 = tclog2l((long )tmp___5);
    apow = (signed char )tmp___6;
  }
  if ((int )fpow < 0) {
    tmp___7 = tchdbfbpmax(bdb->hdb);
    tmp___8 = tclog2l((long )tmp___7);
    fpow = (signed char )tmp___8;
  }
  if ((int )opts == 255) {
    opts = bdb->opts;
  }
  tcbdbtune(tbdb, lmemb, nmemb, bnum, apow, fpow, opts);
  tcbdbsetcache(tbdb, 1, 1);
  tcbdbsetlsmax(tbdb, bdb->lsmax);
  lcnum = bdb->lcnum;
  ncnum = bdb->ncnum;
  bdb->lcnum = 64U;
  bdb->ncnum = 16U;
  tbdb->lcnum = 64U;
  tbdb->ncnum = 16U;
  tmp___10 = tcbdbopen(tbdb, (char const   *)tpath, 14);
  if (! tmp___10) {
    tmp___9 = tcbdbecode(tbdb);
    tcbdbsetecode(bdb, tmp___9, "tcbdb.c", 3450, "tcbdboptimizeimpl");
    tcbdbdel(tbdb);
    while (1) {
      free((void *)tpath);
      break;
    }
    return ((_Bool)0);
  }
  tmp___11 = tcbdbopaque(bdb);
  tmp___12 = tcbdbopaque(tbdb);
  memcpy((void * __restrict  )tmp___12, (void const   * __restrict  )tmp___11, 64U);
  err = (_Bool)0;
  tmp___13 = tcbdbcurnew(bdb);
  cur = tmp___13;
  tcbdbcurfirstimpl(cur);
  cnt___0 = 0;
  while (1) {
    if (! err) {
      if (cur->id > 0ULL) {
        tmp___17 = tcbdbcurrecimpl(cur, & kbuf, & ksiz, & vbuf, & vsiz);
        if (! tmp___17) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    tmp___15 = tcbdbputdup(tbdb, (void const   *)kbuf, ksiz, (void const   *)vbuf,
                           vsiz);
    if (! tmp___15) {
      tmp___14 = tcbdbecode(tbdb);
      tcbdbsetecode(bdb, tmp___14, "tcbdb.c", 3464, "tcbdboptimizeimpl");
      err = (_Bool)1;
    }
    tcbdbcurnextimpl(cur);
    cnt___0 ++;
    if (cnt___0 % 15 == 0) {
      tmp___16 = tcbdbcacheadjust(bdb);
      if (! tmp___16) {
        err = (_Bool)1;
      }
    }
  }
  tcbdbcurdel(cur);
  tmp___19 = tcbdbclose(tbdb);
  if (! tmp___19) {
    tmp___18 = tcbdbecode(tbdb);
    tcbdbsetecode(bdb, tmp___18, "tcbdb.c", 3472, "tcbdboptimizeimpl");
    err = (_Bool)1;
  }
  bdb->lcnum = lcnum;
  bdb->ncnum = ncnum;
  tcbdbdel(tbdb);
  tmp___20 = unlink(path);
  if (tmp___20 == -1) {
    tcbdbsetecode(bdb, 17, "tcbdb.c", 3479, "tcbdboptimizeimpl");
    err = (_Bool)1;
  }
  tmp___21 = rename((char const   *)tpath, path);
  if (tmp___21 == -1) {
    tcbdbsetecode(bdb, 18, "tcbdb.c", 3483, "tcbdboptimizeimpl");
    err = (_Bool)1;
  }
  while (1) {
    free((void *)tpath);
    break;
  }
  if (err) {
    return ((_Bool)0);
  }
  tpath = tcstrdup((void const   *)path);
  tmp___22 = tchdbomode(bdb->hdb);
  omode = (tmp___22 & -5) & -9;
  tmp___23 = tcbdbcloseimpl(bdb);
  if (! tmp___23) {
    while (1) {
      free((void *)tpath);
      break;
    }
    return ((_Bool)0);
  }
  tmp___24 = tcbdbopenimpl(bdb, (char const   *)tpath, omode);
  rv = tmp___24;
  while (1) {
    free((void *)tpath);
    break;
  }
  return (rv);
}
}
static _Bool tcbdbvanishimpl(TCBDB *bdb ) 
{ char *path ;
  char const   *tmp ;
  char *tmp___0 ;
  int omode ;
  int tmp___1 ;
  _Bool err ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  tmp = tchdbpath(bdb->hdb);
  tmp___0 = tcstrdup((void const   *)tmp);
  path = tmp___0;
  tmp___1 = tchdbomode(bdb->hdb);
  omode = tmp___1;
  err = (_Bool)0;
  tmp___2 = tcbdbcloseimpl(bdb);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  tmp___3 = tcbdbopenimpl(bdb, (char const   *)path, 8 | omode);
  if (! tmp___3) {
    err = (_Bool)1;
  }
  while (1) {
    free((void *)path);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcbdblockmethod(TCBDB *bdb , _Bool wr ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (wr) {
    tmp = pthread_rwlock_wrlock((pthread_rwlock_t *)bdb->mmtx);
    tmp___1 = tmp != 0;
  } else {
    tmp___0 = pthread_rwlock_rdlock((pthread_rwlock_t *)bdb->mmtx);
    tmp___1 = tmp___0 != 0;
  }
  if (tmp___1) {
    tcbdbsetecode(bdb, 1, "tcbdb.c", 3522, "tcbdblockmethod");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcbdbunlockmethod(TCBDB *bdb ) 
{ int tmp ;

  {
  tmp = pthread_rwlock_unlock((pthread_rwlock_t *)bdb->mmtx);
  if (tmp != 0) {
    tcbdbsetecode(bdb, 1, "tcbdb.c", 3536, "tcbdbunlockmethod");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcbdblockcache(TCBDB *bdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)bdb->cmtx);
  if (tmp != 0) {
    tcbdbsetecode(bdb, 1, "tcbdb.c", 3550, "tcbdblockcache");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcbdbunlockcache(TCBDB *bdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_unlock((pthread_mutex_t *)bdb->cmtx);
  if (tmp != 0) {
    tcbdbsetecode(bdb, 1, "tcbdb.c", 3564, "tcbdbunlockcache");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcbdbcurfirstimpl(BDBCUR *cur ) 
{ TCBDB *bdb ;
  _Bool tmp ;

  {
  bdb = cur->bdb;
  cur->clock = bdb->clock;
  cur->id = bdb->first;
  cur->kidx = 0;
  cur->vidx = 0;
  tmp = tcbdbcuradjust(cur, (_Bool)1);
  return (tmp);
}
}
static _Bool tcbdbcurlastimpl(BDBCUR *cur ) 
{ TCBDB *bdb ;
  _Bool tmp ;

  {
  bdb = cur->bdb;
  cur->clock = bdb->clock;
  cur->id = bdb->last;
  cur->kidx = 2147483647;
  cur->vidx = 2147483647;
  tmp = tcbdbcuradjust(cur, (_Bool)0);
  return (tmp);
}
}
static _Bool tcbdbcurjumpimpl(BDBCUR *cur , char const   *kbuf , int ksiz , _Bool forward ) 
{ TCBDB *bdb ;
  uint64_t pid ;
  uint64_t tmp ;
  BDBLEAF *leaf ;
  BDBLEAF *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  int ri ;
  BDBREC *rec ;
  BDBREC *tmp___4 ;
  char *dbuf ;
  int rv ;
  int _TC_min ;
  int tmp___5 ;
  int _TC_i ;
  _Bool tmp___6 ;
  int rv___0 ;
  int _TC_min___0 ;
  int tmp___7 ;
  int _TC_i___0 ;
  _Bool tmp___8 ;

  {
  bdb = cur->bdb;
  cur->clock = bdb->clock;
  tmp = tcbdbsearchleaf(bdb, kbuf, ksiz);
  pid = tmp;
  if (pid < 1ULL) {
    cur->id = 0ULL;
    cur->kidx = 0;
    cur->vidx = 0;
    return ((_Bool)0);
  }
  tmp___0 = tcbdbleafload(bdb, pid);
  leaf = tmp___0;
  if (! leaf) {
    cur->id = 0ULL;
    cur->kidx = 0;
    cur->vidx = 0;
    return ((_Bool)0);
  }
  if (leaf->dead) {
    goto _L;
  } else {
    if ((leaf->recs)->num < 1) {
      _L: 
      cur->id = pid;
      cur->kidx = 0;
      cur->vidx = 0;
      if (forward) {
        tmp___1 = tcbdbcurnextimpl(cur);
        tmp___3 = (int )tmp___1;
      } else {
        tmp___2 = tcbdbcurprevimpl(cur);
        tmp___3 = (int )tmp___2;
      }
      return ((_Bool )tmp___3);
    }
  }
  tmp___4 = tcbdbsearchrec(bdb, leaf, kbuf, ksiz, & ri);
  rec = tmp___4;
  if (rec) {
    cur->id = pid;
    cur->kidx = ri;
    if (forward) {
      cur->vidx = 0;
    } else {
      if (rec->rest) {
        cur->vidx = (rec->rest)->num;
      } else {
        cur->vidx = 0;
      }
    }
    return ((_Bool)1);
  }
  cur->id = leaf->id;
  if (ri > 0) {
    if (ri >= (leaf->recs)->num) {
      ri = (leaf->recs)->num - 1;
    }
  }
  cur->kidx = ri;
  rec = (BDBREC *)*((leaf->recs)->array + (ri + (leaf->recs)->start));
  dbuf = (char *)rec + (int )sizeof(*rec);
  if (forward) {
    if ((unsigned int )bdb->cmp == (unsigned int )(& tccmplexical)) {
      while (1) {
        rv = 0;
        if (ksiz < rec->ksiz) {
          tmp___5 = ksiz;
        } else {
          tmp___5 = rec->ksiz;
        }
        _TC_min = tmp___5;
        _TC_i = 0;
        while (_TC_i < _TC_min) {
          if ((int )*((unsigned char *)kbuf + _TC_i) != (int )*((unsigned char *)dbuf + _TC_i)) {
            rv = (int )*((unsigned char *)kbuf + _TC_i) - (int )*((unsigned char *)dbuf + _TC_i);
            break;
          }
          _TC_i ++;
        }
        if (rv == 0) {
          rv = ksiz - rec->ksiz;
        }
        break;
      }
    } else {
      rv = (*(bdb->cmp))(kbuf, ksiz, (char const   *)dbuf, rec->ksiz, bdb->cmpop);
    }
    if (rv < 0) {
      cur->vidx = 0;
      return ((_Bool)1);
    }
    if (rec->rest) {
      cur->vidx = (rec->rest)->num;
    } else {
      cur->vidx = 0;
    }
    tmp___6 = tcbdbcurnextimpl(cur);
    return (tmp___6);
  }
  if ((unsigned int )bdb->cmp == (unsigned int )(& tccmplexical)) {
    while (1) {
      rv___0 = 0;
      if (ksiz < rec->ksiz) {
        tmp___7 = ksiz;
      } else {
        tmp___7 = rec->ksiz;
      }
      _TC_min___0 = tmp___7;
      _TC_i___0 = 0;
      while (_TC_i___0 < _TC_min___0) {
        if ((int )*((unsigned char *)kbuf + _TC_i___0) != (int )*((unsigned char *)dbuf + _TC_i___0)) {
          rv___0 = (int )*((unsigned char *)kbuf + _TC_i___0) - (int )*((unsigned char *)dbuf + _TC_i___0);
          break;
        }
        _TC_i___0 ++;
      }
      if (rv___0 == 0) {
        rv___0 = ksiz - rec->ksiz;
      }
      break;
    }
  } else {
    rv___0 = (*(bdb->cmp))(kbuf, ksiz, (char const   *)dbuf, rec->ksiz, bdb->cmpop);
  }
  if (rv___0 > 0) {
    if (rec->rest) {
      cur->vidx = (rec->rest)->num;
    } else {
      cur->vidx = 0;
    }
    return ((_Bool)1);
  }
  cur->vidx = 0;
  tmp___8 = tcbdbcurprevimpl(cur);
  return (tmp___8);
}
}
static _Bool tcbdbcuradjust(BDBCUR *cur , _Bool forward ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  BDBLEAF *leaf ;
  BDBLEAF *tmp___0 ;
  TCPTRLIST *recs ;
  int knum ;
  BDBREC *rec ;
  int vnum ;
  int tmp___1 ;

  {
  bdb = cur->bdb;
  if (cur->clock != bdb->clock) {
    tmp = tcbdbleafcheck(bdb, cur->id);
    if (! tmp) {
      tcbdbsetecode(bdb, 22, "tcbdb.c", 3685, "tcbdbcuradjust");
      cur->id = 0ULL;
      cur->kidx = 0;
      cur->vidx = 0;
      return ((_Bool)0);
    }
    cur->clock = bdb->clock;
  }
  while (1) {
    if (cur->id < 1ULL) {
      tcbdbsetecode(bdb, 22, "tcbdb.c", 3695, "tcbdbcuradjust");
      cur->id = 0ULL;
      cur->kidx = 0;
      cur->vidx = 0;
      return ((_Bool)0);
    }
    tmp___0 = tcbdbleafload(bdb, cur->id);
    leaf = tmp___0;
    if (! leaf) {
      return ((_Bool)0);
    }
    recs = leaf->recs;
    knum = recs->num;
    if (leaf->dead) {
      if (forward) {
        cur->id = leaf->next;
        cur->kidx = 0;
        cur->vidx = 0;
      } else {
        cur->id = leaf->prev;
        cur->kidx = 2147483647;
        cur->vidx = 2147483647;
      }
    } else {
      if (cur->kidx < 0) {
        if (forward) {
          cur->kidx = 0;
          cur->vidx = 0;
        } else {
          cur->id = leaf->prev;
          cur->kidx = 2147483647;
          cur->vidx = 2147483647;
        }
      } else {
        if (cur->kidx >= knum) {
          if (forward) {
            cur->id = leaf->next;
            cur->kidx = 0;
            cur->vidx = 0;
          } else {
            cur->kidx = knum - 1;
            cur->vidx = 2147483647;
          }
        } else {
          rec = (BDBREC *)*(recs->array + (cur->kidx + recs->start));
          if (rec->rest) {
            tmp___1 = (rec->rest)->num + 1;
          } else {
            tmp___1 = 1;
          }
          vnum = tmp___1;
          if (cur->vidx < 0) {
            if (forward) {
              cur->vidx = 0;
            } else {
              (cur->kidx) --;
              cur->vidx = 2147483647;
            }
          } else {
            if (cur->vidx >= vnum) {
              if (forward) {
                (cur->kidx) ++;
                cur->vidx = 0;
                if (cur->kidx >= knum) {
                  cur->id = leaf->next;
                  cur->kidx = 0;
                  cur->vidx = 0;
                } else {
                  break;
                }
              } else {
                cur->vidx = vnum - 1;
                if (cur->vidx >= 0) {
                  break;
                }
              }
            } else {
              break;
            }
          }
        }
      }
    }
  }
  return ((_Bool)1);
}
}
static _Bool tcbdbcurprevimpl(BDBCUR *cur ) 
{ _Bool tmp ;

  {
  (cur->vidx) --;
  tmp = tcbdbcuradjust(cur, (_Bool)0);
  return (tmp);
}
}
static _Bool tcbdbcurnextimpl(BDBCUR *cur ) 
{ _Bool tmp ;

  {
  (cur->vidx) ++;
  tmp = tcbdbcuradjust(cur, (_Bool)1);
  return (tmp);
}
}
static _Bool tcbdbcurputimpl(BDBCUR *cur , char const   *vbuf , int vsiz , int cpmode ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  BDBLEAF *leaf ;
  BDBLEAF *tmp___0 ;
  TCPTRLIST *recs ;
  BDBREC *rec ;
  int vnum ;
  int tmp___1 ;
  char *dbuf ;
  int psiz ;
  BDBREC *orec ;
  void *tmp___2 ;
  void *tmp___3 ;
  int TC_myindex ;
  TCLISTDATUM *tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int TC_myindex___0 ;
  TCLISTDATUM *tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  void *tmp___11 ;

  {
  bdb = cur->bdb;
  if (cur->clock != bdb->clock) {
    tmp = tcbdbleafcheck(bdb, cur->id);
    if (! tmp) {
      tcbdbsetecode(bdb, 22, "tcbdb.c", 3798, "tcbdbcurputimpl");
      cur->id = 0ULL;
      cur->kidx = 0;
      cur->vidx = 0;
      return ((_Bool)0);
    }
    cur->clock = bdb->clock;
  }
  tmp___0 = tcbdbleafload(bdb, cur->id);
  leaf = tmp___0;
  if (! leaf) {
    return ((_Bool)0);
  }
  recs = leaf->recs;
  if (cur->kidx >= recs->num) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 3810, "tcbdbcurputimpl");
    return ((_Bool)0);
  }
  rec = (BDBREC *)*(recs->array + (cur->kidx + recs->start));
  if (rec->rest) {
    tmp___1 = (rec->rest)->num + 1;
  } else {
    tmp___1 = 1;
  }
  vnum = tmp___1;
  if (cur->vidx >= vnum) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 3816, "tcbdbcurputimpl");
    return ((_Bool)0);
  }
  dbuf = (char *)rec + (int )sizeof(*rec);
  psiz = ((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz;
  orec = rec;
  switch (cpmode) {
  case 0: 
  if (cur->vidx < 1) {
    leaf->size += vsiz - rec->vsiz;
    if (vsiz > rec->vsiz) {
      while (1) {
        tmp___2 = realloc((void *)rec, (unsigned int )(((((int )sizeof(*rec) + rec->ksiz) + psiz) + vsiz) + 1));
        rec = (BDBREC *)tmp___2;
        if (! rec) {
          tcmyfatal("out of memory");
        }
        break;
      }
      if ((unsigned int )rec != (unsigned int )orec) {
        tcptrlistover(recs, cur->kidx, (void *)rec);
        dbuf = (char *)rec + (int )sizeof(*rec);
      }
    }
    memcpy((void * __restrict  )((dbuf + rec->ksiz) + psiz), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf + ((rec->ksiz + psiz) + vsiz)) = (char )'\000';
    rec->vsiz = vsiz;
  } else {
    leaf->size += vsiz - ((rec->rest)->array + ((cur->vidx - 1) + (rec->rest)->start))->size;
    tclistover(rec->rest, cur->vidx - 1, (void const   *)vbuf, vsiz);
  }
  break;
  case 1: 
  leaf->size += vsiz;
  if (cur->vidx < 1) {
    if (! rec->rest) {
      rec->rest = tclistnew2(1);
    }
    tclistunshift(rec->rest, (void const   *)((dbuf + rec->ksiz) + psiz), rec->vsiz);
    if (vsiz > rec->vsiz) {
      while (1) {
        tmp___3 = realloc((void *)rec, (unsigned int )(((((int )sizeof(*rec) + rec->ksiz) + psiz) + vsiz) + 1));
        rec = (BDBREC *)tmp___3;
        if (! rec) {
          tcmyfatal("out of memory");
        }
        break;
      }
      if ((unsigned int )rec != (unsigned int )orec) {
        tcptrlistover(recs, cur->kidx, (void *)rec);
        dbuf = (char *)rec + (int )sizeof(*rec);
      }
    }
    memcpy((void * __restrict  )((dbuf + rec->ksiz) + psiz), (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(dbuf + ((rec->ksiz + psiz) + vsiz)) = (char )'\000';
    rec->vsiz = vsiz;
  } else {
    while (1) {
      TC_myindex = cur->vidx - 1;
      TC_myindex += (rec->rest)->start;
      if ((rec->rest)->start + (rec->rest)->num >= (rec->rest)->anum) {
        (rec->rest)->anum += (rec->rest)->num + 1;
        while (1) {
          tmp___5 = realloc((void *)(rec->rest)->array, (unsigned int )((rec->rest)->anum * (int )sizeof(*((rec->rest)->array + 0))));
          tmp___4 = (TCLISTDATUM *)tmp___5;
          (rec->rest)->array = tmp___4;
          if (! tmp___4) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      memmove((void *)(((rec->rest)->array + TC_myindex) + 1), (void const   *)((rec->rest)->array + TC_myindex),
              (unsigned int )((int )sizeof(*((rec->rest)->array + 0)) * (((rec->rest)->start + (rec->rest)->num) - TC_myindex)));
      while (1) {
        tmp___7 = malloc((unsigned int )(vsiz + 1));
        tmp___6 = (char *)tmp___7;
        ((rec->rest)->array + TC_myindex)->ptr = tmp___6;
        if (! tmp___6) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )((rec->rest)->array + TC_myindex)->ptr, (void const   * __restrict  )vbuf,
             (unsigned int )vsiz);
      *(((rec->rest)->array + TC_myindex)->ptr + vsiz) = (char )'\000';
      ((rec->rest)->array + TC_myindex)->size = vsiz;
      ((rec->rest)->num) ++;
      break;
    }
  }
  (bdb->rnum) ++;
  break;
  case 2: 
  leaf->size += vsiz;
  if (! rec->rest) {
    rec->rest = tclistnew2(1);
  }
  while (1) {
    TC_myindex___0 = cur->vidx;
    TC_myindex___0 += (rec->rest)->start;
    if ((rec->rest)->start + (rec->rest)->num >= (rec->rest)->anum) {
      (rec->rest)->anum += (rec->rest)->num + 1;
      while (1) {
        tmp___9 = realloc((void *)(rec->rest)->array, (unsigned int )((rec->rest)->anum * (int )sizeof(*((rec->rest)->array + 0))));
        tmp___8 = (TCLISTDATUM *)tmp___9;
        (rec->rest)->array = tmp___8;
        if (! tmp___8) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    memmove((void *)(((rec->rest)->array + TC_myindex___0) + 1), (void const   *)((rec->rest)->array + TC_myindex___0),
            (unsigned int )((int )sizeof(*((rec->rest)->array + 0)) * (((rec->rest)->start + (rec->rest)->num) - TC_myindex___0)));
    while (1) {
      tmp___11 = malloc((unsigned int )(vsiz + 1));
      tmp___10 = (char *)tmp___11;
      ((rec->rest)->array + TC_myindex___0)->ptr = tmp___10;
      if (! tmp___10) {
        tcmyfatal("out of memory");
      }
      break;
    }
    memcpy((void * __restrict  )((rec->rest)->array + TC_myindex___0)->ptr, (void const   * __restrict  )vbuf,
           (unsigned int )vsiz);
    *(((rec->rest)->array + TC_myindex___0)->ptr + vsiz) = (char )'\000';
    ((rec->rest)->array + TC_myindex___0)->size = vsiz;
    ((rec->rest)->num) ++;
    break;
  }
  (cur->vidx) ++;
  (bdb->rnum) ++;
  break;
  }
  leaf->dirty = (_Bool)1;
  return ((_Bool)1);
}
}
static _Bool tcbdbcuroutimpl(BDBCUR *cur ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  BDBLEAF *leaf ;
  BDBLEAF *tmp___0 ;
  TCPTRLIST *recs ;
  BDBREC *rec ;
  char *dbuf ;
  int vnum ;
  int tmp___1 ;
  int vsiz ;
  char *vbuf ;
  void *tmp___2 ;
  int psiz ;
  BDBREC *orec ;
  void *tmp___3 ;
  int vsiz___0 ;
  char *vbuf___0 ;
  void *tmp___4 ;
  uint64_t pid ;
  uint64_t tmp___5 ;
  _Bool tmp___6 ;
  void *tmp___7 ;
  _Bool tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  bdb = cur->bdb;
  if (cur->clock != bdb->clock) {
    tmp = tcbdbleafcheck(bdb, cur->id);
    if (! tmp) {
      tcbdbsetecode(bdb, 22, "tcbdb.c", 3882, "tcbdbcuroutimpl");
      cur->id = 0ULL;
      cur->kidx = 0;
      cur->vidx = 0;
      return ((_Bool)0);
    }
    cur->clock = bdb->clock;
  }
  tmp___0 = tcbdbleafload(bdb, cur->id);
  leaf = tmp___0;
  if (! leaf) {
    return ((_Bool)0);
  }
  recs = leaf->recs;
  if (cur->kidx >= recs->num) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 3894, "tcbdbcuroutimpl");
    return ((_Bool)0);
  }
  rec = (BDBREC *)*(recs->array + (cur->kidx + recs->start));
  dbuf = (char *)rec + (int )sizeof(*rec);
  if (rec->rest) {
    tmp___1 = (rec->rest)->num + 1;
  } else {
    tmp___1 = 1;
  }
  vnum = tmp___1;
  if (cur->vidx >= vnum) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 3901, "tcbdbcuroutimpl");
    return ((_Bool)0);
  }
  if (rec->rest) {
    if (cur->vidx < 1) {
      leaf->size -= rec->vsiz;
      tmp___2 = tclistshift(rec->rest, & vsiz);
      vbuf = (char *)tmp___2;
      psiz = ((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz;
      if (vsiz > rec->vsiz) {
        orec = rec;
        while (1) {
          tmp___3 = realloc((void *)rec, (unsigned int )(((((int )sizeof(*rec) + rec->ksiz) + psiz) + vsiz) + 1));
          rec = (BDBREC *)tmp___3;
          if (! rec) {
            tcmyfatal("out of memory");
          }
          break;
        }
        if ((unsigned int )rec != (unsigned int )orec) {
          tcptrlistover(leaf->recs, cur->kidx, (void *)rec);
          dbuf = (char *)rec + (int )sizeof(*rec);
        }
      }
      memcpy((void * __restrict  )((dbuf + rec->ksiz) + psiz), (void const   * __restrict  )vbuf,
             (unsigned int )vsiz);
      *(dbuf + ((rec->ksiz + psiz) + vsiz)) = (char )'\000';
      rec->vsiz = vsiz;
      while (1) {
        free((void *)vbuf);
        break;
      }
    } else {
      tmp___4 = tclistremove(rec->rest, cur->vidx - 1, & vsiz___0);
      vbuf___0 = (char *)tmp___4;
      leaf->size -= vsiz___0;
      while (1) {
        free((void *)vbuf___0);
        break;
      }
    }
    if ((rec->rest)->num < 1) {
      tclistdel(rec->rest);
      rec->rest = (TCLIST *)((void *)0);
    }
  } else {
    leaf->size -= rec->ksiz + rec->vsiz;
    if (recs->num < 2) {
      tmp___5 = tcbdbsearchleaf(bdb, (char const   *)dbuf, rec->ksiz);
      pid = tmp___5;
      if (pid < 1ULL) {
        return ((_Bool)0);
      }
      if (bdb->hnum > 0) {
        leaf = tcbdbleafload(bdb, pid);
        if (! leaf) {
          return ((_Bool)0);
        }
        tmp___6 = tcbdbleafkill(bdb, leaf);
        if (! tmp___6) {
          return ((_Bool)0);
        }
        if (leaf->next != 0ULL) {
          cur->id = leaf->next;
          cur->kidx = 0;
          cur->vidx = 0;
          cur->clock = bdb->clock;
        }
      }
    }
    while (1) {
      tmp___7 = tcptrlistremove(leaf->recs, cur->kidx);
      free(tmp___7);
      break;
    }
  }
  (bdb->rnum) --;
  leaf->dirty = (_Bool)1;
  tmp___8 = tcbdbcuradjust(cur, (_Bool)1);
  if (tmp___8) {
    tmp___10 = 1;
  } else {
    tmp___9 = tchdbecode(bdb->hdb);
    if (tmp___9 == 22) {
      tmp___10 = 1;
    } else {
      tmp___10 = 0;
    }
  }
  return ((_Bool )tmp___10);
}
}
static _Bool tcbdbcurrecimpl(BDBCUR *cur , char const   **kbp , int *ksp , char const   **vbp ,
                             int *vsp ) 
{ TCBDB *bdb ;
  _Bool tmp ;
  BDBLEAF *leaf ;
  BDBLEAF *tmp___0 ;
  TCPTRLIST *recs ;
  BDBREC *rec ;
  char *dbuf ;
  int vnum ;
  int tmp___1 ;
  void const   *tmp___2 ;

  {
  bdb = cur->bdb;
  if (cur->clock != bdb->clock) {
    tmp = tcbdbleafcheck(bdb, cur->id);
    if (! tmp) {
      tcbdbsetecode(bdb, 22, "tcbdb.c", 3970, "tcbdbcurrecimpl");
      cur->id = 0ULL;
      cur->kidx = 0;
      cur->vidx = 0;
      return ((_Bool)0);
    }
    cur->clock = bdb->clock;
  }
  tmp___0 = tcbdbleafload(bdb, cur->id);
  leaf = tmp___0;
  if (! leaf) {
    return ((_Bool)0);
  }
  recs = leaf->recs;
  if (cur->kidx >= recs->num) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 3982, "tcbdbcurrecimpl");
    return ((_Bool)0);
  }
  rec = (BDBREC *)*(recs->array + (cur->kidx + recs->start));
  dbuf = (char *)rec + (int )sizeof(*rec);
  if (rec->rest) {
    tmp___1 = (rec->rest)->num + 1;
  } else {
    tmp___1 = 1;
  }
  vnum = tmp___1;
  if (cur->vidx >= vnum) {
    tcbdbsetecode(bdb, 22, "tcbdb.c", 3989, "tcbdbcurrecimpl");
    return ((_Bool)0);
  }
  *kbp = (char const   *)dbuf;
  *ksp = rec->ksiz;
  if (cur->vidx > 0) {
    tmp___2 = tclistval((TCLIST const   *)rec->rest, cur->vidx - 1, vsp);
    *vbp = (char const   *)tmp___2;
  } else {
    *vbp = (char const   *)((dbuf + rec->ksiz) + (((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz));
    *vsp = rec->vsiz;
  }
  return ((_Bool)1);
}
}
static _Bool tcbdbforeachimpl(TCBDB *bdb , _Bool (*iter)(void const   *kbuf , int ksiz ,
                                                         void const   *vbuf , int vsiz ,
                                                         void *op ) , void *op ) 
{ _Bool err ;
  BDBCUR *cur ;
  BDBCUR *tmp ;
  char const   *kbuf ;
  char const   *vbuf ;
  int ksiz ;
  int vsiz ;
  _Bool tmp___0 ;
  BDBLEAF *leaf ;
  BDBLEAF *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
  err = (_Bool)0;
  tmp = tcbdbcurnew(bdb);
  cur = tmp;
  tcbdbcurfirstimpl(cur);
  while (cur->id > 0ULL) {
    tmp___6 = tcbdbcurrecimpl(cur, & kbuf, & ksiz, & vbuf, & vsiz);
    if (tmp___6) {
      tmp___0 = (*iter)((void const   *)kbuf, ksiz, (void const   *)vbuf, vsiz, op);
      if (! tmp___0) {
        break;
      }
      tcbdbcurnextimpl(cur);
      if (bdb->tran) {
        if (cur->id > 0ULL) {
          tmp___1 = tcbdbleafload(bdb, cur->id);
          leaf = tmp___1;
          if (! leaf) {
            err = (_Bool)1;
            break;
          }
          if (! leaf->dirty) {
            tmp___2 = tcbdbleafcacheout(bdb, leaf);
            if (! tmp___2) {
              err = (_Bool)0;
              break;
            }
          }
        }
      } else {
        if ((bdb->leafc)->rnum > (unsigned long long )bdb->lcnum) {
          tmp___3 = tcbdbcacheadjust(bdb);
          if (! tmp___3) {
            err = (_Bool)1;
            break;
          }
        }
      }
    } else {
      tmp___4 = tchdbecode(bdb->hdb);
      if (tmp___4 != 2) {
        tmp___5 = tchdbecode(bdb->hdb);
        if (tmp___5 != 22) {
          err = (_Bool)1;
        }
      }
      break;
    }
  }
  tcbdbcurdel(cur);
  return ((_Bool )(! err));
}
}
void tcbdbprintmeta(TCBDB *bdb ) 
{ int dbgfd ;
  int tmp ;
  char buf[32768] ;
  char *wp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  char *tmp___39 ;

  {
  tmp = tchdbdbgfd(bdb->hdb);
  dbgfd = tmp;
  if (dbgfd < 0) {
    return;
  }
  if (dbgfd == 65535) {
    dbgfd = 1;
  }
  wp = buf;
  tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"META:");
  wp += tmp___0;
  tmp___1 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" mmtx=%p",
                    bdb->mmtx);
  wp += tmp___1;
  tmp___2 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cmtx=%p",
                    bdb->cmtx);
  wp += tmp___2;
  tmp___3 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" hdb=%p",
                    (void *)bdb->hdb);
  wp += tmp___3;
  tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" opaque=%p",
                    (void *)bdb->opaque);
  wp += tmp___4;
  tmp___5 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" open=%d",
                    bdb->open);
  wp += tmp___5;
  tmp___6 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" wmode=%d",
                    bdb->wmode);
  wp += tmp___6;
  tmp___7 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" lmemb=%u",
                    bdb->lmemb);
  wp += tmp___7;
  tmp___8 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" nmemb=%u",
                    bdb->nmemb);
  wp += tmp___8;
  tmp___9 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" opts=%u",
                    bdb->opts);
  wp += tmp___9;
  tmp___10 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" root=%llx",
                     bdb->root);
  wp += tmp___10;
  tmp___11 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" first=%llx",
                     bdb->first);
  wp += tmp___11;
  tmp___12 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" last=%llx",
                     bdb->last);
  wp += tmp___12;
  tmp___13 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" lnum=%llu",
                     bdb->lnum);
  wp += tmp___13;
  tmp___14 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" nnum=%llu",
                     bdb->nnum);
  wp += tmp___14;
  tmp___15 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rnum=%llu",
                     bdb->rnum);
  wp += tmp___15;
  tmp___16 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" leafc=%p",
                     (void *)bdb->leafc);
  wp += tmp___16;
  tmp___17 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" nodec=%p",
                     (void *)bdb->nodec);
  wp += tmp___17;
  tmp___18 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cmp=%p",
                     (void *)((int )bdb->cmp));
  wp += tmp___18;
  tmp___19 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cmpop=%p",
                     bdb->cmpop);
  wp += tmp___19;
  tmp___20 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" lcnum=%u",
                     bdb->lcnum);
  wp += tmp___20;
  tmp___21 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" ncnum=%u",
                     bdb->ncnum);
  wp += tmp___21;
  tmp___22 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" lsmax=%u",
                     bdb->lsmax);
  wp += tmp___22;
  tmp___23 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" lschk=%u",
                     bdb->lschk);
  wp += tmp___23;
  tmp___24 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" capnum=%llu",
                     bdb->capnum);
  wp += tmp___24;
  tmp___25 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" hist=%p",
                     (void *)bdb->hist);
  wp += tmp___25;
  tmp___26 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" hnum=%d",
                     bdb->hnum);
  wp += tmp___26;
  tmp___27 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" hleaf=%llu",
                     bdb->hleaf);
  wp += tmp___27;
  tmp___28 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" lleaf=%llu",
                     bdb->lleaf);
  wp += tmp___28;
  tmp___29 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" tran=%d",
                     bdb->tran);
  wp += tmp___29;
  tmp___30 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rbopaque=%p",
                     (void *)bdb->rbopaque);
  wp += tmp___30;
  tmp___31 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" clock=%llu",
                     bdb->clock);
  wp += tmp___31;
  tmp___32 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_saveleaf=%lld",
                     bdb->cnt_saveleaf);
  wp += tmp___32;
  tmp___33 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_loadleaf=%lld",
                     bdb->cnt_loadleaf);
  wp += tmp___33;
  tmp___34 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_killleaf=%lld",
                     bdb->cnt_killleaf);
  wp += tmp___34;
  tmp___35 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_adjleafc=%lld",
                     bdb->cnt_adjleafc);
  wp += tmp___35;
  tmp___36 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_savenode=%lld",
                     bdb->cnt_savenode);
  wp += tmp___36;
  tmp___37 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_loadnode=%lld",
                     bdb->cnt_loadnode);
  wp += tmp___37;
  tmp___38 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_adjnodec=%lld",
                     bdb->cnt_adjnodec);
  wp += tmp___38;
  tmp___39 = wp;
  wp ++;
  *tmp___39 = (char )'\n';
  tcwrite(dbgfd, (void const   *)(buf), (unsigned int )(wp - buf));
  return;
}
}
void tcbdbprintleaf(TCBDB *bdb , BDBLEAF *leaf ) 
{ int dbgfd ;
  int tmp ;
  TCPTRLIST *recs ;
  char buf[32768] ;
  char *wp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int i ;
  BDBREC *rec ;
  char *dbuf ;
  int tmp___9 ;
  TCLIST *rest ;
  int j ;
  int tmp___10 ;
  char *tmp___11 ;

  {
  tmp = tchdbdbgfd(bdb->hdb);
  dbgfd = tmp;
  recs = leaf->recs;
  if (dbgfd < 0) {
    return;
  }
  if (dbgfd == 65535) {
    dbgfd = 1;
  }
  wp = buf;
  tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"LEAF:");
  wp += tmp___0;
  tmp___1 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" id:%llx",
                    leaf->id);
  wp += tmp___1;
  tmp___2 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" size:%u",
                    leaf->size);
  wp += tmp___2;
  tmp___3 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" prev:%llx",
                    leaf->prev);
  wp += tmp___3;
  tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" next:%llx",
                    leaf->next);
  wp += tmp___4;
  tmp___5 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" dirty:%d",
                    leaf->dirty);
  wp += tmp___5;
  tmp___6 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" dead:%d",
                    leaf->dead);
  wp += tmp___6;
  tmp___7 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rnum:%d",
                    recs->num);
  wp += tmp___7;
  tmp___8 = wp;
  wp ++;
  *tmp___8 = (char )' ';
  i = 0;
  while (i < recs->num) {
    tcwrite(dbgfd, (void const   *)(buf), (unsigned int )(wp - buf));
    wp = buf;
    rec = (BDBREC *)*(recs->array + (i + recs->start));
    dbuf = (char *)rec + (int )sizeof(*rec);
    tmp___9 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" [%s:%s]",
                      dbuf, (dbuf + rec->ksiz) + (((rec->ksiz | ~ (- ((int )sizeof(void *)))) + 1) - rec->ksiz));
    wp += tmp___9;
    rest = rec->rest;
    if (rest) {
      j = 0;
      while (j < rest->num) {
        tmp___10 = sprintf((char * __restrict  )wp, (char const   * __restrict  )":%s",
                           (char *)((void *)(rest->array + (j + rest->start))->ptr));
        wp += tmp___10;
        j ++;
      }
    }
    i ++;
  }
  tmp___11 = wp;
  wp ++;
  *tmp___11 = (char )'\n';
  tcwrite(dbgfd, (void const   *)(buf), (unsigned int )(wp - buf));
  return;
}
}
void tcbdbprintnode(TCBDB *bdb , BDBNODE *node ) 
{ int dbgfd ;
  int tmp ;
  TCPTRLIST *idxs ;
  char buf[32768] ;
  char *wp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int i ;
  BDBIDX *idx ;
  char *ebuf ;
  int tmp___7 ;
  char *tmp___8 ;

  {
  tmp = tchdbdbgfd(bdb->hdb);
  dbgfd = tmp;
  idxs = node->idxs;
  if (dbgfd < 0) {
    return;
  }
  if (dbgfd == 65535) {
    dbgfd = 1;
  }
  wp = buf;
  tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"NODE:");
  wp += tmp___0;
  tmp___1 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" id:%llx",
                    node->id);
  wp += tmp___1;
  tmp___2 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" heir:%llx",
                    node->heir);
  wp += tmp___2;
  tmp___3 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" dirty:%d",
                    node->dirty);
  wp += tmp___3;
  tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" dead:%d",
                    node->dead);
  wp += tmp___4;
  tmp___5 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rnum:%d",
                    idxs->num);
  wp += tmp___5;
  tmp___6 = wp;
  wp ++;
  *tmp___6 = (char )' ';
  i = 0;
  while (i < idxs->num) {
    tcwrite(dbgfd, (void const   *)(buf), (unsigned int )(wp - buf));
    wp = buf;
    idx = (BDBIDX *)*(idxs->array + (i + idxs->start));
    ebuf = (char *)idx + (int )sizeof(*idx);
    tmp___7 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" [%llx:%s]",
                      idx->pid, ebuf);
    wp += tmp___7;
    i ++;
  }
  tmp___8 = wp;
  wp ++;
  *tmp___8 = (char )'\n';
  tcwrite(dbgfd, (void const   *)(buf), (unsigned int )(wp - buf));
  return;
}
}
#pragma merger(0,"/tmp/cil-onCoZ8Ii.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
char const   *tcfdberrmsg(int ecode ) ;
TCFDB *tcfdbnew(void) ;
void tcfdbdel(TCFDB *fdb ) ;
int tcfdbecode(TCFDB *fdb ) ;
_Bool tcfdbsetmutex(TCFDB *fdb ) ;
_Bool tcfdbtune(TCFDB *fdb , int32_t width , int64_t limsiz ) ;
_Bool tcfdbopen(TCFDB *fdb , char const   *path , int omode ) ;
_Bool tcfdbclose(TCFDB *fdb ) ;
_Bool tcfdbput(TCFDB *fdb , int64_t id , void const   *vbuf , int vsiz ) ;
_Bool tcfdbput2(TCFDB *fdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                int vsiz ) ;
_Bool tcfdbput3(TCFDB *fdb , char const   *kstr , void const   *vstr ) ;
_Bool tcfdbputkeep(TCFDB *fdb , int64_t id , void const   *vbuf , int vsiz ) ;
_Bool tcfdbputkeep2(TCFDB *fdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                    int vsiz ) ;
_Bool tcfdbputkeep3(TCFDB *fdb , char const   *kstr , void const   *vstr ) ;
_Bool tcfdbputcat(TCFDB *fdb , int64_t id , void const   *vbuf , int vsiz ) ;
_Bool tcfdbputcat2(TCFDB *fdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) ;
_Bool tcfdbputcat3(TCFDB *fdb , char const   *kstr , void const   *vstr ) ;
_Bool tcfdbout(TCFDB *fdb , int64_t id ) ;
_Bool tcfdbout2(TCFDB *fdb , void const   *kbuf , int ksiz ) ;
_Bool tcfdbout3(TCFDB *fdb , char const   *kstr ) ;
void *tcfdbget(TCFDB *fdb , int64_t id , int *sp ) ;
void *tcfdbget2(TCFDB *fdb , void const   *kbuf , int ksiz , int *sp ) ;
char *tcfdbget3(TCFDB *fdb , char const   *kstr ) ;
int tcfdbget4(TCFDB *fdb , int64_t id , void *vbuf , int max ) ;
int tcfdbvsiz(TCFDB *fdb , int64_t id ) ;
int tcfdbvsiz2(TCFDB *fdb , void const   *kbuf , int ksiz ) ;
int tcfdbvsiz3(TCFDB *fdb , char const   *kstr ) ;
_Bool tcfdbiterinit(TCFDB *fdb ) ;
uint64_t tcfdbiternext(TCFDB *fdb ) ;
void *tcfdbiternext2(TCFDB *fdb , int *sp ) ;
char *tcfdbiternext3(TCFDB *fdb ) ;
uint64_t *tcfdbrange(TCFDB *fdb , int64_t lower , int64_t upper , int max , int *np ) ;
TCLIST *tcfdbrange2(TCFDB *fdb , void const   *lbuf , int lsiz , void const   *ubuf ,
                    int usiz , int max ) ;
TCLIST *tcfdbrange3(TCFDB *fdb , char const   *lstr , char const   *ustr , int max ) ;
TCLIST *tcfdbrange4(TCFDB *fdb , void const   *ibuf , int isiz , int max ) ;
TCLIST *tcfdbrange5(TCFDB *fdb , void const   *istr , int max ) ;
int tcfdbaddint(TCFDB *fdb , int64_t id , int num ) ;
double tcfdbadddouble(TCFDB *fdb , int64_t id , double num ) ;
_Bool tcfdbsync(TCFDB *fdb ) ;
_Bool tcfdboptimize(TCFDB *fdb , int32_t width , int64_t limsiz ) ;
_Bool tcfdbvanish(TCFDB *fdb ) ;
_Bool tcfdbcopy(TCFDB *fdb , char const   *path ) ;
_Bool tcfdbtranbegin(TCFDB *fdb ) ;
_Bool tcfdbtrancommit(TCFDB *fdb ) ;
_Bool tcfdbtranabort(TCFDB *fdb ) ;
char const   *tcfdbpath(TCFDB *fdb ) ;
uint64_t tcfdbrnum(TCFDB *fdb ) ;
uint64_t tcfdbfsiz(TCFDB *fdb ) ;
void tcfdbsetecode(TCFDB *fdb , int ecode , char const   *filename , int line , char const   *func ) ;
void tcfdbsetdbgfd(TCFDB *fdb , int fd ) ;
int tcfdbdbgfd(TCFDB *fdb ) ;
_Bool tcfdbhasmutex(TCFDB *fdb ) ;
_Bool tcfdbmemsync(TCFDB *fdb , _Bool phys ) ;
uint64_t tcfdbmin(TCFDB *fdb ) ;
uint64_t tcfdbmax(TCFDB *fdb ) ;
uint32_t tcfdbwidth(TCFDB *fdb ) ;
uint64_t tcfdblimsiz(TCFDB *fdb ) ;
uint64_t tcfdblimid(TCFDB *fdb ) ;
uint64_t tcfdbinode(TCFDB *fdb ) ;
time_t tcfdbmtime(TCFDB *fdb ) ;
int tcfdbomode(TCFDB *fdb ) ;
uint8_t tcfdbtype(TCFDB *fdb ) ;
uint8_t tcfdbflags(TCFDB *fdb ) ;
char *tcfdbopaque(TCFDB *fdb ) ;
_Bool tcfdbputproc(TCFDB *fdb , int64_t id , void const   *vbuf , int vsiz , void *(*proc___0)(void const   *vbuf ,
                                                                                               int vsiz ,
                                                                                               int *sp ,
                                                                                               void *op ) ,
                   void *op ) ;
_Bool tcfdbiterinit2(TCFDB *fdb , int64_t id ) ;
_Bool tcfdbiterinit3(TCFDB *fdb , void const   *kbuf , int ksiz ) ;
_Bool tcfdbiterinit4(TCFDB *fdb , char const   *kstr ) ;
_Bool tcfdbforeach(TCFDB *fdb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                              int vsiz , void *op ) , void *op ) ;
int64_t tcfdbkeytoid(char const   *kbuf , int ksiz ) ;
static void tcfdbdumpmeta(TCFDB *fdb , char *hbuf ) ;
static void tcfdbloadmeta(TCFDB *fdb , char const   *hbuf ) ;
static void tcfdbclear(TCFDB *fdb ) ;
static void tcfdbsetflag(TCFDB *fdb , int flag , _Bool sign ) ;
static _Bool tcfdbwalinit(TCFDB *fdb ) ;
static _Bool tcfdbwalwrite(TCFDB *fdb , uint64_t off , int64_t size ) ;
static int tcfdbwalrestore(TCFDB *fdb , char const   *path ) ;
static _Bool tcfdbwalremove(TCFDB *fdb , char const   *path ) ;
static _Bool tcfdbopenimpl(TCFDB *fdb , char const   *path , int omode ) ;
static _Bool tcfdbcloseimpl(TCFDB *fdb ) ;
static int64_t tcfdbprevid(TCFDB *fdb , int64_t id ) ;
static int64_t tcfdbnextid(TCFDB *fdb , int64_t id ) ;
static _Bool tcfdbputimpl(TCFDB *fdb , int64_t id , void const   *vbuf , int vsiz ,
                          int dmode ) ;
static _Bool tcfdboutimpl(TCFDB *fdb , int64_t id ) ;
static void const   *tcfdbgetimpl(TCFDB *fdb , int64_t id , int *sp ) ;
static _Bool tcfdbiterinitimpl(TCFDB *fdb ) ;
static uint64_t tcfdbiternextimpl(TCFDB *fdb ) ;
static uint64_t *tcfdbrangeimpl(TCFDB *fdb , int64_t lower , int64_t upper , int max ,
                                int *np ) ;
static _Bool tcfdboptimizeimpl(TCFDB *fdb , int32_t width , int64_t limsiz ) ;
static _Bool tcfdbvanishimpl(TCFDB *fdb ) ;
static _Bool tcfdbcopyimpl(TCFDB *fdb , char const   *path ) ;
static _Bool tcfdbiterjumpimpl(TCFDB *fdb , int64_t id ) ;
static _Bool tcfdbforeachimpl(TCFDB *fdb , _Bool (*iter)(void const   *kbuf , int ksiz ,
                                                         void const   *vbuf , int vsiz ,
                                                         void *op ) , void *op ) ;
static _Bool tcfdblockmethod(TCFDB *fdb , _Bool wr ) ;
static _Bool tcfdbunlockmethod(TCFDB *fdb ) ;
static _Bool tcfdblockattr(TCFDB *fdb ) ;
static _Bool tcfdbunlockattr(TCFDB *fdb ) ;
static _Bool tcfdblockrecord(TCFDB *fdb , _Bool wr , uint64_t id ) ;
static _Bool tcfdbunlockrecord(TCFDB *fdb , uint64_t id ) ;
static _Bool tcfdblockallrecords(TCFDB *fdb , _Bool wr ) ;
static _Bool tcfdbunlockallrecords(TCFDB *fdb ) ;
static _Bool tcfdblockwal(TCFDB *fdb ) ;
static _Bool tcfdbunlockwal(TCFDB *fdb ) ;
void tcfdbprintmeta(TCFDB *fdb ) ;
char const   *tcfdberrmsg(int ecode ) 
{ char const   *tmp ;

  {
  tmp = tcerrmsg(ecode);
  return (tmp);
}
}
TCFDB *tcfdbnew(void) 
{ TCFDB *fdb ;
  void *tmp ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*fdb)));
    fdb = (TCFDB *)tmp;
    if (! fdb) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tcfdbclear(fdb);
  return (fdb);
}
}
void tcfdbdel(TCFDB *fdb ) 
{ int i ;

  {
  if (fdb->fd >= 0) {
    tcfdbclose(fdb);
  }
  if (fdb->mmtx) {
    pthread_key_delete(*((pthread_key_t *)fdb->eckey));
    pthread_mutex_destroy((pthread_mutex_t *)fdb->wmtx);
    pthread_mutex_destroy((pthread_mutex_t *)fdb->tmtx);
    i = 126;
    while (i >= 0) {
      pthread_rwlock_destroy((pthread_rwlock_t *)fdb->rmtxs + i);
      i --;
    }
    pthread_mutex_destroy((pthread_mutex_t *)fdb->amtx);
    pthread_rwlock_destroy((pthread_rwlock_t *)fdb->mmtx);
    while (1) {
      free(fdb->eckey);
      break;
    }
    while (1) {
      free(fdb->wmtx);
      break;
    }
    while (1) {
      free(fdb->tmtx);
      break;
    }
    while (1) {
      free(fdb->rmtxs);
      break;
    }
    while (1) {
      free(fdb->amtx);
      break;
    }
    while (1) {
      free(fdb->mmtx);
      break;
    }
  }
  while (1) {
    free((void *)fdb);
    break;
  }
  return;
}
}
int tcfdbecode(TCFDB *fdb ) 
{ void *tmp ;
  int tmp___0 ;

  {
  if (fdb->mmtx) {
    tmp = pthread_getspecific(*((pthread_key_t *)fdb->eckey));
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = fdb->ecode;
  }
  return (tmp___0);
}
}
_Bool tcfdbsetmutex(TCFDB *fdb ) 
{ void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  _Bool err ;
  int tmp___5 ;
  int tmp___6 ;
  int i ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  if (fdb->mmtx) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 181, "tcfdbsetmutex");
    return ((_Bool)0);
  } else {
    if (fdb->fd >= 0) {
      tcfdbsetecode(fdb, 2, "tcfdb.c", 181, "tcfdbsetmutex");
      return ((_Bool)0);
    }
  }
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(pthread_rwlock_t )));
    fdb->mmtx = tmp;
    if (! tmp) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___0 = malloc((unsigned int )((int )sizeof(pthread_mutex_t )));
    fdb->amtx = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(pthread_rwlock_t ) * 127));
    fdb->rmtxs = tmp___1;
    if (! tmp___1) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___2 = malloc((unsigned int )((int )sizeof(pthread_mutex_t )));
    fdb->tmtx = tmp___2;
    if (! tmp___2) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___3 = malloc((unsigned int )((int )sizeof(pthread_mutex_t )));
    fdb->wmtx = tmp___3;
    if (! tmp___3) {
      tcmyfatal("out of memory");
    }
    break;
  }
  while (1) {
    tmp___4 = malloc((unsigned int )((int )sizeof(pthread_key_t )));
    fdb->eckey = tmp___4;
    if (! tmp___4) {
      tcmyfatal("out of memory");
    }
    break;
  }
  err = (_Bool)0;
  tmp___5 = pthread_rwlock_init((pthread_rwlock_t * __restrict  )fdb->mmtx, (pthread_rwlockattr_t const   * __restrict  )((void *)0));
  if (tmp___5 != 0) {
    err = (_Bool)1;
  }
  tmp___6 = pthread_mutex_init((pthread_mutex_t *)fdb->amtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___6 != 0) {
    err = (_Bool)1;
  }
  i = 0;
  while (i < 127) {
    tmp___7 = pthread_rwlock_init((pthread_rwlock_t * __restrict  )((pthread_rwlock_t *)fdb->rmtxs + i),
                                  (pthread_rwlockattr_t const   * __restrict  )((void *)0));
    if (tmp___7 != 0) {
      err = (_Bool)1;
    }
    i ++;
  }
  tmp___8 = pthread_mutex_init((pthread_mutex_t *)fdb->tmtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___8 != 0) {
    err = (_Bool)1;
  }
  tmp___9 = pthread_mutex_init((pthread_mutex_t *)fdb->wmtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___9 != 0) {
    err = (_Bool)1;
  }
  tmp___10 = pthread_key_create((pthread_key_t *)fdb->eckey, (void (*)(void * ))((void *)0));
  if (tmp___10 != 0) {
    err = (_Bool)1;
  }
  if (err) {
    while (1) {
      free(fdb->eckey);
      break;
    }
    while (1) {
      free(fdb->wmtx);
      break;
    }
    while (1) {
      free(fdb->tmtx);
      break;
    }
    while (1) {
      free(fdb->rmtxs);
      break;
    }
    while (1) {
      free(fdb->amtx);
      break;
    }
    while (1) {
      free(fdb->mmtx);
      break;
    }
    fdb->eckey = (void *)0;
    fdb->wmtx = (void *)0;
    fdb->tmtx = (void *)0;
    fdb->rmtxs = (void *)0;
    fdb->amtx = (void *)0;
    fdb->mmtx = (void *)0;
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
_Bool tcfdbtune(TCFDB *fdb , int32_t width , int64_t limsiz ) 
{ 

  {
  if (fdb->fd >= 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 222, "tcfdbtune");
    return ((_Bool)0);
  }
  if (width > 0) {
    fdb->width = (unsigned int )width;
  } else {
    fdb->width = 255U;
  }
  if (limsiz > 0LL) {
    fdb->limsiz = (unsigned long long )limsiz;
  } else {
    fdb->limsiz = (unsigned long long )(256LL << 20);
  }
  if (fdb->limsiz < (unsigned long long )((256U + fdb->width) + (unsigned int )((int )sizeof(uint32_t )))) {
    fdb->limsiz = (unsigned long long )((256U + fdb->width) + (unsigned int )((int )sizeof(uint32_t )));
  }
  fdb->limsiz = tcpagealign(fdb->limsiz);
  return ((_Bool)1);
}
}
_Bool tcfdbopen(TCFDB *fdb , char const   *path , int omode ) 
{ _Bool tmp ;
  int tmp___0 ;
  char *rpath ;
  char *tmp___1 ;
  int ecode ;
  int *tmp___2 ;
  _Bool tmp___3 ;
  _Bool rv ;
  _Bool tmp___4 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd >= 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 239, "tcfdbopen");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcrealpath(path);
  rpath = tmp___1;
  if (! rpath) {
    ecode = 7;
    tmp___2 = __errno_location();
    switch (*tmp___2) {
    case 13: 
    ecode = 4;
    break;
    case 2: 
    ecode = 3;
    break;
    case 20: 
    ecode = 3;
    break;
    }
    tcfdbsetecode(fdb, ecode, "tcfdb.c", 251, "tcfdbopen");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  tmp___3 = tcpathlock((char const   *)rpath);
  if (! tmp___3) {
    tcfdbsetecode(fdb, 1, "tcfdb.c", 256, "tcfdbopen");
    while (1) {
      free((void *)rpath);
      break;
    }
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  tmp___4 = tcfdbopenimpl(fdb, path, omode);
  rv = tmp___4;
  if (rv) {
    fdb->rpath = rpath;
  } else {
    tcpathunlock((char const   *)rpath);
    while (1) {
      free((void *)rpath);
      break;
    }
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdbclose(TCFDB *fdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 278, "tcfdbclose");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcfdbcloseimpl(fdb);
  rv = tmp___1;
  tcpathunlock((char const   *)fdb->rpath);
  while (1) {
    free((void *)fdb->rpath);
    break;
  }
  fdb->rpath = (char *)((void *)0);
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdbput(TCFDB *fdb , int64_t id , void const   *vbuf , int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool rv ;
  _Bool tmp___3 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool )(id < 1LL));
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      _L: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 296, "tcfdbput");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
  }
  if (id == -1LL) {
    id = (long long )fdb->min;
  } else {
    if (id == -2LL) {
      id = (long long )(fdb->min - 1ULL);
    } else {
      if (id == -3LL) {
        id = (long long )fdb->max;
      } else {
        if (id == -4LL) {
          id = (long long )(fdb->max + 1ULL);
        }
      }
    }
  }
  if (id < 1LL) {
    goto _L___0;
  } else {
    if ((unsigned long long )id > fdb->limid) {
      _L___0: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 310, "tcfdbput");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockrecord(fdb, (_Bool)1, (unsigned long long )id);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  tmp___3 = tcfdbputimpl(fdb, id, vbuf, vsiz, 0);
  rv = tmp___3;
  if (fdb->mmtx) {
    tcfdbunlockrecord(fdb, (unsigned long long )id);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdbput2(TCFDB *fdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                int vsiz ) 
{ int64_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = tcfdbkeytoid((char const   *)kbuf, ksiz);
  tmp___0 = tcfdbput(fdb, tmp, vbuf, vsiz);
  return (tmp___0);
}
}
_Bool tcfdbput3(TCFDB *fdb , char const   *kstr , void const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  int64_t tmp___1 ;
  _Bool tmp___2 ;

  {
  tmp = strlen((char const   *)vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcfdbkeytoid(kstr, (int )tmp___0);
  tmp___2 = tcfdbput(fdb, tmp___1, vstr, (int )tmp);
  return (tmp___2);
}
}
_Bool tcfdbputkeep(TCFDB *fdb , int64_t id , void const   *vbuf , int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool rv ;
  _Bool tmp___3 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool )(id < 1LL));
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      _L: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 344, "tcfdbputkeep");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
  }
  if (id == -1LL) {
    id = (long long )fdb->min;
  } else {
    if (id == -2LL) {
      id = (long long )(fdb->min - 1ULL);
    } else {
      if (id == -3LL) {
        id = (long long )fdb->max;
      } else {
        if (id == -4LL) {
          id = (long long )(fdb->max + 1ULL);
        }
      }
    }
  }
  if (id < 1LL) {
    goto _L___0;
  } else {
    if ((unsigned long long )id > fdb->limid) {
      _L___0: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 358, "tcfdbputkeep");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockrecord(fdb, (_Bool)1, (unsigned long long )id);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  tmp___3 = tcfdbputimpl(fdb, id, vbuf, vsiz, 1);
  rv = tmp___3;
  if (fdb->mmtx) {
    tcfdbunlockrecord(fdb, (unsigned long long )id);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdbputkeep2(TCFDB *fdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                    int vsiz ) 
{ int64_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = tcfdbkeytoid((char const   *)kbuf, ksiz);
  tmp___0 = tcfdbputkeep(fdb, tmp, vbuf, vsiz);
  return (tmp___0);
}
}
_Bool tcfdbputkeep3(TCFDB *fdb , char const   *kstr , void const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  int64_t tmp___1 ;
  _Bool tmp___2 ;

  {
  tmp = strlen((char const   *)vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcfdbkeytoid(kstr, (int )tmp___0);
  tmp___2 = tcfdbputkeep(fdb, tmp___1, vstr, (int )tmp);
  return (tmp___2);
}
}
_Bool tcfdbputcat(TCFDB *fdb , int64_t id , void const   *vbuf , int vsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool rv ;
  _Bool tmp___3 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool )(id < 1LL));
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      _L: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 392, "tcfdbputcat");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
  }
  if (id == -1LL) {
    id = (long long )fdb->min;
  } else {
    if (id == -2LL) {
      id = (long long )(fdb->min - 1ULL);
    } else {
      if (id == -3LL) {
        id = (long long )fdb->max;
      } else {
        if (id == -4LL) {
          id = (long long )(fdb->max + 1ULL);
        }
      }
    }
  }
  if (id < 1LL) {
    goto _L___0;
  } else {
    if ((unsigned long long )id > fdb->limid) {
      _L___0: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 406, "tcfdbputcat");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockrecord(fdb, (_Bool)1, (unsigned long long )id);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  tmp___3 = tcfdbputimpl(fdb, id, vbuf, vsiz, 2);
  rv = tmp___3;
  if (fdb->mmtx) {
    tcfdbunlockrecord(fdb, (unsigned long long )id);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdbputcat2(TCFDB *fdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) 
{ int64_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = tcfdbkeytoid((char const   *)kbuf, ksiz);
  tmp___0 = tcfdbputcat(fdb, tmp, vbuf, vsiz);
  return (tmp___0);
}
}
_Bool tcfdbputcat3(TCFDB *fdb , char const   *kstr , void const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  int64_t tmp___1 ;
  _Bool tmp___2 ;

  {
  tmp = strlen((char const   *)vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcfdbkeytoid(kstr, (int )tmp___0);
  tmp___2 = tcfdbputcat(fdb, tmp___1, vstr, (int )tmp);
  return (tmp___2);
}
}
_Bool tcfdbout(TCFDB *fdb , int64_t id ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool rv ;
  _Bool tmp___3 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      _L: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 440, "tcfdbout");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
  }
  if (id == -1LL) {
    id = (long long )fdb->min;
  } else {
    if (id == -3LL) {
      id = (long long )fdb->max;
    }
  }
  if (id < 1LL) {
    goto _L___0;
  } else {
    if ((unsigned long long )id > fdb->limid) {
      _L___0: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 450, "tcfdbout");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockrecord(fdb, (_Bool)1, (unsigned long long )id);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  tmp___3 = tcfdboutimpl(fdb, id);
  rv = tmp___3;
  if (fdb->mmtx) {
    tcfdbunlockrecord(fdb, (unsigned long long )id);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdbout2(TCFDB *fdb , void const   *kbuf , int ksiz ) 
{ int64_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = tcfdbkeytoid((char const   *)kbuf, ksiz);
  tmp___0 = tcfdbout(fdb, tmp);
  return (tmp___0);
}
}
_Bool tcfdbout3(TCFDB *fdb , char const   *kstr ) 
{ size_t tmp ;
  int64_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcfdbkeytoid(kstr, (int )tmp);
  tmp___1 = tcfdbout(fdb, tmp___0);
  return (tmp___1);
}
}
void *tcfdbget(TCFDB *fdb , int64_t id , int *sp ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  void const   *vbuf ;
  void const   *tmp___3 ;
  char *rv ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((void *)0);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 484, "tcfdbget");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((void *)0);
  }
  if (id == -1LL) {
    id = (long long )fdb->min;
  } else {
    if (id == -3LL) {
      id = (long long )fdb->max;
    }
  }
  if (id < 1LL) {
    goto _L;
  } else {
    if ((unsigned long long )id > fdb->limid) {
      _L: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 494, "tcfdbget");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((void *)0);
    }
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockrecord(fdb, (_Bool)0, (unsigned long long )id);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((void *)0);
  }
  tmp___3 = tcfdbgetimpl(fdb, id, sp);
  vbuf = tmp___3;
  if (vbuf) {
    tmp___4 = tcmemdup(vbuf, (unsigned int )*sp);
    tmp___5 = tmp___4;
  } else {
    tmp___5 = (void *)0;
  }
  rv = (char *)tmp___5;
  if (fdb->mmtx) {
    tcfdbunlockrecord(fdb, (unsigned long long )id);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return ((void *)rv);
}
}
void *tcfdbget2(TCFDB *fdb , void const   *kbuf , int ksiz , int *sp ) 
{ int64_t tmp ;
  void *tmp___0 ;

  {
  tmp = tcfdbkeytoid((char const   *)kbuf, ksiz);
  tmp___0 = tcfdbget(fdb, tmp, sp);
  return (tmp___0);
}
}
char *tcfdbget3(TCFDB *fdb , char const   *kstr ) 
{ int vsiz ;
  size_t tmp ;
  int64_t tmp___0 ;
  void *tmp___1 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcfdbkeytoid(kstr, (int )tmp);
  tmp___1 = tcfdbget(fdb, tmp___0, & vsiz);
  return ((char *)tmp___1);
}
}
int tcfdbget4(TCFDB *fdb , int64_t id , void *vbuf , int max ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int vsiz ;
  void const   *rbuf ;
  void const   *tmp___3 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 530, "tcfdbget4");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return (0);
  }
  if (id == -1LL) {
    id = (long long )fdb->min;
  } else {
    if (id == -3LL) {
      id = (long long )fdb->max;
    }
  }
  if (id < 1LL) {
    goto _L;
  } else {
    if ((unsigned long long )id > fdb->limid) {
      _L: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 540, "tcfdbget4");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return (0);
    }
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockrecord(fdb, (_Bool)0, (unsigned long long )id);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return (0);
  }
  tmp___3 = tcfdbgetimpl(fdb, id, & vsiz);
  rbuf = tmp___3;
  if (rbuf) {
    if (vsiz > max) {
      vsiz = max;
    }
    memcpy((void * __restrict  )vbuf, (void const   * __restrict  )rbuf, (unsigned int )vsiz);
  } else {
    vsiz = -1;
  }
  if (fdb->mmtx) {
    tcfdbunlockrecord(fdb, (unsigned long long )id);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (vsiz);
}
}
int tcfdbvsiz(TCFDB *fdb , int64_t id ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int vsiz ;
  void const   *vbuf ;
  void const   *tmp___3 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 567, "tcfdbvsiz");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return (0);
  }
  if (id == -1LL) {
    id = (long long )fdb->min;
  } else {
    if (id == -3LL) {
      id = (long long )fdb->max;
    }
  }
  if (id < 1LL) {
    goto _L;
  } else {
    if ((unsigned long long )id > fdb->limid) {
      _L: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 577, "tcfdbvsiz");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return (0);
    }
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockrecord(fdb, (_Bool)0, (unsigned long long )id);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return (0);
  }
  tmp___3 = tcfdbgetimpl(fdb, id, & vsiz);
  vbuf = tmp___3;
  if (! vbuf) {
    vsiz = -1;
  }
  if (fdb->mmtx) {
    tcfdbunlockrecord(fdb, (unsigned long long )id);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (vsiz);
}
}
int tcfdbvsiz2(TCFDB *fdb , void const   *kbuf , int ksiz ) 
{ int64_t tmp ;
  int tmp___0 ;

  {
  tmp = tcfdbkeytoid((char const   *)kbuf, ksiz);
  tmp___0 = tcfdbvsiz(fdb, tmp);
  return (tmp___0);
}
}
int tcfdbvsiz3(TCFDB *fdb , char const   *kstr ) 
{ size_t tmp ;
  int64_t tmp___0 ;
  int tmp___1 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcfdbkeytoid(kstr, (int )tmp);
  tmp___1 = tcfdbvsiz(fdb, tmp___0);
  return (tmp___1);
}
}
_Bool tcfdbiterinit(TCFDB *fdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 613, "tcfdbiterinit");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tcfdbiterinitimpl(fdb);
  rv = tmp___1;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
uint64_t tcfdbiternext(TCFDB *fdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint64_t rv ;
  uint64_t tmp___1 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0ULL);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 628, "tcfdbiternext");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return (0ULL);
  }
  tmp___1 = tcfdbiternextimpl(fdb);
  rv = tmp___1;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
void *tcfdbiternext2(TCFDB *fdb , int *sp ) 
{ uint64_t id ;
  uint64_t tmp ;
  char kbuf[32] ;
  int ksiz ;
  int tmp___0 ;
  void *tmp___1 ;

  {
  tmp = tcfdbiternextimpl(fdb);
  id = tmp;
  if (id < 1ULL) {
    return ((void *)0);
  }
  tmp___0 = sprintf((char * __restrict  )(kbuf), (char const   * __restrict  )"%llu",
                    id);
  ksiz = tmp___0;
  *sp = ksiz;
  tmp___1 = tcmemdup((void const   *)(kbuf), (unsigned int )ksiz);
  return (tmp___1);
}
}
char *tcfdbiternext3(TCFDB *fdb ) 
{ int ksiz ;
  void *tmp ;

  {
  tmp = tcfdbiternext2(fdb, & ksiz);
  return ((char *)tmp);
}
}
uint64_t *tcfdbrange(TCFDB *fdb , int64_t lower , int64_t upper , int max , int *np ) 
{ _Bool tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  uint64_t *rv ;
  uint64_t *tmp___3 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((uint64_t *)0);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 663, "tcfdbrange");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    *np = 0;
    tmp___1 = tcmalloc(1U);
    return ((uint64_t *)tmp___1);
  }
  if (lower == -1LL) {
    lower = (long long )fdb->min;
  }
  if (upper == -3LL) {
    upper = (long long )fdb->max;
  }
  if (lower < 1LL) {
    goto _L;
  } else {
    if ((unsigned long long )lower > fdb->limid) {
      goto _L;
    } else {
      if (upper < 1LL) {
        goto _L;
      } else {
        if ((unsigned long long )upper > fdb->limid) {
          _L: 
          tcfdbsetecode(fdb, 2, "tcfdb.c", 671, "tcfdbrange");
          if (fdb->mmtx) {
            tcfdbunlockmethod(fdb);
          }
          *np = 0;
          tmp___2 = tcmalloc(1U);
          return ((uint64_t *)tmp___2);
        }
      }
    }
  }
  tmp___3 = tcfdbrangeimpl(fdb, lower, upper, max, np);
  rv = tmp___3;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
TCLIST *tcfdbrange2(TCFDB *fdb , void const   *lbuf , int lsiz , void const   *ubuf ,
                    int usiz , int max ) 
{ int num ;
  uint64_t *ids ;
  int64_t tmp ;
  int64_t tmp___0 ;
  uint64_t *tmp___1 ;
  TCLIST *keys ;
  TCLIST *tmp___2 ;
  int i ;
  char kbuf[32] ;
  int ksiz ;
  int tmp___3 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___4 ;
  void *tmp___5 ;
  TCLISTDATUM *array ;
  char *tmp___6 ;
  void *tmp___7 ;

  {
  tmp = tcfdbkeytoid((char const   *)ubuf, usiz);
  tmp___0 = tcfdbkeytoid((char const   *)lbuf, lsiz);
  tmp___1 = tcfdbrange(fdb, tmp___0, tmp, max, & num);
  ids = tmp___1;
  tmp___2 = tclistnew2(num);
  keys = tmp___2;
  i = 0;
  while (i < num) {
    tmp___3 = sprintf((char * __restrict  )(kbuf), (char const   * __restrict  )"%llu",
                      *(ids + i));
    ksiz = tmp___3;
    while (1) {
      TC_mysize = ksiz;
      TC_index = keys->start + keys->num;
      if (TC_index >= keys->anum) {
        keys->anum += keys->num + 1;
        while (1) {
          tmp___5 = realloc((void *)keys->array, (unsigned int )(keys->anum * (int )sizeof(*(keys->array + 0))));
          tmp___4 = (TCLISTDATUM *)tmp___5;
          keys->array = tmp___4;
          if (! tmp___4) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array = keys->array;
      while (1) {
        tmp___7 = malloc((unsigned int )(TC_mysize + 1));
        tmp___6 = (char *)tmp___7;
        (array + TC_index)->ptr = tmp___6;
        if (! tmp___6) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )(kbuf),
             (unsigned int )TC_mysize);
      *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
      (array + TC_index)->size = TC_mysize;
      (keys->num) ++;
      break;
    }
    i ++;
  }
  while (1) {
    free((void *)ids);
    break;
  }
  return (keys);
}
}
TCLIST *tcfdbrange3(TCFDB *fdb , char const   *lstr , char const   *ustr , int max ) 
{ size_t tmp ;
  size_t tmp___0 ;
  TCLIST *tmp___1 ;

  {
  tmp = strlen(ustr);
  tmp___0 = strlen(lstr);
  tmp___1 = tcfdbrange2(fdb, (void const   *)lstr, (int )tmp___0, (void const   *)ustr,
                        (int )tmp, max);
  return (tmp___1);
}
}
TCLIST *tcfdbrange4(TCFDB *fdb , void const   *ibuf , int isiz , int max ) 
{ char *expr ;
  void *tmp ;
  char *pv ;
  _Bool linc ;
  TCLIST *tmp___0 ;
  char *sep ;
  char *tmp___2 ;
  TCLIST *tmp___3 ;
  int64_t lower ;
  size_t tmp___4 ;
  int64_t tmp___5 ;
  _Bool uinc ;
  TCLIST *tmp___6 ;
  char *tmp___8 ;
  char *tmp___10 ;
  int64_t upper ;
  size_t tmp___11 ;
  int64_t tmp___12 ;
  int num ;
  uint64_t *ids ;
  uint64_t *tmp___13 ;
  TCLIST *keys ;
  TCLIST *tmp___14 ;
  int i ;
  char kbuf[32] ;
  int ksiz ;
  int tmp___15 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___16 ;
  void *tmp___17 ;
  TCLISTDATUM *array ;
  char *tmp___18 ;
  void *tmp___19 ;

  {
  while (1) {
    while (1) {
      tmp = malloc((unsigned int )(isiz + 1));
      expr = (char *)tmp;
      if (! expr) {
        tcmyfatal("out of memory");
      }
      break;
    }
    memcpy((void * __restrict  )expr, (void const   * __restrict  )ibuf, (unsigned int )isiz);
    *(expr + isiz) = (char )'\000';
    break;
  }
  pv = expr;
  while (1) {
    if ((int )*pv > 0) {
      if (! ((int )*pv <= 32)) {
        break;
      }
    } else {
      break;
    }
    pv ++;
  }
  linc = (_Bool)0;
  if ((int )*pv == 91) {
    linc = (_Bool)1;
  } else {
    if ((int )*pv != 40) {
      tcfdbsetecode(fdb, 2, "tcfdb.c", 718, "tcfdbrange4");
      while (1) {
        free((void *)expr);
        break;
      }
      tmp___0 = tclistnew();
      return (tmp___0);
    }
  }
  pv ++;
  tmp___2 = __builtin_strchr(pv, ',');
  sep = tmp___2;
  if (! sep) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 725, "tcfdbrange4");
    while (1) {
      free((void *)expr);
      break;
    }
    tmp___3 = tclistnew();
    return (tmp___3);
  }
  *sep = (char )'\000';
  tcstrtrim(pv);
  tmp___4 = strlen((char const   *)pv);
  tmp___5 = tcfdbkeytoid((char const   *)pv, (int )tmp___4);
  lower = tmp___5;
  pv = sep + 1;
  uinc = (_Bool)0;
  tmp___10 = __builtin_strchr(pv, ']');
  sep = tmp___10;
  if ((unsigned int )sep != (unsigned int )((void *)0)) {
    uinc = (_Bool)1;
    *sep = (char )'\000';
  } else {
    tmp___8 = __builtin_strchr(pv, ')');
    sep = tmp___8;
    if ((unsigned int )sep != (unsigned int )((void *)0)) {
      *sep = (char )'\000';
    } else {
      tcfdbsetecode(fdb, 2, "tcfdb.c", 740, "tcfdbrange4");
      while (1) {
        free((void *)expr);
        break;
      }
      tmp___6 = tclistnew();
      return (tmp___6);
    }
  }
  tcstrtrim(pv);
  tmp___11 = strlen((char const   *)pv);
  tmp___12 = tcfdbkeytoid((char const   *)pv, (int )tmp___11);
  upper = tmp___12;
  if (lower == -1LL) {
    lower = (long long )fdb->min;
  } else {
    if (lower == -2LL) {
      lower = (long long )(fdb->min - 1ULL);
    } else {
      if (lower == -3LL) {
        lower = (long long )fdb->max;
      } else {
        if (lower == -4LL) {
          lower = (long long )(fdb->max + 1ULL);
        }
      }
    }
  }
  if (! linc) {
    lower ++;
  }
  if (upper == -1LL) {
    upper = (long long )fdb->min;
  } else {
    if (upper == -2LL) {
      upper = (long long )(fdb->min - 1ULL);
    } else {
      if (upper == -3LL) {
        upper = (long long )fdb->max;
      } else {
        if (upper == -4LL) {
          upper = (long long )(fdb->max + 1ULL);
        }
      }
    }
  }
  if (! uinc) {
    upper --;
  }
  while (1) {
    free((void *)expr);
    break;
  }
  tmp___13 = tcfdbrange(fdb, lower, upper, max, & num);
  ids = tmp___13;
  tmp___14 = tclistnew2(num);
  keys = tmp___14;
  i = 0;
  while (i < num) {
    tmp___15 = sprintf((char * __restrict  )(kbuf), (char const   * __restrict  )"%llu",
                       *(ids + i));
    ksiz = tmp___15;
    while (1) {
      TC_mysize = ksiz;
      TC_index = keys->start + keys->num;
      if (TC_index >= keys->anum) {
        keys->anum += keys->num + 1;
        while (1) {
          tmp___17 = realloc((void *)keys->array, (unsigned int )(keys->anum * (int )sizeof(*(keys->array + 0))));
          tmp___16 = (TCLISTDATUM *)tmp___17;
          keys->array = tmp___16;
          if (! tmp___16) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      array = keys->array;
      while (1) {
        tmp___19 = malloc((unsigned int )(TC_mysize + 1));
        tmp___18 = (char *)tmp___19;
        (array + TC_index)->ptr = tmp___18;
        if (! tmp___18) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )(kbuf),
             (unsigned int )TC_mysize);
      *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
      (array + TC_index)->size = TC_mysize;
      (keys->num) ++;
      break;
    }
    i ++;
  }
  while (1) {
    free((void *)ids);
    break;
  }
  return (keys);
}
}
TCLIST *tcfdbrange5(TCFDB *fdb , void const   *istr , int max ) 
{ size_t tmp ;
  TCLIST *tmp___0 ;

  {
  tmp = strlen((char const   *)istr);
  tmp___0 = tcfdbrange4(fdb, istr, (int )tmp, max);
  return (tmp___0);
}
}
int tcfdbaddint(TCFDB *fdb , int64_t id , int num ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool rv ;
  _Bool tmp___3 ;
  int tmp___4 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool )(id < 1LL));
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((-0x7FFFFFFF-1));
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      _L: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 792, "tcfdbaddint");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((-0x7FFFFFFF-1));
    }
  }
  if (id == -1LL) {
    id = (long long )fdb->min;
  } else {
    if (id == -2LL) {
      id = (long long )(fdb->min - 1ULL);
    } else {
      if (id == -3LL) {
        id = (long long )fdb->max;
      } else {
        if (id == -4LL) {
          id = (long long )(fdb->max + 1ULL);
        }
      }
    }
  }
  if (id < 1LL) {
    goto _L___0;
  } else {
    if ((unsigned long long )id > fdb->limid) {
      _L___0: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 806, "tcfdbaddint");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((-0x7FFFFFFF-1));
    }
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockrecord(fdb, (_Bool)1, (unsigned long long )id);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((-0x7FFFFFFF-1));
  }
  tmp___3 = tcfdbputimpl(fdb, id, (void const   *)((char *)(& num)), (int )sizeof(num),
                         3);
  rv = tmp___3;
  if (fdb->mmtx) {
    tcfdbunlockrecord(fdb, (unsigned long long )id);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  if (rv) {
    tmp___4 = num;
  } else {
    tmp___4 = (-0x7FFFFFFF-1);
  }
  return (tmp___4);
}
}
double tcfdbadddouble(TCFDB *fdb , int64_t id , double num ) 
{ double tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;
  _Bool rv ;
  _Bool tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;

  {
  if (fdb->mmtx) {
    tmp___0 = tcfdblockmethod(fdb, (_Bool )(id < 1LL));
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    tmp = nan("");
    return (tmp);
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      _L: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 826, "tcfdbadddouble");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      tmp___2 = nan("");
      return (tmp___2);
    }
  }
  if (id == -1LL) {
    id = (long long )fdb->min;
  } else {
    if (id == -2LL) {
      id = (long long )(fdb->min - 1ULL);
    } else {
      if (id == -3LL) {
        id = (long long )fdb->max;
      } else {
        if (id == -4LL) {
          id = (long long )(fdb->max + 1ULL);
        }
      }
    }
  }
  if (id < 1LL) {
    goto _L___0;
  } else {
    if ((unsigned long long )id > fdb->limid) {
      _L___0: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 840, "tcfdbadddouble");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      tmp___3 = nan("");
      return (tmp___3);
    }
  }
  if (fdb->mmtx) {
    tmp___5 = tcfdblockrecord(fdb, (_Bool)1, (unsigned long long )id);
    tmp___6 = (int )tmp___5;
  } else {
    tmp___6 = 1;
  }
  if (! tmp___6) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    tmp___4 = nan("");
    return (tmp___4);
  }
  tmp___7 = tcfdbputimpl(fdb, id, (void const   *)((char *)(& num)), (int )sizeof(num),
                         4);
  rv = tmp___7;
  if (fdb->mmtx) {
    tcfdbunlockrecord(fdb, (unsigned long long )id);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  if (rv) {
    tmp___9 = num;
  } else {
    tmp___8 = nan("");
    tmp___9 = tmp___8;
  }
  return (tmp___9);
}
}
_Bool tcfdbsync(TCFDB *fdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      goto _L;
    } else {
      if (fdb->tran) {
        _L: 
        tcfdbsetecode(fdb, 2, "tcfdb.c", 860, "tcfdbsync");
        if (fdb->mmtx) {
          tcfdbunlockmethod(fdb);
        }
        return ((_Bool)0);
      }
    }
  }
  tmp___1 = tcfdbmemsync(fdb, (_Bool)1);
  rv = tmp___1;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdboptimize(TCFDB *fdb , int32_t width , int64_t limsiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      goto _L;
    } else {
      if (fdb->tran) {
        _L: 
        tcfdbsetecode(fdb, 2, "tcfdb.c", 875, "tcfdboptimize");
        if (fdb->mmtx) {
          tcfdbunlockmethod(fdb);
        }
        return ((_Bool)0);
      }
    }
  }
  while (1) {
    if (fdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___1 = tcfdboptimizeimpl(fdb, width, limsiz);
  rv = tmp___1;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdbvanish(TCFDB *fdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      goto _L;
    } else {
      if (fdb->tran) {
        _L: 
        tcfdbsetecode(fdb, 2, "tcfdb.c", 891, "tcfdbvanish");
        if (fdb->mmtx) {
          tcfdbunlockmethod(fdb);
        }
        return ((_Bool)0);
      }
    }
  }
  while (1) {
    if (fdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___1 = tcfdbvanishimpl(fdb);
  rv = tmp___1;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdbcopy(TCFDB *fdb , char const   *path ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool rv ;
  _Bool tmp___3 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 907, "tcfdbcopy");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockallrecords(fdb, (_Bool)0);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  while (1) {
    if (fdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___3 = tcfdbcopyimpl(fdb, path);
  rv = tmp___3;
  if (fdb->mmtx) {
    tcfdbunlockallrecords(fdb);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdbtranbegin(TCFDB *fdb ) 
{ double wsec ;
  long tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;
  char *tpath ;
  char *tmp___4 ;
  int walfd ;
  int tmp___5 ;
  int ecode ;
  int *tmp___6 ;
  _Bool tmp___7 ;

  {
  tmp = sysconf(2);
  wsec = 1.0 / (double )tmp;
  while (1) {
    if (fdb->mmtx) {
      tmp___0 = tcfdblockmethod(fdb, (_Bool)1);
      tmp___1 = (int )tmp___0;
    } else {
      tmp___1 = 1;
    }
    if (! tmp___1) {
      return ((_Bool)0);
    }
    if (fdb->fd < 0) {
      goto _L;
    } else {
      if (! (fdb->omode & 2U)) {
        goto _L;
      } else {
        if (fdb->fatal) {
          _L: 
          tcfdbsetecode(fdb, 2, "tcfdb.c", 929, "tcfdbtranbegin");
          if (fdb->mmtx) {
            tcfdbunlockmethod(fdb);
          }
          return ((_Bool)0);
        }
      }
    }
    if (! fdb->tran) {
      break;
    }
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    if (wsec > 1.0) {
      wsec = 1.0;
    }
    tcsleep(wsec);
    wsec *= (double )2;
  }
  tmp___2 = tcfdbmemsync(fdb, (_Bool)0);
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  if (fdb->omode & 64U) {
    tmp___3 = fsync(fdb->fd);
    if (tmp___3 == -1) {
      tcfdbsetecode(fdb, 10, "tcfdb.c", 943, "tcfdbtranbegin");
      return ((_Bool)0);
    }
  }
  if (fdb->walfd < 0) {
    tmp___4 = tcsprintf("%s%c%s", fdb->path, '.', "wal");
    tpath = tmp___4;
    tmp___5 = open((char const   *)tpath, 578, 420);
    walfd = tmp___5;
    while (1) {
      free((void *)tpath);
      break;
    }
    if (walfd < 0) {
      ecode = 7;
      tmp___6 = __errno_location();
      switch (*tmp___6) {
      case 13: 
      ecode = 4;
      break;
      case 2: 
      ecode = 3;
      break;
      case 20: 
      ecode = 3;
      break;
      }
      tcfdbsetecode(fdb, ecode, "tcfdb.c", 957, "tcfdbtranbegin");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
    fdb->walfd = walfd;
  }
  tcfdbsetflag(fdb, 1, (_Bool)0);
  tmp___7 = tcfdbwalinit(fdb);
  if (! tmp___7) {
    tcfdbsetflag(fdb, 1, (_Bool)1);
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  tcfdbsetflag(fdb, 1, (_Bool)1);
  fdb->tran = (_Bool)1;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return ((_Bool)1);
}
}
_Bool tcfdbtrancommit(TCFDB *fdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  _Bool tmp___1 ;
  int tmp___2 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      goto _L;
    } else {
      if (fdb->fatal) {
        goto _L;
      } else {
        if (! fdb->tran) {
          _L: 
          tcfdbsetecode(fdb, 2, "tcfdb.c", 981, "tcfdbtrancommit");
          if (fdb->mmtx) {
            tcfdbunlockmethod(fdb);
          }
          return ((_Bool)0);
        }
      }
    }
  }
  err = (_Bool)0;
  tmp___1 = tcfdbmemsync(fdb, (_Bool )(fdb->omode & 64U));
  if (! tmp___1) {
    err = (_Bool)1;
  }
  if (! err) {
    tmp___2 = ftruncate(fdb->walfd, 0L);
    if (tmp___2 == -1) {
      tcfdbsetecode(fdb, 9, "tcfdb.c", 988, "tcfdbtrancommit");
      err = (_Bool)1;
    }
  }
  fdb->tran = (_Bool)0;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return ((_Bool )(! err));
}
}
_Bool tcfdbtranabort(TCFDB *fdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  _Bool tmp___1 ;
  int tmp___2 ;
  char hbuf[256] ;
  _Bool tmp___3 ;
  __off_t tmp___4 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      goto _L;
    } else {
      if (! fdb->tran) {
        _L: 
        tcfdbsetecode(fdb, 2, "tcfdb.c", 1002, "tcfdbtranabort");
        if (fdb->mmtx) {
          tcfdbunlockmethod(fdb);
        }
        return ((_Bool)0);
      }
    }
  }
  err = (_Bool)0;
  tmp___1 = tcfdbmemsync(fdb, (_Bool)0);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  tmp___2 = tcfdbwalrestore(fdb, (char const   *)fdb->path);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  tmp___4 = lseek(fdb->fd, 0L, 0);
  if (tmp___4 == -1L) {
    tcfdbsetecode(fdb, 12, "tcfdb.c", 1011, "tcfdbtranabort");
    err = (_Bool)0;
  } else {
    tmp___3 = tcread(fdb->fd, (void *)(hbuf), 256U);
    if (tmp___3) {
      tcfdbloadmeta(fdb, (char const   *)(hbuf));
    } else {
      tcfdbsetecode(fdb, 13, "tcfdb.c", 1014, "tcfdbtranabort");
      err = (_Bool)0;
    }
  }
  fdb->tran = (_Bool)0;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return ((_Bool )(! err));
}
}
char const   *tcfdbpath(TCFDB *fdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  char const   *rv ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((char const   *)((void *)0));
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1030, "tcfdbpath");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((char const   *)((void *)0));
  }
  rv = (char const   *)fdb->path;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
uint64_t tcfdbrnum(TCFDB *fdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint64_t rv ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0ULL);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1045, "tcfdbrnum");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return (0ULL);
  }
  rv = fdb->rnum;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
uint64_t tcfdbfsiz(TCFDB *fdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint64_t rv ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0ULL);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1060, "tcfdbfsiz");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return (0ULL);
  }
  rv = fdb->fsiz;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
void tcfdbsetecode(TCFDB *fdb , int ecode , char const   *filename , int line , char const   *func ) 
{ int myerrno ;
  int *tmp ;
  int dbgfd ;
  int tmp___0 ;
  char obuf[8192] ;
  int osiz ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  tmp = __errno_location();
  myerrno = *tmp;
  if (! fdb->fatal) {
    fdb->ecode = ecode;
    if (fdb->mmtx) {
      pthread_setspecific(*((pthread_key_t *)fdb->eckey), (void const   *)((void *)ecode));
    }
  }
  if (ecode != 2) {
    if (ecode != 21) {
      if (ecode != 22) {
        fdb->fatal = (_Bool)1;
        if (fdb->fd >= 0) {
          if (fdb->omode & 2U) {
            tcfdbsetflag(fdb, 2, (_Bool)1);
          }
        }
      }
    }
  }
  if (fdb->dbgfd >= 0) {
    if (fdb->dbgfd != 65535) {
      goto _L;
    } else {
      if (fdb->fatal) {
        _L: 
        if (fdb->dbgfd == 65535) {
          tmp___0 = 1;
        } else {
          tmp___0 = fdb->dbgfd;
        }
        dbgfd = tmp___0;
        tmp___1 = strerror(myerrno);
        tmp___2 = tcfdberrmsg(ecode);
        if (fdb->path) {
          tmp___3 = (char const   *)fdb->path;
        } else {
          tmp___3 = "-";
        }
        tmp___4 = sprintf((char * __restrict  )(obuf), (char const   * __restrict  )"ERROR:%s:%d:%s:%s:%d:%s:%d:%s\n",
                          filename, line, func, tmp___3, ecode, tmp___2, myerrno,
                          tmp___1);
        osiz = tmp___4;
        tcwrite(dbgfd, (void const   *)(obuf), (unsigned int )osiz);
      }
    }
  }
  return;
}
}
void tcfdbsetdbgfd(TCFDB *fdb , int fd ) 
{ 

  {
  fdb->dbgfd = fd;
  return;
}
}
int tcfdbdbgfd(TCFDB *fdb ) 
{ 

  {
  return (fdb->dbgfd);
}
}
_Bool tcfdbhasmutex(TCFDB *fdb ) 
{ 

  {
  return ((_Bool )((unsigned int )fdb->mmtx != (unsigned int )((void *)0)));
}
}
_Bool tcfdbmemsync(TCFDB *fdb , _Bool phys ) 
{ _Bool err ;
  char hbuf[256] ;
  int tmp ;
  int tmp___0 ;

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1124, "tcfdbmemsync");
    return ((_Bool)0);
  } else {
    if (! (fdb->omode & 2U)) {
      tcfdbsetecode(fdb, 2, "tcfdb.c", 1124, "tcfdbmemsync");
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  tcfdbdumpmeta(fdb, hbuf);
  memcpy((void * __restrict  )fdb->map, (void const   * __restrict  )(hbuf), 128U);
  if (phys) {
    tmp = msync((void *)fdb->map, (unsigned int )fdb->limsiz, 4);
    if (tmp == -1) {
      tcfdbsetecode(fdb, 15, "tcfdb.c", 1133, "tcfdbmemsync");
      err = (_Bool)1;
    }
    tmp___0 = fsync(fdb->fd);
    if (tmp___0 == -1) {
      tcfdbsetecode(fdb, 10, "tcfdb.c", 1137, "tcfdbmemsync");
      err = (_Bool)1;
    }
  }
  return ((_Bool )(! err));
}
}
uint64_t tcfdbmin(TCFDB *fdb ) 
{ 

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1149, "tcfdbmin");
    return (0ULL);
  }
  return (fdb->min);
}
}
uint64_t tcfdbmax(TCFDB *fdb ) 
{ 

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1160, "tcfdbmax");
    return (0ULL);
  }
  return (fdb->max);
}
}
uint32_t tcfdbwidth(TCFDB *fdb ) 
{ 

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1171, "tcfdbwidth");
    return (0U);
  }
  return (fdb->width);
}
}
uint64_t tcfdblimsiz(TCFDB *fdb ) 
{ 

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1182, "tcfdblimsiz");
    return (0ULL);
  }
  return (fdb->limsiz);
}
}
uint64_t tcfdblimid(TCFDB *fdb ) 
{ 

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1193, "tcfdblimid");
    return (0ULL);
  }
  return (fdb->limid);
}
}
uint64_t tcfdbinode(TCFDB *fdb ) 
{ 

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1204, "tcfdbinode");
    return (0ULL);
  }
  return (fdb->inode);
}
}
time_t tcfdbmtime(TCFDB *fdb ) 
{ 

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1215, "tcfdbmtime");
    return (0L);
  }
  return (fdb->mtime);
}
}
int tcfdbomode(TCFDB *fdb ) 
{ 

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1226, "tcfdbomode");
    return (0);
  }
  return ((int )fdb->omode);
}
}
uint8_t tcfdbtype(TCFDB *fdb ) 
{ 

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1237, "tcfdbtype");
    return ((unsigned char)0);
  }
  return (fdb->type);
}
}
uint8_t tcfdbflags(TCFDB *fdb ) 
{ 

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1248, "tcfdbflags");
    return ((unsigned char)0);
  }
  return (fdb->flags);
}
}
char *tcfdbopaque(TCFDB *fdb ) 
{ 

  {
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1259, "tcfdbopaque");
    return ((char *)((void *)0));
  }
  return (fdb->map + 128);
}
}
_Bool tcfdbputproc(TCFDB *fdb , int64_t id , void const   *vbuf , int vsiz , void *(*proc___0)(void const   *vbuf ,
                                                                                               int vsiz ,
                                                                                               int *sp ,
                                                                                               void *op ) ,
                   void *op ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  FDBPDPROCOP procop ;
  FDBPDPROCOP *procptr ;
  char stack[287] ;
  char *rbuf ;
  void *tmp___3 ;
  char *wp ;
  _Bool rv ;
  _Bool tmp___4 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool )(id < 1LL));
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    goto _L;
  } else {
    if (! (fdb->omode & 2U)) {
      _L: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 1271, "tcfdbputproc");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
  }
  if (id == -1LL) {
    id = (long long )fdb->min;
  } else {
    if (id == -2LL) {
      id = (long long )(fdb->min - 1ULL);
    } else {
      if (id == -3LL) {
        id = (long long )fdb->max;
      } else {
        if (id == -4LL) {
          id = (long long )(fdb->max + 1ULL);
        }
      }
    }
  }
  if (id < 1LL) {
    goto _L___0;
  } else {
    if ((unsigned long long )id > fdb->limid) {
      _L___0: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 1285, "tcfdbputproc");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockrecord(fdb, (_Bool)1, (unsigned long long )id);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  procop.proc = proc___0;
  procop.op = op;
  procptr = & procop;
  if (vbuf) {
    if (vsiz <= (int )sizeof(stack) - (int )sizeof(procptr)) {
      rbuf = stack;
    } else {
      while (1) {
        tmp___3 = malloc((unsigned int )(vsiz + (int )sizeof(procptr)));
        rbuf = (char *)tmp___3;
        if (! rbuf) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    wp = rbuf;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& procptr), (unsigned int )((int )sizeof(procptr)));
    wp += (int )sizeof(procptr);
    memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
    vbuf = (void const   *)(rbuf + (int )sizeof(procptr));
  } else {
    rbuf = stack;
    memcpy((void * __restrict  )rbuf, (void const   * __restrict  )(& procptr), (unsigned int )((int )sizeof(procptr)));
    vbuf = (void const   *)(rbuf + (int )sizeof(procptr));
    vsiz = -1;
  }
  tmp___4 = tcfdbputimpl(fdb, id, vbuf, vsiz, 5);
  rv = tmp___4;
  if ((unsigned int )rbuf != (unsigned int )(stack)) {
    while (1) {
      free((void *)rbuf);
      break;
    }
  }
  if (fdb->mmtx) {
    tcfdbunlockrecord(fdb, (unsigned long long )id);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdbiterinit2(TCFDB *fdb , int64_t id ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1329, "tcfdbiterinit2");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  if (id == -1LL) {
    id = (long long )fdb->min;
  } else {
    if (id == -3LL) {
      id = (long long )fdb->max;
    }
  }
  if (id < 1LL) {
    goto _L;
  } else {
    if ((unsigned long long )id > fdb->limid) {
      _L: 
      tcfdbsetecode(fdb, 2, "tcfdb.c", 1339, "tcfdbiterinit2");
      if (fdb->mmtx) {
        tcfdbunlockmethod(fdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___1 = tcfdbiterjumpimpl(fdb, id);
  rv = tmp___1;
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
_Bool tcfdbiterinit3(TCFDB *fdb , void const   *kbuf , int ksiz ) 
{ int64_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = tcfdbkeytoid((char const   *)kbuf, ksiz);
  tmp___0 = tcfdbiterinit2(fdb, tmp);
  return (tmp___0);
}
}
_Bool tcfdbiterinit4(TCFDB *fdb , char const   *kstr ) 
{ size_t tmp ;
  int64_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcfdbkeytoid(kstr, (int )tmp);
  tmp___1 = tcfdbiterinit2(fdb, tmp___0);
  return (tmp___1);
}
}
_Bool tcfdbforeach(TCFDB *fdb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                              int vsiz , void *op ) , void *op ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool rv ;
  _Bool tmp___3 ;

  {
  if (fdb->mmtx) {
    tmp = tcfdblockmethod(fdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (fdb->fd < 0) {
    tcfdbsetecode(fdb, 2, "tcfdb.c", 1368, "tcfdbforeach");
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockallrecords(fdb, (_Bool)0);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    if (fdb->mmtx) {
      tcfdbunlockmethod(fdb);
    }
    return ((_Bool)0);
  }
  while (1) {
    if (fdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___3 = tcfdbforeachimpl(fdb, iter, op);
  rv = tmp___3;
  if (fdb->mmtx) {
    tcfdbunlockallrecords(fdb);
  }
  if (fdb->mmtx) {
    tcfdbunlockmethod(fdb);
  }
  return (rv);
}
}
int64_t tcfdbkeytoid(char const   *kbuf , int ksiz ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int64_t id ;
  char const   *end ;
  int c ;
  char const   *tmp___3 ;

  {
  if (ksiz == 3) {
    tmp___2 = memcmp((void const   *)kbuf, (void const   *)"min", 3U);
    if (tmp___2) {
      goto _L___1;
    } else {
      return (-1LL);
    }
  } else {
    _L___1: 
    if (ksiz == 4) {
      tmp___1 = memcmp((void const   *)kbuf, (void const   *)"prev", 4U);
      if (tmp___1) {
        goto _L___0;
      } else {
        return (-2LL);
      }
    } else {
      _L___0: 
      if (ksiz == 3) {
        tmp___0 = memcmp((void const   *)kbuf, (void const   *)"max", 3U);
        if (tmp___0) {
          goto _L;
        } else {
          return (-3LL);
        }
      } else {
        _L: 
        if (ksiz == 4) {
          tmp = memcmp((void const   *)kbuf, (void const   *)"next", 4U);
          if (! tmp) {
            return (-4LL);
          }
        }
      }
    }
  }
  id = 0LL;
  end = kbuf + ksiz;
  while ((unsigned int )kbuf < (unsigned int )end) {
    tmp___3 = kbuf;
    kbuf ++;
    c = (int )*((unsigned char *)tmp___3);
    if (c >= 48) {
      if (c <= 57) {
        id = (id * 10LL + (long long )c) - 48LL;
      }
    }
  }
  return (id);
}
}
static void tcfdbdumpmeta(TCFDB *fdb , char *hbuf ) 
{ uint64_t llnum ;

  {
  memset((void *)hbuf, 0, 256U);
  sprintf((char * __restrict  )hbuf, (char const   * __restrict  )"%s\n%s:%d\n", "ToKyO CaBiNeT",
          "1.0", 824);
  memcpy((void * __restrict  )(hbuf + 32), (void const   * __restrict  )(& fdb->type),
         (unsigned int )((int )sizeof(fdb->type)));
  memcpy((void * __restrict  )(hbuf + 33), (void const   * __restrict  )(& fdb->flags),
         (unsigned int )((int )sizeof(fdb->flags)));
  llnum = fdb->rnum;
  llnum = llnum;
  memcpy((void * __restrict  )(hbuf + 48), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  llnum = fdb->fsiz;
  llnum = llnum;
  memcpy((void * __restrict  )(hbuf + 56), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  llnum = (unsigned long long )fdb->width;
  llnum = llnum;
  memcpy((void * __restrict  )(hbuf + 64), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  llnum = fdb->limsiz;
  llnum = llnum;
  memcpy((void * __restrict  )(hbuf + 72), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  llnum = fdb->min;
  llnum = llnum;
  memcpy((void * __restrict  )(hbuf + 80), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  llnum = fdb->max;
  llnum = llnum;
  memcpy((void * __restrict  )(hbuf + 88), (void const   * __restrict  )(& llnum),
         (unsigned int )((int )sizeof(llnum)));
  return;
}
}
static void tcfdbloadmeta(TCFDB *fdb , char const   *hbuf ) 
{ uint64_t llnum ;

  {
  memcpy((void * __restrict  )(& fdb->type), (void const   * __restrict  )(hbuf + 32),
         (unsigned int )((int )sizeof(fdb->type)));
  memcpy((void * __restrict  )(& fdb->flags), (void const   * __restrict  )(hbuf + 33),
         (unsigned int )((int )sizeof(fdb->flags)));
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )(hbuf + 48),
         (unsigned int )((int )sizeof(llnum)));
  fdb->rnum = llnum;
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )(hbuf + 56),
         (unsigned int )((int )sizeof(llnum)));
  fdb->fsiz = llnum;
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )(hbuf + 64),
         (unsigned int )((int )sizeof(llnum)));
  fdb->width = (unsigned int )llnum;
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )(hbuf + 72),
         (unsigned int )((int )sizeof(llnum)));
  fdb->limsiz = llnum;
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )(hbuf + 80),
         (unsigned int )((int )sizeof(llnum)));
  fdb->min = llnum;
  memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )(hbuf + 88),
         (unsigned int )((int )sizeof(llnum)));
  fdb->max = llnum;
  return;
}
}
static void tcfdbclear(TCFDB *fdb ) 
{ 

  {
  fdb->mmtx = (void *)0;
  fdb->amtx = (void *)0;
  fdb->rmtxs = (void *)0;
  fdb->tmtx = (void *)0;
  fdb->wmtx = (void *)0;
  fdb->eckey = (void *)0;
  fdb->rpath = (char *)((void *)0);
  fdb->type = (unsigned char)2;
  fdb->flags = (unsigned char)0;
  fdb->width = 255U;
  fdb->limsiz = (unsigned long long )(256LL << 20);
  fdb->wsiz = 0;
  fdb->rsiz = 0;
  fdb->limid = 0ULL;
  fdb->path = (char *)((void *)0);
  fdb->fd = -1;
  fdb->omode = 0U;
  fdb->rnum = 0ULL;
  fdb->fsiz = 0ULL;
  fdb->min = 0ULL;
  fdb->max = 0ULL;
  fdb->iter = 0ULL;
  fdb->map = (char *)((void *)0);
  fdb->array = (unsigned char *)((void *)0);
  fdb->ecode = 0;
  fdb->fatal = (_Bool)0;
  fdb->inode = 0ULL;
  fdb->mtime = 0L;
  fdb->tran = (_Bool)0;
  fdb->walfd = -1;
  fdb->walend = 0ULL;
  fdb->dbgfd = -1;
  fdb->cnt_writerec = -1LL;
  fdb->cnt_readrec = -1LL;
  fdb->cnt_truncfile = -1LL;
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  while (1) {
    break;
  }
  return;
}
}
static void tcfdbsetflag(TCFDB *fdb , int flag , _Bool sign ) 
{ char *fp ;

  {
  fp = fdb->map + 33;
  if (sign) {
    *fp = (char )((int )*fp | (int )((unsigned char )flag));
  } else {
    *fp = (char )((int )*fp & ~ ((int )((unsigned char )flag)));
  }
  fdb->flags = (unsigned char )*fp;
  return;
}
}
static _Bool tcfdbwalinit(TCFDB *fdb ) 
{ __off_t tmp ;
  int tmp___0 ;
  uint64_t llnum ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  tmp = lseek(fdb->walfd, 0L, 0);
  if (tmp == -1L) {
    tcfdbsetecode(fdb, 12, "tcfdb.c", 1531, "tcfdbwalinit");
    return ((_Bool)0);
  }
  tmp___0 = ftruncate(fdb->walfd, 0L);
  if (tmp___0 == -1) {
    tcfdbsetecode(fdb, 9, "tcfdb.c", 1535, "tcfdbwalinit");
    return ((_Bool)0);
  }
  llnum = fdb->fsiz;
  llnum = llnum;
  tmp___1 = tcwrite(fdb->walfd, (void const   *)(& llnum), (unsigned int )((int )sizeof(llnum)));
  if (! tmp___1) {
    tcfdbsetecode(fdb, 14, "tcfdb.c", 1541, "tcfdbwalinit");
    return ((_Bool)0);
  }
  fdb->walend = fdb->fsiz;
  tmp___2 = tcfdbwalwrite(fdb, 0ULL, 256LL);
  if (! tmp___2) {
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static _Bool tcfdbwalwrite(TCFDB *fdb , uint64_t off , int64_t size ) 
{ char stack[8192] ;
  char *buf ;
  void *tmp ;
  char *wp ;
  uint64_t llnum ;
  uint32_t lnum ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  int tmp___3 ;

  {
  if (off + (unsigned long long )size > fdb->walend) {
    size = (long long )(fdb->walend - off);
  }
  if (size < 1LL) {
    return ((_Bool)1);
  }
  if ((size + (long long )((int )sizeof(off))) + (long long )((int )sizeof(size)) <= 8192LL) {
    buf = stack;
  } else {
    while (1) {
      tmp = malloc((unsigned int )((size + (long long )((int )sizeof(off))) + (long long )((int )sizeof(size))));
      buf = (char *)tmp;
      if (! buf) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  wp = buf;
  llnum = off;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
  wp += (int )sizeof(llnum);
  lnum = (unsigned int )size;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
  wp += (int )sizeof(lnum);
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(fdb->map + off), (unsigned int )size);
  wp += size;
  if (fdb->mmtx) {
    tmp___0 = tcfdblockwal(fdb);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    return ((_Bool)0);
  }
  tmp___2 = tcwrite(fdb->walfd, (void const   *)buf, (unsigned int )(wp - buf));
  if (! tmp___2) {
    tcfdbsetecode(fdb, 14, "tcfdb.c", 1577, "tcfdbwalwrite");
    if ((unsigned int )buf != (unsigned int )(stack)) {
      while (1) {
        free((void *)buf);
        break;
      }
    }
    if (fdb->mmtx) {
      tcfdbunlockwal(fdb);
    }
    return ((_Bool)0);
  }
  if ((unsigned int )buf != (unsigned int )(stack)) {
    while (1) {
      free((void *)buf);
      break;
    }
  }
  if (fdb->omode & 64U) {
    tmp___3 = fsync(fdb->walfd);
    if (tmp___3 == -1) {
      tcfdbsetecode(fdb, 10, "tcfdb.c", 1584, "tcfdbwalwrite");
      if (fdb->mmtx) {
        tcfdbunlockwal(fdb);
      }
      return ((_Bool)0);
    }
  }
  if (fdb->mmtx) {
    tcfdbunlockwal(fdb);
  }
  return ((_Bool)1);
}
}
static int tcfdbwalrestore(TCFDB *fdb , char const   *path ) 
{ char *tpath ;
  char *tmp ;
  int walfd ;
  int tmp___0 ;
  _Bool err ;
  uint64_t walsiz ;
  struct stat sbuf ;
  int tmp___1 ;
  int dbfd ;
  int tfd ;
  int ecode ;
  int *tmp___2 ;
  uint64_t fsiz ;
  _Bool tmp___3 ;
  TCLIST *list ;
  TCLIST *tmp___4 ;
  uint64_t waloff ;
  char stack[8192] ;
  uint64_t off ;
  uint32_t size ;
  _Bool tmp___5 ;
  char *buf ;
  void *tmp___6 ;
  _Bool tmp___7 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___8 ;
  void *tmp___9 ;
  TCLISTDATUM *array ;
  char *tmp___10 ;
  void *tmp___11 ;
  int i ;
  char const   *rec ;
  int size___0 ;
  uint64_t off___0 ;
  __off_t tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
  tmp = tcsprintf("%s%c%s", path, '.', "wal");
  tpath = tmp;
  tmp___0 = open((char const   *)tpath, 0, 420);
  walfd = tmp___0;
  while (1) {
    free((void *)tpath);
    break;
  }
  if (walfd < 0) {
    return (0);
  }
  err = (_Bool)0;
  walsiz = 0ULL;
  tmp___1 = fstat(walfd, & sbuf);
  if (tmp___1 == 0) {
    walsiz = (unsigned long long )sbuf.st_size;
  } else {
    tcfdbsetecode(fdb, 11, "tcfdb.c", 1609, "tcfdbwalrestore");
    err = (_Bool)1;
  }
  if (walsiz >= (unsigned long long )((int )sizeof(walsiz) + 256)) {
    dbfd = fdb->fd;
    tfd = -1;
    if (! (fdb->omode & 2U)) {
      tfd = open(path, 1, 420);
      if (tfd >= 0) {
        dbfd = tfd;
      } else {
        ecode = 7;
        tmp___2 = __errno_location();
        switch (*tmp___2) {
        case 13: 
        ecode = 4;
        break;
        case 2: 
        ecode = 3;
        break;
        case 20: 
        ecode = 3;
        break;
        }
        tcfdbsetecode(fdb, ecode, "tcfdb.c", 1626, "tcfdbwalrestore");
        err = (_Bool)1;
      }
    }
    fsiz = 0ULL;
    tmp___3 = tcread(walfd, (void *)(& fsiz), (unsigned int )((int )sizeof(fsiz)));
    if (tmp___3) {
      fsiz = fsiz;
    } else {
      tcfdbsetecode(fdb, 13, "tcfdb.c", 1634, "tcfdbwalrestore");
      err = (_Bool)1;
    }
    tmp___4 = tclistnew();
    list = tmp___4;
    waloff = (unsigned long long )((int )sizeof(fsiz));
    while (waloff < walsiz) {
      tmp___5 = tcread(walfd, (void *)(stack), (unsigned int )((int )sizeof(off) + (int )sizeof(size)));
      if (! tmp___5) {
        tcfdbsetecode(fdb, 13, "tcfdb.c", 1644, "tcfdbwalrestore");
        err = (_Bool)1;
        break;
      }
      memcpy((void * __restrict  )(& off), (void const   * __restrict  )(stack), (unsigned int )((int )sizeof(off)));
      off = off;
      memcpy((void * __restrict  )(& size), (void const   * __restrict  )(stack + (int )sizeof(off)),
             (unsigned int )((int )sizeof(size)));
      size = size;
      if ((unsigned int )((int )sizeof(off)) + size <= 8192U) {
        buf = stack;
      } else {
        while (1) {
          tmp___6 = malloc((unsigned int )((int )sizeof(off)) + size);
          buf = (char *)tmp___6;
          if (! buf) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      *((uint64_t *)buf) = off;
      tmp___7 = tcread(walfd, (void *)(buf + (int )sizeof(off)), size);
      if (! tmp___7) {
        tcfdbsetecode(fdb, 13, "tcfdb.c", 1660, "tcfdbwalrestore");
        err = (_Bool)1;
        if ((unsigned int )buf != (unsigned int )(stack)) {
          while (1) {
            free((void *)buf);
            break;
          }
        }
        break;
      }
      while (1) {
        TC_mysize = (int )((unsigned int )((int )sizeof(off)) + size);
        TC_index = list->start + list->num;
        if (TC_index >= list->anum) {
          list->anum += list->num + 1;
          while (1) {
            tmp___9 = realloc((void *)list->array, (unsigned int )(list->anum * (int )sizeof(*(list->array + 0))));
            tmp___8 = (TCLISTDATUM *)tmp___9;
            list->array = tmp___8;
            if (! tmp___8) {
              tcmyfatal("out of memory");
            }
            break;
          }
        }
        array = list->array;
        while (1) {
          tmp___11 = malloc((unsigned int )(TC_mysize + 1));
          tmp___10 = (char *)tmp___11;
          (array + TC_index)->ptr = tmp___10;
          if (! tmp___10) {
            tcmyfatal("out of memory");
          }
          break;
        }
        memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )buf,
               (unsigned int )TC_mysize);
        *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
        (array + TC_index)->size = TC_mysize;
        (list->num) ++;
        break;
      }
      if ((unsigned int )buf != (unsigned int )(stack)) {
        while (1) {
          free((void *)buf);
          break;
        }
      }
      waloff += (unsigned long long )((unsigned int )((int )sizeof(off) + (int )sizeof(size)) + size);
    }
    i = list->num - 1;
    while (i >= 0) {
      while (1) {
        rec = (char const   *)(list->array + (i + list->start))->ptr;
        size___0 = (list->array + (i + list->start))->size;
        break;
      }
      off___0 = *((uint64_t *)rec);
      rec += (int )sizeof(off___0);
      size___0 -= (int )sizeof(off___0);
      tmp___12 = lseek(dbfd, (long )off___0, 0);
      if (tmp___12 == -1L) {
        tcfdbsetecode(fdb, 12, "tcfdb.c", 1677, "tcfdbwalrestore");
        err = (_Bool)1;
        break;
      }
      tmp___13 = tcwrite(dbfd, (void const   *)rec, (unsigned int )size___0);
      if (! tmp___13) {
        tcfdbsetecode(fdb, 14, "tcfdb.c", 1682, "tcfdbwalrestore");
        err = (_Bool)1;
        break;
      }
      i --;
    }
    tclistdel(list);
    tmp___14 = ftruncate(dbfd, (long )fsiz);
    if (tmp___14 == -1) {
      tcfdbsetecode(fdb, 9, "tcfdb.c", 1689, "tcfdbwalrestore");
      err = (_Bool)1;
    }
    if (fdb->omode & 64U) {
      tmp___15 = fsync(dbfd);
      if (tmp___15 == -1) {
        tcfdbsetecode(fdb, 10, "tcfdb.c", 1693, "tcfdbwalrestore");
        err = (_Bool)1;
      }
    }
    if (tfd >= 0) {
      tmp___16 = close(tfd);
      if (tmp___16 == -1) {
        tcfdbsetecode(fdb, 8, "tcfdb.c", 1697, "tcfdbwalrestore");
        err = (_Bool)1;
      }
    }
  } else {
    err = (_Bool)1;
  }
  tmp___17 = close(walfd);
  if (tmp___17 == -1) {
    tcfdbsetecode(fdb, 8, "tcfdb.c", 1704, "tcfdbwalrestore");
    err = (_Bool)1;
  }
  return (! err);
}
}
static _Bool tcfdbwalremove(TCFDB *fdb , char const   *path ) 
{ char *tpath ;
  char *tmp ;
  _Bool err ;
  int tmp___0 ;
  int *tmp___1 ;

  {
  tmp = tcsprintf("%s%c%s", path, '.', "wal");
  tpath = tmp;
  err = (_Bool)0;
  tmp___0 = unlink((char const   *)tpath);
  if (tmp___0 == -1) {
    tmp___1 = __errno_location();
    if (*tmp___1 != 2) {
      tcfdbsetecode(fdb, 17, "tcfdb.c", 1720, "tcfdbwalremove");
      err = (_Bool)1;
    }
  }
  while (1) {
    free((void *)tpath);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcfdbopenimpl(TCFDB *fdb , char const   *path , int omode ) 
{ int mode ;
  int fd ;
  int tmp ;
  int ecode ;
  int *tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  struct stat sbuf ;
  int tmp___4 ;
  char hbuf[256] ;
  _Bool tmp___5 ;
  __off_t tmp___6 ;
  _Bool tmp___7 ;
  int type ;
  __off_t tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  int tmp___13 ;
  void *map ;
  int tmp___14 ;
  void *tmp___15 ;

  {
  mode = 0;
  if (omode & 2) {
    mode = 2;
    if (omode & 4) {
      mode |= 64;
    }
  }
  tmp = open(path, mode, 420);
  fd = tmp;
  if (fd < 0) {
    ecode = 7;
    tmp___0 = __errno_location();
    switch (*tmp___0) {
    case 13: 
    ecode = 4;
    break;
    case 2: 
    ecode = 3;
    break;
    case 20: 
    ecode = 3;
    break;
    }
    tcfdbsetecode(fdb, ecode, "tcfdb.c", 1748, "tcfdbopenimpl");
    return ((_Bool)0);
  }
  if (! (omode & 16)) {
    tmp___1 = tclock(fd, (_Bool )(omode & 2), (_Bool )(omode & 32));
    if (! tmp___1) {
      tcfdbsetecode(fdb, 16, "tcfdb.c", 1753, "tcfdbopenimpl");
      close(fd);
      return ((_Bool)0);
    }
  }
  if (omode & 2) {
    if (omode & 8) {
      tmp___2 = ftruncate(fd, 0L);
      if (tmp___2 == -1) {
        tcfdbsetecode(fdb, 9, "tcfdb.c", 1760, "tcfdbopenimpl");
        close(fd);
        return ((_Bool)0);
      }
      tmp___3 = tcfdbwalremove(fdb, path);
      if (! tmp___3) {
        close(fd);
        return ((_Bool)0);
      }
    }
  }
  tmp___4 = fstat(fd, & sbuf);
  if (tmp___4 == -1) {
    tcfdbsetecode(fdb, 11, "tcfdb.c", 1771, "tcfdbopenimpl");
    close(fd);
    return ((_Bool)0);
  } else {
    if (! ((sbuf.st_mode & 61440U) == 32768U)) {
      tcfdbsetecode(fdb, 11, "tcfdb.c", 1771, "tcfdbopenimpl");
      close(fd);
      return ((_Bool)0);
    }
  }
  if (omode & 2) {
    if (sbuf.st_size < 1L) {
      fdb->flags = (unsigned char)0;
      fdb->rnum = 0ULL;
      fdb->fsiz = 256ULL;
      fdb->min = 0ULL;
      fdb->max = 0ULL;
      tcfdbdumpmeta(fdb, hbuf);
      tmp___5 = tcwrite(fd, (void const   *)(hbuf), 256U);
      if (! tmp___5) {
        tcfdbsetecode(fdb, 14, "tcfdb.c", 1784, "tcfdbopenimpl");
        close(fd);
        return ((_Bool)0);
      }
      sbuf.st_size = (long )fdb->fsiz;
    }
  }
  tmp___6 = lseek(fd, 0L, 0);
  if (tmp___6 == -1L) {
    tcfdbsetecode(fdb, 12, "tcfdb.c", 1791, "tcfdbopenimpl");
    close(fd);
    return ((_Bool)0);
  }
  tmp___7 = tcread(fd, (void *)(hbuf), 256U);
  if (! tmp___7) {
    tcfdbsetecode(fdb, 13, "tcfdb.c", 1796, "tcfdbopenimpl");
    close(fd);
    return ((_Bool)0);
  }
  type = (int )fdb->type;
  tcfdbloadmeta(fdb, (char const   *)(hbuf));
  if ((int )fdb->flags & 1) {
    tmp___11 = tcfdbwalrestore(fdb, path);
    if (tmp___11) {
      tmp___8 = lseek(fd, 0L, 0);
      if (tmp___8 == -1L) {
        tcfdbsetecode(fdb, 12, "tcfdb.c", 1804, "tcfdbopenimpl");
        close(fd);
        return ((_Bool)0);
      }
      tmp___9 = tcread(fd, (void *)(hbuf), 256U);
      if (! tmp___9) {
        tcfdbsetecode(fdb, 13, "tcfdb.c", 1809, "tcfdbopenimpl");
        close(fd);
        return ((_Bool)0);
      }
      tcfdbloadmeta(fdb, (char const   *)(hbuf));
      tmp___10 = tcfdbwalremove(fdb, path);
      if (! tmp___10) {
        close(fd);
        return ((_Bool)0);
      }
    }
  }
  if (! (omode & 16)) {
    tmp___12 = strlen("ToKyO CaBiNeT");
    tmp___13 = memcmp((void const   *)(hbuf), (void const   *)"ToKyO CaBiNeT", tmp___12);
    if (tmp___13) {
      tcfdbsetecode(fdb, 5, "tcfdb.c", 1823, "tcfdbopenimpl");
      close(fd);
      return ((_Bool)0);
    } else {
      if ((int )fdb->type != type) {
        tcfdbsetecode(fdb, 5, "tcfdb.c", 1823, "tcfdbopenimpl");
        close(fd);
        return ((_Bool)0);
      } else {
        if (fdb->width < 1U) {
          tcfdbsetecode(fdb, 5, "tcfdb.c", 1823, "tcfdbopenimpl");
          close(fd);
          return ((_Bool)0);
        } else {
          if ((unsigned long long )sbuf.st_size < fdb->fsiz) {
            tcfdbsetecode(fdb, 5, "tcfdb.c", 1823, "tcfdbopenimpl");
            close(fd);
            return ((_Bool)0);
          } else {
            if (fdb->limsiz < 256ULL) {
              tcfdbsetecode(fdb, 5, "tcfdb.c", 1823, "tcfdbopenimpl");
              close(fd);
              return ((_Bool)0);
            } else {
              if (fdb->fsiz > fdb->limsiz) {
                tcfdbsetecode(fdb, 5, "tcfdb.c", 1823, "tcfdbopenimpl");
                close(fd);
                return ((_Bool)0);
              }
            }
          }
        }
      }
    }
    if ((unsigned long long )sbuf.st_size > fdb->fsiz) {
      fdb->fsiz = (unsigned long long )sbuf.st_size;
    }
  }
  if (omode & 2) {
    tmp___14 = 2;
  } else {
    tmp___14 = 0;
  }
  tmp___15 = mmap((void *)0, (unsigned int )fdb->limsiz, 1 | tmp___14, 1, fd, 0L);
  map = tmp___15;
  if ((unsigned int )map == (unsigned int )((void *)-1)) {
    tcfdbsetecode(fdb, 15, "tcfdb.c", 1832, "tcfdbopenimpl");
    close(fd);
    return ((_Bool)0);
  }
  if (fdb->width <= 255U) {
    fdb->wsiz = (int )sizeof(uint8_t );
  } else {
    if (fdb->width <= 65535U) {
      fdb->wsiz = (int )sizeof(uint16_t );
    } else {
      fdb->wsiz = (int )sizeof(uint32_t );
    }
  }
  fdb->rsiz = (int )(fdb->width + (unsigned int )fdb->wsiz);
  fdb->limid = (fdb->limsiz - 256ULL) / (unsigned long long )fdb->rsiz;
  fdb->path = tcstrdup((void const   *)path);
  fdb->fd = fd;
  fdb->omode = (unsigned int )omode;
  fdb->iter = 0ULL;
  fdb->map = (char *)map;
  fdb->array = (unsigned char *)map + 256;
  fdb->ecode = 0;
  fdb->fatal = (_Bool)0;
  fdb->inode = (unsigned long long )sbuf.st_ino;
  fdb->mtime = sbuf.st_mtim.tv_sec;
  fdb->tran = (_Bool)0;
  fdb->walfd = -1;
  fdb->walend = 0ULL;
  if (fdb->omode & 2U) {
    tcfdbsetflag(fdb, 1, (_Bool)1);
  }
  return ((_Bool)1);
}
}
static _Bool tcfdbcloseimpl(TCFDB *fdb ) 
{ _Bool err ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;

  {
  err = (_Bool)0;
  if (fdb->omode & 2U) {
    tcfdbsetflag(fdb, 1, (_Bool)0);
  }
  if (fdb->omode & 2U) {
    tmp = tcfdbmemsync(fdb, (_Bool)0);
    if (! tmp) {
      err = (_Bool)1;
    }
  }
  tmp___0 = munmap((void *)fdb->map, (unsigned int )fdb->limsiz);
  if (tmp___0 == -1) {
    tcfdbsetecode(fdb, 15, "tcfdb.c", 1872, "tcfdbcloseimpl");
    err = (_Bool)1;
  }
  if (fdb->tran) {
    tmp___1 = tcfdbwalrestore(fdb, (char const   *)fdb->path);
    if (! tmp___1) {
      err = (_Bool)1;
    }
    fdb->tran = (_Bool)0;
  }
  if (fdb->walfd >= 0) {
    tmp___2 = close(fdb->walfd);
    if (tmp___2 == -1) {
      tcfdbsetecode(fdb, 8, "tcfdb.c", 1881, "tcfdbcloseimpl");
      err = (_Bool)1;
    }
    if (! fdb->fatal) {
      tmp___3 = tcfdbwalremove(fdb, (char const   *)fdb->path);
      if (! tmp___3) {
        err = (_Bool)1;
      }
    }
  }
  tmp___4 = close(fdb->fd);
  if (tmp___4 == -1) {
    tcfdbsetecode(fdb, 8, "tcfdb.c", 1887, "tcfdbcloseimpl");
    err = (_Bool)1;
  }
  while (1) {
    free((void *)fdb->path);
    break;
  }
  fdb->path = (char *)((void *)0);
  fdb->fd = -1;
  return ((_Bool )(! err));
}
}
static int64_t tcfdbprevid(TCFDB *fdb , int64_t id ) 
{ unsigned char *rec ;
  unsigned char *rp ;
  uint32_t osiz ;
  uint16_t snum ;
  uint32_t lnum ;
  unsigned char *tmp ;

  {
  id --;
  while ((unsigned long long )id >= fdb->min) {
    while (1) {
      break;
    }
    rec = fdb->array + (id - 1LL) * (long long )fdb->rsiz;
    rp = rec;
    switch (fdb->wsiz) {
    case 1: 
    tmp = rp;
    rp ++;
    osiz = (unsigned int )*tmp;
    break;
    case 2: 
    memcpy((void * __restrict  )(& snum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(snum)));
    osiz = (unsigned int )snum;
    rp += (int )sizeof(snum);
    break;
    default: 
    memcpy((void * __restrict  )(& lnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(lnum)));
    osiz = lnum;
    rp += (int )sizeof(lnum);
    break;
    }
    if (osiz > 0U) {
      return (id);
    } else {
      if ((int )*rp != 0) {
        return (id);
      }
    }
    id --;
  }
  return (0LL);
}
}
static int64_t tcfdbnextid(TCFDB *fdb , int64_t id ) 
{ unsigned char *rec ;
  unsigned char *rp ;
  uint32_t osiz ;
  uint16_t snum ;
  uint32_t lnum ;
  unsigned char *tmp ;

  {
  id ++;
  while ((unsigned long long )id <= fdb->max) {
    while (1) {
      break;
    }
    rec = fdb->array + (id - 1LL) * (long long )fdb->rsiz;
    rp = rec;
    switch (fdb->wsiz) {
    case 1: 
    tmp = rp;
    rp ++;
    osiz = (unsigned int )*tmp;
    break;
    case 2: 
    memcpy((void * __restrict  )(& snum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(snum)));
    osiz = (unsigned int )snum;
    rp += (int )sizeof(snum);
    break;
    default: 
    memcpy((void * __restrict  )(& lnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(lnum)));
    osiz = lnum;
    rp += (int )sizeof(lnum);
    break;
    }
    if (osiz > 0U) {
      return (id);
    } else {
      if ((int )*rp != 0) {
        return (id);
      }
    }
    id ++;
  }
  return (0LL);
}
}
static _Bool tcfdbputimpl(TCFDB *fdb , int64_t id , void const   *vbuf , int vsiz ,
                          int dmode ) 
{ unsigned char *rec ;
  uint64_t nsiz ;
  _Bool tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char *wp ;
  uint16_t snum ;
  uint32_t lnum ;
  unsigned char *tmp___2 ;
  unsigned char *rp ;
  uint32_t osiz ;
  uint16_t snum___0 ;
  uint32_t lnum___0 ;
  unsigned char *tmp___3 ;
  _Bool miss ;
  int tmp___4 ;
  _Bool tmp___5 ;
  long tmp___6 ;
  unsigned char *wp___0 ;
  int usiz ;
  unsigned char *tmp___7 ;
  int lnum___1 ;
  _Bool tmp___8 ;
  double dnum ;
  _Bool tmp___9 ;
  FDBPDPROCOP *procptr ;
  int nvsiz ;
  char *nvbuf ;
  void *tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;
  int64_t tmp___14 ;
  int64_t tmp___15 ;
  _Bool tmp___16 ;
  unsigned char *wp___1 ;
  unsigned char *tmp___17 ;
  _Bool tmp___18 ;
  unsigned char *wp___2 ;
  unsigned char *tmp___19 ;
  _Bool tmp___20 ;
  int tmp___21 ;

  {
  if ((long long )vsiz > (long long )fdb->width) {
    vsiz = (int )fdb->width;
  }
  while (1) {
    break;
  }
  rec = fdb->array + (id - 1LL) * (long long )fdb->rsiz;
  nsiz = (unsigned long long )(256LL + id * (long long )fdb->rsiz);
  if (nsiz > fdb->fsiz) {
    if (nsiz > fdb->limsiz) {
      tcfdbsetecode(fdb, 2, "tcfdb.c", 1984, "tcfdbputimpl");
      return ((_Bool)0);
    }
    if (fdb->mmtx) {
      tmp = tcfdblockattr(fdb);
      tmp___0 = (int )tmp;
    } else {
      tmp___0 = 1;
    }
    if (! tmp___0) {
      return ((_Bool)0);
    }
    if (nsiz > fdb->fsiz) {
      if (vsiz < 0) {
        tcfdbsetecode(fdb, 22, "tcfdb.c", 1990, "tcfdbputimpl");
        if (fdb->mmtx) {
          tcfdbunlockattr(fdb);
        }
        return ((_Bool)0);
      }
      if (nsiz + (unsigned long long )(fdb->rsiz * 256) < fdb->limsiz) {
        nsiz += (unsigned long long )(fdb->rsiz * 256);
      }
      tmp___1 = ftruncate(fdb->fd, (long )nsiz);
      if (tmp___1 == -1) {
        tcfdbsetecode(fdb, 9, "tcfdb.c", 1996, "tcfdbputimpl");
        if (fdb->mmtx) {
          tcfdbunlockattr(fdb);
        }
        return ((_Bool)0);
      }
      while (1) {
        break;
      }
      fdb->fsiz = nsiz;
      wp = rec;
      switch (fdb->wsiz) {
      case 1: 
      tmp___2 = wp;
      wp ++;
      *tmp___2 = (unsigned char )vsiz;
      break;
      case 2: 
      snum = (unsigned short )vsiz;
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& snum), (unsigned int )((int )sizeof(snum)));
      wp += (int )sizeof(snum);
      break;
      default: 
      lnum = (unsigned int )vsiz;
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
      wp += (int )sizeof(lnum);
      break;
      }
      if (vsiz > 0) {
        memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      } else {
        *wp = (unsigned char)1;
      }
      while (1) {
        break;
      }
      (fdb->rnum) ++;
      if (fdb->min < 1ULL) {
        fdb->min = (unsigned long long )id;
      } else {
        if ((unsigned long long )id < fdb->min) {
          fdb->min = (unsigned long long )id;
        }
      }
      if (fdb->max < 1ULL) {
        fdb->max = (unsigned long long )id;
      } else {
        if ((unsigned long long )id > fdb->max) {
          fdb->max = (unsigned long long )id;
        }
      }
      if (fdb->mmtx) {
        tcfdbunlockattr(fdb);
      }
      return ((_Bool)1);
    }
    if (fdb->mmtx) {
      tcfdbunlockattr(fdb);
    }
  }
  rp = rec;
  switch (fdb->wsiz) {
  case 1: 
  tmp___3 = rp;
  rp ++;
  osiz = (unsigned int )*tmp___3;
  break;
  case 2: 
  memcpy((void * __restrict  )(& snum___0), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(snum___0)));
  osiz = (unsigned int )snum___0;
  rp += (int )sizeof(snum___0);
  break;
  default: 
  memcpy((void * __restrict  )(& lnum___0), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(lnum___0)));
  osiz = lnum___0;
  rp += (int )sizeof(lnum___0);
  break;
  }
  if (osiz == 0U) {
    if ((int )*rp == 0) {
      tmp___4 = 1;
    } else {
      tmp___4 = 0;
    }
  } else {
    tmp___4 = 0;
  }
  miss = (_Bool )tmp___4;
  if (dmode != 0) {
    if (! miss) {
      if (dmode == 1) {
        tcfdbsetecode(fdb, 21, "tcfdb.c", 2056, "tcfdbputimpl");
        return ((_Bool)0);
      }
      if (dmode == 2) {
        if (fdb->tran) {
          tmp___5 = tcfdbwalwrite(fdb, (unsigned long long )((char *)rec - fdb->map),
                                  (long long )fdb->width);
          if (! tmp___5) {
            return ((_Bool)0);
          }
        }
        tmp___6 = tclmin((long )vsiz, (long )(fdb->width - osiz));
        vsiz = (int )tmp___6;
        wp___0 = rec;
        usiz = (int )(osiz + (unsigned int )vsiz);
        switch (fdb->wsiz) {
        case 1: 
        tmp___7 = wp___0;
        wp___0 ++;
        *tmp___7 = (unsigned char )usiz;
        break;
        case 2: 
        snum___0 = (unsigned short )usiz;
        memcpy((void * __restrict  )wp___0, (void const   * __restrict  )(& snum___0),
               (unsigned int )((int )sizeof(snum___0)));
        wp___0 += (int )sizeof(snum___0);
        break;
        default: 
        lnum___0 = (unsigned int )usiz;
        memcpy((void * __restrict  )wp___0, (void const   * __restrict  )(& lnum___0),
               (unsigned int )((int )sizeof(lnum___0)));
        wp___0 += (int )sizeof(lnum___0);
        break;
        }
        if (usiz > 0) {
          memcpy((void * __restrict  )(wp___0 + osiz), (void const   * __restrict  )vbuf,
                 (unsigned int )vsiz);
        } else {
          *wp___0 = (unsigned char)1;
        }
        while (1) {
          break;
        }
        return ((_Bool)1);
      }
      if (dmode == 3) {
        if (osiz != (unsigned int )((int )sizeof(int ))) {
          tcfdbsetecode(fdb, 21, "tcfdb.c", 2089, "tcfdbputimpl");
          return ((_Bool)0);
        }
        memcpy((void * __restrict  )(& lnum___1), (void const   * __restrict  )rp,
               (unsigned int )((int )sizeof(lnum___1)));
        if (*((int *)vbuf) == 0) {
          *((int *)vbuf) = lnum___1;
          return ((_Bool)1);
        }
        if (fdb->tran) {
          tmp___8 = tcfdbwalwrite(fdb, (unsigned long long )((char *)rec - fdb->map),
                                  (long long )fdb->width);
          if (! tmp___8) {
            return ((_Bool)0);
          }
        }
        lnum___1 += *((int *)vbuf);
        *((int *)vbuf) = lnum___1;
        memcpy((void * __restrict  )rp, (void const   * __restrict  )(& lnum___1),
               (unsigned int )((int )sizeof(lnum___1)));
        while (1) {
          break;
        }
        return ((_Bool)1);
      }
      if (dmode == 4) {
        if (osiz != (unsigned int )((int )sizeof(double ))) {
          tcfdbsetecode(fdb, 21, "tcfdb.c", 2107, "tcfdbputimpl");
          return ((_Bool)0);
        }
        memcpy((void * __restrict  )(& dnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(dnum)));
        if (*((double *)vbuf) == 0.0) {
          *((double *)vbuf) = dnum;
          return ((_Bool)1);
        }
        if (fdb->tran) {
          tmp___9 = tcfdbwalwrite(fdb, (unsigned long long )((char *)rec - fdb->map),
                                  (long long )fdb->width);
          if (! tmp___9) {
            return ((_Bool)0);
          }
        }
        dnum += *((double *)vbuf);
        *((double *)vbuf) = dnum;
        memcpy((void * __restrict  )rp, (void const   * __restrict  )(& dnum), (unsigned int )((int )sizeof(dnum)));
        while (1) {
          break;
        }
        return ((_Bool)1);
      }
      if (dmode == 5) {
        procptr = *((FDBPDPROCOP **)((char *)vbuf - (int )sizeof(procptr)));
        tmp___10 = (*(procptr->proc))((void const   *)rp, (int )osiz, & nvsiz, procptr->op);
        nvbuf = (char *)tmp___10;
        if ((unsigned int )nvbuf == (unsigned int )((void *)-1)) {
          if (fdb->tran) {
            tmp___11 = tcfdbwalwrite(fdb, (unsigned long long )((char *)rec - fdb->map),
                                     (long long )fdb->width);
            if (! tmp___11) {
              return ((_Bool)0);
            }
          }
          memset((void *)rec, 0, (unsigned int )(fdb->wsiz + 1));
          while (1) {
            break;
          }
          if (fdb->mmtx) {
            tmp___12 = tcfdblockattr(fdb);
            tmp___13 = (int )tmp___12;
          } else {
            tmp___13 = 1;
          }
          if (! tmp___13) {
            return ((_Bool)0);
          }
          (fdb->rnum) --;
          if (fdb->rnum < 1ULL) {
            fdb->min = 0ULL;
            fdb->max = 0ULL;
          } else {
            if (fdb->rnum < 2ULL) {
              if (fdb->min == (unsigned long long )id) {
                fdb->min = fdb->max;
              } else {
                if (fdb->max == (unsigned long long )id) {
                  fdb->max = fdb->min;
                }
              }
            } else {
              if ((unsigned long long )id == fdb->min) {
                tmp___14 = tcfdbnextid(fdb, id);
                fdb->min = (unsigned long long )tmp___14;
              }
              if ((unsigned long long )id == fdb->max) {
                tmp___15 = tcfdbprevid(fdb, id);
                fdb->max = (unsigned long long )tmp___15;
              }
            }
          }
          if (fdb->mmtx) {
            tcfdbunlockattr(fdb);
          }
          return ((_Bool)1);
        }
        if (! nvbuf) {
          tcfdbsetecode(fdb, 21, "tcfdb.c", 2150, "tcfdbputimpl");
          return ((_Bool)0);
        }
        if (fdb->tran) {
          tmp___16 = tcfdbwalwrite(fdb, (unsigned long long )((char *)rec - fdb->map),
                                   (long long )fdb->width);
          if (! tmp___16) {
            return ((_Bool)0);
          }
        }
        if ((unsigned int )nvsiz > fdb->width) {
          nvsiz = (int )fdb->width;
        }
        wp___1 = rec;
        switch (fdb->wsiz) {
        case 1: 
        tmp___17 = wp___1;
        wp___1 ++;
        *tmp___17 = (unsigned char )nvsiz;
        break;
        case 2: 
        snum___0 = (unsigned short )nvsiz;
        memcpy((void * __restrict  )wp___1, (void const   * __restrict  )(& snum___0),
               (unsigned int )((int )sizeof(snum___0)));
        wp___1 += (int )sizeof(snum___0);
        break;
        default: 
        lnum___0 = (unsigned int )nvsiz;
        memcpy((void * __restrict  )wp___1, (void const   * __restrict  )(& lnum___0),
               (unsigned int )((int )sizeof(lnum___0)));
        wp___1 += (int )sizeof(lnum___0);
        break;
        }
        if (nvsiz > 0) {
          memcpy((void * __restrict  )wp___1, (void const   * __restrict  )nvbuf,
                 (unsigned int )nvsiz);
        } else {
          *wp___1 = (unsigned char)1;
        }
        while (1) {
          free((void *)nvbuf);
          break;
        }
        while (1) {
          break;
        }
        return ((_Bool)1);
      }
    }
  }
  if (vsiz < 0) {
    tcfdbsetecode(fdb, 22, "tcfdb.c", 2182, "tcfdbputimpl");
    return ((_Bool)0);
  }
  if (fdb->tran) {
    tmp___18 = tcfdbwalwrite(fdb, (unsigned long long )((char *)rec - fdb->map), (long long )fdb->width);
    if (! tmp___18) {
      return ((_Bool)0);
    }
  }
  wp___2 = rec;
  switch (fdb->wsiz) {
  case 1: 
  tmp___19 = wp___2;
  wp___2 ++;
  *tmp___19 = (unsigned char )vsiz;
  break;
  case 2: 
  snum___0 = (unsigned short )vsiz;
  memcpy((void * __restrict  )wp___2, (void const   * __restrict  )(& snum___0), (unsigned int )((int )sizeof(snum___0)));
  wp___2 += (int )sizeof(snum___0);
  break;
  default: 
  lnum___0 = (unsigned int )vsiz;
  memcpy((void * __restrict  )wp___2, (void const   * __restrict  )(& lnum___0), (unsigned int )((int )sizeof(lnum___0)));
  wp___2 += (int )sizeof(lnum___0);
  break;
  }
  if (vsiz > 0) {
    memcpy((void * __restrict  )wp___2, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
  } else {
    *wp___2 = (unsigned char)1;
  }
  while (1) {
    break;
  }
  if (miss) {
    if (fdb->mmtx) {
      tmp___20 = tcfdblockattr(fdb);
      tmp___21 = (int )tmp___20;
    } else {
      tmp___21 = 1;
    }
    if (! tmp___21) {
      return ((_Bool)0);
    }
    (fdb->rnum) ++;
    if (fdb->min < 1ULL) {
      fdb->min = (unsigned long long )id;
    } else {
      if ((unsigned long long )id < fdb->min) {
        fdb->min = (unsigned long long )id;
      }
    }
    if (fdb->max < 1ULL) {
      fdb->max = (unsigned long long )id;
    } else {
      if ((unsigned long long )id > fdb->max) {
        fdb->max = (unsigned long long )id;
      }
    }
    if (fdb->mmtx) {
      tcfdbunlockattr(fdb);
    }
  }
  return ((_Bool)1);
}
}
static _Bool tcfdboutimpl(TCFDB *fdb , int64_t id ) 
{ unsigned char *rec ;
  uint64_t nsiz ;
  unsigned char *rp ;
  uint32_t osiz ;
  uint16_t snum ;
  uint32_t lnum ;
  unsigned char *tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  int64_t tmp___3 ;
  int64_t tmp___4 ;

  {
  while (1) {
    break;
  }
  rec = fdb->array + (id - 1LL) * (long long )fdb->rsiz;
  nsiz = (unsigned long long )(256LL + id * (long long )fdb->rsiz);
  if (nsiz > fdb->fsiz) {
    tcfdbsetecode(fdb, 22, "tcfdb.c", 2229, "tcfdboutimpl");
    return ((_Bool)0);
  }
  rp = rec;
  switch (fdb->wsiz) {
  case 1: 
  tmp = rp;
  rp ++;
  osiz = (unsigned int )*tmp;
  break;
  case 2: 
  memcpy((void * __restrict  )(& snum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(snum)));
  osiz = (unsigned int )snum;
  rp += (int )sizeof(snum);
  break;
  default: 
  memcpy((void * __restrict  )(& lnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(lnum)));
  osiz = lnum;
  rp += (int )sizeof(lnum);
  break;
  }
  if (osiz == 0U) {
    if ((int )*rp == 0) {
      tcfdbsetecode(fdb, 22, "tcfdb.c", 2252, "tcfdboutimpl");
      return ((_Bool)0);
    }
  }
  if (fdb->tran) {
    tmp___0 = tcfdbwalwrite(fdb, (unsigned long long )((char *)rec - fdb->map), (long long )fdb->width);
    if (! tmp___0) {
      return ((_Bool)0);
    }
  }
  memset((void *)rec, 0, (unsigned int )(fdb->wsiz + 1));
  while (1) {
    break;
  }
  if (fdb->mmtx) {
    tmp___1 = tcfdblockattr(fdb);
    tmp___2 = (int )tmp___1;
  } else {
    tmp___2 = 1;
  }
  if (! tmp___2) {
    return ((_Bool)0);
  }
  (fdb->rnum) --;
  if (fdb->rnum < 1ULL) {
    fdb->min = 0ULL;
    fdb->max = 0ULL;
  } else {
    if (fdb->rnum < 2ULL) {
      if (fdb->min == (unsigned long long )id) {
        fdb->min = fdb->max;
      } else {
        if (fdb->max == (unsigned long long )id) {
          fdb->max = fdb->min;
        }
      }
    } else {
      if ((unsigned long long )id == fdb->min) {
        tmp___3 = tcfdbnextid(fdb, id);
        fdb->min = (unsigned long long )tmp___3;
      }
      if ((unsigned long long )id == fdb->max) {
        tmp___4 = tcfdbprevid(fdb, id);
        fdb->max = (unsigned long long )tmp___4;
      }
    }
  }
  if (fdb->mmtx) {
    tcfdbunlockattr(fdb);
  }
  return ((_Bool)1);
}
}
static void const   *tcfdbgetimpl(TCFDB *fdb , int64_t id , int *sp ) 
{ unsigned char *rec ;
  uint64_t nsiz ;
  unsigned char *rp ;
  uint32_t osiz ;
  uint16_t snum ;
  uint32_t lnum ;
  unsigned char *tmp ;

  {
  while (1) {
    break;
  }
  rec = fdb->array + (id - 1LL) * (long long )fdb->rsiz;
  nsiz = (unsigned long long )(256LL + id * (long long )fdb->rsiz);
  if (nsiz > fdb->fsiz) {
    tcfdbsetecode(fdb, 22, "tcfdb.c", 2291, "tcfdbgetimpl");
    return ((void const   *)0);
  }
  rp = rec;
  switch (fdb->wsiz) {
  case 1: 
  tmp = rp;
  rp ++;
  osiz = (unsigned int )*tmp;
  break;
  case 2: 
  memcpy((void * __restrict  )(& snum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(snum)));
  osiz = (unsigned int )snum;
  rp += (int )sizeof(snum);
  break;
  default: 
  memcpy((void * __restrict  )(& lnum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(lnum)));
  osiz = lnum;
  rp += (int )sizeof(lnum);
  break;
  }
  if (osiz == 0U) {
    if ((int )*rp == 0) {
      tcfdbsetecode(fdb, 22, "tcfdb.c", 2314, "tcfdbgetimpl");
      return ((void const   *)0);
    }
  }
  *sp = (int )osiz;
  return ((void const   *)rp);
}
}
static _Bool tcfdbiterinitimpl(TCFDB *fdb ) 
{ 

  {
  fdb->iter = fdb->min;
  return ((_Bool)1);
}
}
static uint64_t tcfdbiternextimpl(TCFDB *fdb ) 
{ uint64_t cur ;
  int64_t tmp ;

  {
  if (fdb->iter < 1ULL) {
    tcfdbsetecode(fdb, 22, "tcfdb.c", 2338, "tcfdbiternextimpl");
    return (0ULL);
  }
  cur = fdb->iter;
  tmp = tcfdbnextid(fdb, (long long )fdb->iter);
  fdb->iter = (unsigned long long )tmp;
  return (cur);
}
}
static uint64_t *tcfdbrangeimpl(TCFDB *fdb , int64_t lower , int64_t upper , int max ,
                                int *np ) 
{ int anum ;
  uint64_t *ids ;
  void *tmp ;
  int num ;
  int64_t i ;
  int vsiz ;
  void const   *vbuf ;
  void const   *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  if ((unsigned long long )lower < fdb->min) {
    lower = (long long )fdb->min;
  }
  if ((unsigned long long )upper > fdb->max) {
    upper = (long long )fdb->max;
  }
  if (max < 0) {
    max = 2147483647;
  }
  anum = 2048;
  while (1) {
    tmp = malloc((unsigned int )(anum * (int )sizeof(*ids)));
    ids = (uint64_t *)tmp;
    if (! ids) {
      tcmyfatal("out of memory");
    }
    break;
  }
  num = 0;
  i = lower;
  while (1) {
    if (i <= upper) {
      if (! (num < max)) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = tcfdbgetimpl(fdb, i, & vsiz);
    vbuf = tmp___0;
    if (vbuf) {
      if (num >= anum) {
        anum *= 2;
        while (1) {
          tmp___1 = realloc((void *)ids, (unsigned int )(anum * (int )sizeof(*ids)));
          ids = (uint64_t *)tmp___1;
          if (! ids) {
            tcmyfatal("out of memory");
          }
          break;
        }
      }
      tmp___2 = num;
      num ++;
      *(ids + tmp___2) = (unsigned long long )i;
    }
    i ++;
  }
  *np = num;
  return (ids);
}
}
static _Bool tcfdboptimizeimpl(TCFDB *fdb , int32_t width , int64_t limsiz ) 
{ char *tpath ;
  char *tmp ;
  TCFDB *tfdb ;
  TCFDB *tmp___0 ;
  _Bool tmp___1 ;
  _Bool err ;
  int64_t max ;
  int i ;
  int vsiz ;
  void const   *vbuf ;
  void const   *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int omode ;
  _Bool tmp___7 ;
  _Bool rv ;
  _Bool tmp___8 ;

  {
  tmp = tcsprintf("%s%ctmp%c%llu", fdb->path, '.', '.', fdb->inode);
  tpath = tmp;
  tmp___0 = tcfdbnew();
  tfdb = tmp___0;
  tfdb->dbgfd = fdb->dbgfd;
  if (width < 1) {
    width = (int )fdb->width;
  }
  if (limsiz < 1LL) {
    limsiz = (long long )fdb->limsiz;
  }
  tcfdbtune(tfdb, width, limsiz);
  tmp___1 = tcfdbopen(tfdb, (char const   *)tpath, 14);
  if (! tmp___1) {
    tcfdbsetecode(fdb, tfdb->ecode, "tcfdb.c", 2395, "tcfdboptimizeimpl");
    tcfdbdel(tfdb);
    while (1) {
      free((void *)tpath);
      break;
    }
    return ((_Bool)0);
  }
  err = (_Bool)0;
  max = (long long )fdb->max;
  i = (int )fdb->min;
  while (1) {
    if (! err) {
      if (! ((long long )i <= max)) {
        break;
      }
    } else {
      break;
    }
    tmp___2 = tcfdbgetimpl(fdb, (long long )i, & vsiz);
    vbuf = tmp___2;
    if (vbuf) {
      tmp___3 = tcfdbput(tfdb, (long long )i, vbuf, vsiz);
      if (! tmp___3) {
        tcfdbsetecode(fdb, tfdb->ecode, "tcfdb.c", 2406, "tcfdboptimizeimpl");
        err = (_Bool)1;
      }
    }
    i ++;
  }
  tmp___4 = tcfdbclose(tfdb);
  if (! tmp___4) {
    tcfdbsetecode(fdb, tfdb->ecode, "tcfdb.c", 2411, "tcfdboptimizeimpl");
    err = (_Bool)1;
  }
  tcfdbdel(tfdb);
  tmp___5 = unlink((char const   *)fdb->path);
  if (tmp___5 == -1) {
    tcfdbsetecode(fdb, 17, "tcfdb.c", 2416, "tcfdboptimizeimpl");
    err = (_Bool)1;
  }
  tmp___6 = rename((char const   *)tpath, (char const   *)fdb->path);
  if (tmp___6 == -1) {
    tcfdbsetecode(fdb, 18, "tcfdb.c", 2420, "tcfdboptimizeimpl");
    err = (_Bool)1;
  }
  while (1) {
    free((void *)tpath);
    break;
  }
  if (err) {
    return ((_Bool)0);
  }
  tpath = tcstrdup((void const   *)fdb->path);
  omode = (int )((fdb->omode & 4294967291U) & 4294967287U);
  tmp___7 = tcfdbcloseimpl(fdb);
  if (! tmp___7) {
    while (1) {
      free((void *)tpath);
      break;
    }
    return ((_Bool)0);
  }
  tmp___8 = tcfdbopenimpl(fdb, (char const   *)tpath, omode);
  rv = tmp___8;
  while (1) {
    free((void *)tpath);
    break;
  }
  return (rv);
}
}
static _Bool tcfdbvanishimpl(TCFDB *fdb ) 
{ char *path ;
  char *tmp ;
  int omode ;
  _Bool err ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = tcstrdup((void const   *)fdb->path);
  path = tmp;
  omode = (int )fdb->omode;
  err = (_Bool)0;
  tmp___0 = tcfdbcloseimpl(fdb);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  tmp___1 = tcfdbopenimpl(fdb, (char const   *)path, 8 | omode);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  while (1) {
    free((void *)path);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcfdbcopyimpl(TCFDB *fdb , char const   *path ) 
{ _Bool err ;
  _Bool tmp ;
  char tsbuf[32] ;
  double tmp___0 ;
  char const   *args[3] ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  err = (_Bool)0;
  if (fdb->omode & 2U) {
    tmp = tcfdbmemsync(fdb, (_Bool)0);
    if (! tmp) {
      err = (_Bool)1;
    }
    tcfdbsetflag(fdb, 1, (_Bool)0);
  }
  if ((int const   )*path == 64) {
    tmp___0 = tctime();
    sprintf((char * __restrict  )(tsbuf), (char const   * __restrict  )"%llu", (unsigned long long )(tmp___0 * (double )1000000));
    args[0] = path + 1;
    args[1] = (char const   *)fdb->path;
    args[2] = (char const   *)(tsbuf);
    tmp___1 = tcsystem(args, (int )sizeof(args) / (int )sizeof(args[0]));
    if (tmp___1 != 0) {
      err = (_Bool)1;
    }
  } else {
    tmp___2 = tccopyfile((char const   *)fdb->path, path);
    if (! tmp___2) {
      tcfdbsetecode(fdb, 9999, "tcfdb.c", 2473, "tcfdbcopyimpl");
      err = (_Bool)1;
    }
  }
  if (fdb->omode & 2U) {
    tcfdbsetflag(fdb, 1, (_Bool)1);
  }
  return ((_Bool )(! err));
}
}
static _Bool tcfdbiterjumpimpl(TCFDB *fdb , int64_t id ) 
{ int vsiz ;
  uint64_t iter ;
  int64_t tmp ;
  void const   *tmp___0 ;

  {
  if ((unsigned long long )id <= fdb->min) {
    fdb->iter = fdb->min;
  } else {
    tmp___0 = tcfdbgetimpl(fdb, id, & vsiz);
    if (tmp___0) {
      fdb->iter = (unsigned long long )id;
    } else {
      tmp = tcfdbnextid(fdb, id);
      iter = (unsigned long long )tmp;
      if (iter > 0ULL) {
        fdb->iter = iter;
      } else {
        return ((_Bool)0);
      }
    }
  }
  return ((_Bool)1);
}
}
static _Bool tcfdbforeachimpl(TCFDB *fdb , _Bool (*iter)(void const   *kbuf , int ksiz ,
                                                         void const   *vbuf , int vsiz ,
                                                         void *op ) , void *op ) 
{ _Bool err ;
  uint64_t id ;
  int vsiz ;
  void const   *vbuf ;
  void const   *tmp ;
  char kbuf[32] ;
  int ksiz ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int64_t tmp___2 ;

  {
  err = (_Bool)0;
  id = fdb->min;
  while (id > 0ULL) {
    tmp = tcfdbgetimpl(fdb, (long long )id, & vsiz);
    vbuf = tmp;
    if (vbuf) {
      tmp___0 = sprintf((char * __restrict  )(kbuf), (char const   * __restrict  )"%llu",
                        id);
      ksiz = tmp___0;
      tmp___1 = (*iter)((void const   *)(kbuf), ksiz, vbuf, vsiz, op);
      if (! tmp___1) {
        break;
      }
    } else {
      tcfdbsetecode(fdb, 9999, "tcfdb.c", 2523, "tcfdbforeachimpl");
      err = (_Bool)1;
    }
    tmp___2 = tcfdbnextid(fdb, (long long )id);
    id = (unsigned long long )tmp___2;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcfdblockmethod(TCFDB *fdb , _Bool wr ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (wr) {
    tmp = pthread_rwlock_wrlock((pthread_rwlock_t *)fdb->mmtx);
    tmp___1 = tmp != 0;
  } else {
    tmp___0 = pthread_rwlock_rdlock((pthread_rwlock_t *)fdb->mmtx);
    tmp___1 = tmp___0 != 0;
  }
  if (tmp___1) {
    tcfdbsetecode(fdb, 1, "tcfdb.c", 2539, "tcfdblockmethod");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcfdbunlockmethod(TCFDB *fdb ) 
{ int tmp ;

  {
  tmp = pthread_rwlock_unlock((pthread_rwlock_t *)fdb->mmtx);
  if (tmp != 0) {
    tcfdbsetecode(fdb, 1, "tcfdb.c", 2553, "tcfdbunlockmethod");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcfdblockattr(TCFDB *fdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)fdb->amtx);
  if (tmp != 0) {
    tcfdbsetecode(fdb, 1, "tcfdb.c", 2567, "tcfdblockattr");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcfdbunlockattr(TCFDB *fdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_unlock((pthread_mutex_t *)fdb->amtx);
  if (tmp != 0) {
    tcfdbsetecode(fdb, 1, "tcfdb.c", 2581, "tcfdbunlockattr");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcfdblockrecord(TCFDB *fdb , _Bool wr , uint64_t id ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (wr) {
    tmp = pthread_rwlock_wrlock((pthread_rwlock_t *)fdb->rmtxs + id % 127ULL);
    tmp___1 = tmp != 0;
  } else {
    tmp___0 = pthread_rwlock_rdlock((pthread_rwlock_t *)fdb->rmtxs + id % 127ULL);
    tmp___1 = tmp___0 != 0;
  }
  if (tmp___1) {
    tcfdbsetecode(fdb, 1, "tcfdb.c", 2597, "tcfdblockrecord");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcfdbunlockrecord(TCFDB *fdb , uint64_t id ) 
{ int tmp ;

  {
  tmp = pthread_rwlock_unlock((pthread_rwlock_t *)fdb->rmtxs + id % 127ULL);
  if (tmp != 0) {
    tcfdbsetecode(fdb, 1, "tcfdb.c", 2611, "tcfdbunlockrecord");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcfdblockallrecords(TCFDB *fdb , _Bool wr ) 
{ int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  i = 0;
  while (i < 127) {
    if (wr) {
      tmp = pthread_rwlock_wrlock((pthread_rwlock_t *)fdb->rmtxs + i);
      tmp___1 = tmp != 0;
    } else {
      tmp___0 = pthread_rwlock_rdlock((pthread_rwlock_t *)fdb->rmtxs + i);
      tmp___1 = tmp___0 != 0;
    }
    if (tmp___1) {
      tcfdbsetecode(fdb, 1, "tcfdb.c", 2628, "tcfdblockallrecords");
      while (1) {
        i --;
        if (! (i >= 0)) {
          break;
        }
        pthread_rwlock_unlock((pthread_rwlock_t *)fdb->rmtxs + i);
      }
      return ((_Bool)0);
    }
    i ++;
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcfdbunlockallrecords(TCFDB *fdb ) 
{ _Bool err ;
  int i ;
  int tmp ;

  {
  err = (_Bool)0;
  i = 126;
  while (i >= 0) {
    tmp = pthread_rwlock_unlock((pthread_rwlock_t *)fdb->rmtxs + i);
    if (tmp) {
      err = (_Bool)1;
    }
    i --;
  }
  while (1) {
    break;
  }
  if (err) {
    tcfdbsetecode(fdb, 1, "tcfdb.c", 2651, "tcfdbunlockallrecords");
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static _Bool tcfdblockwal(TCFDB *fdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock((pthread_mutex_t *)fdb->wmtx);
  if (tmp != 0) {
    tcfdbsetecode(fdb, 1, "tcfdb.c", 2664, "tcfdblockwal");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tcfdbunlockwal(TCFDB *fdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_unlock((pthread_mutex_t *)fdb->wmtx);
  if (tmp != 0) {
    tcfdbsetecode(fdb, 1, "tcfdb.c", 2678, "tcfdbunlockwal");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
void tcfdbprintmeta(TCFDB *fdb ) 
{ int dbgfd ;
  int tmp ;
  char buf[8192] ;
  char *wp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;

  {
  if (fdb->dbgfd < 0) {
    return;
  }
  if (fdb->dbgfd == 65535) {
    tmp = 1;
  } else {
    tmp = fdb->dbgfd;
  }
  dbgfd = tmp;
  wp = buf;
  tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"META:");
  wp += tmp___0;
  tmp___1 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" mmtx=%p",
                    fdb->mmtx);
  wp += tmp___1;
  tmp___2 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" amtx=%p",
                    fdb->amtx);
  wp += tmp___2;
  tmp___3 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rmtxs=%p",
                    fdb->rmtxs);
  wp += tmp___3;
  tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" tmtx=%p",
                    fdb->tmtx);
  wp += tmp___4;
  tmp___5 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" wmtx=%p",
                    fdb->wmtx);
  wp += tmp___5;
  tmp___6 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" eckey=%p",
                    fdb->eckey);
  wp += tmp___6;
  if (fdb->rpath) {
    tmp___7 = (char const   *)fdb->rpath;
  } else {
    tmp___7 = "-";
  }
  tmp___8 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rpath=%s",
                    tmp___7);
  wp += tmp___8;
  tmp___9 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" type=%02X",
                    fdb->type);
  wp += tmp___9;
  tmp___10 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" flags=%02X",
                     fdb->flags);
  wp += tmp___10;
  tmp___11 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" width=%u",
                     fdb->width);
  wp += tmp___11;
  tmp___12 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" limsiz=%llu",
                     fdb->limsiz);
  wp += tmp___12;
  tmp___13 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" wsiz=%u",
                     fdb->wsiz);
  wp += tmp___13;
  tmp___14 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rsiz=%u",
                     fdb->rsiz);
  wp += tmp___14;
  tmp___15 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" limid=%llu",
                     fdb->limid);
  wp += tmp___15;
  if (fdb->path) {
    tmp___16 = (char const   *)fdb->path;
  } else {
    tmp___16 = "-";
  }
  tmp___17 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" path=%s",
                     tmp___16);
  wp += tmp___17;
  tmp___18 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" fd=%d",
                     fdb->fd);
  wp += tmp___18;
  tmp___19 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" omode=%u",
                     fdb->omode);
  wp += tmp___19;
  tmp___20 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" rnum=%llu",
                     fdb->rnum);
  wp += tmp___20;
  tmp___21 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" fsiz=%llu",
                     fdb->fsiz);
  wp += tmp___21;
  tmp___22 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" min=%llu",
                     fdb->min);
  wp += tmp___22;
  tmp___23 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" max=%llu",
                     fdb->max);
  wp += tmp___23;
  tmp___24 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" iter=%llu",
                     fdb->iter);
  wp += tmp___24;
  tmp___25 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" map=%p",
                     (void *)fdb->map);
  wp += tmp___25;
  tmp___26 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" array=%p",
                     (void *)fdb->array);
  wp += tmp___26;
  tmp___27 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" ecode=%d",
                     fdb->ecode);
  wp += tmp___27;
  tmp___28 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" fatal=%u",
                     fdb->fatal);
  wp += tmp___28;
  tmp___29 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" inode=%llu",
                     fdb->inode);
  wp += tmp___29;
  tmp___30 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" mtime=%llu",
                     (unsigned long long )fdb->mtime);
  wp += tmp___30;
  tmp___31 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" tran=%d",
                     fdb->tran);
  wp += tmp___31;
  tmp___32 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" walfd=%d",
                     fdb->walfd);
  wp += tmp___32;
  tmp___33 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" walend=%llu",
                     fdb->walend);
  wp += tmp___33;
  tmp___34 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" dbgfd=%d",
                     fdb->dbgfd);
  wp += tmp___34;
  tmp___35 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_writerec=%lld",
                     fdb->cnt_writerec);
  wp += tmp___35;
  tmp___36 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_readrec=%lld",
                     fdb->cnt_readrec);
  wp += tmp___36;
  tmp___37 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" cnt_truncfile=%lld",
                     fdb->cnt_truncfile);
  wp += tmp___37;
  tmp___38 = wp;
  wp ++;
  *tmp___38 = (char )'\n';
  tcwrite(dbgfd, (void const   *)(buf), (unsigned int )(wp - buf));
  return;
}
}
#pragma merger(0,"/tmp/cil-UVXqxMzi.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
extern  __attribute__((__nothrow__)) int __isnan(double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __isnanf(float __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) long double nanl(char const   *__tagb )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __isnanl(long double __value )  __attribute__((__const__)) ;
char const   *tctdberrmsg(int ecode ) ;
TCTDB *tctdbnew(void) ;
void tctdbdel(TCTDB *tdb ) ;
int tctdbecode(TCTDB *tdb ) ;
_Bool tctdbsetmutex(TCTDB *tdb ) ;
_Bool tctdbtune(TCTDB *tdb , int64_t bnum , int8_t apow , int8_t fpow , uint8_t opts ) ;
_Bool tctdbsetcache(TCTDB *tdb , int32_t rcnum , int32_t lcnum , int32_t ncnum ) ;
_Bool tctdbsetxmsiz(TCTDB *tdb , int64_t xmsiz ) ;
_Bool tctdbsetdfunit(TCTDB *tdb , int32_t dfunit ) ;
_Bool tctdbopen(TCTDB *tdb , char const   *path , int omode ) ;
_Bool tctdbclose(TCTDB *tdb ) ;
_Bool tctdbput(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ) ;
_Bool tctdbput2(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *cbuf ,
                int csiz ) ;
_Bool tctdbput3(TCTDB *tdb , char const   *pkstr , char const   *cstr ) ;
_Bool tctdbputkeep(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ) ;
_Bool tctdbputkeep2(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *cbuf ,
                    int csiz ) ;
_Bool tctdbputkeep3(TCTDB *tdb , char const   *pkstr , char const   *cstr ) ;
_Bool tctdbputcat(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ) ;
_Bool tctdbputcat2(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *cbuf ,
                   int csiz ) ;
_Bool tctdbputcat3(TCTDB *tdb , char const   *pkstr , char const   *cstr ) ;
_Bool tctdbout(TCTDB *tdb , void const   *pkbuf , int pksiz ) ;
_Bool tctdbout2(TCTDB *tdb , char const   *pkstr ) ;
TCMAP *tctdbget(TCTDB *tdb , void const   *pkbuf , int pksiz ) ;
char *tctdbget2(TCTDB *tdb , void const   *pkbuf , int pksiz , int *sp ) ;
char *tctdbget3(TCTDB *tdb , char const   *pkstr ) ;
int tctdbvsiz(TCTDB *tdb , void const   *pkbuf , int pksiz ) ;
int tctdbvsiz2(TCTDB *tdb , char const   *pkstr ) ;
_Bool tctdbiterinit(TCTDB *tdb ) ;
void *tctdbiternext(TCTDB *tdb , int *sp ) ;
char *tctdbiternext2(TCTDB *tdb ) ;
TCMAP *tctdbiternext3(TCTDB *tdb ) ;
TCLIST *tctdbfwmkeys(TCTDB *tdb , void const   *pbuf , int psiz , int max ) ;
TCLIST *tctdbfwmkeys2(TCTDB *tdb , char const   *pstr , int max ) ;
int tctdbaddint(TCTDB *tdb , void const   *pkbuf , int pksiz , int num ) ;
double tctdbadddouble(TCTDB *tdb , void const   *pkbuf , int pksiz , double num ) ;
_Bool tctdbsync(TCTDB *tdb ) ;
_Bool tctdboptimize(TCTDB *tdb , int64_t bnum , int8_t apow , int8_t fpow , uint8_t opts ) ;
_Bool tctdbvanish(TCTDB *tdb ) ;
_Bool tctdbcopy(TCTDB *tdb , char const   *path ) ;
_Bool tctdbtranbegin(TCTDB *tdb ) ;
_Bool tctdbtrancommit(TCTDB *tdb ) ;
_Bool tctdbtranabort(TCTDB *tdb ) ;
char const   *tctdbpath(TCTDB *tdb ) ;
uint64_t tctdbrnum(TCTDB *tdb ) ;
uint64_t tctdbfsiz(TCTDB *tdb ) ;
_Bool tctdbsetindex(TCTDB *tdb , char const   *name , int type ) ;
int64_t tctdbgenuid(TCTDB *tdb ) ;
TDBQRY *tctdbqrynew(TCTDB *tdb ) ;
void tctdbqrydel(TDBQRY *qry ) ;
void tctdbqryaddcond(TDBQRY *qry , char const   *name , int op , char const   *expr ) ;
void tctdbqrysetorder(TDBQRY *qry , char const   *name , int type ) ;
void tctdbqrysetlimit(TDBQRY *qry , int max , int skip ) ;
TCLIST *tctdbqrysearch(TDBQRY *qry ) ;
_Bool tctdbqrysearchout(TDBQRY *qry ) ;
_Bool tctdbqryproc(TDBQRY *qry , int (*proc___0)(void const   *pkbuf , int pksiz ,
                                                 TCMAP *cols , void *op ) , void *op ) ;
char const   *tctdbqryhint(TDBQRY *qry ) ;
TCLIST *tctdbmetasearch(TDBQRY **qrys , int num , int type ) ;
void tctdbsetecode(TCTDB *tdb , int ecode , char const   *filename , int line , char const   *func ) ;
void tctdbsetdbgfd(TCTDB *tdb , int fd ) ;
int tctdbdbgfd(TCTDB *tdb ) ;
_Bool tctdbhasmutex(TCTDB *tdb ) ;
_Bool tctdbmemsync(TCTDB *tdb , _Bool phys ) ;
uint64_t tctdbbnum(TCTDB *tdb ) ;
uint32_t tctdbalign(TCTDB *tdb ) ;
uint32_t tctdbfbpmax(TCTDB *tdb ) ;
uint64_t tctdbinode(TCTDB *tdb ) ;
time_t tctdbmtime(TCTDB *tdb ) ;
uint8_t tctdbflags(TCTDB *tdb ) ;
uint8_t tctdbopts(TCTDB *tdb ) ;
char *tctdbopaque(TCTDB *tdb ) ;
uint64_t tctdbbnumused(TCTDB *tdb ) ;
int tctdbinum(TCTDB *tdb ) ;
int64_t tctdbuidseed(TCTDB *tdb ) ;
_Bool tctdbsetuidseed(TCTDB *tdb , int64_t seed___0 ) ;
_Bool tctdbsetinvcache(TCTDB *tdb , int64_t iccmax , double iccsync ) ;
_Bool tctdbsetcodecfunc(TCTDB *tdb , void *(*enc)(void const   *ptr , int size , int *sp ,
                                                  void *op ) , void *encop , void *(*dec)(void const   *ptr ,
                                                                                          int size ,
                                                                                          int *sp ,
                                                                                          void *op ) ,
                        void *decop ) ;
uint32_t tctdbdfunit(TCTDB *tdb ) ;
_Bool tctdbdefrag(TCTDB *tdb , int64_t step ) ;
_Bool tctdbputproc(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *cbuf ,
                   int csiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) ;
char *tctdbget4(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *nbuf ,
                int nsiz , int *sp ) ;
_Bool tctdbiterinit2(TCTDB *tdb , void const   *pkbuf , int pksiz ) ;
_Bool tctdbiterinit3(TCTDB *tdb , char const   *kstr ) ;
_Bool tctdbforeach(TCTDB *tdb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                              int vsiz , void *op ) , void *op ) ;
_Bool tctdbqryproc2(TDBQRY *qry , int (*proc___0)(void const   *pkbuf , int pksiz ,
                                                  TCMAP *cols , void *op ) , void *op ) ;
_Bool tctdbqrysearchout2(TDBQRY *qry ) ;
int tctdbstrtoindextype(char const   *str ) ;
int tctdbstrtometasearcytype(char const   *str ) ;
int tctdbqrycount(TDBQRY *qry ) ;
TCLIST *tctdbqrykwic(TDBQRY *qry , TCMAP *cols , char const   *name , int width ,
                     int opts ) ;
int tctdbqrystrtocondop(char const   *str ) ;
int tctdbqrystrtoordertype(char const   *str ) ;
int tctdbmetastrtosettype(char const   *str ) ;
static void tctdbclear(TCTDB *tdb ) ;
static _Bool tctdbopenimpl(TCTDB *tdb , char const   *path , int omode ) ;
static _Bool tctdbcloseimpl(TCTDB *tdb ) ;
static _Bool tctdbputimpl(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ,
                          int dmode ) ;
static _Bool tctdboutimpl(TCTDB *tdb , char const   *pkbuf , int pksiz ) ;
static TCMAP *tctdbgetimpl(TCTDB *tdb , void const   *pkbuf , int pksiz ) ;
static char *tctdbgetonecol(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *nbuf ,
                            int nsiz , int *sp ) ;
static double tctdbaddnumber(TCTDB *tdb , void const   *pkbuf , int pksiz , double num ) ;
static _Bool tctdboptimizeimpl(TCTDB *tdb , int64_t bnum , int8_t apow , int8_t fpow ,
                               uint8_t opts ) ;
static _Bool tctdbvanishimpl(TCTDB *tdb ) ;
static _Bool tctdbcopyimpl(TCTDB *tdb , char const   *path ) ;
static _Bool tctdbtranbeginimpl(TCTDB *tdb ) ;
static _Bool tctdbtrancommitimpl(TCTDB *tdb ) ;
static _Bool tctdbtranabortimpl(TCTDB *tdb ) ;
static _Bool tctdbsetindeximpl(TCTDB *tdb , char const   *name , int type ) ;
static int64_t tctdbgenuidimpl(TCTDB *tdb , int64_t inc ) ;
static TCLIST *tctdbqrysearchimpl(TDBQRY *qry ) ;
static TCMAP *tctdbqryidxfetch(TDBQRY *qry , TDBCOND *cond , TDBIDX *idx ) ;
static long double tctdbatof(char const   *str ) ;
static _Bool tctdbqryidxcurjumpnum(BDBCUR *cur , char const   *expr , int esiz , _Bool first ) ;
static _Bool tctdbqryonecondmatch(TDBQRY *qry , TDBCOND *cond , char const   *pkbuf ,
                                  int pksiz ) ;
static _Bool tctdbqryallcondmatch(TDBQRY *qry , char const   *pkbuf , int pksiz ) ;
static _Bool tctdbqrycondmatch(TDBCOND *cond , char const   *vbuf , int vsiz ) ;
static _Bool tctdbqrycondcheckstrand(char const   *vbuf , char const   *expr ) ;
static _Bool tctdbqrycondcheckstror(char const   *vbuf , char const   *expr ) ;
static _Bool tctdbqrycondcheckstroreq(char const   *vbuf , char const   *expr ) ;
static _Bool tctdbqrycondchecknumbt(char const   *vbuf , char const   *expr ) ;
static _Bool tctdbqrycondchecknumoreq(char const   *vbuf , char const   *expr ) ;
static _Bool tctdbqrycondcheckfts(char const   *vbuf , int vsiz , TDBCOND *cond ) ;
static int tdbcmppkeynumasc(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) ;
static int tdbcmppkeynumdesc(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) ;
static int tdbcmpsortkeystrasc(TDBSORTKEY const   *a , TDBSORTKEY const   *b ) ;
static int tdbcmpsortkeystrdesc(TDBSORTKEY const   *a , TDBSORTKEY const   *b ) ;
static int tdbcmpsortkeynumasc(TDBSORTKEY const   *a , TDBSORTKEY const   *b ) ;
static int tdbcmpsortkeynumdesc(TDBSORTKEY const   *a , TDBSORTKEY const   *b ) ;
static uint16_t tctdbidxhash(char const   *pkbuf , int pksiz ) ;
static _Bool tctdbidxput(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ) ;
static _Bool tctdbidxputone(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                            uint16_t hash , char const   *vbuf , int vsiz ) ;
static _Bool tctdbidxputtoken(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                              char const   *vbuf , int vsiz ) ;
static _Bool tctdbidxputqgram(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                              char const   *vbuf , int vsiz ) ;
static _Bool tctdbidxout(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ) ;
static _Bool tctdbidxoutone(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                            uint16_t hash , char const   *vbuf , int vsiz ) ;
static _Bool tctdbidxouttoken(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                              char const   *vbuf , int vsiz ) ;
static _Bool tctdbidxoutqgram(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                              char const   *vbuf , int vsiz ) ;
static _Bool tctdbidxsyncicc(TCTDB *tdb , TDBIDX *idx , _Bool all ) ;
static int tctdbidxcmpkey(char const   **a , char const   **b ) ;
static TCMAP *tctdbidxgetbytokens(TCTDB *tdb , TDBIDX *idx , TCLIST const   *tokens ,
                                  int op , TCXSTR *hint ) ;
static TCMAP *tctdbidxgetbyfts(TCTDB *tdb , TDBIDX *idx , TDBCOND *cond , TCXSTR *hint ) ;
static void tctdbidxgetbyftsunion(TDBIDX *idx , TCLIST const   *tokens , _Bool sign ,
                                  TCMAP *ores , TCMAP *nres , TCXSTR *hint ) ;
static int tctdbidxftscmpstrocr(TDBFTSSTROCR *a , TDBFTSSTROCR *b ) ;
static int tctdbidxftscmpnumocr(TDBFTSNUMOCR *a , TDBFTSNUMOCR *b ) ;
static TDBFTSUNIT *tctdbftsparseexpr(char const   *expr , int esiz , int op , int *np ) ;
static _Bool tctdbdefragimpl(TCTDB *tdb , int64_t step ) ;
static _Bool tctdbforeachimpl(TCTDB *tdb , _Bool (*iter)(void const   *kbuf , int ksiz ,
                                                         void const   *vbuf , int vsiz ,
                                                         void *op ) , void *op ) ;
static int tctdbqryprocoutcb(void const   *pkbuf , int pksiz , TCMAP *cols , void *op ) ;
static _Bool tctdblockmethod(TCTDB *tdb , _Bool wr ) ;
static _Bool tctdbunlockmethod(TCTDB *tdb ) ;
void tctdbprintmeta(TCTDB *tdb ) ;
char const   *tctdberrmsg(int ecode ) 
{ char const   *tmp ;

  {
  tmp = tcerrmsg(ecode);
  return (tmp);
}
}
TCTDB *tctdbnew(void) 
{ TCTDB *tdb ;
  void *tmp ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*tdb)));
    tdb = (TCTDB *)tmp;
    if (! tdb) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tctdbclear(tdb);
  tdb->hdb = tchdbnew();
  tchdbtune(tdb->hdb, 131071LL, (signed char)4, (signed char)10, (unsigned char)0);
  tchdbsetxmsiz(tdb->hdb, 64LL << 20);
  return (tdb);
}
}
void tctdbdel(TCTDB *tdb ) 
{ 

  {
  if (tdb->open) {
    tctdbclose(tdb);
  }
  tchdbdel(tdb->hdb);
  if (tdb->mmtx) {
    pthread_rwlock_destroy((pthread_rwlock_t *)tdb->mmtx);
    while (1) {
      free(tdb->mmtx);
      break;
    }
  }
  while (1) {
    free((void *)tdb);
    break;
  }
  return;
}
}
int tctdbecode(TCTDB *tdb ) 
{ int tmp ;

  {
  tmp = tchdbecode(tdb->hdb);
  return (tmp);
}
}
_Bool tctdbsetmutex(TCTDB *tdb ) 
{ void *tmp ;
  _Bool err ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tctdbsetecode(tdb, 2, "tctdb.c", 215, "tctdbsetmutex");
    return ((_Bool)0);
  } else {
    if (tdb->open) {
      tctdbsetecode(tdb, 2, "tctdb.c", 215, "tctdbsetmutex");
      return ((_Bool)0);
    }
  }
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(pthread_rwlock_t )));
    tdb->mmtx = tmp;
    if (! tmp) {
      tcmyfatal("out of memory");
    }
    break;
  }
  err = (_Bool)0;
  tmp___0 = pthread_rwlock_init((pthread_rwlock_t * __restrict  )tdb->mmtx, (pthread_rwlockattr_t const   * __restrict  )((void *)0));
  if (tmp___0 != 0) {
    err = (_Bool)1;
  }
  if (err) {
    while (1) {
      free(tdb->mmtx);
      break;
    }
    tdb->mmtx = (void *)0;
    return ((_Bool)0);
  }
  tmp___1 = tchdbsetmutex(tdb->hdb);
  return (tmp___1);
}
}
_Bool tctdbtune(TCTDB *tdb , int64_t bnum , int8_t apow , int8_t fpow , uint8_t opts ) 
{ uint8_t hopts ;
  _Bool tmp ;

  {
  if (tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 234, "tctdbtune");
    return ((_Bool)0);
  }
  tdb->opts = opts;
  hopts = (unsigned char)0;
  if ((int )opts & 1) {
    hopts = (unsigned char )((int )hopts | 1);
  }
  if ((int )opts & 2) {
    hopts = (unsigned char )((int )hopts | 2);
  }
  if ((int )opts & 4) {
    hopts = (unsigned char )((int )hopts | 4);
  }
  if ((int )opts & 8) {
    hopts = (unsigned char )((int )hopts | 8);
  }
  if ((int )opts & 16) {
    hopts = (unsigned char )((int )hopts | 16);
  }
  if (bnum > 0LL) {
    bnum = bnum;
  } else {
    bnum = 131071LL;
  }
  if ((int )apow >= 0) {
    apow = apow;
  } else {
    apow = (signed char)4;
  }
  if ((int )fpow >= 0) {
    fpow = fpow;
  } else {
    fpow = (signed char)10;
  }
  tmp = tchdbtune(tdb->hdb, bnum, apow, fpow, hopts);
  return (tmp);
}
}
_Bool tctdbsetcache(TCTDB *tdb , int32_t rcnum , int32_t lcnum , int32_t ncnum ) 
{ _Bool tmp ;

  {
  if (tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 255, "tctdbsetcache");
    return ((_Bool)0);
  }
  if (lcnum > 0) {
    tdb->lcnum = lcnum;
  }
  if (ncnum > 0) {
    tdb->ncnum = ncnum;
  }
  tmp = tchdbsetcache(tdb->hdb, rcnum);
  return (tmp);
}
}
_Bool tctdbsetxmsiz(TCTDB *tdb , int64_t xmsiz ) 
{ _Bool tmp ;

  {
  if (tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 268, "tctdbsetxmsiz");
    return ((_Bool)0);
  }
  tmp = tchdbsetxmsiz(tdb->hdb, xmsiz);
  return (tmp);
}
}
_Bool tctdbsetdfunit(TCTDB *tdb , int32_t dfunit ) 
{ _Bool tmp ;

  {
  if (tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 279, "tctdbsetdfunit");
    return ((_Bool)0);
  }
  tmp = tchdbsetdfunit(tdb->hdb, dfunit);
  return (tmp);
}
}
_Bool tctdbopen(TCTDB *tdb , char const   *path , int omode ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 291, "tctdbopen");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tctdbopenimpl(tdb, path, omode);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbclose(TCTDB *tdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 306, "tctdbclose");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tctdbcloseimpl(tdb);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbput(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ) 
{ int vsiz ;
  void const   *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  tmp = tcmapget((TCMAP const   *)cols, (void const   *)"", 0, & vsiz);
  if (tmp) {
    tctdbsetecode(tdb, 2, "tctdb.c", 321, "tctdbput");
    return ((_Bool)0);
  }
  if (tdb->mmtx) {
    tmp___0 = tctdblockmethod(tdb, (_Bool)1);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      _L: 
      tctdbsetecode(tdb, 2, "tctdb.c", 326, "tctdbput");
      if (tdb->mmtx) {
        tctdbunlockmethod(tdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___2 = tctdbputimpl(tdb, pkbuf, pksiz, cols, 0);
  rv = tmp___2;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbput2(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *cbuf ,
                int csiz ) 
{ TCMAP *cols ;
  TCMAP *tmp ;
  _Bool rv ;
  _Bool tmp___0 ;

  {
  tmp = tcstrsplit4(cbuf, csiz);
  cols = tmp;
  tmp___0 = tctdbput(tdb, pkbuf, pksiz, cols);
  rv = tmp___0;
  tcmapdel(cols);
  return (rv);
}
}
_Bool tctdbput3(TCTDB *tdb , char const   *pkstr , char const   *cstr ) 
{ TCMAP *cols ;
  TCMAP *tmp ;
  _Bool rv ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = tcstrsplit3(cstr, "\t");
  cols = tmp;
  tmp___0 = strlen(pkstr);
  tmp___1 = tctdbput(tdb, (void const   *)pkstr, (int )tmp___0, cols);
  rv = tmp___1;
  tcmapdel(cols);
  return (rv);
}
}
_Bool tctdbputkeep(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ) 
{ int vsiz ;
  void const   *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  tmp = tcmapget((TCMAP const   *)cols, (void const   *)"", 0, & vsiz);
  if (tmp) {
    tctdbsetecode(tdb, 2, "tctdb.c", 361, "tctdbputkeep");
    return ((_Bool)0);
  }
  if (tdb->mmtx) {
    tmp___0 = tctdblockmethod(tdb, (_Bool)1);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      _L: 
      tctdbsetecode(tdb, 2, "tctdb.c", 366, "tctdbputkeep");
      if (tdb->mmtx) {
        tctdbunlockmethod(tdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___2 = tctdbputimpl(tdb, pkbuf, pksiz, cols, 1);
  rv = tmp___2;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbputkeep2(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *cbuf ,
                    int csiz ) 
{ TCMAP *cols ;
  TCMAP *tmp ;
  _Bool rv ;
  _Bool tmp___0 ;

  {
  tmp = tcstrsplit4(cbuf, csiz);
  cols = tmp;
  tmp___0 = tctdbputkeep(tdb, pkbuf, pksiz, cols);
  rv = tmp___0;
  tcmapdel(cols);
  return (rv);
}
}
_Bool tctdbputkeep3(TCTDB *tdb , char const   *pkstr , char const   *cstr ) 
{ TCMAP *cols ;
  TCMAP *tmp ;
  _Bool rv ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = tcstrsplit3(cstr, "\t");
  cols = tmp;
  tmp___0 = strlen(pkstr);
  tmp___1 = tctdbputkeep(tdb, (void const   *)pkstr, (int )tmp___0, cols);
  rv = tmp___1;
  tcmapdel(cols);
  return (rv);
}
}
_Bool tctdbputcat(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ) 
{ int vsiz ;
  void const   *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  tmp = tcmapget((TCMAP const   *)cols, (void const   *)"", 0, & vsiz);
  if (tmp) {
    tctdbsetecode(tdb, 2, "tctdb.c", 401, "tctdbputcat");
    return ((_Bool)0);
  }
  if (tdb->mmtx) {
    tmp___0 = tctdblockmethod(tdb, (_Bool)1);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      _L: 
      tctdbsetecode(tdb, 2, "tctdb.c", 406, "tctdbputcat");
      if (tdb->mmtx) {
        tctdbunlockmethod(tdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___2 = tctdbputimpl(tdb, pkbuf, pksiz, cols, 2);
  rv = tmp___2;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbputcat2(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *cbuf ,
                   int csiz ) 
{ TCMAP *cols ;
  TCMAP *tmp ;
  _Bool rv ;
  _Bool tmp___0 ;

  {
  tmp = tcstrsplit4(cbuf, csiz);
  cols = tmp;
  tmp___0 = tctdbputcat(tdb, pkbuf, pksiz, cols);
  rv = tmp___0;
  tcmapdel(cols);
  return (rv);
}
}
_Bool tctdbputcat3(TCTDB *tdb , char const   *pkstr , char const   *cstr ) 
{ TCMAP *cols ;
  TCMAP *tmp ;
  _Bool rv ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = tcstrsplit3(cstr, "\t");
  cols = tmp;
  tmp___0 = strlen(pkstr);
  tmp___1 = tctdbputcat(tdb, (void const   *)pkstr, (int )tmp___0, cols);
  rv = tmp___1;
  tcmapdel(cols);
  return (rv);
}
}
_Bool tctdbout(TCTDB *tdb , void const   *pkbuf , int pksiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      _L: 
      tctdbsetecode(tdb, 2, "tctdb.c", 441, "tctdbout");
      if (tdb->mmtx) {
        tctdbunlockmethod(tdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___1 = tctdboutimpl(tdb, (char const   *)pkbuf, pksiz);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbout2(TCTDB *tdb , char const   *pkstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(pkstr);
  tmp___0 = tctdbout(tdb, (void const   *)pkstr, (int )tmp);
  return (tmp___0);
}
}
TCMAP *tctdbget(TCTDB *tdb , void const   *pkbuf , int pksiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  TCMAP *rv ;
  TCMAP *tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((TCMAP *)((void *)0));
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 463, "tctdbget");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((TCMAP *)((void *)0));
  }
  tmp___1 = tctdbgetimpl(tdb, pkbuf, pksiz);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
char *tctdbget2(TCTDB *tdb , void const   *pkbuf , int pksiz , int *sp ) 
{ TCMAP *cols ;
  TCMAP *tmp ;
  char *cbuf ;
  void *tmp___0 ;

  {
  tmp = tctdbget(tdb, pkbuf, pksiz);
  cols = tmp;
  if (! cols) {
    return ((char *)((void *)0));
  }
  tmp___0 = tcstrjoin4((TCMAP const   *)cols, sp);
  cbuf = (char *)tmp___0;
  tcmapdel(cols);
  return (cbuf);
}
}
char *tctdbget3(TCTDB *tdb , char const   *pkstr ) 
{ TCMAP *cols ;
  size_t tmp ;
  TCMAP *tmp___0 ;
  char *cstr ;
  char *tmp___1 ;

  {
  tmp = strlen(pkstr);
  tmp___0 = tctdbget(tdb, (void const   *)pkstr, (int )tmp);
  cols = tmp___0;
  if (! cols) {
    return ((char *)((void *)0));
  }
  tmp___1 = tcstrjoin3((TCMAP const   *)cols, (char )'\t');
  cstr = tmp___1;
  tcmapdel(cols);
  return (cstr);
}
}
int tctdbvsiz(TCTDB *tdb , void const   *pkbuf , int pksiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  int rv ;
  int tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (-1);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 500, "tctdbvsiz");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return (-1);
  }
  tmp___1 = tchdbvsiz(tdb->hdb, pkbuf, pksiz);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
int tctdbvsiz2(TCTDB *tdb , char const   *pkstr ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(pkstr);
  tmp___0 = tctdbvsiz(tdb, (void const   *)pkstr, (int )tmp);
  return (tmp___0);
}
}
_Bool tctdbiterinit(TCTDB *tdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 522, "tctdbiterinit");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tchdbiterinit(tdb->hdb);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
void *tctdbiternext(TCTDB *tdb , int *sp ) 
{ _Bool tmp ;
  int tmp___0 ;
  char *rv ;
  void *tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((void *)0);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 537, "tctdbiternext");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((void *)0);
  }
  tmp___1 = tchdbiternext(tdb->hdb, sp);
  rv = (char *)tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return ((void *)rv);
}
}
char *tctdbiternext2(TCTDB *tdb ) 
{ int pksiz ;
  void *tmp ;

  {
  tmp = tctdbiternext(tdb, & pksiz);
  return ((char *)tmp);
}
}
TCMAP *tctdbiternext3(TCTDB *tdb ) 
{ TCXSTR *kstr ;
  TCXSTR *tmp ;
  TCXSTR *vstr ;
  TCXSTR *tmp___0 ;
  TCMAP *cols ;
  _Bool tmp___1 ;

  {
  tmp = tcxstrnew();
  kstr = tmp;
  tmp___0 = tcxstrnew();
  vstr = tmp___0;
  cols = (TCMAP *)((void *)0);
  tmp___1 = tchdbiternext3(tdb->hdb, kstr, vstr);
  if (tmp___1) {
    cols = tcmapload((void const   *)vstr->ptr, vstr->size);
    tcmapput(cols, (void const   *)"", 0, (void const   *)kstr->ptr, kstr->size);
  }
  tcxstrdel(vstr);
  tcxstrdel(kstr);
  return (cols);
}
}
TCLIST *tctdbfwmkeys(TCTDB *tdb , void const   *pbuf , int psiz , int max ) 
{ TCLIST *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  TCLIST *tmp___2 ;
  TCLIST *rv ;
  TCLIST *tmp___3 ;

  {
  if (tdb->mmtx) {
    tmp___0 = tctdblockmethod(tdb, (_Bool)1);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    tmp = tclistnew();
    return (tmp);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 576, "tctdbfwmkeys");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    tmp___2 = tclistnew();
    return (tmp___2);
  }
  tmp___3 = tchdbfwmkeys(tdb->hdb, pbuf, psiz, max);
  rv = tmp___3;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
TCLIST *tctdbfwmkeys2(TCTDB *tdb , char const   *pstr , int max ) 
{ size_t tmp ;
  TCLIST *tmp___0 ;

  {
  tmp = strlen(pstr);
  tmp___0 = tctdbfwmkeys(tdb, (void const   *)pstr, (int )tmp, max);
  return (tmp___0);
}
}
int tctdbaddint(TCTDB *tdb , void const   *pkbuf , int pksiz , int num ) 
{ _Bool tmp ;
  int tmp___0 ;
  double rv ;
  double tmp___1 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((-0x7FFFFFFF-1));
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 598, "tctdbaddint");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((-0x7FFFFFFF-1));
  }
  tmp___1 = tctdbaddnumber(tdb, pkbuf, pksiz, (double )num);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  if ((int )sizeof(rv) == (int )sizeof(float )) {
    tmp___8 = __isnanf((float )rv);
    tmp___12 = tmp___8;
  } else {
    if ((int )sizeof(rv) == (int )sizeof(double )) {
      tmp___9 = __isnan(rv);
      tmp___11 = tmp___9;
    } else {
      tmp___10 = __isnanl((long double )rv);
      tmp___11 = tmp___10;
    }
    tmp___12 = tmp___11;
  }
  if (tmp___12) {
    tmp___7 = (-0x7FFFFFFF-1);
  } else {
    tmp___7 = (int )rv;
  }
  return (tmp___7);
}
}
double tctdbadddouble(TCTDB *tdb , void const   *pkbuf , int pksiz , double num ) 
{ _Bool tmp ;
  int tmp___0 ;
  double rv ;
  double tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((double )(-0x7FFFFFFF-1));
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 613, "tctdbadddouble");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((double )(-0x7FFFFFFF-1));
  }
  tmp___1 = tctdbaddnumber(tdb, pkbuf, pksiz, num);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbsync(TCTDB *tdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      goto _L;
    } else {
      if (tdb->tran) {
        _L: 
        tctdbsetecode(tdb, 2, "tctdb.c", 628, "tctdbsync");
        if (tdb->mmtx) {
          tctdbunlockmethod(tdb);
        }
        return ((_Bool)0);
      }
    }
  }
  tmp___1 = tctdbmemsync(tdb, (_Bool)1);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdboptimize(TCTDB *tdb , int64_t bnum , int8_t apow , int8_t fpow , uint8_t opts ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      goto _L;
    } else {
      if (tdb->tran) {
        _L: 
        tctdbsetecode(tdb, 2, "tctdb.c", 643, "tctdboptimize");
        if (tdb->mmtx) {
          tctdbunlockmethod(tdb);
        }
        return ((_Bool)0);
      }
    }
  }
  while (1) {
    if (tdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___1 = tctdboptimizeimpl(tdb, bnum, apow, fpow, opts);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbvanish(TCTDB *tdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      goto _L;
    } else {
      if (tdb->tran) {
        _L: 
        tctdbsetecode(tdb, 2, "tctdb.c", 659, "tctdbvanish");
        if (tdb->mmtx) {
          tctdbunlockmethod(tdb);
        }
        return ((_Bool)0);
      }
    }
  }
  while (1) {
    if (tdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___1 = tctdbvanishimpl(tdb);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbcopy(TCTDB *tdb , char const   *path ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 675, "tctdbcopy");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((_Bool)0);
  }
  while (1) {
    if (tdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___1 = tctdbcopyimpl(tdb, path);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbtranbegin(TCTDB *tdb ) 
{ double wsec ;
  long tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  tmp = sysconf(2);
  wsec = 1.0 / (double )tmp;
  while (1) {
    if (tdb->mmtx) {
      tmp___0 = tctdblockmethod(tdb, (_Bool)1);
      tmp___1 = (int )tmp___0;
    } else {
      tmp___1 = 1;
    }
    if (! tmp___1) {
      return ((_Bool)0);
    }
    if (! tdb->open) {
      goto _L;
    } else {
      if (! tdb->wmode) {
        _L: 
        tctdbsetecode(tdb, 2, "tctdb.c", 692, "tctdbtranbegin");
        if (tdb->mmtx) {
          tctdbunlockmethod(tdb);
        }
        return ((_Bool)0);
      }
    }
    if (! tdb->tran) {
      break;
    }
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    if (wsec > 1.0) {
      wsec = 1.0;
    }
    tcsleep(wsec);
    wsec *= (double )2;
  }
  tmp___2 = tctdbtranbeginimpl(tdb);
  if (! tmp___2) {
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((_Bool)0);
  }
  tdb->tran = (_Bool)1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return ((_Bool)1);
}
}
_Bool tctdbtrancommit(TCTDB *tdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      goto _L;
    } else {
      if (! tdb->tran) {
        _L: 
        tctdbsetecode(tdb, 2, "tctdb.c", 716, "tctdbtrancommit");
        if (tdb->mmtx) {
          tctdbunlockmethod(tdb);
        }
        return ((_Bool)0);
      }
    }
  }
  tdb->tran = (_Bool)0;
  err = (_Bool)0;
  tmp___1 = tctdbtrancommitimpl(tdb);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return ((_Bool )(! err));
}
}
_Bool tctdbtranabort(TCTDB *tdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      goto _L;
    } else {
      if (! tdb->tran) {
        _L: 
        tctdbsetecode(tdb, 2, "tctdb.c", 733, "tctdbtranabort");
        if (tdb->mmtx) {
          tctdbunlockmethod(tdb);
        }
        return ((_Bool)0);
      }
    }
  }
  tdb->tran = (_Bool)0;
  err = (_Bool)0;
  tmp___1 = tctdbtranabortimpl(tdb);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return ((_Bool )(! err));
}
}
char const   *tctdbpath(TCTDB *tdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  char const   *rv ;
  char const   *tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((char const   *)((void *)0));
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 750, "tctdbpath");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((char const   *)((void *)0));
  }
  tmp___1 = tchdbpath(tdb->hdb);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
uint64_t tctdbrnum(TCTDB *tdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint64_t rv ;
  uint64_t tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0ULL);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 765, "tctdbrnum");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return (0ULL);
  }
  tmp___1 = tchdbrnum(tdb->hdb);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
uint64_t tctdbfsiz(TCTDB *tdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  uint64_t rv ;
  uint64_t tmp___1 ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  uint64_t tmp___2 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (0ULL);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 780, "tctdbfsiz");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return (0ULL);
  }
  tmp___1 = tchdbfsiz(tdb->hdb);
  rv = tmp___1;
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    switch (idx->type) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    tmp___2 = tcbdbfsiz((TCBDB *)idx->db);
    rv += tmp___2;
    break;
    }
    i ++;
  }
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbsetindex(TCTDB *tdb , char const   *name , int type ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  double iccsync ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      goto _L;
    } else {
      if (tdb->tran) {
        _L: 
        tctdbsetecode(tdb, 2, "tctdb.c", 808, "tctdbsetindex");
        if (tdb->mmtx) {
          tctdbunlockmethod(tdb);
        }
        return ((_Bool)0);
      }
    }
  }
  err = (_Bool)0;
  iccsync = tdb->iccsync;
  tdb->iccsync = 1.0;
  tmp___1 = tctdbsetindeximpl(tdb, name, type);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  tmp___2 = tctdbmemsync(tdb, (_Bool)0);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  tdb->iccsync = iccsync;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return ((_Bool )(! err));
}
}
int64_t tctdbgenuid(TCTDB *tdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  int64_t rv ;
  int64_t tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (-1LL);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      _L: 
      tctdbsetecode(tdb, 2, "tctdb.c", 828, "tctdbgenuid");
      if (tdb->mmtx) {
        tctdbunlockmethod(tdb);
      }
      return (-1LL);
    }
  }
  tmp___1 = tctdbgenuidimpl(tdb, 1LL);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
TDBQRY *tctdbqrynew(TCTDB *tdb ) 
{ TDBQRY *qry ;
  void *tmp ;
  TDBCOND *tmp___0 ;
  void *tmp___1 ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*qry)));
    qry = (TDBQRY *)tmp;
    if (! qry) {
      tcmyfatal("out of memory");
    }
    break;
  }
  qry->tdb = tdb;
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(*(qry->conds + 0)) * 2));
    tmp___0 = (TDBCOND *)tmp___1;
    qry->conds = tmp___0;
    if (! tmp___0) {
      tcmyfatal("out of memory");
    }
    break;
  }
  qry->cnum = 0;
  qry->oname = (char *)((void *)0);
  qry->otype = 0;
  qry->max = 2147483647;
  qry->skip = 0;
  qry->hint = tcxstrnew3(256);
  qry->count = 0;
  return (qry);
}
}
void tctdbqrydel(TDBQRY *qry ) 
{ TDBCOND *conds ;
  int cnum ;
  int i ;
  TDBCOND *cond ;
  TDBFTSUNIT *ftsunits ;
  int ftsnum ;
  int j ;
  TDBFTSUNIT *ftsunit ;

  {
  tcxstrdel(qry->hint);
  while (1) {
    free((void *)qry->oname);
    break;
  }
  conds = qry->conds;
  cnum = qry->cnum;
  i = 0;
  while (i < cnum) {
    cond = conds + i;
    if (cond->ftsunits) {
      ftsunits = (TDBFTSUNIT *)cond->ftsunits;
      ftsnum = cond->ftsnum;
      j = 0;
      while (j < ftsnum) {
        ftsunit = ftsunits + j;
        tclistdel(ftsunit->tokens);
        j ++;
      }
      while (1) {
        free((void *)ftsunits);
        break;
      }
    }
    if (cond->regex) {
      regfree((regex_t *)cond->regex);
      while (1) {
        free(cond->regex);
        break;
      }
    }
    while (1) {
      free((void *)cond->expr);
      break;
    }
    while (1) {
      free((void *)cond->name);
      break;
    }
    i ++;
  }
  while (1) {
    free((void *)conds);
    break;
  }
  while (1) {
    free((void *)qry);
    break;
  }
  return;
}
}
void tctdbqryaddcond(TDBQRY *qry , char const   *name , int op , char const   *expr ) 
{ int cnum ;
  TDBCOND *tmp ;
  void *tmp___0 ;
  TDBCOND *cond ;
  int nsiz ;
  size_t tmp___1 ;
  int esiz ;
  size_t tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  _Bool sign ;
  _Bool noidx ;
  char *tmp___5 ;
  void *tmp___6 ;
  char const   *rxstr ;
  int rxopt ;
  regex_t rxbuf ;
  void *tmp___7 ;
  int tmp___8 ;
  TDBFTSUNIT *tmp___9 ;

  {
  cnum = qry->cnum;
  while (1) {
    tmp___0 = realloc((void *)qry->conds, (unsigned int )((int )sizeof(*(qry->conds + 0)) * (cnum + 1)));
    tmp = (TDBCOND *)tmp___0;
    qry->conds = tmp;
    if (! tmp) {
      tcmyfatal("out of memory");
    }
    break;
  }
  cond = qry->conds + cnum;
  tmp___1 = strlen(name);
  nsiz = (int )tmp___1;
  tmp___2 = strlen(expr);
  esiz = (int )tmp___2;
  while (1) {
    while (1) {
      tmp___4 = malloc((unsigned int )(nsiz + 1));
      tmp___3 = (char *)tmp___4;
      cond->name = tmp___3;
      if (! tmp___3) {
        tcmyfatal("out of memory");
      }
      break;
    }
    memcpy((void * __restrict  )cond->name, (void const   * __restrict  )name, (unsigned int )nsiz);
    *(cond->name + nsiz) = (char )'\000';
    break;
  }
  cond->nsiz = nsiz;
  sign = (_Bool)1;
  if (op & 16777216) {
    op &= -16777217;
    sign = (_Bool)0;
  }
  noidx = (_Bool)0;
  if (op & 33554432) {
    op &= -33554433;
    noidx = (_Bool)1;
  }
  cond->op = op;
  cond->sign = sign;
  cond->noidx = noidx;
  while (1) {
    while (1) {
      tmp___6 = malloc((unsigned int )(esiz + 1));
      tmp___5 = (char *)tmp___6;
      cond->expr = tmp___5;
      if (! tmp___5) {
        tcmyfatal("out of memory");
      }
      break;
    }
    memcpy((void * __restrict  )cond->expr, (void const   * __restrict  )expr, (unsigned int )esiz);
    *(cond->expr + esiz) = (char )'\000';
    break;
  }
  cond->esiz = esiz;
  cond->regex = (void *)0;
  if (op == 7) {
    rxstr = expr;
    rxopt = 1 | (((1 << 1) << 1) << 1);
    if ((int const   )*rxstr == 42) {
      rxopt |= 1 << 1;
      rxstr ++;
    }
    tmp___8 = regcomp((regex_t * __restrict  )(& rxbuf), (char const   * __restrict  )rxstr,
                      rxopt);
    if (tmp___8 == 0) {
      while (1) {
        tmp___7 = malloc((unsigned int )((int )sizeof(rxbuf)));
        cond->regex = tmp___7;
        if (! tmp___7) {
          tcmyfatal("out of memory");
        }
        break;
      }
      memcpy((void * __restrict  )cond->regex, (void const   * __restrict  )(& rxbuf),
             (unsigned int )((int )sizeof(rxbuf)));
    }
  }
  cond->ftsunits = (void *)0;
  cond->ftsnum = 0;
  if (op >= 15) {
    if (op <= 18) {
      cond->op = 15;
      tmp___9 = tctdbftsparseexpr(expr, esiz, op, & cond->ftsnum);
      cond->ftsunits = (void *)tmp___9;
    }
  }
  (qry->cnum) ++;
  return;
}
}
void tctdbqrysetorder(TDBQRY *qry , char const   *name , int type ) 
{ 

  {
  if (qry->oname) {
    while (1) {
      free((void *)qry->oname);
      break;
    }
  }
  qry->oname = tcstrdup((void const   *)name);
  qry->otype = type;
  return;
}
}
void tctdbqrysetlimit(TDBQRY *qry , int max , int skip ) 
{ 

  {
  if (max >= 0) {
    qry->max = max;
  } else {
    qry->max = 2147483647;
  }
  if (skip > 0) {
    qry->skip = skip;
  } else {
    qry->skip = 0;
  }
  return;
}
}
TCLIST *tctdbqrysearch(TDBQRY *qry ) 
{ TCTDB *tdb ;
  TCLIST *tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  TCLIST *tmp___2 ;
  TCLIST *rv ;
  TCLIST *tmp___3 ;

  {
  tdb = qry->tdb;
  if (tdb->mmtx) {
    tmp___0 = tctdblockmethod(tdb, (_Bool)0);
    tmp___1 = (int )tmp___0;
  } else {
    tmp___1 = 1;
  }
  if (! tmp___1) {
    tmp = tclistnew();
    return (tmp);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 958, "tctdbqrysearch");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    tmp___2 = tclistnew();
    return (tmp___2);
  }
  tmp___3 = tctdbqrysearchimpl(qry);
  rv = tmp___3;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbqrysearchout(TDBQRY *qry ) 
{ _Bool tmp ;

  {
  tmp = tctdbqryproc(qry, & tctdbqryprocoutcb, (void *)0);
  return (tmp);
}
}
_Bool tctdbqryproc(TDBQRY *qry , int (*proc___0)(void const   *pkbuf , int pksiz ,
                                                 TCMAP *cols , void *op ) , void *op ) 
{ TCTDB *tdb ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  int64_t getnum ;
  int64_t putnum ;
  int64_t outnum ;
  TCLIST *res ;
  TCLIST *tmp___1 ;
  int rnum ;
  int i ;
  char const   *pkbuf ;
  int pksiz ;
  TCMAP *cols ;
  TCMAP *tmp___2 ;
  int flags ;
  int tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  tdb = qry->tdb;
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      _L: 
      tctdbsetecode(tdb, 2, "tctdb.c", 981, "tctdbqryproc");
      if (tdb->mmtx) {
        tctdbunlockmethod(tdb);
      }
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  getnum = 0LL;
  putnum = 0LL;
  outnum = 0LL;
  tmp___1 = tctdbqrysearchimpl(qry);
  res = tmp___1;
  rnum = res->num;
  i = 0;
  while (i < rnum) {
    while (1) {
      pkbuf = (char const   *)(res->array + (i + res->start))->ptr;
      pksiz = (res->array + (i + res->start))->size;
      break;
    }
    tmp___2 = tctdbgetimpl(tdb, (void const   *)pkbuf, pksiz);
    cols = tmp___2;
    if (! cols) {
      err = (_Bool)1;
      goto __Cont;
    }
    getnum ++;
    tmp___3 = (*proc___0)((void const   *)pkbuf, pksiz, cols, op);
    flags = tmp___3;
    if (flags & 1) {
      tmp___4 = tctdbputimpl(tdb, (void const   *)pkbuf, pksiz, cols, 0);
      if (tmp___4) {
        putnum ++;
      } else {
        err = (_Bool)1;
      }
    } else {
      if (flags & 2) {
        tmp___5 = tctdboutimpl(tdb, pkbuf, pksiz);
        if (tmp___5) {
          outnum ++;
        } else {
          err = (_Bool)1;
        }
      }
    }
    tcmapdel(cols);
    if (flags & 16777216) {
      break;
    }
    __Cont: 
    i ++;
  }
  tclistdel(res);
  tcxstrprintf(qry->hint, "post treatment: get=%lld, put=%lld, out=%lld\n", getnum,
               putnum, outnum);
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return ((_Bool )(! err));
}
}
char const   *tctdbqryhint(TDBQRY *qry ) 
{ void const   *tmp ;

  {
  tmp = tcxstrptr((TCXSTR const   *)qry->hint);
  return ((char const   *)tmp);
}
}
TCLIST *tctdbmetasearch(TDBQRY **qrys , int num , int type ) 
{ TCLIST *tmp ;
  TCLIST *tmp___0 ;
  char const   *oname ;
  int onsiz ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int otype ;
  TCMAP *uset ;
  TCMAP *tmp___3 ;
  int i ;
  TDBQRY *qry ;
  TCTDB *tdb ;
  TCLIST *res ;
  TCLIST *tmp___4 ;
  int rnum ;
  int j ;
  char const   *pkbuf ;
  int pksiz ;
  int csiz ;
  char *cbuf ;
  char *tmp___5 ;
  TCLIST *res___0 ;
  TCLIST *tmp___6 ;
  int rnum___0 ;
  int i___0 ;
  char const   *pkbuf___0 ;
  int pksiz___0 ;
  int i___1 ;
  TDBQRY *qry___0 ;
  TCMAP *nset ;
  long tmp___7 ;
  TCMAP *tmp___8 ;
  int j___0 ;
  char const   *pkbuf___1 ;
  int pksiz___1 ;
  int vsiz ;
  void const   *tmp___9 ;
  TCLIST *res___1 ;
  TCLIST *tmp___10 ;
  int rnum___1 ;
  int i___2 ;
  char const   *pkbuf___2 ;
  int pksiz___2 ;
  int i___3 ;
  TDBQRY *qry___1 ;
  int j___1 ;
  char const   *pkbuf___3 ;
  int pksiz___3 ;
  TCLIST *res___2 ;
  int rnum___2 ;
  TDBSORTKEY *keys ;
  void *tmp___11 ;
  char const   *pkbuf___4 ;
  int pksiz___4 ;
  TDBSORTKEY *key ;
  int vsiz___0 ;
  char const   *vbuf ;
  void const   *tmp___12 ;
  void const   *tmp___13 ;
  int (*compar)(TDBSORTKEY const   *a , TDBSORTKEY const   *b ) ;
  int i___4 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___14 ;
  void *tmp___15 ;
  TCLISTDATUM *array ;
  char *tmp___16 ;
  void *tmp___17 ;
  TCXSTR *hint ;
  TCXSTR *tmp___18 ;
  int i___5 ;
  TDBQRY *qry___2 ;
  TCLIST *lines ;
  char const   *tmp___19 ;
  TCLIST *tmp___20 ;
  int lnum ;
  int j___2 ;
  char const   *line ;
  int TC_mysize___0 ;
  int TC_nsize ;
  char *tmp___21 ;
  void *tmp___22 ;

  {
  if (num < 1) {
    tmp = tclistnew2(1);
    return (tmp);
  }
  if (num < 2) {
    tmp___0 = tctdbqrysearch(*(qrys + 0));
    return (tmp___0);
  }
  oname = (char const   *)(*(qrys + 0))->oname;
  if (oname) {
    tmp___1 = strlen(oname);
    tmp___2 = tmp___1;
  } else {
    tmp___2 = 0U;
  }
  onsiz = (int )tmp___2;
  otype = (*(qrys + 0))->otype;
  tmp___3 = tcmapnew();
  uset = tmp___3;
  if (type == 0) {
    i = 0;
    while (i < num) {
      qry = *(qrys + i);
      tdb = qry->tdb;
      tmp___4 = tctdbqrysearch(qry);
      res = tmp___4;
      rnum = res->num;
      j = 0;
      while (j < rnum) {
        while (1) {
          pkbuf = (char const   *)(res->array + (j + res->start))->ptr;
          pksiz = (res->array + (j + res->start))->size;
          break;
        }
        if (oname) {
          tmp___5 = tctdbget4(tdb, (void const   *)pkbuf, pksiz, (void const   *)oname,
                              onsiz, & csiz);
          cbuf = tmp___5;
          if (cbuf) {
            tcmapput4(uset, (void const   *)pkbuf, pksiz, (void const   *)"=", 1,
                      (void const   *)cbuf, csiz);
            while (1) {
              free((void *)cbuf);
              break;
            }
          } else {
            tcmapput(uset, (void const   *)pkbuf, pksiz, (void const   *)"*", 1);
          }
        } else {
          tcmapputkeep(uset, (void const   *)pkbuf, pksiz, (void const   *)"", 0);
        }
        j ++;
      }
      tclistdel(res);
      i ++;
    }
  } else {
    if (type == 1) {
      tmp___6 = tctdbqrysearch(*(qrys + 0));
      res___0 = tmp___6;
      rnum___0 = res___0->num;
      i___0 = 0;
      while (i___0 < rnum___0) {
        while (1) {
          pkbuf___0 = (char const   *)(res___0->array + (i___0 + res___0->start))->ptr;
          pksiz___0 = (res___0->array + (i___0 + res___0->start))->size;
          break;
        }
        tcmapputkeep(uset, (void const   *)pkbuf___0, pksiz___0, (void const   *)"",
                     0);
        i___0 ++;
      }
      tclistdel(res___0);
      i___1 = 1;
      while (i___1 < num) {
        qry___0 = *(qrys + i___1);
        if (uset->rnum < 1ULL) {
          tcxstrclear(qry___0->hint);
          tcxstrprintf(qry___0->hint, "omitted\n");
          goto __Cont;
        }
        res___0 = tctdbqrysearch(qry___0);
        rnum___0 = res___0->num;
        tmp___7 = tclmin((long )uset->rnum, (long )rnum___0);
        tmp___8 = tcmapnew2((unsigned int )(tmp___7 + 1L));
        nset = tmp___8;
        j___0 = 0;
        while (j___0 < rnum___0) {
          while (1) {
            pkbuf___1 = (char const   *)(res___0->array + (j___0 + res___0->start))->ptr;
            pksiz___1 = (res___0->array + (j___0 + res___0->start))->size;
            break;
          }
          tmp___9 = tcmapget((TCMAP const   *)uset, (void const   *)pkbuf___1, pksiz___1,
                             & vsiz);
          if (tmp___9) {
            tcmapputkeep(nset, (void const   *)pkbuf___1, pksiz___1, (void const   *)"",
                         0);
          }
          j___0 ++;
        }
        tcmapdel(uset);
        uset = nset;
        tclistdel(res___0);
        __Cont: 
        i___1 ++;
      }
    } else {
      if (type == 2) {
        tmp___10 = tctdbqrysearch(*(qrys + 0));
        res___1 = tmp___10;
        rnum___1 = res___1->num;
        i___2 = 0;
        while (i___2 < rnum___1) {
          while (1) {
            pkbuf___2 = (char const   *)(res___1->array + (i___2 + res___1->start))->ptr;
            pksiz___2 = (res___1->array + (i___2 + res___1->start))->size;
            break;
          }
          tcmapputkeep(uset, (void const   *)pkbuf___2, pksiz___2, (void const   *)"",
                       0);
          i___2 ++;
        }
        tclistdel(res___1);
        i___3 = 1;
        while (i___3 < num) {
          qry___1 = *(qrys + i___3);
          if (uset->rnum < 1ULL) {
            tcxstrclear(qry___1->hint);
            tcxstrprintf(qry___1->hint, "omitted\n");
            goto __Cont___0;
          }
          res___1 = tctdbqrysearch(qry___1);
          rnum___1 = res___1->num;
          j___1 = 0;
          while (j___1 < rnum___1) {
            while (1) {
              pkbuf___3 = (char const   *)(res___1->array + (j___1 + res___1->start))->ptr;
              pksiz___3 = (res___1->array + (j___1 + res___1->start))->size;
              break;
            }
            tcmapout(uset, (void const   *)pkbuf___3, pksiz___3);
            j___1 ++;
          }
          tclistdel(res___1);
          __Cont___0: 
          i___3 ++;
        }
      }
    }
  }
  if (oname) {
    if (type == 0) {
      rnum___2 = (int )uset->rnum;
      while (1) {
        tmp___11 = malloc((unsigned int )((int )sizeof(*keys) * rnum___2 + 1));
        keys = (TDBSORTKEY *)tmp___11;
        if (! keys) {
          tcmyfatal("out of memory");
        }
        break;
      }
      tcmapiterinit(uset);
      key = keys;
      while (1) {
        tmp___13 = tcmapiternext(uset, & pksiz___4);
        pkbuf___4 = (char const   *)tmp___13;
        if (! ((unsigned int )pkbuf___4 != (unsigned int )((void *)0))) {
          break;
        }
        tmp___12 = tcmapiterval((void const   *)pkbuf___4, & vsiz___0);
        vbuf = (char const   *)tmp___12;
        key->kbuf = pkbuf___4;
        key->ksiz = pksiz___4;
        if ((int const   )*vbuf == 61) {
          key->vbuf = (char *)vbuf + 1;
          key->vsiz = vsiz___0 - 1;
        } else {
          key->vbuf = (char *)((void *)0);
          key->vsiz = 0;
        }
        key ++;
      }
      compar = (int (*)(TDBSORTKEY const   *a , TDBSORTKEY const   *b ))((void *)0);
      switch (otype) {
      case 0: 
      compar = & tdbcmpsortkeystrasc;
      break;
      case 1: 
      compar = & tdbcmpsortkeystrdesc;
      break;
      case 2: 
      compar = & tdbcmpsortkeynumasc;
      break;
      case 3: 
      compar = & tdbcmpsortkeynumdesc;
      break;
      }
      if (compar) {
        qsort((void *)keys, (unsigned int )rnum___2, (unsigned int )((int )sizeof(*keys)),
              (int (*)(void const   * , void const   * ))compar);
      }
      res___2 = tclistnew2(rnum___2);
      i___4 = 0;
      while (i___4 < rnum___2) {
        key = keys + i___4;
        while (1) {
          TC_mysize = key->ksiz;
          TC_index = res___2->start + res___2->num;
          if (TC_index >= res___2->anum) {
            res___2->anum += res___2->num + 1;
            while (1) {
              tmp___15 = realloc((void *)res___2->array, (unsigned int )(res___2->anum * (int )sizeof(*(res___2->array + 0))));
              tmp___14 = (TCLISTDATUM *)tmp___15;
              res___2->array = tmp___14;
              if (! tmp___14) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          array = res___2->array;
          while (1) {
            tmp___17 = malloc((unsigned int )(TC_mysize + 1));
            tmp___16 = (char *)tmp___17;
            (array + TC_index)->ptr = tmp___16;
            if (! tmp___16) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )key->kbuf,
                 (unsigned int )TC_mysize);
          *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
          (array + TC_index)->size = TC_mysize;
          (res___2->num) ++;
          break;
        }
        i___4 ++;
      }
      while (1) {
        free((void *)keys);
        break;
      }
    } else {
      res___2 = tcmapkeys((TCMAP const   *)uset);
    }
  } else {
    res___2 = tcmapkeys((TCMAP const   *)uset);
  }
  tcmapdel(uset);
  tmp___18 = tcxstrnew();
  hint = tmp___18;
  i___5 = 0;
  while (i___5 < num) {
    qry___2 = *(qrys + i___5);
    tmp___19 = tctdbqryhint(qry___2);
    tmp___20 = tcstrsplit(tmp___19, "\n");
    lines = tmp___20;
    lnum = lines->num;
    j___2 = 0;
    while (j___2 < lnum) {
      line = (char const   *)((void *)(lines->array + (j___2 + lines->start))->ptr);
      if ((int const   )*line != 0) {
        tcxstrprintf(hint, "[%d] %s\n", i___5, line);
      }
      j___2 ++;
    }
    tclistdel(lines);
    tcxstrclear(qry___2->hint);
    qry___2->count = 0;
    i___5 ++;
  }
  while (1) {
    TC_mysize___0 = hint->size;
    TC_nsize = (((*(qrys + 0))->hint)->size + TC_mysize___0) + 1;
    if (((*(qrys + 0))->hint)->asize < TC_nsize) {
      while (((*(qrys + 0))->hint)->asize < TC_nsize) {
        ((*(qrys + 0))->hint)->asize *= 2;
        if (((*(qrys + 0))->hint)->asize < TC_nsize) {
          ((*(qrys + 0))->hint)->asize = TC_nsize;
        }
      }
      while (1) {
        tmp___22 = realloc((void *)((*(qrys + 0))->hint)->ptr, (unsigned int )((*(qrys + 0))->hint)->asize);
        tmp___21 = (char *)tmp___22;
        ((*(qrys + 0))->hint)->ptr = tmp___21;
        if (! tmp___21) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    memcpy((void * __restrict  )(((*(qrys + 0))->hint)->ptr + ((*(qrys + 0))->hint)->size),
           (void const   * __restrict  )hint->ptr, (unsigned int )TC_mysize___0);
    ((*(qrys + 0))->hint)->size += TC_mysize___0;
    *(((*(qrys + 0))->hint)->ptr + ((*(qrys + 0))->hint)->size) = (char )'\000';
    break;
  }
  (*(qrys + 0))->count = res___2->num;
  tcxstrdel(hint);
  return (res___2);
}
}
void tctdbsetecode(TCTDB *tdb , int ecode , char const   *filename , int line , char const   *func ) 
{ 

  {
  tchdbsetecode(tdb->hdb, ecode, filename, line, func);
  return;
}
}
void tctdbsetdbgfd(TCTDB *tdb , int fd ) 
{ 

  {
  tchdbsetdbgfd(tdb->hdb, fd);
  return;
}
}
int tctdbdbgfd(TCTDB *tdb ) 
{ int tmp ;

  {
  tmp = tchdbdbgfd(tdb->hdb);
  return (tmp);
}
}
_Bool tctdbhasmutex(TCTDB *tdb ) 
{ 

  {
  return ((_Bool )((unsigned int )tdb->mmtx != (unsigned int )((void *)0)));
}
}
_Bool tctdbmemsync(TCTDB *tdb , _Bool phys ) 
{ _Bool err ;
  _Bool tmp ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  _Bool tmp___0 ;
  int i___0 ;
  TDBIDX *idx___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;

  {
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1233, "tctdbmemsync");
    return ((_Bool)0);
  } else {
    if (! tdb->wmode) {
      tctdbsetecode(tdb, 2, "tctdb.c", 1233, "tctdbmemsync");
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  tmp = tchdbmemsync(tdb->hdb, phys);
  if (! tmp) {
    err = (_Bool)1;
  }
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    switch (idx->type) {
    case 2: 
    case 3: 
    tmp___0 = tctdbidxsyncicc(tdb, idx, (_Bool)1);
    if (! tmp___0) {
      err = (_Bool)1;
    }
    break;
    }
    i ++;
  }
  i___0 = 0;
  while (i___0 < inum) {
    idx___0 = idxs + i___0;
    switch (idx___0->type) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    tmp___2 = tcbdbmemsync((TCBDB *)idx___0->db, phys);
    if (! tmp___2) {
      tmp___1 = tcbdbecode((TCBDB *)idx___0->db);
      tctdbsetecode(tdb, tmp___1, "tctdb.c", 1257, "tctdbmemsync");
      err = (_Bool)1;
    }
    break;
    }
    i___0 ++;
  }
  return ((_Bool )(! err));
}
}
uint64_t tctdbbnum(TCTDB *tdb ) 
{ uint64_t tmp ;

  {
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1271, "tctdbbnum");
    return (0ULL);
  }
  tmp = tchdbbnum(tdb->hdb);
  return (tmp);
}
}
uint32_t tctdbalign(TCTDB *tdb ) 
{ uint32_t tmp ;

  {
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1282, "tctdbalign");
    return (0U);
  }
  tmp = tchdbalign(tdb->hdb);
  return (tmp);
}
}
uint32_t tctdbfbpmax(TCTDB *tdb ) 
{ uint32_t tmp ;

  {
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1293, "tctdbfbpmax");
    return (0U);
  }
  tmp = tchdbfbpmax(tdb->hdb);
  return (tmp);
}
}
uint64_t tctdbinode(TCTDB *tdb ) 
{ uint64_t tmp ;

  {
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1304, "tctdbinode");
    return (0ULL);
  }
  tmp = tchdbinode(tdb->hdb);
  return (tmp);
}
}
time_t tctdbmtime(TCTDB *tdb ) 
{ time_t tmp ;

  {
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1315, "tctdbmtime");
    return (0L);
  }
  tmp = tchdbmtime(tdb->hdb);
  return (tmp);
}
}
uint8_t tctdbflags(TCTDB *tdb ) 
{ uint8_t tmp ;

  {
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1326, "tctdbflags");
    return ((unsigned char)0);
  }
  tmp = tchdbflags(tdb->hdb);
  return (tmp);
}
}
uint8_t tctdbopts(TCTDB *tdb ) 
{ 

  {
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1337, "tctdbopts");
    return ((unsigned char)0);
  }
  return (tdb->opts);
}
}
char *tctdbopaque(TCTDB *tdb ) 
{ char *tmp ;

  {
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1348, "tctdbopaque");
    return ((char *)((void *)0));
  }
  tmp = tchdbopaque(tdb->hdb);
  return (tmp + 64);
}
}
uint64_t tctdbbnumused(TCTDB *tdb ) 
{ uint64_t tmp ;

  {
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1359, "tctdbbnumused");
    return (0ULL);
  }
  tmp = tchdbbnumused(tdb->hdb);
  return (tmp);
}
}
int tctdbinum(TCTDB *tdb ) 
{ 

  {
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1370, "tctdbinum");
    return (0);
  }
  return (tdb->inum);
}
}
int64_t tctdbuidseed(TCTDB *tdb ) 
{ _Bool tmp ;
  int tmp___0 ;
  int64_t rv ;
  int64_t tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return (-1LL);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1382, "tctdbuidseed");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return (-1LL);
  }
  tmp___1 = tctdbgenuidimpl(tdb, 0LL);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbsetinvcache(TCTDB *tdb , int64_t iccmax , double iccsync ) 
{ 

  {
  if (tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1396, "tctdbsetinvcache");
    return ((_Bool)0);
  }
  if (iccmax > 0LL) {
    tdb->iccmax = iccmax;
  } else {
    tdb->iccmax = 64LL << 20;
  }
  if (iccsync > (double )0) {
    tdb->iccsync = iccsync;
  } else {
    tdb->iccsync = 0.01;
  }
  return ((_Bool)1);
}
}
_Bool tctdbsetuidseed(TCTDB *tdb , int64_t seed___0 ) 
{ _Bool tmp ;
  int tmp___0 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)1);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      _L: 
      tctdbsetecode(tdb, 2, "tctdb.c", 1410, "tctdbsetuidseed");
      if (tdb->mmtx) {
        tctdbunlockmethod(tdb);
      }
      return ((_Bool)0);
    }
  }
  tctdbgenuidimpl(tdb, - seed___0 - 1LL);
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return ((_Bool)1);
}
}
_Bool tctdbsetcodecfunc(TCTDB *tdb , void *(*enc)(void const   *ptr , int size , int *sp ,
                                                  void *op ) , void *encop , void *(*dec)(void const   *ptr ,
                                                                                          int size ,
                                                                                          int *sp ,
                                                                                          void *op ) ,
                        void *decop ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1425, "tctdbsetcodecfunc");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tchdbsetcodecfunc(tdb->hdb, enc, encop, dec, decop);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
uint32_t tctdbdfunit(TCTDB *tdb ) 
{ uint32_t tmp ;

  {
  tmp = tchdbdfunit(tdb->hdb);
  return (tmp);
}
}
_Bool tctdbdefrag(TCTDB *tdb , int64_t step ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      _L: 
      tctdbsetecode(tdb, 2, "tctdb.c", 1447, "tctdbdefrag");
      if (tdb->mmtx) {
        tctdbunlockmethod(tdb);
      }
      return ((_Bool)0);
    }
  }
  tmp___1 = tctdbdefragimpl(tdb, step);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbputproc(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *cbuf ,
                   int csiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool err ;
  TCMAP *cols ;
  TCMAP *tmp___1 ;
  int zsiz ;
  char *zbuf ;
  void *tmp___2 ;
  int ncsiz ;
  void *ncbuf ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  TCMAP *ncols ;
  TCMAP *tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    goto _L;
  } else {
    if (! tdb->wmode) {
      _L: 
      tctdbsetecode(tdb, 2, "tctdb.c", 1463, "tctdbputproc");
      if (tdb->mmtx) {
        tctdbunlockmethod(tdb);
      }
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  tmp___1 = tctdbgetimpl(tdb, pkbuf, pksiz);
  cols = tmp___1;
  if (cols) {
    tmp___2 = tcstrjoin4((TCMAP const   *)cols, & zsiz);
    zbuf = (char *)tmp___2;
    tmp___3 = (*proc___0)((void const   *)zbuf, zsiz, & ncsiz, op);
    ncbuf = tmp___3;
    if ((unsigned int )ncbuf == (unsigned int )((void *)-1)) {
      tmp___4 = tctdboutimpl(tdb, (char const   *)pkbuf, pksiz);
      if (! tmp___4) {
        err = (_Bool)1;
      }
    } else {
      if (ncbuf) {
        tmp___5 = tcstrsplit4((void const   *)ncbuf, ncsiz);
        ncols = tmp___5;
        tmp___6 = tctdbputimpl(tdb, pkbuf, pksiz, ncols, 0);
        if (! tmp___6) {
          err = (_Bool)1;
        }
        tcmapdel(ncols);
        while (1) {
          free(ncbuf);
          break;
        }
      } else {
        tctdbsetecode(tdb, 21, "tctdb.c", 1482, "tctdbputproc");
        err = (_Bool)1;
      }
    }
    while (1) {
      free((void *)zbuf);
      break;
    }
    tcmapdel(cols);
  } else {
    if (cbuf) {
      cols = tcstrsplit4(cbuf, csiz);
      tmp___7 = tctdbputimpl(tdb, pkbuf, pksiz, cols, 0);
      if (! tmp___7) {
        err = (_Bool)1;
      }
      tcmapdel(cols);
    } else {
      tctdbsetecode(tdb, 22, "tctdb.c", 1493, "tctdbputproc");
      err = (_Bool)1;
    }
  }
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return ((_Bool )(! err));
}
}
char *tctdbget4(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *nbuf ,
                int nsiz , int *sp ) 
{ _Bool tmp ;
  int tmp___0 ;
  char *rv ;
  char *tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((char *)((void *)0));
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1507, "tctdbget4");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((char *)((void *)0));
  }
  tmp___1 = tctdbgetonecol(tdb, pkbuf, pksiz, nbuf, nsiz, sp);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbiterinit2(TCTDB *tdb , void const   *pkbuf , int pksiz ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)1);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1522, "tctdbiterinit2");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((_Bool)0);
  }
  tmp___1 = tchdbiterinit2(tdb->hdb, pkbuf, pksiz);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbiterinit3(TCTDB *tdb , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tctdbiterinit2(tdb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
_Bool tctdbforeach(TCTDB *tdb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                              int vsiz , void *op ) , void *op ) 
{ _Bool tmp ;
  int tmp___0 ;
  _Bool rv ;
  _Bool tmp___1 ;

  {
  if (tdb->mmtx) {
    tmp = tctdblockmethod(tdb, (_Bool)0);
    tmp___0 = (int )tmp;
  } else {
    tmp___0 = 1;
  }
  if (! tmp___0) {
    return ((_Bool)0);
  }
  if (! tdb->open) {
    tctdbsetecode(tdb, 2, "tctdb.c", 1544, "tctdbforeach");
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    return ((_Bool)0);
  }
  while (1) {
    if (tdb->mmtx) {
      sched_yield();
    }
    break;
  }
  tmp___1 = tctdbforeachimpl(tdb, iter, op);
  rv = tmp___1;
  if (tdb->mmtx) {
    tctdbunlockmethod(tdb);
  }
  return (rv);
}
}
_Bool tctdbqryproc2(TDBQRY *qry , int (*proc___0)(void const   *pkbuf , int pksiz ,
                                                  TCMAP *cols , void *op ) , void *op ) 
{ TCTDB *tdb ;
  TDBCOND *conds ;
  int cnum ;
  _Bool err ;
  int64_t getnum ;
  int64_t putnum ;
  int64_t outnum ;
  TCLIST *res ;
  TCLIST *tmp ;
  int rnum ;
  int i ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int pksiz ;
  char const   *pkbuf ;
  TCMAP *cols ;
  TCMAP *tmp___2 ;
  _Bool ok ;
  int j ;
  TDBCOND *cond ;
  _Bool tmp___3 ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___4 ;
  _Bool tmp___5 ;
  int flags ;
  int tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
  tdb = qry->tdb;
  conds = qry->conds;
  cnum = qry->cnum;
  err = (_Bool)0;
  getnum = 0LL;
  putnum = 0LL;
  outnum = 0LL;
  tmp = tctdbqrysearch(qry);
  res = tmp;
  rnum = res->num;
  i = 0;
  while (i < rnum) {
    if (tdb->mmtx) {
      tmp___0 = tctdblockmethod(tdb, (_Bool)1);
      tmp___1 = (int )tmp___0;
    } else {
      tmp___1 = 1;
    }
    if (! tmp___1) {
      err = (_Bool)1;
      break;
    }
    if (! tdb->open) {
      goto _L;
    } else {
      if (! tdb->wmode) {
        _L: 
        tctdbsetecode(tdb, 2, "tctdb.c", 1573, "tctdbqryproc2");
        if (tdb->mmtx) {
          tctdbunlockmethod(tdb);
        }
        err = (_Bool)1;
        break;
      }
    }
    while (1) {
      pkbuf = (char const   *)(res->array + (i + res->start))->ptr;
      pksiz = (res->array + (i + res->start))->size;
      break;
    }
    tmp___2 = tctdbgetimpl(tdb, (void const   *)pkbuf, pksiz);
    cols = tmp___2;
    if (cols) {
      getnum ++;
      ok = (_Bool)1;
      j = 0;
      while (j < cnum) {
        cond = conds + j;
        if (cond->nsiz < 1) {
          tmp___3 = tctdbqrycondmatch(cond, pkbuf, pksiz);
          if ((int )tmp___3 != (int )cond->sign) {
            ok = (_Bool)0;
            break;
          }
        } else {
          tmp___4 = tcmapget((TCMAP const   *)cols, (void const   *)cond->name, cond->nsiz,
                             & vsiz);
          vbuf = (char const   *)tmp___4;
          if (vbuf) {
            tmp___5 = tctdbqrycondmatch(cond, vbuf, vsiz);
            if ((int )tmp___5 != (int )cond->sign) {
              ok = (_Bool)0;
              break;
            }
          } else {
            if (cond->sign) {
              ok = (_Bool)0;
              break;
            }
          }
        }
        j ++;
      }
      if (ok) {
        tmp___6 = (*proc___0)((void const   *)pkbuf, pksiz, cols, op);
        flags = tmp___6;
        if (flags & 1) {
          tmp___7 = tctdbputimpl(tdb, (void const   *)pkbuf, pksiz, cols, 0);
          if (tmp___7) {
            putnum ++;
          } else {
            err = (_Bool)1;
          }
        } else {
          if (flags & 2) {
            tmp___8 = tctdboutimpl(tdb, pkbuf, pksiz);
            if (tmp___8) {
              outnum ++;
            } else {
              err = (_Bool)1;
            }
          }
        }
        if (flags & 16777216) {
          i = rnum;
        }
      }
      tcmapdel(cols);
    }
    if (tdb->mmtx) {
      tctdbunlockmethod(tdb);
    }
    i ++;
  }
  tclistdel(res);
  tcxstrprintf(qry->hint, "post treatment: get=%lld, put=%lld, out=%lld\n", getnum,
               putnum, outnum);
  return ((_Bool )(! err));
}
}
_Bool tctdbqrysearchout2(TDBQRY *qry ) 
{ _Bool tmp ;

  {
  tmp = tctdbqryproc2(qry, & tctdbqryprocoutcb, (void *)0);
  return (tmp);
}
}
int tctdbstrtoindextype(char const   *str ) 
{ int type ;
  int flags ;
  int64_t tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
  type = -1;
  flags = 0;
  if ((int const   )*str == 43) {
    flags |= 16777216;
    str ++;
  }
  tmp___13 = tcstricmp(str, "LEX");
  if (tmp___13) {
    tmp___14 = tcstricmp(str, "LEXICAL");
    if (tmp___14) {
      tmp___15 = tcstricmp(str, "STR");
      if (tmp___15) {
        tmp___10 = tcstricmp(str, "DEC");
        if (tmp___10) {
          tmp___11 = tcstricmp(str, "DECIMAL");
          if (tmp___11) {
            tmp___12 = tcstricmp(str, "NUM");
            if (tmp___12) {
              tmp___8 = tcstricmp(str, "TOK");
              if (tmp___8) {
                tmp___9 = tcstricmp(str, "TOKEN");
                if (tmp___9) {
                  tmp___5 = tcstricmp(str, "QGR");
                  if (tmp___5) {
                    tmp___6 = tcstricmp(str, "QGRAM");
                    if (tmp___6) {
                      tmp___7 = tcstricmp(str, "FTS");
                      if (tmp___7) {
                        tmp___3 = tcstricmp(str, "OPT");
                        if (tmp___3) {
                          tmp___4 = tcstricmp(str, "OPTIMIZE");
                          if (tmp___4) {
                            tmp___1 = tcstricmp(str, "VOID");
                            if (tmp___1) {
                              tmp___2 = tcstricmp(str, "NULL");
                              if (tmp___2) {
                                tmp___0 = tcstrisnum(str);
                                if (tmp___0) {
                                  tmp = tcatoi(str);
                                  type = (int )tmp;
                                }
                              } else {
                                type = 9999;
                              }
                            } else {
                              type = 9999;
                            }
                          } else {
                            type = 9998;
                          }
                        } else {
                          type = 9998;
                        }
                      } else {
                        type = 3;
                      }
                    } else {
                      type = 3;
                    }
                  } else {
                    type = 3;
                  }
                } else {
                  type = 2;
                }
              } else {
                type = 2;
              }
            } else {
              type = 1;
            }
          } else {
            type = 1;
          }
        } else {
          type = 1;
        }
      } else {
        type = 0;
      }
    } else {
      type = 0;
    }
  } else {
    type = 0;
  }
  return (type | flags);
}
}
int tctdbstrtometasearcytype(char const   *str ) 
{ int type ;
  int64_t tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  type = -1;
  tmp___8 = tcstricmp(str, "UNION");
  if (tmp___8) {
    tmp___9 = tcstricmp(str, "OR");
    if (tmp___9) {
      tmp___5 = tcstricmp(str, "ISECT");
      if (tmp___5) {
        tmp___6 = tcstricmp(str, "INTERSECTION");
        if (tmp___6) {
          tmp___7 = tcstricmp(str, "AND");
          if (tmp___7) {
            tmp___1 = tcstricmp(str, "DIFF");
            if (tmp___1) {
              tmp___2 = tcstricmp(str, "DIFFERENCE");
              if (tmp___2) {
                tmp___3 = tcstricmp(str, "ANDNOT");
                if (tmp___3) {
                  tmp___4 = tcstricmp(str, "NOT");
                  if (tmp___4) {
                    tmp___0 = tcstrisnum(str);
                    if (tmp___0) {
                      tmp = tcatoi(str);
                      type = (int )tmp;
                    }
                  } else {
                    type = 2;
                  }
                } else {
                  type = 2;
                }
              } else {
                type = 2;
              }
            } else {
              type = 2;
            }
          } else {
            type = 1;
          }
        } else {
          type = 1;
        }
      } else {
        type = 1;
      }
    } else {
      type = 0;
    }
  } else {
    type = 0;
  }
  return (type);
}
}
int tctdbqrycount(TDBQRY *qry ) 
{ 

  {
  return (qry->count);
}
}
TCLIST *tctdbqrykwic(TDBQRY *qry , TCMAP *cols , char const   *name , int width ,
                     int opts ) 
{ TDBCOND *conds ;
  int cnum ;
  TDBCOND *cond ;
  int i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  TCLIST *tmp___6 ;
  char const   *str ;
  char const   *tmp___7 ;
  TCLIST *tmp___8 ;
  TCLIST *words ;
  TDBFTSUNIT *ftsunits ;
  int ftsnum ;
  int i___0 ;
  TCLIST *tokens ;
  int tnum ;
  int j ;
  char const   *token ;
  int tsiz ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___9 ;
  void *tmp___10 ;
  TCLISTDATUM *array ;
  char *tmp___11 ;
  void *tmp___12 ;
  TCLIST *texts ;
  TCLIST *tmp___13 ;

  {
  conds = qry->conds;
  cnum = qry->cnum;
  cond = (TDBCOND *)((void *)0);
  if (name) {
    i = 0;
    while (i < cnum) {
      if (0) {
        __s1_len = strlen((char const   *)(conds + i)->name);
        __s2_len = strlen(name);
        if (! ((unsigned int )((void const   *)((conds + i)->name + 1)) - (unsigned int )((void const   *)(conds + i)->name) == 1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              tmp___5 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___5 = 1;
              } else {
                tmp___5 = 0;
              }
            }
          } else {
            tmp___5 = 0;
          }
        }
        if (tmp___5) {
          tmp___0 = __builtin_strcmp((char const   *)(conds + i)->name, name);
          tmp___4 = tmp___0;
        } else {
          tmp___3 = __builtin_strcmp((char const   *)(conds + i)->name, name);
          tmp___4 = tmp___3;
        }
      } else {
        tmp___3 = __builtin_strcmp((char const   *)(conds + i)->name, name);
        tmp___4 = tmp___3;
      }
      if (! tmp___4) {
        cond = conds + i;
        break;
      }
      i ++;
    }
  } else {
    if (cnum > 0) {
      cond = conds;
      name = (char const   *)cond->name;
    }
  }
  if (! cond) {
    tmp___6 = tclistnew2(1);
    return (tmp___6);
  }
  tmp___7 = tcmapget2((TCMAP const   *)cols, name);
  str = tmp___7;
  if (! str) {
    tmp___8 = tclistnew2(1);
    return (tmp___8);
  }
  if (cond->op == 4) {
    words = tcstrsplit((char const   *)cond->expr, " ,");
  } else {
    if (cond->op == 5) {
      words = tcstrsplit((char const   *)cond->expr, " ,");
    } else {
      if (cond->op == 6) {
        words = tcstrsplit((char const   *)cond->expr, " ,");
      } else {
        if (cond->op == 14) {
          words = tcstrsplit((char const   *)cond->expr, " ,");
        } else {
          if (cond->op == 15) {
            ftsunits = (TDBFTSUNIT *)cond->ftsunits;
            ftsnum = cond->ftsnum;
            if (ftsnum > 0) {
              words = tclistnew2(ftsnum * 2 + 1);
              i___0 = 0;
              while (i___0 < ftsnum) {
                if (! (ftsunits + i___0)->sign) {
                  goto __Cont;
                }
                tokens = (ftsunits + i___0)->tokens;
                tnum = tokens->num;
                j = 0;
                while (j < tnum) {
                  while (1) {
                    token = (char const   *)(tokens->array + (j + tokens->start))->ptr;
                    tsiz = (tokens->array + (j + tokens->start))->size;
                    break;
                  }
                  while (1) {
                    TC_mysize = tsiz;
                    TC_index = words->start + words->num;
                    if (TC_index >= words->anum) {
                      words->anum += words->num + 1;
                      while (1) {
                        tmp___10 = realloc((void *)words->array, (unsigned int )(words->anum * (int )sizeof(*(words->array + 0))));
                        tmp___9 = (TCLISTDATUM *)tmp___10;
                        words->array = tmp___9;
                        if (! tmp___9) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    array = words->array;
                    while (1) {
                      tmp___12 = malloc((unsigned int )(TC_mysize + 1));
                      tmp___11 = (char *)tmp___12;
                      (array + TC_index)->ptr = tmp___11;
                      if (! tmp___11) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )token,
                           (unsigned int )TC_mysize);
                    *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
                    (array + TC_index)->size = TC_mysize;
                    (words->num) ++;
                    break;
                  }
                  j ++;
                }
                __Cont: 
                i___0 ++;
              }
            } else {
              words = tclistnew2(1);
            }
          } else {
            words = tclistnew3((char const   *)cond->expr, (void *)0);
          }
        }
      }
    }
  }
  tmp___13 = tcstrkwic(str, (TCLIST const   *)words, width, opts);
  texts = tmp___13;
  tclistdel(words);
  return (texts);
}
}
int tctdbqrystrtocondop(char const   *str ) 
{ int op ;
  int flags ;
  int64_t tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;

  {
  op = -1;
  flags = 0;
  if ((int const   )*str == 126) {
    flags |= 16777216;
    str ++;
  } else {
    if ((int const   )*str == 33) {
      flags |= 16777216;
      str ++;
    }
  }
  if ((int const   )*str == 43) {
    flags |= 33554432;
    str ++;
  }
  tmp___34 = tcstricmp(str, "STREQ");
  if (tmp___34) {
    tmp___35 = tcstricmp(str, "STR");
    if (tmp___35) {
      tmp___36 = tcstricmp(str, "EQ");
      if (tmp___36) {
        tmp___32 = tcstricmp(str, "STRINC");
        if (tmp___32) {
          tmp___33 = tcstricmp(str, "INC");
          if (tmp___33) {
            tmp___30 = tcstricmp(str, "STRBW");
            if (tmp___30) {
              tmp___31 = tcstricmp(str, "BW");
              if (tmp___31) {
                tmp___28 = tcstricmp(str, "STREW");
                if (tmp___28) {
                  tmp___29 = tcstricmp(str, "EW");
                  if (tmp___29) {
                    tmp___26 = tcstricmp(str, "STRAND");
                    if (tmp___26) {
                      tmp___27 = tcstricmp(str, "AND");
                      if (tmp___27) {
                        tmp___24 = tcstricmp(str, "STROR");
                        if (tmp___24) {
                          tmp___25 = tcstricmp(str, "OR");
                          if (tmp___25) {
                            tmp___22 = tcstricmp(str, "STROREQ");
                            if (tmp___22) {
                              tmp___23 = tcstricmp(str, "OREQ");
                              if (tmp___23) {
                                tmp___20 = tcstricmp(str, "STRRX");
                                if (tmp___20) {
                                  tmp___21 = tcstricmp(str, "RX");
                                  if (tmp___21) {
                                    tmp___16 = tcstricmp(str, "NUMEQ");
                                    if (tmp___16) {
                                      tmp___17 = tcstricmp(str, "NUM");
                                      if (tmp___17) {
                                        tmp___18 = tcstricmp(str, "=");
                                        if (tmp___18) {
                                          tmp___19 = tcstricmp(str, "==");
                                          if (tmp___19) {
                                            tmp___14 = tcstricmp(str, "NUMGT");
                                            if (tmp___14) {
                                              tmp___15 = tcstricmp(str, ">");
                                              if (tmp___15) {
                                                tmp___12 = tcstricmp(str, "NUMGE");
                                                if (tmp___12) {
                                                  tmp___13 = tcstricmp(str, ">=");
                                                  if (tmp___13) {
                                                    tmp___10 = tcstricmp(str, "NUMLT");
                                                    if (tmp___10) {
                                                      tmp___11 = tcstricmp(str, "<");
                                                      if (tmp___11) {
                                                        tmp___8 = tcstricmp(str, "NUMLE");
                                                        if (tmp___8) {
                                                          tmp___9 = tcstricmp(str,
                                                                              "<=");
                                                          if (tmp___9) {
                                                            tmp___7 = tcstricmp(str,
                                                                                "NUMBT");
                                                            if (tmp___7) {
                                                              tmp___6 = tcstricmp(str,
                                                                                  "NUMOREQ");
                                                              if (tmp___6) {
                                                                tmp___4 = tcstricmp(str,
                                                                                    "FTSPH");
                                                                if (tmp___4) {
                                                                  tmp___5 = tcstricmp(str,
                                                                                      "FTS");
                                                                  if (tmp___5) {
                                                                    tmp___3 = tcstricmp(str,
                                                                                        "FTSAND");
                                                                    if (tmp___3) {
                                                                      tmp___2 = tcstricmp(str,
                                                                                          "FTSOR");
                                                                      if (tmp___2) {
                                                                        tmp___1 = tcstricmp(str,
                                                                                            "FTSEX");
                                                                        if (tmp___1) {
                                                                          tmp___0 = tcstrisnum(str);
                                                                          if (tmp___0) {
                                                                            tmp = tcatoi(str);
                                                                            op = (int )tmp;
                                                                          }
                                                                        } else {
                                                                          op = 18;
                                                                        }
                                                                      } else {
                                                                        op = 17;
                                                                      }
                                                                    } else {
                                                                      op = 16;
                                                                    }
                                                                  } else {
                                                                    op = 15;
                                                                  }
                                                                } else {
                                                                  op = 15;
                                                                }
                                                              } else {
                                                                op = 14;
                                                              }
                                                            } else {
                                                              op = 13;
                                                            }
                                                          } else {
                                                            op = 12;
                                                          }
                                                        } else {
                                                          op = 12;
                                                        }
                                                      } else {
                                                        op = 11;
                                                      }
                                                    } else {
                                                      op = 11;
                                                    }
                                                  } else {
                                                    op = 10;
                                                  }
                                                } else {
                                                  op = 10;
                                                }
                                              } else {
                                                op = 9;
                                              }
                                            } else {
                                              op = 9;
                                            }
                                          } else {
                                            op = 8;
                                          }
                                        } else {
                                          op = 8;
                                        }
                                      } else {
                                        op = 8;
                                      }
                                    } else {
                                      op = 8;
                                    }
                                  } else {
                                    op = 7;
                                  }
                                } else {
                                  op = 7;
                                }
                              } else {
                                op = 6;
                              }
                            } else {
                              op = 6;
                            }
                          } else {
                            op = 5;
                          }
                        } else {
                          op = 5;
                        }
                      } else {
                        op = 4;
                      }
                    } else {
                      op = 4;
                    }
                  } else {
                    op = 3;
                  }
                } else {
                  op = 3;
                }
              } else {
                op = 2;
              }
            } else {
              op = 2;
            }
          } else {
            op = 1;
          }
        } else {
          op = 1;
        }
      } else {
        op = 0;
      }
    } else {
      op = 0;
    }
  } else {
    op = 0;
  }
  return (op | flags);
}
}
int tctdbqrystrtoordertype(char const   *str ) 
{ int type ;
  int64_t tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  type = -1;
  tmp___6 = tcstricmp(str, "STRASC");
  if (tmp___6) {
    tmp___7 = tcstricmp(str, "STR");
    if (tmp___7) {
      tmp___8 = tcstricmp(str, "ASC");
      if (tmp___8) {
        tmp___4 = tcstricmp(str, "STRDESC");
        if (tmp___4) {
          tmp___5 = tcstricmp(str, "DESC");
          if (tmp___5) {
            tmp___2 = tcstricmp(str, "NUMASC");
            if (tmp___2) {
              tmp___3 = tcstricmp(str, "NUM");
              if (tmp___3) {
                tmp___1 = tcstricmp(str, "NUMDESC");
                if (tmp___1) {
                  tmp___0 = tcstrisnum(str);
                  if (tmp___0) {
                    tmp = tcatoi(str);
                    type = (int )tmp;
                  }
                } else {
                  type = 3;
                }
              } else {
                type = 2;
              }
            } else {
              type = 2;
            }
          } else {
            type = 1;
          }
        } else {
          type = 1;
        }
      } else {
        type = 0;
      }
    } else {
      type = 0;
    }
  } else {
    type = 0;
  }
  return (type);
}
}
int tctdbmetastrtosettype(char const   *str ) 
{ int type ;
  int64_t tmp ;
  _Bool tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
  type = -1;
  tmp___9 = tcstricmp(str, "UNION");
  if (tmp___9) {
    tmp___10 = tcstricmp(str, "CUP");
    if (tmp___10) {
      tmp___11 = tcstricmp(str, "+");
      if (tmp___11) {
        tmp___5 = tcstricmp(str, "ISECT");
        if (tmp___5) {
          tmp___6 = tcstricmp(str, "INTERSECTION");
          if (tmp___6) {
            tmp___7 = tcstricmp(str, "CAP");
            if (tmp___7) {
              tmp___8 = tcstricmp(str, "*");
              if (tmp___8) {
                tmp___1 = tcstricmp(str, "DIFF");
                if (tmp___1) {
                  tmp___2 = tcstricmp(str, "DIFFERENCE");
                  if (tmp___2) {
                    tmp___3 = tcstricmp(str, "MINUS");
                    if (tmp___3) {
                      tmp___4 = tcstricmp(str, "-");
                      if (tmp___4) {
                        tmp___0 = tcstrisnum(str);
                        if (tmp___0) {
                          tmp = tcatoi(str);
                          type = (int )tmp;
                        }
                      } else {
                        type = 2;
                      }
                    } else {
                      type = 2;
                    }
                  } else {
                    type = 2;
                  }
                } else {
                  type = 2;
                }
              } else {
                type = 1;
              }
            } else {
              type = 1;
            }
          } else {
            type = 1;
          }
        } else {
          type = 1;
        }
      } else {
        type = 0;
      }
    } else {
      type = 0;
    }
  } else {
    type = 0;
  }
  return (type);
}
}
static void tctdbclear(TCTDB *tdb ) 
{ 

  {
  tdb->mmtx = (void *)0;
  tdb->hdb = (TCHDB *)((void *)0);
  tdb->open = (_Bool)0;
  tdb->wmode = (_Bool)0;
  tdb->opts = (unsigned char)0;
  tdb->lcnum = 4096;
  tdb->ncnum = 512;
  tdb->iccmax = 64LL << 20;
  tdb->iccsync = 0.01;
  tdb->idxs = (TDBIDX *)((void *)0);
  tdb->inum = 0;
  tdb->tran = (_Bool)0;
  return;
}
}
static _Bool tctdbopenimpl(TCTDB *tdb , char const   *path , int omode ) 
{ int dbgfd ;
  int tmp ;
  void *(*enc)(void const   *ptr , int size , int *sp , void *op ) ;
  void *(*dec)(void const   *ptr , int size , int *sp , void *op ) ;
  void *encop ;
  void *decop ;
  int homode ;
  int bomode ;
  _Bool tmp___0 ;
  char *tpath ;
  char *tmp___1 ;
  TCLIST *paths ;
  TCLIST *tmp___2 ;
  int pnum ;
  int i ;
  TCLIST *paths___0 ;
  TCLIST *tmp___3 ;
  int pnum___0 ;
  TDBIDX *tmp___4 ;
  void *tmp___5 ;
  TDBIDX *idxs ;
  int inum ;
  int i___0 ;
  char const   *ipath ;
  _Bool tmp___6 ;
  char const   *rp ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  size_t tmp___9 ;
  char *stem ;
  char *tmp___10 ;
  char *ep ;
  char *tmp___11 ;
  char *tmp___12 ;
  int nsiz ;
  char *name ;
  char *tmp___13 ;
  TCBDB *bdb ;
  TCBDB *tmp___14 ;
  uint64_t tmp___15 ;
  uint32_t tmp___16 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___18 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___25 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___32 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  TCMAP *tmp___38 ;
  TCMAP *tmp___39 ;
  _Bool tmp___40 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___42 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___49 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___56 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___63 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  uint8_t hopts ;
  uint8_t tmp___69 ;
  uint8_t opts ;

  {
  tmp = tchdbdbgfd(tdb->hdb);
  dbgfd = tmp;
  tchdbcodecfunc(tdb->hdb, & enc, & encop, & dec, & decop);
  homode = 1;
  bomode = 1;
  if (omode & 2) {
    homode = 2;
    bomode = 2;
    if (omode & 4) {
      homode |= 4;
      bomode |= 4;
    }
    if (omode & 8) {
      homode |= 8;
      bomode |= 8;
    }
    tdb->wmode = (_Bool)1;
  } else {
    tdb->wmode = (_Bool)0;
  }
  if (omode & 16) {
    homode |= 16;
    bomode |= 16;
  }
  if (omode & 32) {
    homode |= 32;
    bomode |= 32;
  }
  if (omode & 64) {
    homode |= 64;
    bomode |= 64;
  }
  tchdbsettype(tdb->hdb, (unsigned char)3);
  tmp___0 = tchdbopen(tdb->hdb, path, homode);
  if (! tmp___0) {
    return ((_Bool)0);
  }
  tmp___1 = tcsprintf("%s%c%s%c*", path, '.', "idx", '.');
  tpath = tmp___1;
  if (omode & 2) {
    if (omode & 8) {
      tmp___2 = tcglobpat((char const   *)tpath);
      paths = tmp___2;
      pnum = paths->num;
      i = 0;
      while (i < pnum) {
        unlink((char const   *)((void *)(paths->array + (i + paths->start))->ptr));
        i ++;
      }
      tclistdel(paths);
    }
  }
  tmp___3 = tcglobpat((char const   *)tpath);
  paths___0 = tmp___3;
  pnum___0 = paths___0->num;
  while (1) {
    tmp___5 = malloc((unsigned int )((int )sizeof(*(tdb->idxs + 0)) * pnum___0 + 1));
    tmp___4 = (TDBIDX *)tmp___5;
    tdb->idxs = tmp___4;
    if (! tmp___4) {
      tcmyfatal("out of memory");
    }
    break;
  }
  idxs = tdb->idxs;
  inum = 0;
  i___0 = 0;
  while (i___0 < pnum___0) {
    ipath = (char const   *)((void *)(paths___0->array + (i___0 + paths___0->start))->ptr);
    tmp___6 = tcstrfwm(ipath, path);
    if (! tmp___6) {
      goto __Cont;
    }
    tmp___7 = strlen(path);
    rp = ipath + tmp___7;
    if ((int const   )*rp != 46) {
      goto __Cont;
    }
    rp ++;
    tmp___8 = tcstrfwm(rp, "idx");
    if (! tmp___8) {
      goto __Cont;
    }
    tmp___9 = strlen("idx");
    rp += tmp___9;
    if ((int const   )*rp != 46) {
      goto __Cont;
    }
    rp ++;
    tmp___10 = tcstrdup((void const   *)rp);
    stem = tmp___10;
    tmp___11 = strrchr((char const   *)stem, '.');
    ep = tmp___11;
    if (! ep) {
      goto __Cont;
    }
    tmp___12 = ep;
    ep ++;
    *tmp___12 = (char )'\000';
    tmp___13 = tcurldecode((char const   *)stem, & nsiz);
    name = tmp___13;
    if (0) {
      __s1_len___2 = strlen((char const   *)ep);
      __s2_len___2 = strlen("lex");
      if (! ((unsigned int )((void const   *)(ep + 1)) - (unsigned int )((void const   *)ep) == 1U)) {
        goto _L___6;
      } else {
        if (__s1_len___2 >= 4U) {
          _L___6: 
          if (! ((unsigned int )((void const   *)("lex" + 1)) - (unsigned int )((void const   *)"lex") == 1U)) {
            tmp___47 = 1;
          } else {
            if (__s2_len___2 >= 4U) {
              tmp___47 = 1;
            } else {
              tmp___47 = 0;
            }
          }
        } else {
          tmp___47 = 0;
        }
      }
      if (tmp___47) {
        tmp___42 = __builtin_strcmp((char const   *)ep, "lex");
        tmp___46 = tmp___42;
      } else {
        tmp___45 = __builtin_strcmp((char const   *)ep, "lex");
        tmp___46 = tmp___45;
      }
    } else {
      tmp___45 = __builtin_strcmp((char const   *)ep, "lex");
      tmp___46 = tmp___45;
    }
    if (tmp___46) {
      if (0) {
        __s1_len___3 = strlen((char const   *)ep);
        __s2_len___3 = strlen("dec");
        if (! ((unsigned int )((void const   *)(ep + 1)) - (unsigned int )((void const   *)ep) == 1U)) {
          goto _L___8;
        } else {
          if (__s1_len___3 >= 4U) {
            _L___8: 
            if (! ((unsigned int )((void const   *)("dec" + 1)) - (unsigned int )((void const   *)"dec") == 1U)) {
              tmp___54 = 1;
            } else {
              if (__s2_len___3 >= 4U) {
                tmp___54 = 1;
              } else {
                tmp___54 = 0;
              }
            }
          } else {
            tmp___54 = 0;
          }
        }
        if (tmp___54) {
          tmp___49 = __builtin_strcmp((char const   *)ep, "dec");
          tmp___53 = tmp___49;
        } else {
          tmp___52 = __builtin_strcmp((char const   *)ep, "dec");
          tmp___53 = tmp___52;
        }
      } else {
        tmp___52 = __builtin_strcmp((char const   *)ep, "dec");
        tmp___53 = tmp___52;
      }
      if (tmp___53) {
        if (0) {
          __s1_len___4 = strlen((char const   *)ep);
          __s2_len___4 = strlen("tok");
          if (! ((unsigned int )((void const   *)(ep + 1)) - (unsigned int )((void const   *)ep) == 1U)) {
            goto _L___10;
          } else {
            if (__s1_len___4 >= 4U) {
              _L___10: 
              if (! ((unsigned int )((void const   *)("tok" + 1)) - (unsigned int )((void const   *)"tok") == 1U)) {
                tmp___61 = 1;
              } else {
                if (__s2_len___4 >= 4U) {
                  tmp___61 = 1;
                } else {
                  tmp___61 = 0;
                }
              }
            } else {
              tmp___61 = 0;
            }
          }
          if (tmp___61) {
            tmp___56 = __builtin_strcmp((char const   *)ep, "tok");
            tmp___60 = tmp___56;
          } else {
            tmp___59 = __builtin_strcmp((char const   *)ep, "tok");
            tmp___60 = tmp___59;
          }
        } else {
          tmp___59 = __builtin_strcmp((char const   *)ep, "tok");
          tmp___60 = tmp___59;
        }
        if (tmp___60) {
          if (0) {
            __s1_len___5 = strlen((char const   *)ep);
            __s2_len___5 = strlen("qgr");
            if (! ((unsigned int )((void const   *)(ep + 1)) - (unsigned int )((void const   *)ep) == 1U)) {
              goto _L___12;
            } else {
              if (__s1_len___5 >= 4U) {
                _L___12: 
                if (! ((unsigned int )((void const   *)("qgr" + 1)) - (unsigned int )((void const   *)"qgr") == 1U)) {
                  tmp___68 = 1;
                } else {
                  if (__s2_len___5 >= 4U) {
                    tmp___68 = 1;
                  } else {
                    tmp___68 = 0;
                  }
                }
              } else {
                tmp___68 = 0;
              }
            }
            if (tmp___68) {
              tmp___63 = __builtin_strcmp((char const   *)ep, "qgr");
              tmp___67 = tmp___63;
            } else {
              tmp___66 = __builtin_strcmp((char const   *)ep, "qgr");
              tmp___67 = tmp___66;
            }
          } else {
            tmp___66 = __builtin_strcmp((char const   *)ep, "qgr");
            tmp___67 = tmp___66;
          }
          if (! tmp___67) {
            _L___13: 
            tmp___14 = tcbdbnew();
            bdb = tmp___14;
            if (dbgfd >= 0) {
              tcbdbsetdbgfd(bdb, dbgfd);
            }
            if (tdb->mmtx) {
              tcbdbsetmutex(bdb);
            }
            if (enc) {
              if (dec) {
                tcbdbsetcodecfunc(bdb, enc, encop, dec, decop);
              }
            }
            tcbdbsetcache(bdb, tdb->lcnum, tdb->ncnum);
            tmp___15 = tchdbxmsiz(tdb->hdb);
            tcbdbsetxmsiz(bdb, (long long )tmp___15);
            tmp___16 = tchdbdfunit(tdb->hdb);
            tcbdbsetdfunit(bdb, (int )tmp___16);
            tcbdbsetlsmax(bdb, 4096U);
            tmp___40 = tcbdbopen(bdb, ipath, bomode);
            if (tmp___40) {
              (idxs + inum)->name = tcstrdup((void const   *)name);
              (idxs + inum)->type = 0;
              if (0) {
                __s1_len___1 = strlen((char const   *)ep);
                __s2_len___1 = strlen("dec");
                if (! ((unsigned int )((void const   *)(ep + 1)) - (unsigned int )((void const   *)ep) == 1U)) {
                  goto _L___4;
                } else {
                  if (__s1_len___1 >= 4U) {
                    _L___4: 
                    if (! ((unsigned int )((void const   *)("dec" + 1)) - (unsigned int )((void const   *)"dec") == 1U)) {
                      tmp___37 = 1;
                    } else {
                      if (__s2_len___1 >= 4U) {
                        tmp___37 = 1;
                      } else {
                        tmp___37 = 0;
                      }
                    }
                  } else {
                    tmp___37 = 0;
                  }
                }
                if (tmp___37) {
                  tmp___32 = __builtin_strcmp((char const   *)ep, "dec");
                  tmp___36 = tmp___32;
                } else {
                  tmp___35 = __builtin_strcmp((char const   *)ep, "dec");
                  tmp___36 = tmp___35;
                }
              } else {
                tmp___35 = __builtin_strcmp((char const   *)ep, "dec");
                tmp___36 = tmp___35;
              }
              if (tmp___36) {
                if (0) {
                  __s1_len___0 = strlen((char const   *)ep);
                  __s2_len___0 = strlen("tok");
                  if (! ((unsigned int )((void const   *)(ep + 1)) - (unsigned int )((void const   *)ep) == 1U)) {
                    goto _L___2;
                  } else {
                    if (__s1_len___0 >= 4U) {
                      _L___2: 
                      if (! ((unsigned int )((void const   *)("tok" + 1)) - (unsigned int )((void const   *)"tok") == 1U)) {
                        tmp___30 = 1;
                      } else {
                        if (__s2_len___0 >= 4U) {
                          tmp___30 = 1;
                        } else {
                          tmp___30 = 0;
                        }
                      }
                    } else {
                      tmp___30 = 0;
                    }
                  }
                  if (tmp___30) {
                    tmp___25 = __builtin_strcmp((char const   *)ep, "tok");
                    tmp___29 = tmp___25;
                  } else {
                    tmp___28 = __builtin_strcmp((char const   *)ep, "tok");
                    tmp___29 = tmp___28;
                  }
                } else {
                  tmp___28 = __builtin_strcmp((char const   *)ep, "tok");
                  tmp___29 = tmp___28;
                }
                if (tmp___29) {
                  if (0) {
                    __s1_len = strlen((char const   *)ep);
                    __s2_len = strlen("qgr");
                    if (! ((unsigned int )((void const   *)(ep + 1)) - (unsigned int )((void const   *)ep) == 1U)) {
                      goto _L___0;
                    } else {
                      if (__s1_len >= 4U) {
                        _L___0: 
                        if (! ((unsigned int )((void const   *)("qgr" + 1)) - (unsigned int )((void const   *)"qgr") == 1U)) {
                          tmp___23 = 1;
                        } else {
                          if (__s2_len >= 4U) {
                            tmp___23 = 1;
                          } else {
                            tmp___23 = 0;
                          }
                        }
                      } else {
                        tmp___23 = 0;
                      }
                    }
                    if (tmp___23) {
                      tmp___18 = __builtin_strcmp((char const   *)ep, "qgr");
                      tmp___22 = tmp___18;
                    } else {
                      tmp___21 = __builtin_strcmp((char const   *)ep, "qgr");
                      tmp___22 = tmp___21;
                    }
                  } else {
                    tmp___21 = __builtin_strcmp((char const   *)ep, "qgr");
                    tmp___22 = tmp___21;
                  }
                  if (! tmp___22) {
                    (idxs + inum)->type = 3;
                  }
                } else {
                  (idxs + inum)->type = 2;
                }
              } else {
                (idxs + inum)->type = 1;
              }
              (idxs + inum)->db = (void *)bdb;
              (idxs + inum)->cc = (void *)0;
              if ((idxs + inum)->type == 2) {
                tmp___38 = tcmapnew2(262139U);
                (idxs + inum)->cc = (void *)tmp___38;
              } else {
                if ((idxs + inum)->type == 3) {
                  tmp___39 = tcmapnew2(262139U);
                  (idxs + inum)->cc = (void *)tmp___39;
                }
              }
              inum ++;
            } else {
              tcbdbdel(bdb);
            }
          }
        } else {
          goto _L___13;
        }
      } else {
        goto _L___13;
      }
    } else {
      goto _L___13;
    }
    while (1) {
      free((void *)name);
      break;
    }
    while (1) {
      free((void *)stem);
      break;
    }
    __Cont: 
    i___0 ++;
  }
  tclistdel(paths___0);
  while (1) {
    free((void *)tpath);
    break;
  }
  tdb->inum = inum;
  tdb->open = (_Bool)1;
  tmp___69 = tchdbopts(tdb->hdb);
  hopts = tmp___69;
  opts = (unsigned char)0;
  if ((int )hopts & 1) {
    opts = (unsigned char )((int )opts | 1);
  }
  if ((int )hopts & 2) {
    opts = (unsigned char )((int )opts | 2);
  }
  if ((int )hopts & 4) {
    opts = (unsigned char )((int )opts | 4);
  }
  if ((int )hopts & 8) {
    opts = (unsigned char )((int )opts | 8);
  }
  if ((int )hopts & 16) {
    opts = (unsigned char )((int )opts | 16);
  }
  tdb->opts = opts;
  tdb->tran = (_Bool)0;
  return ((_Bool)1);
}
}
static _Bool tctdbcloseimpl(TCTDB *tdb ) 
{ _Bool err ;
  _Bool tmp ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  _Bool tmp___0 ;
  int i___0 ;
  TDBIDX *idx___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  err = (_Bool)0;
  if (tdb->tran) {
    tmp = tctdbtranabortimpl(tdb);
    if (! tmp) {
      err = (_Bool)1;
    }
  }
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    switch (idx->type) {
    case 2: 
    case 3: 
    tmp___0 = tctdbidxsyncicc(tdb, idx, (_Bool)1);
    if (! tmp___0) {
      err = (_Bool)1;
    }
    tcmapdel((TCMAP *)idx->cc);
    break;
    }
    i ++;
  }
  i___0 = 0;
  while (i___0 < inum) {
    idx___0 = idxs + i___0;
    switch (idx___0->type) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    tmp___2 = tcbdbclose((TCBDB *)idx___0->db);
    if (! tmp___2) {
      tmp___1 = tcbdbecode((TCBDB *)idx___0->db);
      tctdbsetecode(tdb, tmp___1, "tctdb.c", 2021, "tctdbcloseimpl");
      err = (_Bool)1;
    }
    tcbdbdel((TCBDB *)idx___0->db);
    break;
    }
    while (1) {
      free((void *)idx___0->name);
      break;
    }
    i___0 ++;
  }
  while (1) {
    free((void *)idxs);
    break;
  }
  tmp___3 = tchdbclose(tdb->hdb);
  if (! tmp___3) {
    err = (_Bool)1;
  }
  tdb->open = (_Bool)0;
  return ((_Bool )(! err));
}
}
static _Bool tctdbputimpl(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ,
                          int dmode ) 
{ _Bool err ;
  int osiz ;
  char *obuf ;
  void *tmp ;
  TCMAP *ocols ;
  TCMAP *tmp___0 ;
  TCMAP *ncols ;
  TCMAP *tmp___1 ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___2 ;
  _Bool tmp___3 ;
  void const   *tmp___4 ;
  _Bool tmp___5 ;
  int csiz ;
  char *cbuf ;
  void *tmp___6 ;
  _Bool tmp___7 ;
  TCMAP *ncols___0 ;
  TCMAP *tmp___8 ;
  char const   *kbuf___0 ;
  int ksiz___0 ;
  int vsiz___0 ;
  char const   *vbuf___0 ;
  void const   *tmp___9 ;
  int osiz___0 ;
  char const   *obuf___0 ;
  void const   *tmp___10 ;
  int tmp___11 ;
  void const   *tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  int csiz___0 ;
  char *cbuf___0 ;
  void *tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  int csiz___1 ;
  char *cbuf___1 ;
  void *tmp___18 ;
  _Bool tmp___19 ;

  {
  err = (_Bool)0;
  tmp = tchdbget(tdb->hdb, pkbuf, pksiz, & osiz);
  obuf = (char *)tmp;
  if (obuf) {
    if (dmode == 1) {
      tctdbsetecode(tdb, 21, "tctdb.c", 2050, "tctdbputimpl");
      while (1) {
        free((void *)obuf);
        break;
      }
      return ((_Bool)0);
    }
    tmp___0 = tcmapload((void const   *)obuf, osiz);
    ocols = tmp___0;
    if (dmode == 2) {
      tmp___1 = tcmapnew2((unsigned int )(cols->rnum + 1ULL));
      ncols = tmp___1;
      tcmapiterinit(cols);
      while (1) {
        tmp___4 = tcmapiternext(cols, & ksiz);
        kbuf = (char const   *)tmp___4;
        if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
          break;
        }
        tmp___2 = tcmapiterval((void const   *)kbuf, & vsiz);
        vbuf = (char const   *)tmp___2;
        tmp___3 = tcmapputkeep(ocols, (void const   *)kbuf, ksiz, (void const   *)vbuf,
                               vsiz);
        if (tmp___3) {
          tcmapput(ncols, (void const   *)kbuf, ksiz, (void const   *)vbuf, vsiz);
        }
      }
      tmp___5 = tctdbidxput(tdb, pkbuf, pksiz, ncols);
      if (! tmp___5) {
        err = (_Bool)1;
      }
      tcmapdel(ncols);
      tmp___6 = tcmapdump((TCMAP const   *)ocols, & csiz);
      cbuf = (char *)tmp___6;
      tmp___7 = tchdbput(tdb->hdb, pkbuf, pksiz, (void const   *)cbuf, csiz);
      if (! tmp___7) {
        err = (_Bool)1;
      }
      while (1) {
        free((void *)cbuf);
        break;
      }
    } else {
      tmp___8 = tcmapnew2((unsigned int )(cols->rnum + 1ULL));
      ncols___0 = tmp___8;
      tcmapiterinit(cols);
      while (1) {
        tmp___12 = tcmapiternext(cols, & ksiz___0);
        kbuf___0 = (char const   *)tmp___12;
        if (! ((unsigned int )kbuf___0 != (unsigned int )((void *)0))) {
          break;
        }
        tmp___9 = tcmapiterval((void const   *)kbuf___0, & vsiz___0);
        vbuf___0 = (char const   *)tmp___9;
        tmp___10 = tcmapget((TCMAP const   *)ocols, (void const   *)kbuf___0, ksiz___0,
                            & osiz___0);
        obuf___0 = (char const   *)tmp___10;
        if (obuf___0) {
          if (osiz___0 == vsiz___0) {
            tmp___11 = memcmp((void const   *)obuf___0, (void const   *)vbuf___0,
                              (unsigned int )osiz___0);
            if (tmp___11) {
              tcmapput(ncols___0, (void const   *)kbuf___0, ksiz___0, (void const   *)vbuf___0,
                       vsiz___0);
            } else {
              tcmapout(ocols, (void const   *)kbuf___0, ksiz___0);
            }
          } else {
            tcmapput(ncols___0, (void const   *)kbuf___0, ksiz___0, (void const   *)vbuf___0,
                     vsiz___0);
          }
        } else {
          tcmapput(ncols___0, (void const   *)kbuf___0, ksiz___0, (void const   *)vbuf___0,
                   vsiz___0);
        }
      }
      tmp___13 = tctdbidxout(tdb, pkbuf, pksiz, ocols);
      if (! tmp___13) {
        err = (_Bool)1;
      }
      tmp___14 = tctdbidxput(tdb, pkbuf, pksiz, ncols___0);
      if (! tmp___14) {
        err = (_Bool)1;
      }
      tcmapdel(ncols___0);
      tmp___15 = tcmapdump((TCMAP const   *)cols, & csiz___0);
      cbuf___0 = (char *)tmp___15;
      tmp___16 = tchdbput(tdb->hdb, pkbuf, pksiz, (void const   *)cbuf___0, csiz___0);
      if (! tmp___16) {
        err = (_Bool)1;
      }
      while (1) {
        free((void *)cbuf___0);
        break;
      }
    }
    tcmapdel(ocols);
    while (1) {
      free((void *)obuf);
      break;
    }
  } else {
    tmp___17 = tctdbidxput(tdb, pkbuf, pksiz, cols);
    if (! tmp___17) {
      err = (_Bool)1;
    }
    tmp___18 = tcmapdump((TCMAP const   *)cols, & csiz___1);
    cbuf___1 = (char *)tmp___18;
    tmp___19 = tchdbput(tdb->hdb, pkbuf, pksiz, (void const   *)cbuf___1, csiz___1);
    if (! tmp___19) {
      err = (_Bool)1;
    }
    while (1) {
      free((void *)cbuf___1);
      break;
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdboutimpl(TCTDB *tdb , char const   *pkbuf , int pksiz ) 
{ int csiz ;
  char *cbuf ;
  void *tmp ;
  _Bool err ;
  TCMAP *cols ;
  TCMAP *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;

  {
  tmp = tchdbget(tdb->hdb, (void const   *)pkbuf, pksiz, & csiz);
  cbuf = (char *)tmp;
  if (! cbuf) {
    return ((_Bool)0);
  }
  err = (_Bool)0;
  tmp___0 = tcmapload((void const   *)cbuf, csiz);
  cols = tmp___0;
  tmp___1 = tctdbidxout(tdb, (void const   *)pkbuf, pksiz, cols);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  tmp___2 = tchdbout(tdb->hdb, (void const   *)pkbuf, pksiz);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  tcmapdel(cols);
  while (1) {
    free((void *)cbuf);
    break;
  }
  return ((_Bool )(! err));
}
}
static TCMAP *tctdbgetimpl(TCTDB *tdb , void const   *pkbuf , int pksiz ) 
{ int csiz ;
  char *cbuf ;
  void *tmp ;
  TCMAP *cols ;
  TCMAP *tmp___0 ;

  {
  tmp = tchdbget(tdb->hdb, pkbuf, pksiz, & csiz);
  cbuf = (char *)tmp;
  if (! cbuf) {
    return ((TCMAP *)((void *)0));
  }
  tmp___0 = tcmapload((void const   *)cbuf, csiz);
  cols = tmp___0;
  while (1) {
    free((void *)cbuf);
    break;
  }
  return (cols);
}
}
static char *tctdbgetonecol(TCTDB *tdb , void const   *pkbuf , int pksiz , void const   *nbuf ,
                            int nsiz , int *sp ) 
{ int csiz ;
  char *cbuf ;
  void *tmp ;
  void *rv ;
  void *tmp___0 ;

  {
  tmp = tchdbget(tdb->hdb, pkbuf, pksiz, & csiz);
  cbuf = (char *)tmp;
  if (! cbuf) {
    return ((char *)((void *)0));
  }
  tmp___0 = tcmaploadone((void const   *)cbuf, csiz, nbuf, nsiz, sp);
  rv = tmp___0;
  while (1) {
    free((void *)cbuf);
    break;
  }
  return ((char *)rv);
}
}
static double tctdbaddnumber(TCTDB *tdb , void const   *pkbuf , int pksiz , double num ) 
{ int csiz ;
  char *cbuf ;
  void *tmp ;
  TCMAP *cols ;
  TCMAP *tmp___0 ;
  TCMAP *tmp___1 ;
  TCMAP *tmp___2 ;
  char const   *vbuf ;
  char const   *tmp___3 ;
  long double tmp___4 ;
  char numbuf[1024] ;
  int len ;
  int tmp___5 ;
  _Bool tmp___6 ;

  {
  tmp = tchdbget(tdb->hdb, pkbuf, pksiz, & csiz);
  cbuf = (char *)tmp;
  if (cbuf) {
    tmp___0 = tcmapload((void const   *)cbuf, csiz);
    tmp___2 = tmp___0;
  } else {
    tmp___1 = tcmapnew2(1U);
    tmp___2 = tmp___1;
  }
  cols = tmp___2;
  if (cbuf) {
    tmp___3 = tcmapget2((TCMAP const   *)cols, "_num");
    vbuf = tmp___3;
    if (vbuf) {
      tmp___4 = tctdbatof(vbuf);
      num = (double )((long double )num + tmp___4);
    }
    while (1) {
      free((void *)cbuf);
      break;
    }
  }
  tmp___5 = snprintf((char * __restrict  )(numbuf), 1023U, (char const   * __restrict  )"%f",
                     num);
  len = tmp___5;
  if (len > 1023) {
    tctdbsetecode(tdb, 9999, "tctdb.c", 2185, "tctdbaddnumber");
    num = nan("");
  } else {
    while (1) {
      len --;
      if (! (len > 0)) {
        break;
      }
      if ((int )numbuf[len] != 48) {
        break;
      }
      numbuf[len] = (char )'\000';
    }
    if ((int )numbuf[len] == 46) {
      numbuf[len] = (char )'\000';
    }
    tcmapput2(cols, "_num", (char const   *)(numbuf));
    tmp___6 = tctdbputimpl(tdb, pkbuf, pksiz, cols, 0);
    if (! tmp___6) {
      num = nan("");
    }
  }
  tcmapdel(cols);
  return (num);
}
}
static _Bool tctdboptimizeimpl(TCTDB *tdb , int64_t bnum , int8_t apow , int8_t fpow ,
                               uint8_t opts ) 
{ _Bool err ;
  TCHDB *hdb ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  int i___0 ;
  TDBIDX *idx___0 ;
  int tmp ;
  _Bool tmp___0 ;
  char const   *path ;
  char const   *tmp___1 ;
  char *tpath ;
  uint64_t tmp___2 ;
  char *tmp___3 ;
  TCHDB *thdb ;
  TCHDB *tmp___4 ;
  int dbgfd ;
  int tmp___5 ;
  void *(*enc)(void const   *ptr , int size , int *sp , void *op ) ;
  void *(*dec)(void const   *ptr , int size , int *sp , void *op ) ;
  void *encop ;
  void *decop ;
  uint64_t tmp___6 ;
  uint32_t tmp___7 ;
  long tmp___8 ;
  uint32_t tmp___9 ;
  long tmp___10 ;
  uint8_t hopts ;
  char *tmp___11 ;
  char *tmp___12 ;
  _Bool tmp___13 ;
  TCXSTR *kxstr ;
  TCXSTR *tmp___14 ;
  TCXSTR *vxstr ;
  TCXSTR *tmp___15 ;
  TCMAP *cols ;
  TCMAP *tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;
  _Bool tmp___19 ;
  _Bool tmp___20 ;
  int tmp___21 ;
  _Bool tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *npath ;
  char *tmp___25 ;
  int omode ;
  int tmp___26 ;
  _Bool tmp___27 ;
  _Bool tmp___28 ;
  int tmp___29 ;
  _Bool tmp___30 ;
  int i___1 ;
  TDBIDX *idx___1 ;
  _Bool tmp___31 ;
  int i___2 ;
  TDBIDX *idx___2 ;
  int tmp___32 ;
  _Bool tmp___33 ;

  {
  err = (_Bool)0;
  hdb = tdb->hdb;
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    switch (idx->type) {
    case 2: 
    case 3: 
    tcmapclear((TCMAP *)idx->cc);
    break;
    }
    i ++;
  }
  i___0 = 0;
  while (i___0 < inum) {
    idx___0 = idxs + i___0;
    switch (idx___0->type) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    tmp___0 = tcbdbvanish((TCBDB *)idx___0->db);
    if (! tmp___0) {
      tmp = tcbdbecode((TCBDB *)idx___0->db);
      tctdbsetecode(tdb, tmp, "tctdb.c", 2232, "tctdboptimizeimpl");
      err = (_Bool)1;
    }
    break;
    }
    i___0 ++;
  }
  tmp___1 = tchdbpath(tdb->hdb);
  path = tmp___1;
  tmp___2 = tchdbinode(tdb->hdb);
  tmp___3 = tcsprintf("%s%ctmp%c%llu", path, '.', '.', tmp___2);
  tpath = tmp___3;
  tmp___4 = tchdbnew();
  thdb = tmp___4;
  tchdbsettype(thdb, (unsigned char)3);
  tmp___5 = tchdbdbgfd(tdb->hdb);
  dbgfd = tmp___5;
  if (dbgfd >= 0) {
    tchdbsetdbgfd(thdb, dbgfd);
  }
  tchdbcodecfunc(hdb, & enc, & encop, & dec, & decop);
  if (enc) {
    if (dec) {
      tchdbsetcodecfunc(thdb, enc, encop, dec, decop);
    }
  }
  if (bnum < 1LL) {
    tmp___6 = tchdbrnum(hdb);
    bnum = (long long )(tmp___6 * 2ULL + 1ULL);
  }
  if ((int )apow < 0) {
    tmp___7 = tchdbalign(hdb);
    tmp___8 = tclog2l((long )tmp___7);
    apow = (signed char )tmp___8;
  }
  if ((int )fpow < 0) {
    tmp___9 = tchdbfbpmax(hdb);
    tmp___10 = tclog2l((long )tmp___9);
    fpow = (signed char )tmp___10;
  }
  if ((int )opts == 255) {
    opts = tdb->opts;
  }
  hopts = (unsigned char)0;
  if ((int )opts & 1) {
    hopts = (unsigned char )((int )hopts | 1);
  }
  if ((int )opts & 2) {
    hopts = (unsigned char )((int )hopts | 2);
  }
  if ((int )opts & 4) {
    hopts = (unsigned char )((int )hopts | 4);
  }
  if ((int )opts & 8) {
    hopts = (unsigned char )((int )hopts | 8);
  }
  if ((int )opts & 16) {
    hopts = (unsigned char )((int )hopts | 16);
  }
  tchdbtune(thdb, bnum, apow, fpow, hopts);
  tmp___30 = tchdbopen(thdb, (char const   *)tpath, 14);
  if (tmp___30) {
    tmp___11 = tchdbopaque(hdb);
    tmp___12 = tchdbopaque(thdb);
    memcpy((void * __restrict  )tmp___12, (void const   * __restrict  )tmp___11, 128U);
    tmp___13 = tchdbiterinit(hdb);
    if (! tmp___13) {
      err = (_Bool)1;
    }
    tmp___14 = tcxstrnew();
    kxstr = tmp___14;
    tmp___15 = tcxstrnew();
    vxstr = tmp___15;
    while (1) {
      tmp___20 = tchdbiternext3(hdb, kxstr, vxstr);
      if (! tmp___20) {
        break;
      }
      tmp___16 = tcmapload((void const   *)vxstr->ptr, vxstr->size);
      cols = tmp___16;
      tmp___17 = tctdbidxput(tdb, (void const   *)kxstr->ptr, kxstr->size, cols);
      if (! tmp___17) {
        err = (_Bool)1;
      }
      tcmapdel(cols);
      tmp___19 = tchdbput(thdb, (void const   *)kxstr->ptr, kxstr->size, (void const   *)vxstr->ptr,
                          vxstr->size);
      if (! tmp___19) {
        tmp___18 = tchdbecode(thdb);
        tctdbsetecode(tdb, tmp___18, "tctdb.c", 2270, "tctdboptimizeimpl");
        err = (_Bool)1;
      }
    }
    tcxstrdel(vxstr);
    tcxstrdel(kxstr);
    tmp___22 = tchdbclose(thdb);
    if (! tmp___22) {
      tmp___21 = tchdbecode(thdb);
      tctdbsetecode(tdb, tmp___21, "tctdb.c", 2277, "tctdboptimizeimpl");
      err = (_Bool)1;
    }
    if (! err) {
      tmp___23 = unlink(path);
      if (tmp___23 == -1) {
        tctdbsetecode(tdb, 17, "tctdb.c", 2282, "tctdboptimizeimpl");
        err = (_Bool)1;
      }
      tmp___24 = rename((char const   *)tpath, path);
      if (tmp___24 == -1) {
        tctdbsetecode(tdb, 18, "tctdb.c", 2286, "tctdboptimizeimpl");
        err = (_Bool)1;
      }
      tmp___25 = tcstrdup((void const   *)path);
      npath = tmp___25;
      tmp___26 = tchdbomode(hdb);
      omode = (tmp___26 & -5) & -9;
      tmp___27 = tchdbclose(hdb);
      if (! tmp___27) {
        err = (_Bool)1;
      }
      tmp___28 = tchdbopen(hdb, (char const   *)npath, omode);
      if (! tmp___28) {
        err = (_Bool)1;
      }
      while (1) {
        free((void *)npath);
        break;
      }
    }
  } else {
    tmp___29 = tchdbecode(thdb);
    tctdbsetecode(tdb, tmp___29, "tctdb.c", 2296, "tctdboptimizeimpl");
    err = (_Bool)1;
  }
  tchdbdel(thdb);
  while (1) {
    free((void *)tpath);
    break;
  }
  i___1 = 0;
  while (i___1 < inum) {
    idx___1 = idxs + i___1;
    switch (idx___1->type) {
    case 2: 
    case 3: 
    tmp___31 = tctdbidxsyncicc(tdb, idx___1, (_Bool)1);
    if (! tmp___31) {
      err = (_Bool)1;
    }
    break;
    }
    i___1 ++;
  }
  i___2 = 0;
  while (i___2 < inum) {
    idx___2 = idxs + i___2;
    switch (idx___2->type) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    tmp___33 = tcbdboptimize((TCBDB *)idx___2->db, -1, -1, -1LL, (signed char)-1,
                             (signed char)-1, (unsigned char)255);
    if (! tmp___33) {
      tmp___32 = tcbdbecode((TCBDB *)idx___2->db);
      tctdbsetecode(tdb, tmp___32, "tctdb.c", 2318, "tctdboptimizeimpl");
      err = (_Bool)1;
    }
    break;
    }
    i___2 ++;
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbvanishimpl(TCTDB *tdb ) 
{ _Bool err ;
  _Bool tmp ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  int i___0 ;
  TDBIDX *idx___0 ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  err = (_Bool)0;
  tmp = tchdbvanish(tdb->hdb);
  if (! tmp) {
    err = (_Bool)1;
  }
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    switch (idx->type) {
    case 2: 
    case 3: 
    tcmapclear((TCMAP *)idx->cc);
    break;
    }
    i ++;
  }
  i___0 = 0;
  while (i___0 < inum) {
    idx___0 = idxs + i___0;
    switch (idx___0->type) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    tmp___1 = tcbdbvanish((TCBDB *)idx___0->db);
    if (! tmp___1) {
      tmp___0 = tcbdbecode((TCBDB *)idx___0->db);
      tctdbsetecode(tdb, tmp___0, "tctdb.c", 2354, "tctdbvanishimpl");
      err = (_Bool)1;
    }
    break;
    }
    i___0 ++;
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbcopyimpl(TCTDB *tdb , char const   *path ) 
{ _Bool err ;
  _Bool tmp ;
  char const   *opath ;
  char const   *tmp___0 ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  _Bool tmp___1 ;
  int i___0 ;
  TDBIDX *idx___0 ;
  char const   *ipath ;
  int tmp___2 ;
  _Bool tmp___3 ;
  char *tpath ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
  err = (_Bool)0;
  tmp = tchdbcopy(tdb->hdb, path);
  if (! tmp) {
    err = (_Bool)1;
  }
  tmp___0 = tchdbpath(tdb->hdb);
  opath = tmp___0;
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    switch (idx->type) {
    case 2: 
    case 3: 
    tmp___1 = tctdbidxsyncicc(tdb, idx, (_Bool)1);
    if (! tmp___1) {
      err = (_Bool)1;
    }
    break;
    }
    i ++;
  }
  i___0 = 0;
  while (i___0 < inum) {
    idx___0 = idxs + i___0;
    switch (idx___0->type) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    if ((int const   )*path == 64) {
      tmp___3 = tcbdbcopy((TCBDB *)idx___0->db, path);
      if (! tmp___3) {
        tmp___2 = tcbdbecode((TCBDB *)idx___0->db);
        tctdbsetecode(tdb, tmp___2, "tctdb.c", 2394, "tctdbcopyimpl");
        err = (_Bool)1;
      }
    } else {
      ipath = tcbdbpath((TCBDB *)idx___0->db);
      tmp___8 = tcstrfwm(ipath, opath);
      if (tmp___8) {
        tmp___4 = strlen(opath);
        tmp___5 = tcsprintf("%s%s", path, ipath + tmp___4);
        tpath = tmp___5;
        tmp___7 = tcbdbcopy((TCBDB *)idx___0->db, (char const   *)tpath);
        if (! tmp___7) {
          tmp___6 = tcbdbecode((TCBDB *)idx___0->db);
          tctdbsetecode(tdb, tmp___6, "tctdb.c", 2402, "tctdbcopyimpl");
          err = (_Bool)1;
        }
        while (1) {
          free((void *)tpath);
          break;
        }
      } else {
        tctdbsetecode(tdb, 9999, "tctdb.c", 2407, "tctdbcopyimpl");
        err = (_Bool)1;
      }
    }
    break;
    }
    i___0 ++;
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbtranbeginimpl(TCTDB *tdb ) 
{ _Bool tmp ;
  _Bool tmp___0 ;
  _Bool err ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  _Bool tmp___1 ;
  int i___0 ;
  TDBIDX *idx___0 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  tmp = tctdbmemsync(tdb, (_Bool)0);
  if (! tmp) {
    return ((_Bool)0);
  }
  tmp___0 = tchdbtranbegin(tdb->hdb);
  if (! tmp___0) {
    return ((_Bool)0);
  }
  err = (_Bool)0;
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    switch (idx->type) {
    case 2: 
    case 3: 
    tmp___1 = tctdbidxsyncicc(tdb, idx, (_Bool)1);
    if (! tmp___1) {
      err = (_Bool)1;
    }
    break;
    }
    i ++;
  }
  i___0 = 0;
  while (i___0 < inum) {
    idx___0 = idxs + i___0;
    switch (idx___0->type) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    tmp___3 = tcbdbtranbegin((TCBDB *)idx___0->db);
    if (! tmp___3) {
      tmp___2 = tcbdbecode((TCBDB *)idx___0->db);
      tctdbsetecode(tdb, tmp___2, "tctdb.c", 2445, "tctdbtranbeginimpl");
      err = (_Bool)1;
    }
    break;
    }
    i___0 ++;
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbtrancommitimpl(TCTDB *tdb ) 
{ _Bool err ;
  _Bool tmp ;
  _Bool tmp___0 ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  _Bool tmp___1 ;
  int i___0 ;
  TDBIDX *idx___0 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
  err = (_Bool)0;
  tmp = tctdbmemsync(tdb, (_Bool)0);
  if (! tmp) {
    err = (_Bool)1;
  }
  tmp___0 = tchdbtrancommit(tdb->hdb);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    switch (idx->type) {
    case 2: 
    case 3: 
    tmp___1 = tctdbidxsyncicc(tdb, idx, (_Bool)1);
    if (! tmp___1) {
      err = (_Bool)1;
    }
    break;
    }
    i ++;
  }
  i___0 = 0;
  while (i___0 < inum) {
    idx___0 = idxs + i___0;
    switch (idx___0->type) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    tmp___3 = tcbdbtrancommit((TCBDB *)idx___0->db);
    if (! tmp___3) {
      tmp___2 = tcbdbecode((TCBDB *)idx___0->db);
      tctdbsetecode(tdb, tmp___2, "tctdb.c", 2482, "tctdbtrancommitimpl");
      err = (_Bool)1;
    }
    break;
    }
    i___0 ++;
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbtranabortimpl(TCTDB *tdb ) 
{ _Bool err ;
  _Bool tmp ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  int i___0 ;
  TDBIDX *idx___0 ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  err = (_Bool)0;
  tmp = tchdbtranabort(tdb->hdb);
  if (! tmp) {
    err = (_Bool)1;
  }
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    switch (idx->type) {
    case 2: 
    case 3: 
    tcmapclear((TCMAP *)idx->cc);
    break;
    }
    i ++;
  }
  i___0 = 0;
  while (i___0 < inum) {
    idx___0 = idxs + i___0;
    switch (idx___0->type) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    tmp___1 = tcbdbtranabort((TCBDB *)idx___0->db);
    if (! tmp___1) {
      tmp___0 = tcbdbecode((TCBDB *)idx___0->db);
      tctdbsetecode(tdb, tmp___0, "tctdb.c", 2518, "tctdbtranabortimpl");
      err = (_Bool)1;
    }
    break;
    }
    i___0 ++;
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbsetindeximpl(TCTDB *tdb , char const   *name , int type ) 
{ _Bool err ;
  _Bool keep ;
  _Bool done ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  char const   *path ;
  _Bool tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;
  int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  TCXSTR *pbuf ;
  TCXSTR *tmp___10 ;
  char const   *tmp___11 ;
  TDBIDX *tmp___12 ;
  void *tmp___13 ;
  TDBIDX *idx___0 ;
  int homode ;
  int tmp___14 ;
  int bomode ;
  int dbgfd ;
  int tmp___15 ;
  void *(*enc)(void const   *ptr , int size , int *sp , void *op ) ;
  void *(*dec)(void const   *ptr , int size , int *sp , void *op ) ;
  void *encop ;
  void *decop ;
  int64_t bbnum ;
  uint64_t tmp___16 ;
  int64_t bxmsiz ;
  uint64_t tmp___17 ;
  uint8_t opts ;
  uint8_t bopts ;
  TCBDB *tmp___18 ;
  uint32_t tmp___19 ;
  int tmp___20 ;
  _Bool tmp___21 ;
  TCBDB *tmp___22 ;
  uint32_t tmp___23 ;
  int tmp___24 ;
  _Bool tmp___25 ;
  TCBDB *tmp___26 ;
  TCMAP *tmp___27 ;
  uint32_t tmp___28 ;
  int tmp___29 ;
  _Bool tmp___30 ;
  TCBDB *tmp___31 ;
  TCMAP *tmp___32 ;
  uint32_t tmp___33 ;
  int tmp___34 ;
  _Bool tmp___35 ;
  TCHDB *hdb ;
  _Bool tmp___36 ;
  void *db ;
  TCXSTR *kxstr ;
  TCXSTR *tmp___37 ;
  TCXSTR *vxstr ;
  TCXSTR *tmp___38 ;
  int nsiz ;
  size_t tmp___39 ;
  char const   *pkbuf ;
  int pksiz ;
  int tmp___40 ;
  _Bool tmp___41 ;
  _Bool tmp___42 ;
  _Bool tmp___43 ;
  char const   *pkbuf___0 ;
  int pksiz___0 ;
  uint16_t hash ;
  uint16_t tmp___44 ;
  int vsiz ;
  char *vbuf ;
  void *tmp___45 ;
  _Bool tmp___46 ;
  _Bool tmp___47 ;
  _Bool tmp___48 ;
  _Bool tmp___49 ;

  {
  err = (_Bool)0;
  keep = (_Bool)0;
  if (type & 16777216) {
    type &= -16777217;
    keep = (_Bool)1;
  }
  done = (_Bool)0;
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    if (0) {
      __s1_len = strlen((char const   *)idx->name);
      __s2_len = strlen(name);
      if (! ((unsigned int )((void const   *)(idx->name + 1)) - (unsigned int )((void const   *)idx->name) == 1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: 
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            tmp___9 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___9 = 1;
            } else {
              tmp___9 = 0;
            }
          }
        } else {
          tmp___9 = 0;
        }
      }
      if (tmp___9) {
        tmp___4 = __builtin_strcmp((char const   *)idx->name, name);
        tmp___8 = tmp___4;
      } else {
        tmp___7 = __builtin_strcmp((char const   *)idx->name, name);
        tmp___8 = tmp___7;
      }
    } else {
      tmp___7 = __builtin_strcmp((char const   *)idx->name, name);
      tmp___8 = tmp___7;
    }
    if (! tmp___8) {
      if (keep) {
        tctdbsetecode(tdb, 21, "tctdb.c", 2549, "tctdbsetindeximpl");
        return ((_Bool)0);
      }
      if (type == 9998) {
        switch (idx->type) {
        case 2: 
        case 3: 
        tmp = tctdbidxsyncicc(tdb, idx, (_Bool)1);
        if (! tmp) {
          err = (_Bool)1;
        }
        break;
        }
        switch (idx->type) {
        case 0: 
        case 1: 
        case 2: 
        case 3: 
        tmp___1 = tcbdboptimize((TCBDB *)idx->db, -1, -1, -1LL, (signed char)-1, (signed char)-1,
                                (unsigned char)255);
        if (! tmp___1) {
          tmp___0 = tcbdbecode((TCBDB *)idx->db);
          tctdbsetecode(tdb, tmp___0, "tctdb.c", 2565, "tctdbsetindeximpl");
          err = (_Bool)1;
        }
        break;
        }
        done = (_Bool)1;
        break;
      }
      switch (idx->type) {
      case 2: 
      case 3: 
      tcmapdel((TCMAP *)idx->cc);
      break;
      }
      switch (idx->type) {
      case 0: 
      case 1: 
      case 2: 
      case 3: 
      path = tcbdbpath((TCBDB *)idx->db);
      if (path) {
        tmp___2 = unlink(path);
        if (tmp___2) {
          tctdbsetecode(tdb, 17, "tctdb.c", 2586, "tctdbsetindeximpl");
          err = (_Bool)1;
        }
      }
      tcbdbdel((TCBDB *)idx->db);
      break;
      }
      while (1) {
        free((void *)idx->name);
        break;
      }
      (tdb->inum) --;
      inum = tdb->inum;
      memmove((void *)(idxs + i), (void const   *)((idxs + i) + 1), (unsigned int )((int )sizeof(*idxs) * (inum - i)));
      done = (_Bool)1;
      break;
    }
    i ++;
  }
  if (type == 9998) {
    goto _L___1;
  } else {
    if (type == 9999) {
      _L___1: 
      if (! done) {
        tctdbsetecode(tdb, 2, "tctdb.c", 2602, "tctdbsetindeximpl");
        err = (_Bool)1;
      }
      return ((_Bool )(! err));
    }
  }
  tmp___10 = tcxstrnew();
  pbuf = tmp___10;
  tmp___11 = tchdbpath(tdb->hdb);
  tcxstrprintf(pbuf, "%s%c%s%c%?", tmp___11, '.', "idx", '.', name);
  while (1) {
    tmp___13 = realloc((void *)tdb->idxs, (unsigned int )((int )sizeof(*(tdb->idxs + 0)) * (inum + 1)));
    tmp___12 = (TDBIDX *)tmp___13;
    tdb->idxs = tmp___12;
    if (! tmp___12) {
      tcmyfatal("out of memory");
    }
    break;
  }
  idx___0 = tdb->idxs + inum;
  tmp___14 = tchdbomode(tdb->hdb);
  homode = tmp___14;
  bomode = 14;
  if (homode & 16) {
    bomode |= 16;
  }
  if (homode & 32) {
    bomode |= 32;
  }
  if (homode & 64) {
    bomode |= 64;
  }
  tmp___15 = tchdbdbgfd(tdb->hdb);
  dbgfd = tmp___15;
  tchdbcodecfunc(tdb->hdb, & enc, & encop, & dec, & decop);
  tmp___16 = tchdbbnum(tdb->hdb);
  bbnum = (long long )((tmp___16 / 64ULL) * 4ULL + 64ULL);
  tmp___17 = tchdbxmsiz(tdb->hdb);
  bxmsiz = (long long )tmp___17;
  opts = tdb->opts;
  bopts = (unsigned char)0;
  if ((int )opts & 1) {
    bopts = (unsigned char )((int )bopts | 1);
  }
  if ((int )opts & 2) {
    bopts = (unsigned char )((int )bopts | 2);
  }
  if ((int )opts & 4) {
    bopts = (unsigned char )((int )bopts | 4);
  }
  if ((int )opts & 8) {
    bopts = (unsigned char )((int )bopts | 8);
  }
  if ((int )opts & 16) {
    bopts = (unsigned char )((int )bopts | 16);
  }
  switch (type) {
  case 0: 
  tmp___18 = tcbdbnew();
  idx___0->db = (void *)tmp___18;
  idx___0->name = tcstrdup((void const   *)name);
  tcxstrprintf(pbuf, "%clex", '.');
  if (dbgfd >= 0) {
    tcbdbsetdbgfd((TCBDB *)idx___0->db, dbgfd);
  }
  if (tdb->mmtx) {
    tcbdbsetmutex((TCBDB *)idx___0->db);
  }
  if (enc) {
    if (dec) {
      tcbdbsetcodecfunc((TCBDB *)idx___0->db, enc, encop, dec, decop);
    }
  }
  tcbdbtune((TCBDB *)idx___0->db, 64, 256, bbnum, (signed char)-1, (signed char)-1,
            bopts);
  tcbdbsetcache((TCBDB *)idx___0->db, tdb->lcnum, tdb->ncnum);
  tcbdbsetxmsiz((TCBDB *)idx___0->db, bxmsiz);
  tmp___19 = tchdbdfunit(tdb->hdb);
  tcbdbsetdfunit((TCBDB *)idx___0->db, (int )tmp___19);
  tcbdbsetlsmax((TCBDB *)idx___0->db, 4096U);
  tmp___21 = tcbdbopen((TCBDB *)idx___0->db, (char const   *)pbuf->ptr, bomode);
  if (! tmp___21) {
    tmp___20 = tcbdbecode((TCBDB *)idx___0->db);
    tctdbsetecode(tdb, tmp___20, "tctdb.c", 2643, "tctdbsetindeximpl");
    err = (_Bool)1;
  }
  (tdb->inum) ++;
  break;
  case 1: 
  tmp___22 = tcbdbnew();
  idx___0->db = (void *)tmp___22;
  idx___0->name = tcstrdup((void const   *)name);
  tcxstrprintf(pbuf, "%cdec", '.');
  if (dbgfd >= 0) {
    tcbdbsetdbgfd((TCBDB *)idx___0->db, dbgfd);
  }
  if (tdb->mmtx) {
    tcbdbsetmutex((TCBDB *)idx___0->db);
  }
  tcbdbsetcmpfunc((TCBDB *)idx___0->db, & tccmpdecimal, (void *)0);
  if (enc) {
    if (dec) {
      tcbdbsetcodecfunc((TCBDB *)idx___0->db, enc, encop, dec, decop);
    }
  }
  tcbdbtune((TCBDB *)idx___0->db, 64, 256, bbnum, (signed char)-1, (signed char)-1,
            bopts);
  tcbdbsetcache((TCBDB *)idx___0->db, tdb->lcnum, tdb->ncnum);
  tcbdbsetxmsiz((TCBDB *)idx___0->db, bxmsiz);
  tmp___23 = tchdbdfunit(tdb->hdb);
  tcbdbsetdfunit((TCBDB *)idx___0->db, (int )tmp___23);
  tcbdbsetlsmax((TCBDB *)idx___0->db, 4096U);
  tmp___25 = tcbdbopen((TCBDB *)idx___0->db, (char const   *)pbuf->ptr, bomode);
  if (! tmp___25) {
    tmp___24 = tcbdbecode((TCBDB *)idx___0->db);
    tctdbsetecode(tdb, tmp___24, "tctdb.c", 2662, "tctdbsetindeximpl");
    err = (_Bool)1;
  }
  (tdb->inum) ++;
  break;
  case 2: 
  tmp___26 = tcbdbnew();
  idx___0->db = (void *)tmp___26;
  tmp___27 = tcmapnew2(262139U);
  idx___0->cc = (void *)tmp___27;
  idx___0->name = tcstrdup((void const   *)name);
  tcxstrprintf(pbuf, "%ctok", '.');
  if (dbgfd >= 0) {
    tcbdbsetdbgfd((TCBDB *)idx___0->db, dbgfd);
  }
  if (tdb->mmtx) {
    tcbdbsetmutex((TCBDB *)idx___0->db);
  }
  if (enc) {
    if (dec) {
      tcbdbsetcodecfunc((TCBDB *)idx___0->db, enc, encop, dec, decop);
    }
  }
  tcbdbtune((TCBDB *)idx___0->db, 64, 256, bbnum, (signed char)-1, (signed char)-1,
            bopts);
  tcbdbsetcache((TCBDB *)idx___0->db, tdb->lcnum, tdb->ncnum);
  tcbdbsetxmsiz((TCBDB *)idx___0->db, bxmsiz);
  tmp___28 = tchdbdfunit(tdb->hdb);
  tcbdbsetdfunit((TCBDB *)idx___0->db, (int )tmp___28);
  tcbdbsetlsmax((TCBDB *)idx___0->db, 4096U);
  tmp___30 = tcbdbopen((TCBDB *)idx___0->db, (char const   *)pbuf->ptr, bomode);
  if (! tmp___30) {
    tmp___29 = tcbdbecode((TCBDB *)idx___0->db);
    tctdbsetecode(tdb, tmp___29, "tctdb.c", 2681, "tctdbsetindeximpl");
    err = (_Bool)1;
  }
  (tdb->inum) ++;
  break;
  case 3: 
  tmp___31 = tcbdbnew();
  idx___0->db = (void *)tmp___31;
  tmp___32 = tcmapnew2(262139U);
  idx___0->cc = (void *)tmp___32;
  idx___0->name = tcstrdup((void const   *)name);
  tcxstrprintf(pbuf, "%cqgr", '.');
  if (dbgfd >= 0) {
    tcbdbsetdbgfd((TCBDB *)idx___0->db, dbgfd);
  }
  if (tdb->mmtx) {
    tcbdbsetmutex((TCBDB *)idx___0->db);
  }
  if (enc) {
    if (dec) {
      tcbdbsetcodecfunc((TCBDB *)idx___0->db, enc, encop, dec, decop);
    }
  }
  tcbdbtune((TCBDB *)idx___0->db, 64, 256, bbnum, (signed char)-1, (signed char)-1,
            bopts);
  tcbdbsetcache((TCBDB *)idx___0->db, tdb->lcnum, tdb->ncnum);
  tcbdbsetxmsiz((TCBDB *)idx___0->db, bxmsiz);
  tmp___33 = tchdbdfunit(tdb->hdb);
  tcbdbsetdfunit((TCBDB *)idx___0->db, (int )tmp___33);
  tcbdbsetlsmax((TCBDB *)idx___0->db, 4096U);
  tmp___35 = tcbdbopen((TCBDB *)idx___0->db, (char const   *)pbuf->ptr, bomode);
  if (! tmp___35) {
    tmp___34 = tcbdbecode((TCBDB *)idx___0->db);
    tctdbsetecode(tdb, tmp___34, "tctdb.c", 2700, "tctdbsetindeximpl");
    err = (_Bool)1;
  }
  (tdb->inum) ++;
  break;
  default: 
  tctdbsetecode(tdb, 2, "tctdb.c", 2706, "tctdbsetindeximpl");
  err = (_Bool)1;
  break;
  }
  idx___0->type = type;
  if (! err) {
    hdb = tdb->hdb;
    tmp___36 = tchdbiterinit(hdb);
    if (! tmp___36) {
      err = (_Bool)1;
    }
    db = idx___0->db;
    tmp___37 = tcxstrnew();
    kxstr = tmp___37;
    tmp___38 = tcxstrnew();
    vxstr = tmp___38;
    tmp___39 = strlen(name);
    nsiz = (int )tmp___39;
    while (1) {
      tmp___49 = tchdbiternext3(hdb, kxstr, vxstr);
      if (! tmp___49) {
        break;
      }
      if (nsiz < 1) {
        pkbuf = (char const   *)kxstr->ptr;
        pksiz = kxstr->size;
        switch (type) {
        case 0: 
        case 1: 
        tmp___41 = tcbdbput((TCBDB *)db, (void const   *)pkbuf, pksiz, (void const   *)pkbuf,
                            pksiz);
        if (! tmp___41) {
          tmp___40 = tcbdbecode((TCBDB *)db);
          tctdbsetecode(tdb, tmp___40, "tctdb.c", 2726, "tctdbsetindeximpl");
          err = (_Bool)1;
        }
        break;
        case 2: 
        tmp___42 = tctdbidxputtoken(tdb, idx___0, pkbuf, pksiz, pkbuf, pksiz);
        if (! tmp___42) {
          err = (_Bool)1;
        }
        break;
        case 3: 
        tmp___43 = tctdbidxputqgram(tdb, idx___0, pkbuf, pksiz, pkbuf, pksiz);
        if (! tmp___43) {
          err = (_Bool)1;
        }
        break;
        }
      } else {
        pkbuf___0 = (char const   *)kxstr->ptr;
        pksiz___0 = kxstr->size;
        tmp___44 = tctdbidxhash(pkbuf___0, pksiz___0);
        hash = tmp___44;
        tmp___45 = tcmaploadone((void const   *)vxstr->ptr, vxstr->size, (void const   *)name,
                                nsiz, & vsiz);
        vbuf = (char *)tmp___45;
        if (vbuf) {
          switch (type) {
          case 0: 
          case 1: 
          tmp___46 = tctdbidxputone(tdb, idx___0, pkbuf___0, pksiz___0, hash, (char const   *)vbuf,
                                    vsiz);
          if (! tmp___46) {
            err = (_Bool)1;
          }
          break;
          case 2: 
          tmp___47 = tctdbidxputtoken(tdb, idx___0, pkbuf___0, pksiz___0, (char const   *)vbuf,
                                      vsiz);
          if (! tmp___47) {
            err = (_Bool)1;
          }
          break;
          case 3: 
          tmp___48 = tctdbidxputqgram(tdb, idx___0, pkbuf___0, pksiz___0, (char const   *)vbuf,
                                      vsiz);
          if (! tmp___48) {
            err = (_Bool)1;
          }
          break;
          }
          while (1) {
            free((void *)vbuf);
            break;
          }
        }
      }
    }
    tcxstrdel(vxstr);
    tcxstrdel(kxstr);
  }
  tcxstrdel(pbuf);
  return ((_Bool )(! err));
}
}
static int64_t tctdbgenuidimpl(TCTDB *tdb , int64_t inc ) 
{ void *opq ;
  char *tmp ;
  uint64_t llnum ;
  uint64_t uid ;

  {
  tmp = tchdbopaque(tdb->hdb);
  opq = (void *)tmp;
  if (inc < 0LL) {
    uid = (unsigned long long )(- inc - 1LL);
  } else {
    memcpy((void * __restrict  )(& llnum), (void const   * __restrict  )opq, (unsigned int )((int )sizeof(llnum)));
    if (inc == 0LL) {
      return ((long long )llnum);
    }
    uid = llnum + (unsigned long long )inc;
  }
  llnum = uid;
  memcpy((void * __restrict  )opq, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
  return ((long long )uid);
}
}
static TCLIST *tctdbqrysearchimpl(TDBQRY *qry ) 
{ TCTDB *tdb ;
  TCHDB *hdb ;
  TDBIDX *idxs ;
  int inum ;
  TDBCOND *conds ;
  int cnum ;
  int acnum ;
  int max ;
  char const   *oname ;
  int otype ;
  TCXSTR *hint ;
  TCLIST *res ;
  int i ;
  TDBCOND *cond ;
  _Bool isord ;
  TDBCOND *mcond ;
  TDBIDX *midx ;
  TDBCOND *ncond ;
  TDBIDX *nidx ;
  TDBCOND *scond ;
  TDBIDX *sidx ;
  int i___0 ;
  TDBCOND *cond___0 ;
  int j ;
  TDBIDX *idx ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  TCMAP *nmap ;
  long tmp___6 ;
  char const   *expr ;
  int esiz ;
  TDBCOND *ucond ;
  int i___1 ;
  TDBCOND *cond___1 ;
  _Bool trim ;
  BDBCUR *cur ;
  BDBCUR *tmp___7 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  _Bool all ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___15 ;
  int nsiz ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___16 ;
  void *tmp___17 ;
  TCLISTDATUM *array ;
  char *tmp___18 ;
  void *tmp___19 ;
  int TC_mysize___0 ;
  int TC_index___0 ;
  TCLISTDATUM *tmp___20 ;
  void *tmp___21 ;
  TCLISTDATUM *array___0 ;
  char *tmp___22 ;
  void *tmp___23 ;
  _Bool tmp___24 ;
  int TC_mysize___1 ;
  int TC_index___1 ;
  TCLISTDATUM *tmp___25 ;
  void *tmp___26 ;
  TCLISTDATUM *array___1 ;
  char *tmp___27 ;
  void *tmp___28 ;
  _Bool tmp___29 ;
  void const   *tmp___30 ;
  int tmp___31 ;
  void const   *tmp___32 ;
  BDBCUR *cur___0 ;
  BDBCUR *tmp___33 ;
  _Bool all___0 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___35 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  char const   *kbuf___0 ;
  int ksiz___0 ;
  int vsiz___0 ;
  char const   *vbuf___0 ;
  void const   *tmp___42 ;
  int nsiz___0 ;
  int TC_mysize___2 ;
  int TC_index___2 ;
  TCLISTDATUM *tmp___43 ;
  void *tmp___44 ;
  TCLISTDATUM *array___2 ;
  char *tmp___45 ;
  void *tmp___46 ;
  int TC_mysize___3 ;
  int TC_index___3 ;
  TCLISTDATUM *tmp___47 ;
  void *tmp___48 ;
  TCLISTDATUM *array___3 ;
  char *tmp___49 ;
  void *tmp___50 ;
  _Bool tmp___51 ;
  int TC_mysize___4 ;
  int TC_index___4 ;
  TCLISTDATUM *tmp___52 ;
  void *tmp___53 ;
  TCLISTDATUM *array___4 ;
  char *tmp___54 ;
  void *tmp___55 ;
  _Bool tmp___56 ;
  void const   *tmp___57 ;
  int tmp___58 ;
  void const   *tmp___59 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___61 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  BDBCUR *cur___1 ;
  BDBCUR *tmp___67 ;
  TCLIST *tokens ;
  TCLIST *tmp___68 ;
  int i___2 ;
  char *tmp___69 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___71 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___78 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tnum ;
  _Bool all___1 ;
  int i___3 ;
  char const   *token ;
  int tsiz ;
  char const   *kbuf___1 ;
  int ksiz___1 ;
  int vsiz___1 ;
  char const   *vbuf___1 ;
  void const   *tmp___84 ;
  int nsiz___1 ;
  int TC_mysize___5 ;
  int TC_index___5 ;
  TCLISTDATUM *tmp___85 ;
  void *tmp___86 ;
  TCLISTDATUM *array___5 ;
  char *tmp___87 ;
  void *tmp___88 ;
  int TC_mysize___6 ;
  int TC_index___6 ;
  TCLISTDATUM *tmp___89 ;
  void *tmp___90 ;
  TCLISTDATUM *array___6 ;
  char *tmp___91 ;
  void *tmp___92 ;
  _Bool tmp___93 ;
  int TC_mysize___7 ;
  int TC_index___7 ;
  TCLISTDATUM *tmp___94 ;
  void *tmp___95 ;
  TCLISTDATUM *array___7 ;
  char *tmp___96 ;
  void *tmp___97 ;
  _Bool tmp___98 ;
  void const   *tmp___99 ;
  int tmp___100 ;
  void const   *tmp___101 ;
  BDBCUR *cur___2 ;
  BDBCUR *tmp___102 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___104 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  long double xnum ;
  long double tmp___110 ;
  _Bool all___2 ;
  char const   *kbuf___2 ;
  int ksiz___2 ;
  int vsiz___2 ;
  char const   *vbuf___2 ;
  void const   *tmp___111 ;
  int nsiz___2 ;
  int TC_mysize___8 ;
  int TC_index___8 ;
  TCLISTDATUM *tmp___112 ;
  void *tmp___113 ;
  TCLISTDATUM *array___8 ;
  char *tmp___114 ;
  void *tmp___115 ;
  int TC_mysize___9 ;
  int TC_index___9 ;
  TCLISTDATUM *tmp___116 ;
  void *tmp___117 ;
  TCLISTDATUM *array___9 ;
  char *tmp___118 ;
  void *tmp___119 ;
  _Bool tmp___120 ;
  int TC_mysize___10 ;
  int TC_index___10 ;
  TCLISTDATUM *tmp___121 ;
  void *tmp___122 ;
  TCLISTDATUM *array___10 ;
  char *tmp___123 ;
  void *tmp___124 ;
  _Bool tmp___125 ;
  void const   *tmp___126 ;
  long double tmp___127 ;
  void const   *tmp___128 ;
  long double xnum___0 ;
  long double tmp___129 ;
  BDBCUR *cur___3 ;
  BDBCUR *tmp___130 ;
  char const   *kbuf___3 ;
  int ksiz___3 ;
  long double knum ;
  long double tmp___131 ;
  int vsiz___3 ;
  char const   *vbuf___3 ;
  void const   *tmp___132 ;
  int nsiz___3 ;
  int TC_mysize___11 ;
  int TC_index___11 ;
  TCLISTDATUM *tmp___133 ;
  void *tmp___134 ;
  TCLISTDATUM *array___11 ;
  char *tmp___135 ;
  void *tmp___136 ;
  int TC_mysize___12 ;
  int TC_index___12 ;
  TCLISTDATUM *tmp___137 ;
  void *tmp___138 ;
  TCLISTDATUM *array___12 ;
  char *tmp___139 ;
  void *tmp___140 ;
  _Bool tmp___141 ;
  int TC_mysize___13 ;
  int TC_index___13 ;
  TCLISTDATUM *tmp___142 ;
  void *tmp___143 ;
  TCLISTDATUM *array___13 ;
  char *tmp___144 ;
  void *tmp___145 ;
  _Bool tmp___146 ;
  void const   *tmp___147 ;
  void const   *tmp___148 ;
  long double xnum___1 ;
  long double tmp___149 ;
  BDBCUR *cur___4 ;
  BDBCUR *tmp___150 ;
  _Bool all___3 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___152 ;
  int tmp___155 ;
  int tmp___156 ;
  int tmp___157 ;
  int tmp___158 ;
  char const   *kbuf___4 ;
  int ksiz___4 ;
  long double knum___0 ;
  long double tmp___159 ;
  int vsiz___4 ;
  char const   *vbuf___4 ;
  void const   *tmp___160 ;
  int nsiz___4 ;
  int TC_mysize___14 ;
  int TC_index___14 ;
  TCLISTDATUM *tmp___161 ;
  void *tmp___162 ;
  TCLISTDATUM *array___14 ;
  char *tmp___163 ;
  void *tmp___164 ;
  int TC_mysize___15 ;
  int TC_index___15 ;
  TCLISTDATUM *tmp___165 ;
  void *tmp___166 ;
  TCLISTDATUM *array___15 ;
  char *tmp___167 ;
  void *tmp___168 ;
  _Bool tmp___169 ;
  int TC_mysize___16 ;
  int TC_index___16 ;
  TCLISTDATUM *tmp___170 ;
  void *tmp___171 ;
  TCLISTDATUM *array___16 ;
  char *tmp___172 ;
  void *tmp___173 ;
  _Bool tmp___174 ;
  void const   *tmp___175 ;
  void const   *tmp___176 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___178 ;
  int tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  long double xnum___2 ;
  long double tmp___184 ;
  BDBCUR *cur___5 ;
  BDBCUR *tmp___185 ;
  char const   *kbuf___5 ;
  int ksiz___5 ;
  long double knum___1 ;
  long double tmp___186 ;
  int vsiz___5 ;
  char const   *vbuf___5 ;
  void const   *tmp___187 ;
  int nsiz___5 ;
  int TC_mysize___17 ;
  int TC_index___17 ;
  TCLISTDATUM *tmp___188 ;
  void *tmp___189 ;
  TCLISTDATUM *array___17 ;
  char *tmp___190 ;
  void *tmp___191 ;
  int TC_mysize___18 ;
  int TC_index___18 ;
  TCLISTDATUM *tmp___192 ;
  void *tmp___193 ;
  TCLISTDATUM *array___18 ;
  char *tmp___194 ;
  void *tmp___195 ;
  _Bool tmp___196 ;
  int TC_mysize___19 ;
  int TC_index___19 ;
  TCLISTDATUM *tmp___197 ;
  void *tmp___198 ;
  TCLISTDATUM *array___19 ;
  char *tmp___199 ;
  void *tmp___200 ;
  _Bool tmp___201 ;
  void const   *tmp___202 ;
  void const   *tmp___203 ;
  long double xnum___3 ;
  long double tmp___204 ;
  BDBCUR *cur___6 ;
  BDBCUR *tmp___205 ;
  _Bool all___4 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___207 ;
  int tmp___210 ;
  int tmp___211 ;
  int tmp___212 ;
  int tmp___213 ;
  char const   *kbuf___6 ;
  int ksiz___6 ;
  long double knum___2 ;
  long double tmp___214 ;
  int vsiz___6 ;
  char const   *vbuf___6 ;
  void const   *tmp___215 ;
  int nsiz___6 ;
  int TC_mysize___20 ;
  int TC_index___20 ;
  TCLISTDATUM *tmp___216 ;
  void *tmp___217 ;
  TCLISTDATUM *array___20 ;
  char *tmp___218 ;
  void *tmp___219 ;
  int TC_mysize___21 ;
  int TC_index___21 ;
  TCLISTDATUM *tmp___220 ;
  void *tmp___221 ;
  TCLISTDATUM *array___21 ;
  char *tmp___222 ;
  void *tmp___223 ;
  _Bool tmp___224 ;
  int TC_mysize___22 ;
  int TC_index___22 ;
  TCLISTDATUM *tmp___225 ;
  void *tmp___226 ;
  TCLISTDATUM *array___22 ;
  char *tmp___227 ;
  void *tmp___228 ;
  _Bool tmp___229 ;
  void const   *tmp___230 ;
  void const   *tmp___231 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___233 ;
  int tmp___236 ;
  int tmp___237 ;
  int tmp___238 ;
  char const   *pv ;
  long double lower ;
  long double tmp___239 ;
  long double upper ;
  long double tmp___240 ;
  size_t tmp___241 ;
  long double swap ;
  BDBCUR *cur___7 ;
  BDBCUR *tmp___242 ;
  _Bool all___5 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___244 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  char const   *kbuf___7 ;
  int ksiz___7 ;
  long double tmp___251 ;
  int vsiz___7 ;
  char const   *vbuf___7 ;
  void const   *tmp___252 ;
  int nsiz___7 ;
  int TC_mysize___23 ;
  int TC_index___23 ;
  TCLISTDATUM *tmp___253 ;
  void *tmp___254 ;
  TCLISTDATUM *array___23 ;
  char *tmp___255 ;
  void *tmp___256 ;
  int TC_mysize___24 ;
  int TC_index___24 ;
  TCLISTDATUM *tmp___257 ;
  void *tmp___258 ;
  TCLISTDATUM *array___24 ;
  char *tmp___259 ;
  void *tmp___260 ;
  _Bool tmp___261 ;
  int TC_mysize___25 ;
  int TC_index___25 ;
  TCLISTDATUM *tmp___262 ;
  void *tmp___263 ;
  TCLISTDATUM *array___25 ;
  char *tmp___264 ;
  void *tmp___265 ;
  _Bool tmp___266 ;
  void const   *tmp___267 ;
  void const   *tmp___268 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___270 ;
  int tmp___273 ;
  int tmp___274 ;
  int tmp___275 ;
  BDBCUR *cur___8 ;
  BDBCUR *tmp___276 ;
  TCLIST *tokens___0 ;
  TCLIST *tmp___277 ;
  int i___4 ;
  char *tmp___278 ;
  long double tmp___279 ;
  long double tmp___280 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___282 ;
  int tmp___285 ;
  int tmp___286 ;
  int tmp___287 ;
  int tnum___0 ;
  _Bool all___6 ;
  int i___5 ;
  char const   *token___0 ;
  int tsiz___0 ;
  long double xnum___4 ;
  long double tmp___288 ;
  char const   *kbuf___8 ;
  int ksiz___8 ;
  int vsiz___8 ;
  char const   *vbuf___8 ;
  void const   *tmp___289 ;
  int nsiz___8 ;
  int TC_mysize___26 ;
  int TC_index___26 ;
  TCLISTDATUM *tmp___290 ;
  void *tmp___291 ;
  TCLISTDATUM *array___26 ;
  char *tmp___292 ;
  void *tmp___293 ;
  int TC_mysize___27 ;
  int TC_index___27 ;
  TCLISTDATUM *tmp___294 ;
  void *tmp___295 ;
  TCLISTDATUM *array___27 ;
  char *tmp___296 ;
  void *tmp___297 ;
  _Bool tmp___298 ;
  int TC_mysize___28 ;
  int TC_index___28 ;
  TCLISTDATUM *tmp___299 ;
  void *tmp___300 ;
  TCLISTDATUM *array___28 ;
  char *tmp___301 ;
  void *tmp___302 ;
  _Bool tmp___303 ;
  void const   *tmp___304 ;
  long double tmp___305 ;
  void const   *tmp___306 ;
  char const   *tmp___307 ;
  _Bool all___7 ;
  TCLIST *tokens___1 ;
  TCLIST *tmp___308 ;
  int i___6 ;
  char *tmp___309 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___311 ;
  int tmp___314 ;
  int tmp___315 ;
  int tmp___316 ;
  TCMAP *tres ;
  TCMAP *tmp___317 ;
  char const   *kbuf___9 ;
  int ksiz___9 ;
  int nsiz___9 ;
  int TC_mysize___29 ;
  int TC_index___29 ;
  TCLISTDATUM *tmp___318 ;
  void *tmp___319 ;
  TCLISTDATUM *array___29 ;
  char *tmp___320 ;
  void *tmp___321 ;
  int TC_mysize___30 ;
  int TC_index___30 ;
  TCLISTDATUM *tmp___322 ;
  void *tmp___323 ;
  TCLISTDATUM *array___30 ;
  char *tmp___324 ;
  void *tmp___325 ;
  _Bool tmp___326 ;
  int TC_mysize___31 ;
  int TC_index___31 ;
  TCLISTDATUM *tmp___327 ;
  void *tmp___328 ;
  TCLISTDATUM *array___31 ;
  char *tmp___329 ;
  void *tmp___330 ;
  _Bool tmp___331 ;
  void const   *tmp___332 ;
  void const   *tmp___333 ;
  TCMAP *tres___0 ;
  TCMAP *tmp___334 ;
  _Bool all___8 ;
  char const   *kbuf___10 ;
  int ksiz___10 ;
  int nsiz___10 ;
  int TC_mysize___32 ;
  int TC_index___32 ;
  TCLISTDATUM *tmp___335 ;
  void *tmp___336 ;
  TCLISTDATUM *array___32 ;
  char *tmp___337 ;
  void *tmp___338 ;
  int TC_mysize___33 ;
  int TC_index___33 ;
  TCLISTDATUM *tmp___339 ;
  void *tmp___340 ;
  TCLISTDATUM *array___33 ;
  char *tmp___341 ;
  void *tmp___342 ;
  _Bool tmp___343 ;
  int TC_mysize___34 ;
  int TC_index___34 ;
  TCLISTDATUM *tmp___344 ;
  void *tmp___345 ;
  TCLISTDATUM *array___34 ;
  char *tmp___346 ;
  void *tmp___347 ;
  _Bool tmp___348 ;
  void const   *tmp___349 ;
  void const   *tmp___350 ;
  TDBCOND *ucond___0 ;
  int i___7 ;
  TDBCOND *cond___2 ;
  _Bool trim___0 ;
  _Bool asc ;
  _Bool all___9 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___352 ;
  int tmp___355 ;
  int tmp___356 ;
  int tmp___357 ;
  BDBCUR *cur___9 ;
  BDBCUR *tmp___358 ;
  char const   *kbuf___11 ;
  int ksiz___11 ;
  int vsiz___9 ;
  char const   *vbuf___9 ;
  void const   *tmp___359 ;
  int TC_mysize___35 ;
  int TC_index___35 ;
  TCLISTDATUM *tmp___360 ;
  void *tmp___361 ;
  TCLISTDATUM *array___35 ;
  char *tmp___362 ;
  void *tmp___363 ;
  int TC_mysize___36 ;
  int TC_index___36 ;
  TCLISTDATUM *tmp___364 ;
  void *tmp___365 ;
  TCLISTDATUM *array___36 ;
  char *tmp___366 ;
  void *tmp___367 ;
  _Bool tmp___368 ;
  int TC_mysize___37 ;
  int TC_index___37 ;
  TCLISTDATUM *tmp___369 ;
  void *tmp___370 ;
  TCLISTDATUM *array___37 ;
  char *tmp___371 ;
  void *tmp___372 ;
  _Bool tmp___373 ;
  _Bool tmp___374 ;
  void const   *tmp___375 ;
  BDBCUR *cur___10 ;
  BDBCUR *tmp___376 ;
  char const   *kbuf___12 ;
  int ksiz___12 ;
  int vsiz___10 ;
  char const   *vbuf___10 ;
  void const   *tmp___377 ;
  int TC_mysize___38 ;
  int TC_index___38 ;
  TCLISTDATUM *tmp___378 ;
  void *tmp___379 ;
  TCLISTDATUM *array___38 ;
  char *tmp___380 ;
  void *tmp___381 ;
  int TC_mysize___39 ;
  int TC_index___39 ;
  TCLISTDATUM *tmp___382 ;
  void *tmp___383 ;
  TCLISTDATUM *array___39 ;
  char *tmp___384 ;
  void *tmp___385 ;
  _Bool tmp___386 ;
  int TC_mysize___40 ;
  int TC_index___40 ;
  TCLISTDATUM *tmp___387 ;
  void *tmp___388 ;
  TCLISTDATUM *array___40 ;
  char *tmp___389 ;
  void *tmp___390 ;
  _Bool tmp___391 ;
  _Bool tmp___392 ;
  void const   *tmp___393 ;
  TDBIDX *oidx ;
  _Bool asc___0 ;
  int i___8 ;
  TDBIDX *idx___0 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___395 ;
  int tmp___398 ;
  int tmp___399 ;
  int tmp___400 ;
  TDBCOND *ucond___1 ;
  int i___9 ;
  TDBCOND *cond___3 ;
  _Bool trim___1 ;
  BDBCUR *cur___11 ;
  BDBCUR *tmp___401 ;
  char const   *kbuf___13 ;
  int ksiz___13 ;
  int vsiz___11 ;
  char const   *vbuf___11 ;
  void const   *tmp___402 ;
  int TC_mysize___41 ;
  int TC_index___41 ;
  TCLISTDATUM *tmp___403 ;
  void *tmp___404 ;
  TCLISTDATUM *array___41 ;
  char *tmp___405 ;
  void *tmp___406 ;
  int TC_mysize___42 ;
  int TC_index___42 ;
  TCLISTDATUM *tmp___407 ;
  void *tmp___408 ;
  TCLISTDATUM *array___42 ;
  char *tmp___409 ;
  void *tmp___410 ;
  _Bool tmp___411 ;
  int TC_mysize___43 ;
  int TC_index___43 ;
  TCLISTDATUM *tmp___412 ;
  void *tmp___413 ;
  TCLISTDATUM *array___43 ;
  char *tmp___414 ;
  void *tmp___415 ;
  _Bool tmp___416 ;
  void const   *tmp___417 ;
  BDBCUR *cur___12 ;
  BDBCUR *tmp___418 ;
  char const   *kbuf___14 ;
  int ksiz___14 ;
  int vsiz___12 ;
  char const   *vbuf___12 ;
  void const   *tmp___419 ;
  int TC_mysize___44 ;
  int TC_index___44 ;
  TCLISTDATUM *tmp___420 ;
  void *tmp___421 ;
  TCLISTDATUM *array___44 ;
  char *tmp___422 ;
  void *tmp___423 ;
  int TC_mysize___45 ;
  int TC_index___45 ;
  TCLISTDATUM *tmp___424 ;
  void *tmp___425 ;
  TCLISTDATUM *array___45 ;
  char *tmp___426 ;
  void *tmp___427 ;
  _Bool tmp___428 ;
  int TC_mysize___46 ;
  int TC_index___46 ;
  TCLISTDATUM *tmp___429 ;
  void *tmp___430 ;
  TCLISTDATUM *array___46 ;
  char *tmp___431 ;
  void *tmp___432 ;
  _Bool tmp___433 ;
  void const   *tmp___434 ;
  int rnum ;
  uint64_t tmp___435 ;
  uint64_t tmp___436 ;
  uint64_t tmp___437 ;
  TDBCOND *ucond___2 ;
  int i___10 ;
  TDBCOND *cond___4 ;
  char *lkbuf ;
  int lksiz ;
  char *pkbuf ;
  int pksiz ;
  char const   *cbuf ;
  int csiz ;
  _Bool all___10 ;
  char *tkbuf ;
  void *tmp___438 ;
  int TC_mysize___47 ;
  int TC_index___47 ;
  TCLISTDATUM *tmp___439 ;
  void *tmp___440 ;
  TCLISTDATUM *array___47 ;
  char *tmp___441 ;
  void *tmp___442 ;
  _Bool tmp___443 ;
  int vsiz___13 ;
  char *vbuf___13 ;
  void *tmp___444 ;
  int TC_mysize___48 ;
  int TC_index___48 ;
  TCLISTDATUM *tmp___445 ;
  void *tmp___446 ;
  TCLISTDATUM *array___48 ;
  char *tmp___447 ;
  void *tmp___448 ;
  _Bool tmp___449 ;
  int TC_mysize___49 ;
  int TC_index___49 ;
  TCLISTDATUM *tmp___450 ;
  void *tmp___451 ;
  TCLISTDATUM *array___49 ;
  char *tmp___452 ;
  void *tmp___453 ;
  TCMAP *cols ;
  TCMAP *tmp___454 ;
  _Bool ok ;
  int i___11 ;
  TDBCOND *cond___5 ;
  char *tkbuf___0 ;
  void *tmp___455 ;
  _Bool tmp___456 ;
  int vsiz___14 ;
  char const   *vbuf___14 ;
  void const   *tmp___457 ;
  _Bool tmp___458 ;
  int TC_mysize___50 ;
  int TC_index___50 ;
  TCLISTDATUM *tmp___459 ;
  void *tmp___460 ;
  TCLISTDATUM *array___50 ;
  char *tmp___461 ;
  void *tmp___462 ;
  int rnum___0 ;
  TDBSORTKEY *keys ;
  void *tmp___463 ;
  int onsiz ;
  size_t tmp___464 ;
  int i___12 ;
  TDBSORTKEY *key ;
  char const   *kbuf___15 ;
  int ksiz___15 ;
  char *vbuf___15 ;
  int vsiz___15 ;
  int csiz___0 ;
  char *cbuf___0 ;
  void *tmp___465 ;
  void *tmp___466 ;
  int (*compar)(TDBSORTKEY const   *a , TDBSORTKEY const   *b ) ;
  TCLIST *nres ;
  TCLIST *tmp___467 ;
  int i___13 ;
  TDBSORTKEY *key___0 ;
  int TC_mysize___51 ;
  int TC_index___51 ;
  TCLISTDATUM *tmp___468 ;
  void *tmp___469 ;
  TCLISTDATUM *array___51 ;
  char *tmp___470 ;
  void *tmp___471 ;
  int left ;
  long tmp___472 ;
  int rsiz ;
  void *tmp___473 ;
  int tmp___474 ;
  int left___0 ;
  int rsiz___0 ;
  void *tmp___475 ;
  int tmp___476 ;

  {
  tdb = qry->tdb;
  hdb = tdb->hdb;
  idxs = tdb->idxs;
  inum = tdb->inum;
  conds = qry->conds;
  cnum = qry->cnum;
  acnum = cnum;
  max = qry->max;
  if (max < 2147483647 - qry->skip) {
    max += qry->skip;
  }
  oname = (char const   *)qry->oname;
  otype = qry->otype;
  hint = qry->hint;
  res = (TCLIST *)((void *)0);
  i = 0;
  while (i < cnum) {
    cond = conds + i;
    cond->alive = (_Bool)1;
    i ++;
  }
  tcxstrclear(hint);
  isord = (_Bool )((unsigned int )oname != (unsigned int )((void *)0));
  mcond = (TDBCOND *)((void *)0);
  midx = (TDBIDX *)((void *)0);
  ncond = (TDBCOND *)((void *)0);
  nidx = (TDBIDX *)((void *)0);
  scond = (TDBCOND *)((void *)0);
  sidx = (TDBIDX *)((void *)0);
  i___0 = 0;
  while (i___0 < cnum) {
    cond___0 = conds + i___0;
    if (! cond___0->sign) {
      goto __Cont;
    } else {
      if (cond___0->noidx) {
        goto __Cont;
      }
    }
    j = 0;
    while (j < inum) {
      idx = idxs + j;
      if (0) {
        __s1_len = strlen((char const   *)cond___0->name);
        __s2_len = strlen((char const   *)idx->name);
        if (! ((unsigned int )((void const   *)(cond___0->name + 1)) - (unsigned int )((void const   *)cond___0->name) == 1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)(idx->name + 1)) - (unsigned int )((void const   *)idx->name) == 1U)) {
              tmp___5 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___5 = 1;
              } else {
                tmp___5 = 0;
              }
            }
          } else {
            tmp___5 = 0;
          }
        }
        if (tmp___5) {
          tmp___0 = __builtin_strcmp((char const   *)cond___0->name, (char const   *)idx->name);
          tmp___4 = tmp___0;
        } else {
          tmp___3 = __builtin_strcmp((char const   *)cond___0->name, (char const   *)idx->name);
          tmp___4 = tmp___3;
        }
      } else {
        tmp___3 = __builtin_strcmp((char const   *)cond___0->name, (char const   *)idx->name);
        tmp___4 = tmp___3;
      }
      if (! tmp___4) {
        switch (idx->type) {
        case 0: 
        switch (cond___0->op) {
        case 0: 
        case 2: 
        case 6: 
        if (! mcond) {
          mcond = cond___0;
          midx = idx;
        } else {
          if (! ncond) {
            ncond = cond___0;
            nidx = idx;
          }
        }
        break;
        default: ;
        if (! scond) {
          scond = cond___0;
          sidx = idx;
        }
        break;
        }
        break;
        case 1: 
        switch (cond___0->op) {
        case 8: 
        case 9: 
        case 10: 
        case 11: 
        case 12: 
        case 13: 
        case 14: 
        if (! mcond) {
          mcond = cond___0;
          midx = idx;
        } else {
          if (! ncond) {
            ncond = cond___0;
            nidx = idx;
          }
        }
        break;
        default: ;
        if (! scond) {
          scond = cond___0;
          sidx = idx;
        }
        break;
        }
        break;
        case 2: 
        switch (cond___0->op) {
        case 4: 
        case 5: 
        if (! mcond) {
          mcond = cond___0;
          midx = idx;
        } else {
          if (! ncond) {
            ncond = cond___0;
            nidx = idx;
          }
        }
        break;
        }
        break;
        case 3: 
        switch (cond___0->op) {
        case 15: 
        if (! mcond) {
          mcond = cond___0;
          midx = idx;
        } else {
          if (! ncond) {
            ncond = cond___0;
            nidx = idx;
          }
        }
        break;
        }
        break;
        }
      }
      j ++;
    }
    __Cont: 
    i___0 ++;
  }
  if (mcond) {
    res = tclistnew();
    mcond->alive = (_Bool)0;
    acnum --;
    nmap = (TCMAP *)((void *)0);
    if (ncond) {
      ncond->alive = (_Bool)0;
      acnum --;
      nmap = tctdbqryidxfetch(qry, ncond, nidx);
      tmp___6 = tclmin((long )max, (long )nmap->rnum);
      max = (int )tmp___6;
    }
    expr = (char const   *)mcond->expr;
    esiz = mcond->esiz;
    ucond = (TDBCOND *)((void *)0);
    i___1 = 0;
    while (i___1 < cnum) {
      cond___1 = conds + i___1;
      if (! cond___1->alive) {
        goto __Cont___0;
      }
      if (ucond) {
        ucond = (TDBCOND *)((void *)0);
        break;
      }
      ucond = cond___1;
      __Cont___0: 
      i___1 ++;
    }
    trim = (_Bool )((int )*(midx->name) != 0);
    if (mcond->op == 0) {
      tcxstrprintf(hint, "using an index: \"%s\" asc (STREQ)\n", mcond->name);
      tmp___7 = tcbdbcurnew((TCBDB *)midx->db);
      cur = tmp___7;
      tcbdbcurjump(cur, (void const   *)expr, esiz + (int )trim);
      if (oname) {
        if (0) {
          __s1_len___0 = strlen(oname);
          __s2_len___0 = strlen((char const   *)mcond->name);
          if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
            goto _L___2;
          } else {
            if (__s1_len___0 >= 4U) {
              _L___2: 
              if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                tmp___14 = 1;
              } else {
                if (__s2_len___0 >= 4U) {
                  tmp___14 = 1;
                } else {
                  tmp___14 = 0;
                }
              }
            } else {
              tmp___14 = 0;
            }
          }
          if (tmp___14) {
            tmp___9 = __builtin_strcmp(oname, (char const   *)mcond->name);
            tmp___13 = tmp___9;
          } else {
            tmp___12 = __builtin_strcmp(oname, (char const   *)mcond->name);
            tmp___13 = tmp___12;
          }
        } else {
          tmp___12 = __builtin_strcmp(oname, (char const   *)mcond->name);
          tmp___13 = tmp___12;
        }
        if (! tmp___13) {
          oname = (char const   *)((void *)0);
        }
      }
      all = (_Bool )((unsigned int )oname != (unsigned int )((void *)0));
      if (! all) {
        if (max < 2147483647) {
          tcxstrprintf(hint, "limited matching: %d\n", max);
        }
      }
      trim = (_Bool )((int )*(midx->name) != 0);
      while (1) {
        if (all) {
          goto _L___4;
        } else {
          if (res->num < max) {
            _L___4: 
            tmp___32 = tcbdbcurkey3(cur, & ksiz);
            kbuf = (char const   *)tmp___32;
            if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
              break;
            }
          } else {
            break;
          }
        }
        if (trim) {
          ksiz -= 3;
        }
        if (ksiz == esiz) {
          tmp___31 = memcmp((void const   *)kbuf, (void const   *)expr, (unsigned int )esiz);
          if (tmp___31) {
            break;
          } else {
            tmp___15 = tcbdbcurval3(cur, & vsiz);
            vbuf = (char const   *)tmp___15;
            if (! nmap) {
              goto _L___3;
            } else {
              tmp___30 = tcmapget((TCMAP const   *)nmap, (void const   *)vbuf, vsiz,
                                  & nsiz);
              if (tmp___30) {
                _L___3: 
                if (acnum < 1) {
                  while (1) {
                    TC_mysize = vsiz;
                    TC_index = res->start + res->num;
                    if (TC_index >= res->anum) {
                      res->anum += res->num + 1;
                      while (1) {
                        tmp___17 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                        tmp___16 = (TCLISTDATUM *)tmp___17;
                        res->array = tmp___16;
                        if (! tmp___16) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    array = res->array;
                    while (1) {
                      tmp___19 = malloc((unsigned int )(TC_mysize + 1));
                      tmp___18 = (char *)tmp___19;
                      (array + TC_index)->ptr = tmp___18;
                      if (! tmp___18) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )vbuf,
                           (unsigned int )TC_mysize);
                    *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
                    (array + TC_index)->size = TC_mysize;
                    (res->num) ++;
                    break;
                  }
                } else {
                  if (ucond) {
                    tmp___24 = tctdbqryonecondmatch(qry, ucond, vbuf, vsiz);
                    if (tmp___24) {
                      while (1) {
                        TC_mysize___0 = vsiz;
                        TC_index___0 = res->start + res->num;
                        if (TC_index___0 >= res->anum) {
                          res->anum += res->num + 1;
                          while (1) {
                            tmp___21 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                            tmp___20 = (TCLISTDATUM *)tmp___21;
                            res->array = tmp___20;
                            if (! tmp___20) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___0 = res->array;
                        while (1) {
                          tmp___23 = malloc((unsigned int )(TC_mysize___0 + 1));
                          tmp___22 = (char *)tmp___23;
                          (array___0 + TC_index___0)->ptr = tmp___22;
                          if (! tmp___22) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___0 + TC_index___0)->ptr,
                               (void const   * __restrict  )vbuf, (unsigned int )TC_mysize___0);
                        *((array___0 + TC_index___0)->ptr + TC_mysize___0) = (char )'\000';
                        (array___0 + TC_index___0)->size = TC_mysize___0;
                        (res->num) ++;
                        break;
                      }
                    }
                  } else {
                    tmp___29 = tctdbqryallcondmatch(qry, vbuf, vsiz);
                    if (tmp___29) {
                      while (1) {
                        TC_mysize___1 = vsiz;
                        TC_index___1 = res->start + res->num;
                        if (TC_index___1 >= res->anum) {
                          res->anum += res->num + 1;
                          while (1) {
                            tmp___26 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                            tmp___25 = (TCLISTDATUM *)tmp___26;
                            res->array = tmp___25;
                            if (! tmp___25) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___1 = res->array;
                        while (1) {
                          tmp___28 = malloc((unsigned int )(TC_mysize___1 + 1));
                          tmp___27 = (char *)tmp___28;
                          (array___1 + TC_index___1)->ptr = tmp___27;
                          if (! tmp___27) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___1 + TC_index___1)->ptr,
                               (void const   * __restrict  )vbuf, (unsigned int )TC_mysize___1);
                        *((array___1 + TC_index___1)->ptr + TC_mysize___1) = (char )'\000';
                        (array___1 + TC_index___1)->size = TC_mysize___1;
                        (res->num) ++;
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          break;
        }
        tcbdbcurnext(cur);
      }
      tcbdbcurdel(cur);
    } else {
      if (mcond->op == 2) {
        tcxstrprintf(hint, "using an index: \"%s\" asc (STRBW)\n", mcond->name);
        tmp___33 = tcbdbcurnew((TCBDB *)midx->db);
        cur___0 = tmp___33;
        tcbdbcurjump(cur___0, (void const   *)expr, esiz + (int )trim);
        if (oname) {
          if (0) {
            __s1_len___1 = strlen(oname);
            __s2_len___1 = strlen((char const   *)mcond->name);
            if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
              goto _L___6;
            } else {
              if (__s1_len___1 >= 4U) {
                _L___6: 
                if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                  tmp___40 = 1;
                } else {
                  if (__s2_len___1 >= 4U) {
                    tmp___40 = 1;
                  } else {
                    tmp___40 = 0;
                  }
                }
              } else {
                tmp___40 = 0;
              }
            }
            if (tmp___40) {
              tmp___35 = __builtin_strcmp(oname, (char const   *)mcond->name);
              tmp___39 = tmp___35;
            } else {
              tmp___38 = __builtin_strcmp(oname, (char const   *)mcond->name);
              tmp___39 = tmp___38;
            }
          } else {
            tmp___38 = __builtin_strcmp(oname, (char const   *)mcond->name);
            tmp___39 = tmp___38;
          }
          if (tmp___39) {
            tmp___41 = 1;
          } else {
            if (otype != 0) {
              tmp___41 = 1;
            } else {
              tmp___41 = 0;
            }
          }
        } else {
          tmp___41 = 0;
        }
        all___0 = (_Bool )tmp___41;
        if (! all___0) {
          if (max < 2147483647) {
            tcxstrprintf(hint, "limited matching: %d\n", max);
          }
        }
        while (1) {
          if (all___0) {
            goto _L___8;
          } else {
            if (res->num < max) {
              _L___8: 
              tmp___59 = tcbdbcurkey3(cur___0, & ksiz___0);
              kbuf___0 = (char const   *)tmp___59;
              if (! ((unsigned int )kbuf___0 != (unsigned int )((void *)0))) {
                break;
              }
            } else {
              break;
            }
          }
          if (trim) {
            ksiz___0 -= 3;
          }
          if (ksiz___0 >= esiz) {
            tmp___58 = memcmp((void const   *)kbuf___0, (void const   *)expr, (unsigned int )esiz);
            if (tmp___58) {
              break;
            } else {
              tmp___42 = tcbdbcurval3(cur___0, & vsiz___0);
              vbuf___0 = (char const   *)tmp___42;
              if (! nmap) {
                goto _L___7;
              } else {
                tmp___57 = tcmapget((TCMAP const   *)nmap, (void const   *)vbuf___0,
                                    vsiz___0, & nsiz___0);
                if (tmp___57) {
                  _L___7: 
                  if (acnum < 1) {
                    while (1) {
                      TC_mysize___2 = vsiz___0;
                      TC_index___2 = res->start + res->num;
                      if (TC_index___2 >= res->anum) {
                        res->anum += res->num + 1;
                        while (1) {
                          tmp___44 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                          tmp___43 = (TCLISTDATUM *)tmp___44;
                          res->array = tmp___43;
                          if (! tmp___43) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                      }
                      array___2 = res->array;
                      while (1) {
                        tmp___46 = malloc((unsigned int )(TC_mysize___2 + 1));
                        tmp___45 = (char *)tmp___46;
                        (array___2 + TC_index___2)->ptr = tmp___45;
                        if (! tmp___45) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                      memcpy((void * __restrict  )(array___2 + TC_index___2)->ptr,
                             (void const   * __restrict  )vbuf___0, (unsigned int )TC_mysize___2);
                      *((array___2 + TC_index___2)->ptr + TC_mysize___2) = (char )'\000';
                      (array___2 + TC_index___2)->size = TC_mysize___2;
                      (res->num) ++;
                      break;
                    }
                  } else {
                    if (ucond) {
                      tmp___51 = tctdbqryonecondmatch(qry, ucond, vbuf___0, vsiz___0);
                      if (tmp___51) {
                        while (1) {
                          TC_mysize___3 = vsiz___0;
                          TC_index___3 = res->start + res->num;
                          if (TC_index___3 >= res->anum) {
                            res->anum += res->num + 1;
                            while (1) {
                              tmp___48 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                              tmp___47 = (TCLISTDATUM *)tmp___48;
                              res->array = tmp___47;
                              if (! tmp___47) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                          }
                          array___3 = res->array;
                          while (1) {
                            tmp___50 = malloc((unsigned int )(TC_mysize___3 + 1));
                            tmp___49 = (char *)tmp___50;
                            (array___3 + TC_index___3)->ptr = tmp___49;
                            if (! tmp___49) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                          memcpy((void * __restrict  )(array___3 + TC_index___3)->ptr,
                                 (void const   * __restrict  )vbuf___0, (unsigned int )TC_mysize___3);
                          *((array___3 + TC_index___3)->ptr + TC_mysize___3) = (char )'\000';
                          (array___3 + TC_index___3)->size = TC_mysize___3;
                          (res->num) ++;
                          break;
                        }
                      }
                    } else {
                      tmp___56 = tctdbqryallcondmatch(qry, vbuf___0, vsiz___0);
                      if (tmp___56) {
                        while (1) {
                          TC_mysize___4 = vsiz___0;
                          TC_index___4 = res->start + res->num;
                          if (TC_index___4 >= res->anum) {
                            res->anum += res->num + 1;
                            while (1) {
                              tmp___53 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                              tmp___52 = (TCLISTDATUM *)tmp___53;
                              res->array = tmp___52;
                              if (! tmp___52) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                          }
                          array___4 = res->array;
                          while (1) {
                            tmp___55 = malloc((unsigned int )(TC_mysize___4 + 1));
                            tmp___54 = (char *)tmp___55;
                            (array___4 + TC_index___4)->ptr = tmp___54;
                            if (! tmp___54) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                          memcpy((void * __restrict  )(array___4 + TC_index___4)->ptr,
                                 (void const   * __restrict  )vbuf___0, (unsigned int )TC_mysize___4);
                          *((array___4 + TC_index___4)->ptr + TC_mysize___4) = (char )'\000';
                          (array___4 + TC_index___4)->size = TC_mysize___4;
                          (res->num) ++;
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            break;
          }
          tcbdbcurnext(cur___0);
        }
        tcbdbcurdel(cur___0);
        if (oname) {
          if (0) {
            __s1_len___2 = strlen(oname);
            __s2_len___2 = strlen((char const   *)mcond->name);
            if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
              goto _L___10;
            } else {
              if (__s1_len___2 >= 4U) {
                _L___10: 
                if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                  tmp___66 = 1;
                } else {
                  if (__s2_len___2 >= 4U) {
                    tmp___66 = 1;
                  } else {
                    tmp___66 = 0;
                  }
                }
              } else {
                tmp___66 = 0;
              }
            }
            if (tmp___66) {
              tmp___61 = __builtin_strcmp(oname, (char const   *)mcond->name);
              tmp___65 = tmp___61;
            } else {
              tmp___64 = __builtin_strcmp(oname, (char const   *)mcond->name);
              tmp___65 = tmp___64;
            }
          } else {
            tmp___64 = __builtin_strcmp(oname, (char const   *)mcond->name);
            tmp___65 = tmp___64;
          }
          if (! tmp___65) {
            if (otype == 0) {
              oname = (char const   *)((void *)0);
            } else {
              if (otype == 1) {
                tclistinvert(res);
                oname = (char const   *)((void *)0);
              }
            }
          }
        }
      } else {
        if (mcond->op == 6) {
          tcxstrprintf(hint, "using an index: \"%s\" skip (STROREQ)\n", mcond->name);
          tmp___67 = tcbdbcurnew((TCBDB *)midx->db);
          cur___1 = tmp___67;
          tmp___68 = tcstrsplit(expr, "\t\n\r ,");
          tokens = tmp___68;
          tclistsort(tokens);
          i___2 = 1;
          while (i___2 < tokens->num) {
            if (0) {
              __s1_len___3 = strlen((char const   *)((void *)(tokens->array + (i___2 + tokens->start))->ptr));
              __s2_len___3 = strlen((char const   *)((void *)(tokens->array + ((i___2 - 1) + tokens->start))->ptr));
              if (! ((unsigned int )((void const   *)((void *)(tokens->array + (i___2 + tokens->start))->ptr + 1)) - (unsigned int )((void const   *)((void *)(tokens->array + (i___2 + tokens->start))->ptr)) == 1U)) {
                goto _L___12;
              } else {
                if (__s1_len___3 >= 4U) {
                  _L___12: 
                  if (! ((unsigned int )((void const   *)((void *)(tokens->array + ((i___2 - 1) + tokens->start))->ptr + 1)) - (unsigned int )((void const   *)((void *)(tokens->array + ((i___2 - 1) + tokens->start))->ptr)) == 1U)) {
                    tmp___76 = 1;
                  } else {
                    if (__s2_len___3 >= 4U) {
                      tmp___76 = 1;
                    } else {
                      tmp___76 = 0;
                    }
                  }
                } else {
                  tmp___76 = 0;
                }
              }
              if (tmp___76) {
                tmp___71 = __builtin_strcmp((char const   *)((void *)(tokens->array + (i___2 + tokens->start))->ptr),
                                            (char const   *)((void *)(tokens->array + ((i___2 - 1) + tokens->start))->ptr));
                tmp___75 = tmp___71;
              } else {
                tmp___74 = __builtin_strcmp((char const   *)((void *)(tokens->array + (i___2 + tokens->start))->ptr),
                                            (char const   *)((void *)(tokens->array + ((i___2 - 1) + tokens->start))->ptr));
                tmp___75 = tmp___74;
              }
            } else {
              tmp___74 = __builtin_strcmp((char const   *)((void *)(tokens->array + (i___2 + tokens->start))->ptr),
                                          (char const   *)((void *)(tokens->array + ((i___2 - 1) + tokens->start))->ptr));
              tmp___75 = tmp___74;
            }
            if (! tmp___75) {
              while (1) {
                tmp___69 = tclistremove2(tokens, i___2);
                free((void *)tmp___69);
                break;
              }
              i___2 --;
            }
            i___2 ++;
          }
          if (oname) {
            if (0) {
              __s1_len___4 = strlen(oname);
              __s2_len___4 = strlen((char const   *)mcond->name);
              if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
                goto _L___14;
              } else {
                if (__s1_len___4 >= 4U) {
                  _L___14: 
                  if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                    tmp___83 = 1;
                  } else {
                    if (__s2_len___4 >= 4U) {
                      tmp___83 = 1;
                    } else {
                      tmp___83 = 0;
                    }
                  }
                } else {
                  tmp___83 = 0;
                }
              }
              if (tmp___83) {
                tmp___78 = __builtin_strcmp(oname, (char const   *)mcond->name);
                tmp___82 = tmp___78;
              } else {
                tmp___81 = __builtin_strcmp(oname, (char const   *)mcond->name);
                tmp___82 = tmp___81;
              }
            } else {
              tmp___81 = __builtin_strcmp(oname, (char const   *)mcond->name);
              tmp___82 = tmp___81;
            }
            if (! tmp___82) {
              if (otype == 0) {
                oname = (char const   *)((void *)0);
              } else {
                if (otype == 1) {
                  tclistinvert(tokens);
                  oname = (char const   *)((void *)0);
                }
              }
            }
          }
          tnum = tokens->num;
          all___1 = (_Bool )((unsigned int )oname != (unsigned int )((void *)0));
          if (! all___1) {
            if (max < 2147483647) {
              tcxstrprintf(hint, "limited matching: %d\n", max);
            }
          }
          i___3 = 0;
          while (1) {
            if (all___1) {
              goto _L___17;
            } else {
              if (res->num < max) {
                _L___17: 
                if (! (i___3 < tnum)) {
                  break;
                }
              } else {
                break;
              }
            }
            while (1) {
              token = (char const   *)(tokens->array + (i___3 + tokens->start))->ptr;
              tsiz = (tokens->array + (i___3 + tokens->start))->size;
              break;
            }
            if (tsiz < 1) {
              goto __Cont___1;
            }
            tcbdbcurjump(cur___1, (void const   *)token, tsiz + (int )trim);
            while (1) {
              if (all___1) {
                goto _L___16;
              } else {
                if (res->num < max) {
                  _L___16: 
                  tmp___101 = tcbdbcurkey3(cur___1, & ksiz___1);
                  kbuf___1 = (char const   *)tmp___101;
                  if (! ((unsigned int )kbuf___1 != (unsigned int )((void *)0))) {
                    break;
                  }
                } else {
                  break;
                }
              }
              if (trim) {
                ksiz___1 -= 3;
              }
              if (ksiz___1 == tsiz) {
                tmp___100 = memcmp((void const   *)kbuf___1, (void const   *)token,
                                   (unsigned int )tsiz);
                if (tmp___100) {
                  break;
                } else {
                  tmp___84 = tcbdbcurval3(cur___1, & vsiz___1);
                  vbuf___1 = (char const   *)tmp___84;
                  if (! nmap) {
                    goto _L___15;
                  } else {
                    tmp___99 = tcmapget((TCMAP const   *)nmap, (void const   *)vbuf___1,
                                        vsiz___1, & nsiz___1);
                    if (tmp___99) {
                      _L___15: 
                      if (acnum < 1) {
                        while (1) {
                          TC_mysize___5 = vsiz___1;
                          TC_index___5 = res->start + res->num;
                          if (TC_index___5 >= res->anum) {
                            res->anum += res->num + 1;
                            while (1) {
                              tmp___86 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                              tmp___85 = (TCLISTDATUM *)tmp___86;
                              res->array = tmp___85;
                              if (! tmp___85) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                          }
                          array___5 = res->array;
                          while (1) {
                            tmp___88 = malloc((unsigned int )(TC_mysize___5 + 1));
                            tmp___87 = (char *)tmp___88;
                            (array___5 + TC_index___5)->ptr = tmp___87;
                            if (! tmp___87) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                          memcpy((void * __restrict  )(array___5 + TC_index___5)->ptr,
                                 (void const   * __restrict  )vbuf___1, (unsigned int )TC_mysize___5);
                          *((array___5 + TC_index___5)->ptr + TC_mysize___5) = (char )'\000';
                          (array___5 + TC_index___5)->size = TC_mysize___5;
                          (res->num) ++;
                          break;
                        }
                      } else {
                        if (ucond) {
                          tmp___93 = tctdbqryonecondmatch(qry, ucond, vbuf___1, vsiz___1);
                          if (tmp___93) {
                            while (1) {
                              TC_mysize___6 = vsiz___1;
                              TC_index___6 = res->start + res->num;
                              if (TC_index___6 >= res->anum) {
                                res->anum += res->num + 1;
                                while (1) {
                                  tmp___90 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                  tmp___89 = (TCLISTDATUM *)tmp___90;
                                  res->array = tmp___89;
                                  if (! tmp___89) {
                                    tcmyfatal("out of memory");
                                  }
                                  break;
                                }
                              }
                              array___6 = res->array;
                              while (1) {
                                tmp___92 = malloc((unsigned int )(TC_mysize___6 + 1));
                                tmp___91 = (char *)tmp___92;
                                (array___6 + TC_index___6)->ptr = tmp___91;
                                if (! tmp___91) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                              memcpy((void * __restrict  )(array___6 + TC_index___6)->ptr,
                                     (void const   * __restrict  )vbuf___1, (unsigned int )TC_mysize___6);
                              *((array___6 + TC_index___6)->ptr + TC_mysize___6) = (char )'\000';
                              (array___6 + TC_index___6)->size = TC_mysize___6;
                              (res->num) ++;
                              break;
                            }
                          }
                        } else {
                          tmp___98 = tctdbqryallcondmatch(qry, vbuf___1, vsiz___1);
                          if (tmp___98) {
                            while (1) {
                              TC_mysize___7 = vsiz___1;
                              TC_index___7 = res->start + res->num;
                              if (TC_index___7 >= res->anum) {
                                res->anum += res->num + 1;
                                while (1) {
                                  tmp___95 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                  tmp___94 = (TCLISTDATUM *)tmp___95;
                                  res->array = tmp___94;
                                  if (! tmp___94) {
                                    tcmyfatal("out of memory");
                                  }
                                  break;
                                }
                              }
                              array___7 = res->array;
                              while (1) {
                                tmp___97 = malloc((unsigned int )(TC_mysize___7 + 1));
                                tmp___96 = (char *)tmp___97;
                                (array___7 + TC_index___7)->ptr = tmp___96;
                                if (! tmp___96) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                              memcpy((void * __restrict  )(array___7 + TC_index___7)->ptr,
                                     (void const   * __restrict  )vbuf___1, (unsigned int )TC_mysize___7);
                              *((array___7 + TC_index___7)->ptr + TC_mysize___7) = (char )'\000';
                              (array___7 + TC_index___7)->size = TC_mysize___7;
                              (res->num) ++;
                              break;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                break;
              }
              tcbdbcurnext(cur___1);
            }
            __Cont___1: 
            i___3 ++;
          }
          tclistdel(tokens);
          tcbdbcurdel(cur___1);
        } else {
          if (mcond->op == 8) {
            tcxstrprintf(hint, "using an index: \"%s\" asc (NUMEQ)\n", mcond->name);
            tmp___102 = tcbdbcurnew((TCBDB *)midx->db);
            cur___2 = tmp___102;
            if (oname) {
              if (0) {
                __s1_len___5 = strlen(oname);
                __s2_len___5 = strlen((char const   *)mcond->name);
                if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
                  goto _L___19;
                } else {
                  if (__s1_len___5 >= 4U) {
                    _L___19: 
                    if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                      tmp___109 = 1;
                    } else {
                      if (__s2_len___5 >= 4U) {
                        tmp___109 = 1;
                      } else {
                        tmp___109 = 0;
                      }
                    }
                  } else {
                    tmp___109 = 0;
                  }
                }
                if (tmp___109) {
                  tmp___104 = __builtin_strcmp(oname, (char const   *)mcond->name);
                  tmp___108 = tmp___104;
                } else {
                  tmp___107 = __builtin_strcmp(oname, (char const   *)mcond->name);
                  tmp___108 = tmp___107;
                }
              } else {
                tmp___107 = __builtin_strcmp(oname, (char const   *)mcond->name);
                tmp___108 = tmp___107;
              }
              if (! tmp___108) {
                oname = (char const   *)((void *)0);
              }
            }
            tmp___110 = tctdbatof(expr);
            xnum = tmp___110;
            tctdbqryidxcurjumpnum(cur___2, expr, esiz, (_Bool)1);
            all___2 = (_Bool )((unsigned int )oname != (unsigned int )((void *)0));
            if (! all___2) {
              if (max < 2147483647) {
                tcxstrprintf(hint, "limited matching: %d\n", max);
              }
            }
            while (1) {
              if (all___2) {
                goto _L___21;
              } else {
                if (res->num < max) {
                  _L___21: 
                  tmp___128 = tcbdbcurkey3(cur___2, & ksiz___2);
                  kbuf___2 = (char const   *)tmp___128;
                  if (! ((unsigned int )kbuf___2 != (unsigned int )((void *)0))) {
                    break;
                  }
                } else {
                  break;
                }
              }
              tmp___127 = tctdbatof(kbuf___2);
              if (tmp___127 == xnum) {
                tmp___111 = tcbdbcurval3(cur___2, & vsiz___2);
                vbuf___2 = (char const   *)tmp___111;
                if (! nmap) {
                  goto _L___20;
                } else {
                  tmp___126 = tcmapget((TCMAP const   *)nmap, (void const   *)vbuf___2,
                                       vsiz___2, & nsiz___2);
                  if (tmp___126) {
                    _L___20: 
                    if (acnum < 1) {
                      while (1) {
                        TC_mysize___8 = vsiz___2;
                        TC_index___8 = res->start + res->num;
                        if (TC_index___8 >= res->anum) {
                          res->anum += res->num + 1;
                          while (1) {
                            tmp___113 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                            tmp___112 = (TCLISTDATUM *)tmp___113;
                            res->array = tmp___112;
                            if (! tmp___112) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___8 = res->array;
                        while (1) {
                          tmp___115 = malloc((unsigned int )(TC_mysize___8 + 1));
                          tmp___114 = (char *)tmp___115;
                          (array___8 + TC_index___8)->ptr = tmp___114;
                          if (! tmp___114) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___8 + TC_index___8)->ptr,
                               (void const   * __restrict  )vbuf___2, (unsigned int )TC_mysize___8);
                        *((array___8 + TC_index___8)->ptr + TC_mysize___8) = (char )'\000';
                        (array___8 + TC_index___8)->size = TC_mysize___8;
                        (res->num) ++;
                        break;
                      }
                    } else {
                      if (ucond) {
                        tmp___120 = tctdbqryonecondmatch(qry, ucond, vbuf___2, vsiz___2);
                        if (tmp___120) {
                          while (1) {
                            TC_mysize___9 = vsiz___2;
                            TC_index___9 = res->start + res->num;
                            if (TC_index___9 >= res->anum) {
                              res->anum += res->num + 1;
                              while (1) {
                                tmp___117 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                tmp___116 = (TCLISTDATUM *)tmp___117;
                                res->array = tmp___116;
                                if (! tmp___116) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                            }
                            array___9 = res->array;
                            while (1) {
                              tmp___119 = malloc((unsigned int )(TC_mysize___9 + 1));
                              tmp___118 = (char *)tmp___119;
                              (array___9 + TC_index___9)->ptr = tmp___118;
                              if (! tmp___118) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                            memcpy((void * __restrict  )(array___9 + TC_index___9)->ptr,
                                   (void const   * __restrict  )vbuf___2, (unsigned int )TC_mysize___9);
                            *((array___9 + TC_index___9)->ptr + TC_mysize___9) = (char )'\000';
                            (array___9 + TC_index___9)->size = TC_mysize___9;
                            (res->num) ++;
                            break;
                          }
                        }
                      } else {
                        tmp___125 = tctdbqryallcondmatch(qry, vbuf___2, vsiz___2);
                        if (tmp___125) {
                          while (1) {
                            TC_mysize___10 = vsiz___2;
                            TC_index___10 = res->start + res->num;
                            if (TC_index___10 >= res->anum) {
                              res->anum += res->num + 1;
                              while (1) {
                                tmp___122 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                tmp___121 = (TCLISTDATUM *)tmp___122;
                                res->array = tmp___121;
                                if (! tmp___121) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                            }
                            array___10 = res->array;
                            while (1) {
                              tmp___124 = malloc((unsigned int )(TC_mysize___10 + 1));
                              tmp___123 = (char *)tmp___124;
                              (array___10 + TC_index___10)->ptr = tmp___123;
                              if (! tmp___123) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                            memcpy((void * __restrict  )(array___10 + TC_index___10)->ptr,
                                   (void const   * __restrict  )vbuf___2, (unsigned int )TC_mysize___10);
                            *((array___10 + TC_index___10)->ptr + TC_mysize___10) = (char )'\000';
                            (array___10 + TC_index___10)->size = TC_mysize___10;
                            (res->num) ++;
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              } else {
                break;
              }
              tcbdbcurnext(cur___2);
            }
            tcbdbcurdel(cur___2);
          } else {
            if (mcond->op == 9) {
              goto _L___63;
            } else {
              if (mcond->op == 10) {
                _L___63: 
                if (oname) {
                  if (0) {
                    __s1_len___7 = strlen(oname);
                    __s2_len___7 = strlen((char const   *)mcond->name);
                    if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
                      goto _L___30;
                    } else {
                      if (__s1_len___7 >= 4U) {
                        _L___30: 
                        if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                          tmp___183 = 1;
                        } else {
                          if (__s2_len___7 >= 4U) {
                            tmp___183 = 1;
                          } else {
                            tmp___183 = 0;
                          }
                        }
                      } else {
                        tmp___183 = 0;
                      }
                    }
                    if (tmp___183) {
                      tmp___178 = __builtin_strcmp(oname, (char const   *)mcond->name);
                      tmp___182 = tmp___178;
                    } else {
                      tmp___181 = __builtin_strcmp(oname, (char const   *)mcond->name);
                      tmp___182 = tmp___181;
                    }
                  } else {
                    tmp___181 = __builtin_strcmp(oname, (char const   *)mcond->name);
                    tmp___182 = tmp___181;
                  }
                  if (tmp___182) {
                    goto _L___32;
                  } else {
                    if (otype == 3) {
                      tcxstrprintf(hint, "using an index: \"%s\" desc (NUMGT/NUMGE)\n",
                                   mcond->name);
                      tmp___129 = tctdbatof(expr);
                      xnum___0 = tmp___129;
                      tmp___130 = tcbdbcurnew((TCBDB *)midx->db);
                      cur___3 = tmp___130;
                      tcbdbcurlast(cur___3);
                      if (max < 2147483647) {
                        tcxstrprintf(hint, "limited matching: %d\n", max);
                      }
                      while (1) {
                        if (res->num < max) {
                          tmp___148 = tcbdbcurkey3(cur___3, & ksiz___3);
                          kbuf___3 = (char const   *)tmp___148;
                          if (! ((unsigned int )kbuf___3 != (unsigned int )((void *)0))) {
                            break;
                          }
                        } else {
                          break;
                        }
                        tmp___131 = tctdbatof(kbuf___3);
                        knum = tmp___131;
                        if (knum < xnum___0) {
                          break;
                        }
                        if (knum > xnum___0) {
                          goto _L___23;
                        } else {
                          if (knum >= xnum___0) {
                            if (mcond->op == 10) {
                              _L___23: 
                              tmp___132 = tcbdbcurval3(cur___3, & vsiz___3);
                              vbuf___3 = (char const   *)tmp___132;
                              if (! nmap) {
                                goto _L___22;
                              } else {
                                tmp___147 = tcmapget((TCMAP const   *)nmap, (void const   *)vbuf___3,
                                                     vsiz___3, & nsiz___3);
                                if (tmp___147) {
                                  _L___22: 
                                  if (acnum < 1) {
                                    while (1) {
                                      TC_mysize___11 = vsiz___3;
                                      TC_index___11 = res->start + res->num;
                                      if (TC_index___11 >= res->anum) {
                                        res->anum += res->num + 1;
                                        while (1) {
                                          tmp___134 = realloc((void *)res->array,
                                                              (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                          tmp___133 = (TCLISTDATUM *)tmp___134;
                                          res->array = tmp___133;
                                          if (! tmp___133) {
                                            tcmyfatal("out of memory");
                                          }
                                          break;
                                        }
                                      }
                                      array___11 = res->array;
                                      while (1) {
                                        tmp___136 = malloc((unsigned int )(TC_mysize___11 + 1));
                                        tmp___135 = (char *)tmp___136;
                                        (array___11 + TC_index___11)->ptr = tmp___135;
                                        if (! tmp___135) {
                                          tcmyfatal("out of memory");
                                        }
                                        break;
                                      }
                                      memcpy((void * __restrict  )(array___11 + TC_index___11)->ptr,
                                             (void const   * __restrict  )vbuf___3,
                                             (unsigned int )TC_mysize___11);
                                      *((array___11 + TC_index___11)->ptr + TC_mysize___11) = (char )'\000';
                                      (array___11 + TC_index___11)->size = TC_mysize___11;
                                      (res->num) ++;
                                      break;
                                    }
                                  } else {
                                    if (ucond) {
                                      tmp___141 = tctdbqryonecondmatch(qry, ucond,
                                                                       vbuf___3, vsiz___3);
                                      if (tmp___141) {
                                        while (1) {
                                          TC_mysize___12 = vsiz___3;
                                          TC_index___12 = res->start + res->num;
                                          if (TC_index___12 >= res->anum) {
                                            res->anum += res->num + 1;
                                            while (1) {
                                              tmp___138 = realloc((void *)res->array,
                                                                  (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                              tmp___137 = (TCLISTDATUM *)tmp___138;
                                              res->array = tmp___137;
                                              if (! tmp___137) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          array___12 = res->array;
                                          while (1) {
                                            tmp___140 = malloc((unsigned int )(TC_mysize___12 + 1));
                                            tmp___139 = (char *)tmp___140;
                                            (array___12 + TC_index___12)->ptr = tmp___139;
                                            if (! tmp___139) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                          memcpy((void * __restrict  )(array___12 + TC_index___12)->ptr,
                                                 (void const   * __restrict  )vbuf___3,
                                                 (unsigned int )TC_mysize___12);
                                          *((array___12 + TC_index___12)->ptr + TC_mysize___12) = (char )'\000';
                                          (array___12 + TC_index___12)->size = TC_mysize___12;
                                          (res->num) ++;
                                          break;
                                        }
                                      }
                                    } else {
                                      tmp___146 = tctdbqryallcondmatch(qry, vbuf___3,
                                                                       vsiz___3);
                                      if (tmp___146) {
                                        while (1) {
                                          TC_mysize___13 = vsiz___3;
                                          TC_index___13 = res->start + res->num;
                                          if (TC_index___13 >= res->anum) {
                                            res->anum += res->num + 1;
                                            while (1) {
                                              tmp___143 = realloc((void *)res->array,
                                                                  (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                              tmp___142 = (TCLISTDATUM *)tmp___143;
                                              res->array = tmp___142;
                                              if (! tmp___142) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          array___13 = res->array;
                                          while (1) {
                                            tmp___145 = malloc((unsigned int )(TC_mysize___13 + 1));
                                            tmp___144 = (char *)tmp___145;
                                            (array___13 + TC_index___13)->ptr = tmp___144;
                                            if (! tmp___144) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                          memcpy((void * __restrict  )(array___13 + TC_index___13)->ptr,
                                                 (void const   * __restrict  )vbuf___3,
                                                 (unsigned int )TC_mysize___13);
                                          *((array___13 + TC_index___13)->ptr + TC_mysize___13) = (char )'\000';
                                          (array___13 + TC_index___13)->size = TC_mysize___13;
                                          (res->num) ++;
                                          break;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        tcbdbcurprev(cur___3);
                      }
                      tcbdbcurdel(cur___3);
                      oname = (char const   *)((void *)0);
                    } else {
                      goto _L___32;
                    }
                  }
                } else {
                  _L___32: 
                  tcxstrprintf(hint, "using an index: \"%s\" asc (NUMGT/NUMGE)\n",
                               mcond->name);
                  tmp___149 = tctdbatof(expr);
                  xnum___1 = tmp___149;
                  tmp___150 = tcbdbcurnew((TCBDB *)midx->db);
                  cur___4 = tmp___150;
                  tctdbqryidxcurjumpnum(cur___4, expr, esiz, (_Bool)1);
                  if (oname) {
                    if (0) {
                      __s1_len___6 = strlen(oname);
                      __s2_len___6 = strlen((char const   *)mcond->name);
                      if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
                        goto _L___25;
                      } else {
                        if (__s1_len___6 >= 4U) {
                          _L___25: 
                          if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                            tmp___157 = 1;
                          } else {
                            if (__s2_len___6 >= 4U) {
                              tmp___157 = 1;
                            } else {
                              tmp___157 = 0;
                            }
                          }
                        } else {
                          tmp___157 = 0;
                        }
                      }
                      if (tmp___157) {
                        tmp___152 = __builtin_strcmp(oname, (char const   *)mcond->name);
                        tmp___156 = tmp___152;
                      } else {
                        tmp___155 = __builtin_strcmp(oname, (char const   *)mcond->name);
                        tmp___156 = tmp___155;
                      }
                    } else {
                      tmp___155 = __builtin_strcmp(oname, (char const   *)mcond->name);
                      tmp___156 = tmp___155;
                    }
                    if (tmp___156) {
                      tmp___158 = 1;
                    } else {
                      if (otype != 2) {
                        tmp___158 = 1;
                      } else {
                        tmp___158 = 0;
                      }
                    }
                  } else {
                    tmp___158 = 0;
                  }
                  all___3 = (_Bool )tmp___158;
                  if (! all___3) {
                    if (max < 2147483647) {
                      tcxstrprintf(hint, "limited matching: %d\n", max);
                    }
                  }
                  while (1) {
                    if (all___3) {
                      goto _L___28;
                    } else {
                      if (res->num < max) {
                        _L___28: 
                        tmp___176 = tcbdbcurkey3(cur___4, & ksiz___4);
                        kbuf___4 = (char const   *)tmp___176;
                        if (! ((unsigned int )kbuf___4 != (unsigned int )((void *)0))) {
                          break;
                        }
                      } else {
                        break;
                      }
                    }
                    tmp___159 = tctdbatof(kbuf___4);
                    knum___0 = tmp___159;
                    if (knum___0 > xnum___1) {
                      goto _L___27;
                    } else {
                      if (knum___0 >= xnum___1) {
                        if (mcond->op == 10) {
                          _L___27: 
                          tmp___160 = tcbdbcurval3(cur___4, & vsiz___4);
                          vbuf___4 = (char const   *)tmp___160;
                          if (! nmap) {
                            goto _L___26;
                          } else {
                            tmp___175 = tcmapget((TCMAP const   *)nmap, (void const   *)vbuf___4,
                                                 vsiz___4, & nsiz___4);
                            if (tmp___175) {
                              _L___26: 
                              if (acnum < 1) {
                                while (1) {
                                  TC_mysize___14 = vsiz___4;
                                  TC_index___14 = res->start + res->num;
                                  if (TC_index___14 >= res->anum) {
                                    res->anum += res->num + 1;
                                    while (1) {
                                      tmp___162 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                      tmp___161 = (TCLISTDATUM *)tmp___162;
                                      res->array = tmp___161;
                                      if (! tmp___161) {
                                        tcmyfatal("out of memory");
                                      }
                                      break;
                                    }
                                  }
                                  array___14 = res->array;
                                  while (1) {
                                    tmp___164 = malloc((unsigned int )(TC_mysize___14 + 1));
                                    tmp___163 = (char *)tmp___164;
                                    (array___14 + TC_index___14)->ptr = tmp___163;
                                    if (! tmp___163) {
                                      tcmyfatal("out of memory");
                                    }
                                    break;
                                  }
                                  memcpy((void * __restrict  )(array___14 + TC_index___14)->ptr,
                                         (void const   * __restrict  )vbuf___4, (unsigned int )TC_mysize___14);
                                  *((array___14 + TC_index___14)->ptr + TC_mysize___14) = (char )'\000';
                                  (array___14 + TC_index___14)->size = TC_mysize___14;
                                  (res->num) ++;
                                  break;
                                }
                              } else {
                                if (ucond) {
                                  tmp___169 = tctdbqryonecondmatch(qry, ucond, vbuf___4,
                                                                   vsiz___4);
                                  if (tmp___169) {
                                    while (1) {
                                      TC_mysize___15 = vsiz___4;
                                      TC_index___15 = res->start + res->num;
                                      if (TC_index___15 >= res->anum) {
                                        res->anum += res->num + 1;
                                        while (1) {
                                          tmp___166 = realloc((void *)res->array,
                                                              (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                          tmp___165 = (TCLISTDATUM *)tmp___166;
                                          res->array = tmp___165;
                                          if (! tmp___165) {
                                            tcmyfatal("out of memory");
                                          }
                                          break;
                                        }
                                      }
                                      array___15 = res->array;
                                      while (1) {
                                        tmp___168 = malloc((unsigned int )(TC_mysize___15 + 1));
                                        tmp___167 = (char *)tmp___168;
                                        (array___15 + TC_index___15)->ptr = tmp___167;
                                        if (! tmp___167) {
                                          tcmyfatal("out of memory");
                                        }
                                        break;
                                      }
                                      memcpy((void * __restrict  )(array___15 + TC_index___15)->ptr,
                                             (void const   * __restrict  )vbuf___4,
                                             (unsigned int )TC_mysize___15);
                                      *((array___15 + TC_index___15)->ptr + TC_mysize___15) = (char )'\000';
                                      (array___15 + TC_index___15)->size = TC_mysize___15;
                                      (res->num) ++;
                                      break;
                                    }
                                  }
                                } else {
                                  tmp___174 = tctdbqryallcondmatch(qry, vbuf___4,
                                                                   vsiz___4);
                                  if (tmp___174) {
                                    while (1) {
                                      TC_mysize___16 = vsiz___4;
                                      TC_index___16 = res->start + res->num;
                                      if (TC_index___16 >= res->anum) {
                                        res->anum += res->num + 1;
                                        while (1) {
                                          tmp___171 = realloc((void *)res->array,
                                                              (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                          tmp___170 = (TCLISTDATUM *)tmp___171;
                                          res->array = tmp___170;
                                          if (! tmp___170) {
                                            tcmyfatal("out of memory");
                                          }
                                          break;
                                        }
                                      }
                                      array___16 = res->array;
                                      while (1) {
                                        tmp___173 = malloc((unsigned int )(TC_mysize___16 + 1));
                                        tmp___172 = (char *)tmp___173;
                                        (array___16 + TC_index___16)->ptr = tmp___172;
                                        if (! tmp___172) {
                                          tcmyfatal("out of memory");
                                        }
                                        break;
                                      }
                                      memcpy((void * __restrict  )(array___16 + TC_index___16)->ptr,
                                             (void const   * __restrict  )vbuf___4,
                                             (unsigned int )TC_mysize___16);
                                      *((array___16 + TC_index___16)->ptr + TC_mysize___16) = (char )'\000';
                                      (array___16 + TC_index___16)->size = TC_mysize___16;
                                      (res->num) ++;
                                      break;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    tcbdbcurnext(cur___4);
                  }
                  tcbdbcurdel(cur___4);
                  if (! all___3) {
                    oname = (char const   *)((void *)0);
                  }
                }
              } else {
                if (mcond->op == 11) {
                  goto _L___62;
                } else {
                  if (mcond->op == 12) {
                    _L___62: 
                    if (oname) {
                      if (0) {
                        __s1_len___9 = strlen(oname);
                        __s2_len___9 = strlen((char const   *)mcond->name);
                        if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
                          goto _L___41;
                        } else {
                          if (__s1_len___9 >= 4U) {
                            _L___41: 
                            if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                              tmp___238 = 1;
                            } else {
                              if (__s2_len___9 >= 4U) {
                                tmp___238 = 1;
                              } else {
                                tmp___238 = 0;
                              }
                            }
                          } else {
                            tmp___238 = 0;
                          }
                        }
                        if (tmp___238) {
                          tmp___233 = __builtin_strcmp(oname, (char const   *)mcond->name);
                          tmp___237 = tmp___233;
                        } else {
                          tmp___236 = __builtin_strcmp(oname, (char const   *)mcond->name);
                          tmp___237 = tmp___236;
                        }
                      } else {
                        tmp___236 = __builtin_strcmp(oname, (char const   *)mcond->name);
                        tmp___237 = tmp___236;
                      }
                      if (tmp___237) {
                        goto _L___43;
                      } else {
                        if (otype == 2) {
                          tcxstrprintf(hint, "using an index: \"%s\" asc (NUMLT/NUMLE)\n",
                                       mcond->name);
                          tmp___184 = tctdbatof(expr);
                          xnum___2 = tmp___184;
                          tmp___185 = tcbdbcurnew((TCBDB *)midx->db);
                          cur___5 = tmp___185;
                          tcbdbcurfirst(cur___5);
                          if (max < 2147483647) {
                            tcxstrprintf(hint, "limited matching: %d\n", max);
                          }
                          while (1) {
                            if (res->num < max) {
                              tmp___203 = tcbdbcurkey3(cur___5, & ksiz___5);
                              kbuf___5 = (char const   *)tmp___203;
                              if (! ((unsigned int )kbuf___5 != (unsigned int )((void *)0))) {
                                break;
                              }
                            } else {
                              break;
                            }
                            tmp___186 = tctdbatof(kbuf___5);
                            knum___1 = tmp___186;
                            if (knum___1 > xnum___2) {
                              break;
                            }
                            if (knum___1 < xnum___2) {
                              goto _L___34;
                            } else {
                              if (knum___1 <= xnum___2) {
                                if (mcond->op == 12) {
                                  _L___34: 
                                  tmp___187 = tcbdbcurval3(cur___5, & vsiz___5);
                                  vbuf___5 = (char const   *)tmp___187;
                                  if (! nmap) {
                                    goto _L___33;
                                  } else {
                                    tmp___202 = tcmapget((TCMAP const   *)nmap, (void const   *)vbuf___5,
                                                         vsiz___5, & nsiz___5);
                                    if (tmp___202) {
                                      _L___33: 
                                      if (acnum < 1) {
                                        while (1) {
                                          TC_mysize___17 = vsiz___5;
                                          TC_index___17 = res->start + res->num;
                                          if (TC_index___17 >= res->anum) {
                                            res->anum += res->num + 1;
                                            while (1) {
                                              tmp___189 = realloc((void *)res->array,
                                                                  (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                              tmp___188 = (TCLISTDATUM *)tmp___189;
                                              res->array = tmp___188;
                                              if (! tmp___188) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          array___17 = res->array;
                                          while (1) {
                                            tmp___191 = malloc((unsigned int )(TC_mysize___17 + 1));
                                            tmp___190 = (char *)tmp___191;
                                            (array___17 + TC_index___17)->ptr = tmp___190;
                                            if (! tmp___190) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                          memcpy((void * __restrict  )(array___17 + TC_index___17)->ptr,
                                                 (void const   * __restrict  )vbuf___5,
                                                 (unsigned int )TC_mysize___17);
                                          *((array___17 + TC_index___17)->ptr + TC_mysize___17) = (char )'\000';
                                          (array___17 + TC_index___17)->size = TC_mysize___17;
                                          (res->num) ++;
                                          break;
                                        }
                                      } else {
                                        if (ucond) {
                                          tmp___196 = tctdbqryonecondmatch(qry, ucond,
                                                                           vbuf___5,
                                                                           vsiz___5);
                                          if (tmp___196) {
                                            while (1) {
                                              TC_mysize___18 = vsiz___5;
                                              TC_index___18 = res->start + res->num;
                                              if (TC_index___18 >= res->anum) {
                                                res->anum += res->num + 1;
                                                while (1) {
                                                  tmp___193 = realloc((void *)res->array,
                                                                      (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                                  tmp___192 = (TCLISTDATUM *)tmp___193;
                                                  res->array = tmp___192;
                                                  if (! tmp___192) {
                                                    tcmyfatal("out of memory");
                                                  }
                                                  break;
                                                }
                                              }
                                              array___18 = res->array;
                                              while (1) {
                                                tmp___195 = malloc((unsigned int )(TC_mysize___18 + 1));
                                                tmp___194 = (char *)tmp___195;
                                                (array___18 + TC_index___18)->ptr = tmp___194;
                                                if (! tmp___194) {
                                                  tcmyfatal("out of memory");
                                                }
                                                break;
                                              }
                                              memcpy((void * __restrict  )(array___18 + TC_index___18)->ptr,
                                                     (void const   * __restrict  )vbuf___5,
                                                     (unsigned int )TC_mysize___18);
                                              *((array___18 + TC_index___18)->ptr + TC_mysize___18) = (char )'\000';
                                              (array___18 + TC_index___18)->size = TC_mysize___18;
                                              (res->num) ++;
                                              break;
                                            }
                                          }
                                        } else {
                                          tmp___201 = tctdbqryallcondmatch(qry, vbuf___5,
                                                                           vsiz___5);
                                          if (tmp___201) {
                                            while (1) {
                                              TC_mysize___19 = vsiz___5;
                                              TC_index___19 = res->start + res->num;
                                              if (TC_index___19 >= res->anum) {
                                                res->anum += res->num + 1;
                                                while (1) {
                                                  tmp___198 = realloc((void *)res->array,
                                                                      (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                                  tmp___197 = (TCLISTDATUM *)tmp___198;
                                                  res->array = tmp___197;
                                                  if (! tmp___197) {
                                                    tcmyfatal("out of memory");
                                                  }
                                                  break;
                                                }
                                              }
                                              array___19 = res->array;
                                              while (1) {
                                                tmp___200 = malloc((unsigned int )(TC_mysize___19 + 1));
                                                tmp___199 = (char *)tmp___200;
                                                (array___19 + TC_index___19)->ptr = tmp___199;
                                                if (! tmp___199) {
                                                  tcmyfatal("out of memory");
                                                }
                                                break;
                                              }
                                              memcpy((void * __restrict  )(array___19 + TC_index___19)->ptr,
                                                     (void const   * __restrict  )vbuf___5,
                                                     (unsigned int )TC_mysize___19);
                                              *((array___19 + TC_index___19)->ptr + TC_mysize___19) = (char )'\000';
                                              (array___19 + TC_index___19)->size = TC_mysize___19;
                                              (res->num) ++;
                                              break;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            tcbdbcurnext(cur___5);
                          }
                          tcbdbcurdel(cur___5);
                          oname = (char const   *)((void *)0);
                        } else {
                          goto _L___43;
                        }
                      }
                    } else {
                      _L___43: 
                      tcxstrprintf(hint, "using an index: \"%s\" desc (NUMLT/NUMLE)\n",
                                   mcond->name);
                      tmp___204 = tctdbatof(expr);
                      xnum___3 = tmp___204;
                      tmp___205 = tcbdbcurnew((TCBDB *)midx->db);
                      cur___6 = tmp___205;
                      tctdbqryidxcurjumpnum(cur___6, expr, esiz, (_Bool)0);
                      if (oname) {
                        if (0) {
                          __s1_len___8 = strlen(oname);
                          __s2_len___8 = strlen((char const   *)mcond->name);
                          if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
                            goto _L___36;
                          } else {
                            if (__s1_len___8 >= 4U) {
                              _L___36: 
                              if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                                tmp___212 = 1;
                              } else {
                                if (__s2_len___8 >= 4U) {
                                  tmp___212 = 1;
                                } else {
                                  tmp___212 = 0;
                                }
                              }
                            } else {
                              tmp___212 = 0;
                            }
                          }
                          if (tmp___212) {
                            tmp___207 = __builtin_strcmp(oname, (char const   *)mcond->name);
                            tmp___211 = tmp___207;
                          } else {
                            tmp___210 = __builtin_strcmp(oname, (char const   *)mcond->name);
                            tmp___211 = tmp___210;
                          }
                        } else {
                          tmp___210 = __builtin_strcmp(oname, (char const   *)mcond->name);
                          tmp___211 = tmp___210;
                        }
                        if (tmp___211) {
                          tmp___213 = 1;
                        } else {
                          if (otype != 3) {
                            tmp___213 = 1;
                          } else {
                            tmp___213 = 0;
                          }
                        }
                      } else {
                        tmp___213 = 0;
                      }
                      all___4 = (_Bool )tmp___213;
                      if (! all___4) {
                        if (max < 2147483647) {
                          tcxstrprintf(hint, "limited matching: %d\n", max);
                        }
                      }
                      while (1) {
                        if (all___4) {
                          goto _L___39;
                        } else {
                          if (res->num < max) {
                            _L___39: 
                            tmp___231 = tcbdbcurkey3(cur___6, & ksiz___6);
                            kbuf___6 = (char const   *)tmp___231;
                            if (! ((unsigned int )kbuf___6 != (unsigned int )((void *)0))) {
                              break;
                            }
                          } else {
                            break;
                          }
                        }
                        tmp___214 = tctdbatof(kbuf___6);
                        knum___2 = tmp___214;
                        if (knum___2 < xnum___3) {
                          goto _L___38;
                        } else {
                          if (knum___2 <= xnum___3) {
                            if (mcond->op == 12) {
                              _L___38: 
                              tmp___215 = tcbdbcurval3(cur___6, & vsiz___6);
                              vbuf___6 = (char const   *)tmp___215;
                              if (! nmap) {
                                goto _L___37;
                              } else {
                                tmp___230 = tcmapget((TCMAP const   *)nmap, (void const   *)vbuf___6,
                                                     vsiz___6, & nsiz___6);
                                if (tmp___230) {
                                  _L___37: 
                                  if (acnum < 1) {
                                    while (1) {
                                      TC_mysize___20 = vsiz___6;
                                      TC_index___20 = res->start + res->num;
                                      if (TC_index___20 >= res->anum) {
                                        res->anum += res->num + 1;
                                        while (1) {
                                          tmp___217 = realloc((void *)res->array,
                                                              (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                          tmp___216 = (TCLISTDATUM *)tmp___217;
                                          res->array = tmp___216;
                                          if (! tmp___216) {
                                            tcmyfatal("out of memory");
                                          }
                                          break;
                                        }
                                      }
                                      array___20 = res->array;
                                      while (1) {
                                        tmp___219 = malloc((unsigned int )(TC_mysize___20 + 1));
                                        tmp___218 = (char *)tmp___219;
                                        (array___20 + TC_index___20)->ptr = tmp___218;
                                        if (! tmp___218) {
                                          tcmyfatal("out of memory");
                                        }
                                        break;
                                      }
                                      memcpy((void * __restrict  )(array___20 + TC_index___20)->ptr,
                                             (void const   * __restrict  )vbuf___6,
                                             (unsigned int )TC_mysize___20);
                                      *((array___20 + TC_index___20)->ptr + TC_mysize___20) = (char )'\000';
                                      (array___20 + TC_index___20)->size = TC_mysize___20;
                                      (res->num) ++;
                                      break;
                                    }
                                  } else {
                                    if (ucond) {
                                      tmp___224 = tctdbqryonecondmatch(qry, ucond,
                                                                       vbuf___6, vsiz___6);
                                      if (tmp___224) {
                                        while (1) {
                                          TC_mysize___21 = vsiz___6;
                                          TC_index___21 = res->start + res->num;
                                          if (TC_index___21 >= res->anum) {
                                            res->anum += res->num + 1;
                                            while (1) {
                                              tmp___221 = realloc((void *)res->array,
                                                                  (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                              tmp___220 = (TCLISTDATUM *)tmp___221;
                                              res->array = tmp___220;
                                              if (! tmp___220) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          array___21 = res->array;
                                          while (1) {
                                            tmp___223 = malloc((unsigned int )(TC_mysize___21 + 1));
                                            tmp___222 = (char *)tmp___223;
                                            (array___21 + TC_index___21)->ptr = tmp___222;
                                            if (! tmp___222) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                          memcpy((void * __restrict  )(array___21 + TC_index___21)->ptr,
                                                 (void const   * __restrict  )vbuf___6,
                                                 (unsigned int )TC_mysize___21);
                                          *((array___21 + TC_index___21)->ptr + TC_mysize___21) = (char )'\000';
                                          (array___21 + TC_index___21)->size = TC_mysize___21;
                                          (res->num) ++;
                                          break;
                                        }
                                      }
                                    } else {
                                      tmp___229 = tctdbqryallcondmatch(qry, vbuf___6,
                                                                       vsiz___6);
                                      if (tmp___229) {
                                        while (1) {
                                          TC_mysize___22 = vsiz___6;
                                          TC_index___22 = res->start + res->num;
                                          if (TC_index___22 >= res->anum) {
                                            res->anum += res->num + 1;
                                            while (1) {
                                              tmp___226 = realloc((void *)res->array,
                                                                  (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                              tmp___225 = (TCLISTDATUM *)tmp___226;
                                              res->array = tmp___225;
                                              if (! tmp___225) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          array___22 = res->array;
                                          while (1) {
                                            tmp___228 = malloc((unsigned int )(TC_mysize___22 + 1));
                                            tmp___227 = (char *)tmp___228;
                                            (array___22 + TC_index___22)->ptr = tmp___227;
                                            if (! tmp___227) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                          memcpy((void * __restrict  )(array___22 + TC_index___22)->ptr,
                                                 (void const   * __restrict  )vbuf___6,
                                                 (unsigned int )TC_mysize___22);
                                          *((array___22 + TC_index___22)->ptr + TC_mysize___22) = (char )'\000';
                                          (array___22 + TC_index___22)->size = TC_mysize___22;
                                          (res->num) ++;
                                          break;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        tcbdbcurprev(cur___6);
                      }
                      tcbdbcurdel(cur___6);
                      if (! all___4) {
                        oname = (char const   *)((void *)0);
                      }
                    }
                  } else {
                    if (mcond->op == 13) {
                      tcxstrprintf(hint, "using an index: \"%s\" asc (NUMBT)\n", mcond->name);
                      while (1) {
                        if (! ((int const   )*expr == 32)) {
                          if (! ((int const   )*expr == 44)) {
                            break;
                          }
                        }
                        expr ++;
                      }
                      pv = expr;
                      while (1) {
                        if ((int const   )*pv != 0) {
                          if ((int const   )*pv != 32) {
                            if (! ((int const   )*pv != 44)) {
                              break;
                            }
                          } else {
                            break;
                          }
                        } else {
                          break;
                        }
                        pv ++;
                      }
                      esiz = pv - expr;
                      if ((int const   )*pv != 32) {
                        if ((int const   )*pv != 44) {
                          pv = " ";
                        }
                      }
                      pv ++;
                      while (1) {
                        if (! ((int const   )*pv == 32)) {
                          if (! ((int const   )*pv == 44)) {
                            break;
                          }
                        }
                        pv ++;
                      }
                      tmp___239 = tctdbatof(expr);
                      lower = tmp___239;
                      tmp___240 = tctdbatof(pv);
                      upper = tmp___240;
                      if (lower > upper) {
                        expr = pv;
                        tmp___241 = strlen(expr);
                        esiz = (int )tmp___241;
                        swap = lower;
                        lower = upper;
                        upper = swap;
                      }
                      tmp___242 = tcbdbcurnew((TCBDB *)midx->db);
                      cur___7 = tmp___242;
                      tctdbqryidxcurjumpnum(cur___7, expr, esiz, (_Bool)1);
                      if (oname) {
                        if (0) {
                          __s1_len___10 = strlen(oname);
                          __s2_len___10 = strlen((char const   *)mcond->name);
                          if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
                            goto _L___45;
                          } else {
                            if (__s1_len___10 >= 4U) {
                              _L___45: 
                              if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                                tmp___249 = 1;
                              } else {
                                if (__s2_len___10 >= 4U) {
                                  tmp___249 = 1;
                                } else {
                                  tmp___249 = 0;
                                }
                              }
                            } else {
                              tmp___249 = 0;
                            }
                          }
                          if (tmp___249) {
                            tmp___244 = __builtin_strcmp(oname, (char const   *)mcond->name);
                            tmp___248 = tmp___244;
                          } else {
                            tmp___247 = __builtin_strcmp(oname, (char const   *)mcond->name);
                            tmp___248 = tmp___247;
                          }
                        } else {
                          tmp___247 = __builtin_strcmp(oname, (char const   *)mcond->name);
                          tmp___248 = tmp___247;
                        }
                        if (tmp___248) {
                          tmp___250 = 1;
                        } else {
                          if (otype != 2) {
                            tmp___250 = 1;
                          } else {
                            tmp___250 = 0;
                          }
                        }
                      } else {
                        tmp___250 = 0;
                      }
                      all___5 = (_Bool )tmp___250;
                      if (! all___5) {
                        if (max < 2147483647) {
                          tcxstrprintf(hint, "limited matching: %d\n", max);
                        }
                      }
                      while (1) {
                        if (all___5) {
                          goto _L___47;
                        } else {
                          if (res->num < max) {
                            _L___47: 
                            tmp___268 = tcbdbcurkey3(cur___7, & ksiz___7);
                            kbuf___7 = (char const   *)tmp___268;
                            if (! ((unsigned int )kbuf___7 != (unsigned int )((void *)0))) {
                              break;
                            }
                          } else {
                            break;
                          }
                        }
                        tmp___251 = tctdbatof(kbuf___7);
                        if (tmp___251 > upper) {
                          break;
                        }
                        tmp___252 = tcbdbcurval3(cur___7, & vsiz___7);
                        vbuf___7 = (char const   *)tmp___252;
                        if (! nmap) {
                          goto _L___46;
                        } else {
                          tmp___267 = tcmapget((TCMAP const   *)nmap, (void const   *)vbuf___7,
                                               vsiz___7, & nsiz___7);
                          if (tmp___267) {
                            _L___46: 
                            if (acnum < 1) {
                              while (1) {
                                TC_mysize___23 = vsiz___7;
                                TC_index___23 = res->start + res->num;
                                if (TC_index___23 >= res->anum) {
                                  res->anum += res->num + 1;
                                  while (1) {
                                    tmp___254 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                    tmp___253 = (TCLISTDATUM *)tmp___254;
                                    res->array = tmp___253;
                                    if (! tmp___253) {
                                      tcmyfatal("out of memory");
                                    }
                                    break;
                                  }
                                }
                                array___23 = res->array;
                                while (1) {
                                  tmp___256 = malloc((unsigned int )(TC_mysize___23 + 1));
                                  tmp___255 = (char *)tmp___256;
                                  (array___23 + TC_index___23)->ptr = tmp___255;
                                  if (! tmp___255) {
                                    tcmyfatal("out of memory");
                                  }
                                  break;
                                }
                                memcpy((void * __restrict  )(array___23 + TC_index___23)->ptr,
                                       (void const   * __restrict  )vbuf___7, (unsigned int )TC_mysize___23);
                                *((array___23 + TC_index___23)->ptr + TC_mysize___23) = (char )'\000';
                                (array___23 + TC_index___23)->size = TC_mysize___23;
                                (res->num) ++;
                                break;
                              }
                            } else {
                              if (ucond) {
                                tmp___261 = tctdbqryonecondmatch(qry, ucond, vbuf___7,
                                                                 vsiz___7);
                                if (tmp___261) {
                                  while (1) {
                                    TC_mysize___24 = vsiz___7;
                                    TC_index___24 = res->start + res->num;
                                    if (TC_index___24 >= res->anum) {
                                      res->anum += res->num + 1;
                                      while (1) {
                                        tmp___258 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                        tmp___257 = (TCLISTDATUM *)tmp___258;
                                        res->array = tmp___257;
                                        if (! tmp___257) {
                                          tcmyfatal("out of memory");
                                        }
                                        break;
                                      }
                                    }
                                    array___24 = res->array;
                                    while (1) {
                                      tmp___260 = malloc((unsigned int )(TC_mysize___24 + 1));
                                      tmp___259 = (char *)tmp___260;
                                      (array___24 + TC_index___24)->ptr = tmp___259;
                                      if (! tmp___259) {
                                        tcmyfatal("out of memory");
                                      }
                                      break;
                                    }
                                    memcpy((void * __restrict  )(array___24 + TC_index___24)->ptr,
                                           (void const   * __restrict  )vbuf___7,
                                           (unsigned int )TC_mysize___24);
                                    *((array___24 + TC_index___24)->ptr + TC_mysize___24) = (char )'\000';
                                    (array___24 + TC_index___24)->size = TC_mysize___24;
                                    (res->num) ++;
                                    break;
                                  }
                                }
                              } else {
                                tmp___266 = tctdbqryallcondmatch(qry, vbuf___7, vsiz___7);
                                if (tmp___266) {
                                  while (1) {
                                    TC_mysize___25 = vsiz___7;
                                    TC_index___25 = res->start + res->num;
                                    if (TC_index___25 >= res->anum) {
                                      res->anum += res->num + 1;
                                      while (1) {
                                        tmp___263 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                        tmp___262 = (TCLISTDATUM *)tmp___263;
                                        res->array = tmp___262;
                                        if (! tmp___262) {
                                          tcmyfatal("out of memory");
                                        }
                                        break;
                                      }
                                    }
                                    array___25 = res->array;
                                    while (1) {
                                      tmp___265 = malloc((unsigned int )(TC_mysize___25 + 1));
                                      tmp___264 = (char *)tmp___265;
                                      (array___25 + TC_index___25)->ptr = tmp___264;
                                      if (! tmp___264) {
                                        tcmyfatal("out of memory");
                                      }
                                      break;
                                    }
                                    memcpy((void * __restrict  )(array___25 + TC_index___25)->ptr,
                                           (void const   * __restrict  )vbuf___7,
                                           (unsigned int )TC_mysize___25);
                                    *((array___25 + TC_index___25)->ptr + TC_mysize___25) = (char )'\000';
                                    (array___25 + TC_index___25)->size = TC_mysize___25;
                                    (res->num) ++;
                                    break;
                                  }
                                }
                              }
                            }
                          }
                        }
                        tcbdbcurnext(cur___7);
                      }
                      tcbdbcurdel(cur___7);
                      if (oname) {
                        if (0) {
                          __s1_len___11 = strlen(oname);
                          __s2_len___11 = strlen((char const   *)mcond->name);
                          if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
                            goto _L___49;
                          } else {
                            if (__s1_len___11 >= 4U) {
                              _L___49: 
                              if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                                tmp___275 = 1;
                              } else {
                                if (__s2_len___11 >= 4U) {
                                  tmp___275 = 1;
                                } else {
                                  tmp___275 = 0;
                                }
                              }
                            } else {
                              tmp___275 = 0;
                            }
                          }
                          if (tmp___275) {
                            tmp___270 = __builtin_strcmp(oname, (char const   *)mcond->name);
                            tmp___274 = tmp___270;
                          } else {
                            tmp___273 = __builtin_strcmp(oname, (char const   *)mcond->name);
                            tmp___274 = tmp___273;
                          }
                        } else {
                          tmp___273 = __builtin_strcmp(oname, (char const   *)mcond->name);
                          tmp___274 = tmp___273;
                        }
                        if (! tmp___274) {
                          if (otype == 2) {
                            oname = (char const   *)((void *)0);
                          } else {
                            if (otype == 3) {
                              tclistinvert(res);
                              oname = (char const   *)((void *)0);
                            }
                          }
                        }
                      }
                    } else {
                      if (mcond->op == 14) {
                        tcxstrprintf(hint, "using an index: \"%s\" skip (NUMOREQ)\n",
                                     mcond->name);
                        tmp___276 = tcbdbcurnew((TCBDB *)midx->db);
                        cur___8 = tmp___276;
                        tmp___277 = tcstrsplit(expr, "\t\n\r ,");
                        tokens___0 = tmp___277;
                        tclistsortex(tokens___0, & tdbcmppkeynumasc);
                        i___4 = 1;
                        while (i___4 < tokens___0->num) {
                          tmp___279 = tctdbatof((char const   *)((void *)(tokens___0->array + (i___4 + tokens___0->start))->ptr));
                          tmp___280 = tctdbatof((char const   *)((void *)(tokens___0->array + ((i___4 - 1) + tokens___0->start))->ptr));
                          if (tmp___279 == tmp___280) {
                            while (1) {
                              tmp___278 = tclistremove2(tokens___0, i___4);
                              free((void *)tmp___278);
                              break;
                            }
                            i___4 --;
                          }
                          i___4 ++;
                        }
                        if (oname) {
                          if (0) {
                            __s1_len___12 = strlen(oname);
                            __s2_len___12 = strlen((char const   *)mcond->name);
                            if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
                              goto _L___51;
                            } else {
                              if (__s1_len___12 >= 4U) {
                                _L___51: 
                                if (! ((unsigned int )((void const   *)(mcond->name + 1)) - (unsigned int )((void const   *)mcond->name) == 1U)) {
                                  tmp___287 = 1;
                                } else {
                                  if (__s2_len___12 >= 4U) {
                                    tmp___287 = 1;
                                  } else {
                                    tmp___287 = 0;
                                  }
                                }
                              } else {
                                tmp___287 = 0;
                              }
                            }
                            if (tmp___287) {
                              tmp___282 = __builtin_strcmp(oname, (char const   *)mcond->name);
                              tmp___286 = tmp___282;
                            } else {
                              tmp___285 = __builtin_strcmp(oname, (char const   *)mcond->name);
                              tmp___286 = tmp___285;
                            }
                          } else {
                            tmp___285 = __builtin_strcmp(oname, (char const   *)mcond->name);
                            tmp___286 = tmp___285;
                          }
                          if (! tmp___286) {
                            if (otype == 2) {
                              oname = (char const   *)((void *)0);
                            } else {
                              if (otype == 3) {
                                tclistinvert(tokens___0);
                                oname = (char const   *)((void *)0);
                              }
                            }
                          }
                        }
                        tnum___0 = tokens___0->num;
                        all___6 = (_Bool )((unsigned int )oname != (unsigned int )((void *)0));
                        if (! all___6) {
                          if (max < 2147483647) {
                            tcxstrprintf(hint, "limited matching: %d\n", max);
                          }
                        }
                        i___5 = 0;
                        while (1) {
                          if (all___6) {
                            goto _L___54;
                          } else {
                            if (res->num < max) {
                              _L___54: 
                              if (! (i___5 < tnum___0)) {
                                break;
                              }
                            } else {
                              break;
                            }
                          }
                          while (1) {
                            token___0 = (char const   *)(tokens___0->array + (i___5 + tokens___0->start))->ptr;
                            tsiz___0 = (tokens___0->array + (i___5 + tokens___0->start))->size;
                            break;
                          }
                          if (tsiz___0 < 1) {
                            goto __Cont___2;
                          }
                          tmp___288 = tctdbatof(token___0);
                          xnum___4 = tmp___288;
                          tctdbqryidxcurjumpnum(cur___8, token___0, tsiz___0, (_Bool)1);
                          while (1) {
                            if (all___6) {
                              goto _L___53;
                            } else {
                              if (res->num < max) {
                                _L___53: 
                                tmp___306 = tcbdbcurkey3(cur___8, & ksiz___8);
                                kbuf___8 = (char const   *)tmp___306;
                                if (! ((unsigned int )kbuf___8 != (unsigned int )((void *)0))) {
                                  break;
                                }
                              } else {
                                break;
                              }
                            }
                            tmp___305 = tctdbatof(kbuf___8);
                            if (tmp___305 == xnum___4) {
                              tmp___289 = tcbdbcurval3(cur___8, & vsiz___8);
                              vbuf___8 = (char const   *)tmp___289;
                              if (! nmap) {
                                goto _L___52;
                              } else {
                                tmp___304 = tcmapget((TCMAP const   *)nmap, (void const   *)vbuf___8,
                                                     vsiz___8, & nsiz___8);
                                if (tmp___304) {
                                  _L___52: 
                                  if (acnum < 1) {
                                    while (1) {
                                      TC_mysize___26 = vsiz___8;
                                      TC_index___26 = res->start + res->num;
                                      if (TC_index___26 >= res->anum) {
                                        res->anum += res->num + 1;
                                        while (1) {
                                          tmp___291 = realloc((void *)res->array,
                                                              (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                          tmp___290 = (TCLISTDATUM *)tmp___291;
                                          res->array = tmp___290;
                                          if (! tmp___290) {
                                            tcmyfatal("out of memory");
                                          }
                                          break;
                                        }
                                      }
                                      array___26 = res->array;
                                      while (1) {
                                        tmp___293 = malloc((unsigned int )(TC_mysize___26 + 1));
                                        tmp___292 = (char *)tmp___293;
                                        (array___26 + TC_index___26)->ptr = tmp___292;
                                        if (! tmp___292) {
                                          tcmyfatal("out of memory");
                                        }
                                        break;
                                      }
                                      memcpy((void * __restrict  )(array___26 + TC_index___26)->ptr,
                                             (void const   * __restrict  )vbuf___8,
                                             (unsigned int )TC_mysize___26);
                                      *((array___26 + TC_index___26)->ptr + TC_mysize___26) = (char )'\000';
                                      (array___26 + TC_index___26)->size = TC_mysize___26;
                                      (res->num) ++;
                                      break;
                                    }
                                  } else {
                                    if (ucond) {
                                      tmp___298 = tctdbqryonecondmatch(qry, ucond,
                                                                       vbuf___8, vsiz___8);
                                      if (tmp___298) {
                                        while (1) {
                                          TC_mysize___27 = vsiz___8;
                                          TC_index___27 = res->start + res->num;
                                          if (TC_index___27 >= res->anum) {
                                            res->anum += res->num + 1;
                                            while (1) {
                                              tmp___295 = realloc((void *)res->array,
                                                                  (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                              tmp___294 = (TCLISTDATUM *)tmp___295;
                                              res->array = tmp___294;
                                              if (! tmp___294) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          array___27 = res->array;
                                          while (1) {
                                            tmp___297 = malloc((unsigned int )(TC_mysize___27 + 1));
                                            tmp___296 = (char *)tmp___297;
                                            (array___27 + TC_index___27)->ptr = tmp___296;
                                            if (! tmp___296) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                          memcpy((void * __restrict  )(array___27 + TC_index___27)->ptr,
                                                 (void const   * __restrict  )vbuf___8,
                                                 (unsigned int )TC_mysize___27);
                                          *((array___27 + TC_index___27)->ptr + TC_mysize___27) = (char )'\000';
                                          (array___27 + TC_index___27)->size = TC_mysize___27;
                                          (res->num) ++;
                                          break;
                                        }
                                      }
                                    } else {
                                      tmp___303 = tctdbqryallcondmatch(qry, vbuf___8,
                                                                       vsiz___8);
                                      if (tmp___303) {
                                        while (1) {
                                          TC_mysize___28 = vsiz___8;
                                          TC_index___28 = res->start + res->num;
                                          if (TC_index___28 >= res->anum) {
                                            res->anum += res->num + 1;
                                            while (1) {
                                              tmp___300 = realloc((void *)res->array,
                                                                  (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                              tmp___299 = (TCLISTDATUM *)tmp___300;
                                              res->array = tmp___299;
                                              if (! tmp___299) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          array___28 = res->array;
                                          while (1) {
                                            tmp___302 = malloc((unsigned int )(TC_mysize___28 + 1));
                                            tmp___301 = (char *)tmp___302;
                                            (array___28 + TC_index___28)->ptr = tmp___301;
                                            if (! tmp___301) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                          memcpy((void * __restrict  )(array___28 + TC_index___28)->ptr,
                                                 (void const   * __restrict  )vbuf___8,
                                                 (unsigned int )TC_mysize___28);
                                          *((array___28 + TC_index___28)->ptr + TC_mysize___28) = (char )'\000';
                                          (array___28 + TC_index___28)->size = TC_mysize___28;
                                          (res->num) ++;
                                          break;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            } else {
                              break;
                            }
                            tcbdbcurnext(cur___8);
                          }
                          __Cont___2: 
                          i___5 ++;
                        }
                        tclistdel(tokens___0);
                        tcbdbcurdel(cur___8);
                      } else {
                        if (mcond->op == 4) {
                          goto _L___61;
                        } else {
                          if (mcond->op == 5) {
                            _L___61: 
                            if (mcond->op == 4) {
                              tmp___307 = "STRAND";
                            } else {
                              tmp___307 = "STROR";
                            }
                            tcxstrprintf(hint, "using an index: \"%s\" inverted (%s)\n",
                                         mcond->name, tmp___307);
                            all___7 = (_Bool )((unsigned int )oname != (unsigned int )((void *)0));
                            if (! all___7) {
                              if (max < 2147483647) {
                                tcxstrprintf(hint, "limited matching: %d\n", max);
                              }
                            }
                            tmp___308 = tcstrsplit(expr, "\t\n\r ,");
                            tokens___1 = tmp___308;
                            tclistsort(tokens___1);
                            i___6 = 1;
                            while (i___6 < tokens___1->num) {
                              if (0) {
                                __s1_len___13 = strlen((char const   *)((void *)(tokens___1->array + (i___6 + tokens___1->start))->ptr));
                                __s2_len___13 = strlen((char const   *)((void *)(tokens___1->array + ((i___6 - 1) + tokens___1->start))->ptr));
                                if (! ((unsigned int )((void const   *)((void *)(tokens___1->array + (i___6 + tokens___1->start))->ptr + 1)) - (unsigned int )((void const   *)((void *)(tokens___1->array + (i___6 + tokens___1->start))->ptr)) == 1U)) {
                                  goto _L___56;
                                } else {
                                  if (__s1_len___13 >= 4U) {
                                    _L___56: 
                                    if (! ((unsigned int )((void const   *)((void *)(tokens___1->array + ((i___6 - 1) + tokens___1->start))->ptr + 1)) - (unsigned int )((void const   *)((void *)(tokens___1->array + ((i___6 - 1) + tokens___1->start))->ptr)) == 1U)) {
                                      tmp___316 = 1;
                                    } else {
                                      if (__s2_len___13 >= 4U) {
                                        tmp___316 = 1;
                                      } else {
                                        tmp___316 = 0;
                                      }
                                    }
                                  } else {
                                    tmp___316 = 0;
                                  }
                                }
                                if (tmp___316) {
                                  tmp___311 = __builtin_strcmp((char const   *)((void *)(tokens___1->array + (i___6 + tokens___1->start))->ptr),
                                                               (char const   *)((void *)(tokens___1->array + ((i___6 - 1) + tokens___1->start))->ptr));
                                  tmp___315 = tmp___311;
                                } else {
                                  tmp___314 = __builtin_strcmp((char const   *)((void *)(tokens___1->array + (i___6 + tokens___1->start))->ptr),
                                                               (char const   *)((void *)(tokens___1->array + ((i___6 - 1) + tokens___1->start))->ptr));
                                  tmp___315 = tmp___314;
                                }
                              } else {
                                tmp___314 = __builtin_strcmp((char const   *)((void *)(tokens___1->array + (i___6 + tokens___1->start))->ptr),
                                                             (char const   *)((void *)(tokens___1->array + ((i___6 - 1) + tokens___1->start))->ptr));
                                tmp___315 = tmp___314;
                              }
                              if (! tmp___315) {
                                while (1) {
                                  tmp___309 = tclistremove2(tokens___1, i___6);
                                  free((void *)tmp___309);
                                  break;
                                }
                                i___6 --;
                              }
                              i___6 ++;
                            }
                            tmp___317 = tctdbidxgetbytokens(tdb, midx, (TCLIST const   *)tokens___1,
                                                            mcond->op, hint);
                            tres = tmp___317;
                            tcmapiterinit(tres);
                            while (1) {
                              if (all___7) {
                                goto _L___58;
                              } else {
                                if (res->num < max) {
                                  _L___58: 
                                  tmp___333 = tcmapiternext(tres, & ksiz___9);
                                  kbuf___9 = (char const   *)tmp___333;
                                  if (! ((unsigned int )kbuf___9 != (unsigned int )((void *)0))) {
                                    break;
                                  }
                                } else {
                                  break;
                                }
                              }
                              if (! nmap) {
                                goto _L___57;
                              } else {
                                tmp___332 = tcmapget((TCMAP const   *)nmap, (void const   *)kbuf___9,
                                                     ksiz___9, & nsiz___9);
                                if (tmp___332) {
                                  _L___57: 
                                  if (acnum < 1) {
                                    while (1) {
                                      TC_mysize___29 = ksiz___9;
                                      TC_index___29 = res->start + res->num;
                                      if (TC_index___29 >= res->anum) {
                                        res->anum += res->num + 1;
                                        while (1) {
                                          tmp___319 = realloc((void *)res->array,
                                                              (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                          tmp___318 = (TCLISTDATUM *)tmp___319;
                                          res->array = tmp___318;
                                          if (! tmp___318) {
                                            tcmyfatal("out of memory");
                                          }
                                          break;
                                        }
                                      }
                                      array___29 = res->array;
                                      while (1) {
                                        tmp___321 = malloc((unsigned int )(TC_mysize___29 + 1));
                                        tmp___320 = (char *)tmp___321;
                                        (array___29 + TC_index___29)->ptr = tmp___320;
                                        if (! tmp___320) {
                                          tcmyfatal("out of memory");
                                        }
                                        break;
                                      }
                                      memcpy((void * __restrict  )(array___29 + TC_index___29)->ptr,
                                             (void const   * __restrict  )kbuf___9,
                                             (unsigned int )TC_mysize___29);
                                      *((array___29 + TC_index___29)->ptr + TC_mysize___29) = (char )'\000';
                                      (array___29 + TC_index___29)->size = TC_mysize___29;
                                      (res->num) ++;
                                      break;
                                    }
                                  } else {
                                    if (ucond) {
                                      tmp___326 = tctdbqryonecondmatch(qry, ucond,
                                                                       kbuf___9, ksiz___9);
                                      if (tmp___326) {
                                        while (1) {
                                          TC_mysize___30 = ksiz___9;
                                          TC_index___30 = res->start + res->num;
                                          if (TC_index___30 >= res->anum) {
                                            res->anum += res->num + 1;
                                            while (1) {
                                              tmp___323 = realloc((void *)res->array,
                                                                  (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                              tmp___322 = (TCLISTDATUM *)tmp___323;
                                              res->array = tmp___322;
                                              if (! tmp___322) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          array___30 = res->array;
                                          while (1) {
                                            tmp___325 = malloc((unsigned int )(TC_mysize___30 + 1));
                                            tmp___324 = (char *)tmp___325;
                                            (array___30 + TC_index___30)->ptr = tmp___324;
                                            if (! tmp___324) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                          memcpy((void * __restrict  )(array___30 + TC_index___30)->ptr,
                                                 (void const   * __restrict  )kbuf___9,
                                                 (unsigned int )TC_mysize___30);
                                          *((array___30 + TC_index___30)->ptr + TC_mysize___30) = (char )'\000';
                                          (array___30 + TC_index___30)->size = TC_mysize___30;
                                          (res->num) ++;
                                          break;
                                        }
                                      }
                                    } else {
                                      tmp___331 = tctdbqryallcondmatch(qry, kbuf___9,
                                                                       ksiz___9);
                                      if (tmp___331) {
                                        while (1) {
                                          TC_mysize___31 = ksiz___9;
                                          TC_index___31 = res->start + res->num;
                                          if (TC_index___31 >= res->anum) {
                                            res->anum += res->num + 1;
                                            while (1) {
                                              tmp___328 = realloc((void *)res->array,
                                                                  (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                              tmp___327 = (TCLISTDATUM *)tmp___328;
                                              res->array = tmp___327;
                                              if (! tmp___327) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          array___31 = res->array;
                                          while (1) {
                                            tmp___330 = malloc((unsigned int )(TC_mysize___31 + 1));
                                            tmp___329 = (char *)tmp___330;
                                            (array___31 + TC_index___31)->ptr = tmp___329;
                                            if (! tmp___329) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                          memcpy((void * __restrict  )(array___31 + TC_index___31)->ptr,
                                                 (void const   * __restrict  )kbuf___9,
                                                 (unsigned int )TC_mysize___31);
                                          *((array___31 + TC_index___31)->ptr + TC_mysize___31) = (char )'\000';
                                          (array___31 + TC_index___31)->size = TC_mysize___31;
                                          (res->num) ++;
                                          break;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                            tcmapdel(tres);
                            tclistdel(tokens___1);
                          } else {
                            if (mcond->op == 15) {
                              tcxstrprintf(hint, "using an index: \"%s\" inverted (FTS)\n",
                                           mcond->name);
                              tmp___334 = tctdbidxgetbyfts(tdb, midx, mcond, hint);
                              tres___0 = tmp___334;
                              all___8 = (_Bool )((unsigned int )oname != (unsigned int )((void *)0));
                              if (! all___8) {
                                if (max < 2147483647) {
                                  tcxstrprintf(hint, "limited matching: %d\n", max);
                                }
                              }
                              tcmapiterinit(tres___0);
                              while (1) {
                                if (all___8) {
                                  goto _L___60;
                                } else {
                                  if (res->num < max) {
                                    _L___60: 
                                    tmp___350 = tcmapiternext(tres___0, & ksiz___10);
                                    kbuf___10 = (char const   *)tmp___350;
                                    if (! ((unsigned int )kbuf___10 != (unsigned int )((void *)0))) {
                                      break;
                                    }
                                  } else {
                                    break;
                                  }
                                }
                                if (! nmap) {
                                  goto _L___59;
                                } else {
                                  tmp___349 = tcmapget((TCMAP const   *)nmap, (void const   *)kbuf___10,
                                                       ksiz___10, & nsiz___10);
                                  if (tmp___349) {
                                    _L___59: 
                                    if (acnum < 1) {
                                      while (1) {
                                        TC_mysize___32 = ksiz___10;
                                        TC_index___32 = res->start + res->num;
                                        if (TC_index___32 >= res->anum) {
                                          res->anum += res->num + 1;
                                          while (1) {
                                            tmp___336 = realloc((void *)res->array,
                                                                (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                            tmp___335 = (TCLISTDATUM *)tmp___336;
                                            res->array = tmp___335;
                                            if (! tmp___335) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                        }
                                        array___32 = res->array;
                                        while (1) {
                                          tmp___338 = malloc((unsigned int )(TC_mysize___32 + 1));
                                          tmp___337 = (char *)tmp___338;
                                          (array___32 + TC_index___32)->ptr = tmp___337;
                                          if (! tmp___337) {
                                            tcmyfatal("out of memory");
                                          }
                                          break;
                                        }
                                        memcpy((void * __restrict  )(array___32 + TC_index___32)->ptr,
                                               (void const   * __restrict  )kbuf___10,
                                               (unsigned int )TC_mysize___32);
                                        *((array___32 + TC_index___32)->ptr + TC_mysize___32) = (char )'\000';
                                        (array___32 + TC_index___32)->size = TC_mysize___32;
                                        (res->num) ++;
                                        break;
                                      }
                                    } else {
                                      if (ucond) {
                                        tmp___343 = tctdbqryonecondmatch(qry, ucond,
                                                                         kbuf___10,
                                                                         ksiz___10);
                                        if (tmp___343) {
                                          while (1) {
                                            TC_mysize___33 = ksiz___10;
                                            TC_index___33 = res->start + res->num;
                                            if (TC_index___33 >= res->anum) {
                                              res->anum += res->num + 1;
                                              while (1) {
                                                tmp___340 = realloc((void *)res->array,
                                                                    (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                                tmp___339 = (TCLISTDATUM *)tmp___340;
                                                res->array = tmp___339;
                                                if (! tmp___339) {
                                                  tcmyfatal("out of memory");
                                                }
                                                break;
                                              }
                                            }
                                            array___33 = res->array;
                                            while (1) {
                                              tmp___342 = malloc((unsigned int )(TC_mysize___33 + 1));
                                              tmp___341 = (char *)tmp___342;
                                              (array___33 + TC_index___33)->ptr = tmp___341;
                                              if (! tmp___341) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                            memcpy((void * __restrict  )(array___33 + TC_index___33)->ptr,
                                                   (void const   * __restrict  )kbuf___10,
                                                   (unsigned int )TC_mysize___33);
                                            *((array___33 + TC_index___33)->ptr + TC_mysize___33) = (char )'\000';
                                            (array___33 + TC_index___33)->size = TC_mysize___33;
                                            (res->num) ++;
                                            break;
                                          }
                                        }
                                      } else {
                                        tmp___348 = tctdbqryallcondmatch(qry, kbuf___10,
                                                                         ksiz___10);
                                        if (tmp___348) {
                                          while (1) {
                                            TC_mysize___34 = ksiz___10;
                                            TC_index___34 = res->start + res->num;
                                            if (TC_index___34 >= res->anum) {
                                              res->anum += res->num + 1;
                                              while (1) {
                                                tmp___345 = realloc((void *)res->array,
                                                                    (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                                                tmp___344 = (TCLISTDATUM *)tmp___345;
                                                res->array = tmp___344;
                                                if (! tmp___344) {
                                                  tcmyfatal("out of memory");
                                                }
                                                break;
                                              }
                                            }
                                            array___34 = res->array;
                                            while (1) {
                                              tmp___347 = malloc((unsigned int )(TC_mysize___34 + 1));
                                              tmp___346 = (char *)tmp___347;
                                              (array___34 + TC_index___34)->ptr = tmp___346;
                                              if (! tmp___346) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                            memcpy((void * __restrict  )(array___34 + TC_index___34)->ptr,
                                                   (void const   * __restrict  )kbuf___10,
                                                   (unsigned int )TC_mysize___34);
                                            *((array___34 + TC_index___34)->ptr + TC_mysize___34) = (char )'\000';
                                            (array___34 + TC_index___34)->size = TC_mysize___34;
                                            (res->num) ++;
                                            break;
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                              tcmapdel(tres___0);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (nmap) {
      tcmapdel(nmap);
    }
  }
  if (! res) {
    if (scond) {
      res = tclistnew();
      scond->alive = (_Bool)0;
      acnum --;
      ucond___0 = (TDBCOND *)((void *)0);
      i___7 = 0;
      while (i___7 < cnum) {
        cond___2 = conds + i___7;
        if (! cond___2->alive) {
          goto __Cont___3;
        }
        if (ucond___0) {
          ucond___0 = (TDBCOND *)((void *)0);
          break;
        }
        ucond___0 = cond___2;
        __Cont___3: 
        i___7 ++;
      }
      trim___0 = (_Bool )((int )*(sidx->name) != 0);
      asc = (_Bool)1;
      all___9 = (_Bool)1;
      if (! oname) {
        all___9 = (_Bool)0;
      } else {
        if (0) {
          __s1_len___14 = strlen(oname);
          __s2_len___14 = strlen((char const   *)scond->name);
          if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
            goto _L___65;
          } else {
            if (__s1_len___14 >= 4U) {
              _L___65: 
              if (! ((unsigned int )((void const   *)(scond->name + 1)) - (unsigned int )((void const   *)scond->name) == 1U)) {
                tmp___357 = 1;
              } else {
                if (__s2_len___14 >= 4U) {
                  tmp___357 = 1;
                } else {
                  tmp___357 = 0;
                }
              }
            } else {
              tmp___357 = 0;
            }
          }
          if (tmp___357) {
            tmp___352 = __builtin_strcmp(oname, (char const   *)scond->name);
            tmp___356 = tmp___352;
          } else {
            tmp___355 = __builtin_strcmp(oname, (char const   *)scond->name);
            tmp___356 = tmp___355;
          }
        } else {
          tmp___355 = __builtin_strcmp(oname, (char const   *)scond->name);
          tmp___356 = tmp___355;
        }
        if (! tmp___356) {
          switch (sidx->type) {
          case 0: 
          switch (otype) {
          case 0: 
          asc = (_Bool)1;
          all___9 = (_Bool)0;
          break;
          case 1: 
          asc = (_Bool)0;
          all___9 = (_Bool)0;
          break;
          }
          break;
          case 1: 
          switch (otype) {
          case 2: 
          asc = (_Bool)1;
          all___9 = (_Bool)0;
          break;
          case 3: 
          asc = (_Bool)0;
          all___9 = (_Bool)0;
          break;
          }
          break;
          }
        }
      }
      if (asc) {
        tcxstrprintf(hint, "using an index: \"%s\" asc (all)\n", scond->name);
        tmp___358 = tcbdbcurnew((TCBDB *)sidx->db);
        cur___9 = tmp___358;
        tcbdbcurfirst(cur___9);
        if (! all___9) {
          if (max < 2147483647) {
            tcxstrprintf(hint, "limited matching: %d\n", max);
          }
        }
        while (1) {
          if (all___9) {
            goto _L___66;
          } else {
            if (res->num < max) {
              _L___66: 
              tmp___375 = tcbdbcurkey3(cur___9, & ksiz___11);
              kbuf___11 = (char const   *)tmp___375;
              if (! ((unsigned int )kbuf___11 != (unsigned int )((void *)0))) {
                break;
              }
            } else {
              break;
            }
          }
          if (trim___0) {
            ksiz___11 -= 3;
          }
          if (ksiz___11 < 0) {
            break;
          }
          tmp___374 = tctdbqrycondmatch(scond, kbuf___11, ksiz___11);
          if (tmp___374) {
            tmp___359 = tcbdbcurval3(cur___9, & vsiz___9);
            vbuf___9 = (char const   *)tmp___359;
            if (acnum < 1) {
              while (1) {
                TC_mysize___35 = vsiz___9;
                TC_index___35 = res->start + res->num;
                if (TC_index___35 >= res->anum) {
                  res->anum += res->num + 1;
                  while (1) {
                    tmp___361 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                    tmp___360 = (TCLISTDATUM *)tmp___361;
                    res->array = tmp___360;
                    if (! tmp___360) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                }
                array___35 = res->array;
                while (1) {
                  tmp___363 = malloc((unsigned int )(TC_mysize___35 + 1));
                  tmp___362 = (char *)tmp___363;
                  (array___35 + TC_index___35)->ptr = tmp___362;
                  if (! tmp___362) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
                memcpy((void * __restrict  )(array___35 + TC_index___35)->ptr, (void const   * __restrict  )vbuf___9,
                       (unsigned int )TC_mysize___35);
                *((array___35 + TC_index___35)->ptr + TC_mysize___35) = (char )'\000';
                (array___35 + TC_index___35)->size = TC_mysize___35;
                (res->num) ++;
                break;
              }
            } else {
              if (ucond___0) {
                tmp___368 = tctdbqryonecondmatch(qry, ucond___0, vbuf___9, vsiz___9);
                if (tmp___368) {
                  while (1) {
                    TC_mysize___36 = vsiz___9;
                    TC_index___36 = res->start + res->num;
                    if (TC_index___36 >= res->anum) {
                      res->anum += res->num + 1;
                      while (1) {
                        tmp___365 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                        tmp___364 = (TCLISTDATUM *)tmp___365;
                        res->array = tmp___364;
                        if (! tmp___364) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    array___36 = res->array;
                    while (1) {
                      tmp___367 = malloc((unsigned int )(TC_mysize___36 + 1));
                      tmp___366 = (char *)tmp___367;
                      (array___36 + TC_index___36)->ptr = tmp___366;
                      if (! tmp___366) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )(array___36 + TC_index___36)->ptr,
                           (void const   * __restrict  )vbuf___9, (unsigned int )TC_mysize___36);
                    *((array___36 + TC_index___36)->ptr + TC_mysize___36) = (char )'\000';
                    (array___36 + TC_index___36)->size = TC_mysize___36;
                    (res->num) ++;
                    break;
                  }
                }
              } else {
                tmp___373 = tctdbqryallcondmatch(qry, vbuf___9, vsiz___9);
                if (tmp___373) {
                  while (1) {
                    TC_mysize___37 = vsiz___9;
                    TC_index___37 = res->start + res->num;
                    if (TC_index___37 >= res->anum) {
                      res->anum += res->num + 1;
                      while (1) {
                        tmp___370 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                        tmp___369 = (TCLISTDATUM *)tmp___370;
                        res->array = tmp___369;
                        if (! tmp___369) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    array___37 = res->array;
                    while (1) {
                      tmp___372 = malloc((unsigned int )(TC_mysize___37 + 1));
                      tmp___371 = (char *)tmp___372;
                      (array___37 + TC_index___37)->ptr = tmp___371;
                      if (! tmp___371) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )(array___37 + TC_index___37)->ptr,
                           (void const   * __restrict  )vbuf___9, (unsigned int )TC_mysize___37);
                    *((array___37 + TC_index___37)->ptr + TC_mysize___37) = (char )'\000';
                    (array___37 + TC_index___37)->size = TC_mysize___37;
                    (res->num) ++;
                    break;
                  }
                }
              }
            }
          }
          tcbdbcurnext(cur___9);
        }
        tcbdbcurdel(cur___9);
      } else {
        tcxstrprintf(hint, "using an index: \"%s\" desc (all)\n", scond->name);
        tmp___376 = tcbdbcurnew((TCBDB *)sidx->db);
        cur___10 = tmp___376;
        tcbdbcurlast(cur___10);
        if (! all___9) {
          if (max < 2147483647) {
            tcxstrprintf(hint, "limited matching: %d\n", max);
          }
        }
        while (1) {
          if (all___9) {
            goto _L___67;
          } else {
            if (res->num < max) {
              _L___67: 
              tmp___393 = tcbdbcurkey3(cur___10, & ksiz___12);
              kbuf___12 = (char const   *)tmp___393;
              if (! ((unsigned int )kbuf___12 != (unsigned int )((void *)0))) {
                break;
              }
            } else {
              break;
            }
          }
          if (trim___0) {
            ksiz___12 -= 3;
          }
          if (ksiz___12 < 0) {
            break;
          }
          tmp___392 = tctdbqrycondmatch(scond, kbuf___12, ksiz___12);
          if (tmp___392) {
            tmp___377 = tcbdbcurval3(cur___10, & vsiz___10);
            vbuf___10 = (char const   *)tmp___377;
            if (acnum < 1) {
              while (1) {
                TC_mysize___38 = vsiz___10;
                TC_index___38 = res->start + res->num;
                if (TC_index___38 >= res->anum) {
                  res->anum += res->num + 1;
                  while (1) {
                    tmp___379 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                    tmp___378 = (TCLISTDATUM *)tmp___379;
                    res->array = tmp___378;
                    if (! tmp___378) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                }
                array___38 = res->array;
                while (1) {
                  tmp___381 = malloc((unsigned int )(TC_mysize___38 + 1));
                  tmp___380 = (char *)tmp___381;
                  (array___38 + TC_index___38)->ptr = tmp___380;
                  if (! tmp___380) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
                memcpy((void * __restrict  )(array___38 + TC_index___38)->ptr, (void const   * __restrict  )vbuf___10,
                       (unsigned int )TC_mysize___38);
                *((array___38 + TC_index___38)->ptr + TC_mysize___38) = (char )'\000';
                (array___38 + TC_index___38)->size = TC_mysize___38;
                (res->num) ++;
                break;
              }
            } else {
              if (ucond___0) {
                tmp___386 = tctdbqryonecondmatch(qry, ucond___0, vbuf___10, vsiz___10);
                if (tmp___386) {
                  while (1) {
                    TC_mysize___39 = vsiz___10;
                    TC_index___39 = res->start + res->num;
                    if (TC_index___39 >= res->anum) {
                      res->anum += res->num + 1;
                      while (1) {
                        tmp___383 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                        tmp___382 = (TCLISTDATUM *)tmp___383;
                        res->array = tmp___382;
                        if (! tmp___382) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    array___39 = res->array;
                    while (1) {
                      tmp___385 = malloc((unsigned int )(TC_mysize___39 + 1));
                      tmp___384 = (char *)tmp___385;
                      (array___39 + TC_index___39)->ptr = tmp___384;
                      if (! tmp___384) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )(array___39 + TC_index___39)->ptr,
                           (void const   * __restrict  )vbuf___10, (unsigned int )TC_mysize___39);
                    *((array___39 + TC_index___39)->ptr + TC_mysize___39) = (char )'\000';
                    (array___39 + TC_index___39)->size = TC_mysize___39;
                    (res->num) ++;
                    break;
                  }
                }
              } else {
                tmp___391 = tctdbqryallcondmatch(qry, vbuf___10, vsiz___10);
                if (tmp___391) {
                  while (1) {
                    TC_mysize___40 = vsiz___10;
                    TC_index___40 = res->start + res->num;
                    if (TC_index___40 >= res->anum) {
                      res->anum += res->num + 1;
                      while (1) {
                        tmp___388 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                        tmp___387 = (TCLISTDATUM *)tmp___388;
                        res->array = tmp___387;
                        if (! tmp___387) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    array___40 = res->array;
                    while (1) {
                      tmp___390 = malloc((unsigned int )(TC_mysize___40 + 1));
                      tmp___389 = (char *)tmp___390;
                      (array___40 + TC_index___40)->ptr = tmp___389;
                      if (! tmp___389) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )(array___40 + TC_index___40)->ptr,
                           (void const   * __restrict  )vbuf___10, (unsigned int )TC_mysize___40);
                    *((array___40 + TC_index___40)->ptr + TC_mysize___40) = (char )'\000';
                    (array___40 + TC_index___40)->size = TC_mysize___40;
                    (res->num) ++;
                    break;
                  }
                }
              }
            }
          }
          tcbdbcurprev(cur___10);
        }
        tcbdbcurdel(cur___10);
      }
      if (! all___9) {
        oname = (char const   *)((void *)0);
      }
    }
  }
  if (! res) {
    if (oname) {
      tmp___437 = tchdbrnum(hdb);
      if ((double )max < (double )tmp___437 * 0.2) {
        oidx = (TDBIDX *)((void *)0);
        asc___0 = (_Bool)1;
        i___8 = 0;
        while (1) {
          if (! oidx) {
            if (! (i___8 < inum)) {
              break;
            }
          } else {
            break;
          }
          idx___0 = idxs + i___8;
          if (0) {
            __s1_len___15 = strlen((char const   *)idx___0->name);
            __s2_len___15 = strlen(oname);
            if (! ((unsigned int )((void const   *)(idx___0->name + 1)) - (unsigned int )((void const   *)idx___0->name) == 1U)) {
              goto _L___69;
            } else {
              if (__s1_len___15 >= 4U) {
                _L___69: 
                if (! ((unsigned int )((void const   *)(oname + 1)) - (unsigned int )((void const   *)oname) == 1U)) {
                  tmp___400 = 1;
                } else {
                  if (__s2_len___15 >= 4U) {
                    tmp___400 = 1;
                  } else {
                    tmp___400 = 0;
                  }
                }
              } else {
                tmp___400 = 0;
              }
            }
            if (tmp___400) {
              tmp___395 = __builtin_strcmp((char const   *)idx___0->name, oname);
              tmp___399 = tmp___395;
            } else {
              tmp___398 = __builtin_strcmp((char const   *)idx___0->name, oname);
              tmp___399 = tmp___398;
            }
          } else {
            tmp___398 = __builtin_strcmp((char const   *)idx___0->name, oname);
            tmp___399 = tmp___398;
          }
          if (tmp___399) {
            goto __Cont___4;
          }
          switch (idx___0->type) {
          case 0: 
          switch (otype) {
          case 0: 
          oidx = idx___0;
          asc___0 = (_Bool)1;
          break;
          case 1: 
          oidx = idx___0;
          asc___0 = (_Bool)0;
          break;
          }
          break;
          case 1: 
          switch (otype) {
          case 2: 
          oidx = idx___0;
          asc___0 = (_Bool)1;
          break;
          case 3: 
          oidx = idx___0;
          asc___0 = (_Bool)0;
          break;
          }
          break;
          }
          __Cont___4: 
          i___8 ++;
        }
        if (oidx) {
          res = tclistnew();
          ucond___1 = (TDBCOND *)((void *)0);
          i___9 = 0;
          while (i___9 < cnum) {
            cond___3 = conds + i___9;
            if (! cond___3->alive) {
              goto __Cont___5;
            }
            if (ucond___1) {
              ucond___1 = (TDBCOND *)((void *)0);
              break;
            }
            ucond___1 = cond___3;
            __Cont___5: 
            i___9 ++;
          }
          trim___1 = (_Bool )((int )*(oidx->name) != 0);
          if (asc___0) {
            tcxstrprintf(hint, "using an index: \"%s\" asc (order)\n", oname);
            tmp___401 = tcbdbcurnew((TCBDB *)oidx->db);
            cur___11 = tmp___401;
            tcbdbcurfirst(cur___11);
            tcxstrprintf(hint, "limited matching: %d\n", max);
            while (1) {
              if (res->num < max) {
                tmp___417 = tcbdbcurkey3(cur___11, & ksiz___13);
                kbuf___13 = (char const   *)tmp___417;
                if (! ((unsigned int )kbuf___13 != (unsigned int )((void *)0))) {
                  break;
                }
              } else {
                break;
              }
              if (trim___1) {
                ksiz___13 -= 3;
              }
              if (ksiz___13 < 0) {
                break;
              }
              tmp___402 = tcbdbcurval3(cur___11, & vsiz___11);
              vbuf___11 = (char const   *)tmp___402;
              if (acnum < 1) {
                while (1) {
                  TC_mysize___41 = vsiz___11;
                  TC_index___41 = res->start + res->num;
                  if (TC_index___41 >= res->anum) {
                    res->anum += res->num + 1;
                    while (1) {
                      tmp___404 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                      tmp___403 = (TCLISTDATUM *)tmp___404;
                      res->array = tmp___403;
                      if (! tmp___403) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                  }
                  array___41 = res->array;
                  while (1) {
                    tmp___406 = malloc((unsigned int )(TC_mysize___41 + 1));
                    tmp___405 = (char *)tmp___406;
                    (array___41 + TC_index___41)->ptr = tmp___405;
                    if (! tmp___405) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                  memcpy((void * __restrict  )(array___41 + TC_index___41)->ptr, (void const   * __restrict  )vbuf___11,
                         (unsigned int )TC_mysize___41);
                  *((array___41 + TC_index___41)->ptr + TC_mysize___41) = (char )'\000';
                  (array___41 + TC_index___41)->size = TC_mysize___41;
                  (res->num) ++;
                  break;
                }
              } else {
                if (ucond___1) {
                  tmp___411 = tctdbqryonecondmatch(qry, ucond___1, vbuf___11, vsiz___11);
                  if (tmp___411) {
                    while (1) {
                      TC_mysize___42 = vsiz___11;
                      TC_index___42 = res->start + res->num;
                      if (TC_index___42 >= res->anum) {
                        res->anum += res->num + 1;
                        while (1) {
                          tmp___408 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                          tmp___407 = (TCLISTDATUM *)tmp___408;
                          res->array = tmp___407;
                          if (! tmp___407) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                      }
                      array___42 = res->array;
                      while (1) {
                        tmp___410 = malloc((unsigned int )(TC_mysize___42 + 1));
                        tmp___409 = (char *)tmp___410;
                        (array___42 + TC_index___42)->ptr = tmp___409;
                        if (! tmp___409) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                      memcpy((void * __restrict  )(array___42 + TC_index___42)->ptr,
                             (void const   * __restrict  )vbuf___11, (unsigned int )TC_mysize___42);
                      *((array___42 + TC_index___42)->ptr + TC_mysize___42) = (char )'\000';
                      (array___42 + TC_index___42)->size = TC_mysize___42;
                      (res->num) ++;
                      break;
                    }
                  }
                } else {
                  tmp___416 = tctdbqryallcondmatch(qry, vbuf___11, vsiz___11);
                  if (tmp___416) {
                    while (1) {
                      TC_mysize___43 = vsiz___11;
                      TC_index___43 = res->start + res->num;
                      if (TC_index___43 >= res->anum) {
                        res->anum += res->num + 1;
                        while (1) {
                          tmp___413 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                          tmp___412 = (TCLISTDATUM *)tmp___413;
                          res->array = tmp___412;
                          if (! tmp___412) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                      }
                      array___43 = res->array;
                      while (1) {
                        tmp___415 = malloc((unsigned int )(TC_mysize___43 + 1));
                        tmp___414 = (char *)tmp___415;
                        (array___43 + TC_index___43)->ptr = tmp___414;
                        if (! tmp___414) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                      memcpy((void * __restrict  )(array___43 + TC_index___43)->ptr,
                             (void const   * __restrict  )vbuf___11, (unsigned int )TC_mysize___43);
                      *((array___43 + TC_index___43)->ptr + TC_mysize___43) = (char )'\000';
                      (array___43 + TC_index___43)->size = TC_mysize___43;
                      (res->num) ++;
                      break;
                    }
                  }
                }
              }
              tcbdbcurnext(cur___11);
            }
            tcbdbcurdel(cur___11);
          } else {
            tcxstrprintf(hint, "using an index: \"%s\" desc (order)\n", oname);
            tmp___418 = tcbdbcurnew((TCBDB *)oidx->db);
            cur___12 = tmp___418;
            tcbdbcurlast(cur___12);
            tcxstrprintf(hint, "limited matching: %d\n", max);
            while (1) {
              if (res->num < max) {
                tmp___434 = tcbdbcurkey3(cur___12, & ksiz___14);
                kbuf___14 = (char const   *)tmp___434;
                if (! ((unsigned int )kbuf___14 != (unsigned int )((void *)0))) {
                  break;
                }
              } else {
                break;
              }
              if (trim___1) {
                ksiz___14 -= 3;
              }
              if (ksiz___14 < 0) {
                break;
              }
              tmp___419 = tcbdbcurval3(cur___12, & vsiz___12);
              vbuf___12 = (char const   *)tmp___419;
              if (acnum < 1) {
                while (1) {
                  TC_mysize___44 = vsiz___12;
                  TC_index___44 = res->start + res->num;
                  if (TC_index___44 >= res->anum) {
                    res->anum += res->num + 1;
                    while (1) {
                      tmp___421 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                      tmp___420 = (TCLISTDATUM *)tmp___421;
                      res->array = tmp___420;
                      if (! tmp___420) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                  }
                  array___44 = res->array;
                  while (1) {
                    tmp___423 = malloc((unsigned int )(TC_mysize___44 + 1));
                    tmp___422 = (char *)tmp___423;
                    (array___44 + TC_index___44)->ptr = tmp___422;
                    if (! tmp___422) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                  memcpy((void * __restrict  )(array___44 + TC_index___44)->ptr, (void const   * __restrict  )vbuf___12,
                         (unsigned int )TC_mysize___44);
                  *((array___44 + TC_index___44)->ptr + TC_mysize___44) = (char )'\000';
                  (array___44 + TC_index___44)->size = TC_mysize___44;
                  (res->num) ++;
                  break;
                }
              } else {
                if (ucond___1) {
                  tmp___428 = tctdbqryonecondmatch(qry, ucond___1, vbuf___12, vsiz___12);
                  if (tmp___428) {
                    while (1) {
                      TC_mysize___45 = vsiz___12;
                      TC_index___45 = res->start + res->num;
                      if (TC_index___45 >= res->anum) {
                        res->anum += res->num + 1;
                        while (1) {
                          tmp___425 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                          tmp___424 = (TCLISTDATUM *)tmp___425;
                          res->array = tmp___424;
                          if (! tmp___424) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                      }
                      array___45 = res->array;
                      while (1) {
                        tmp___427 = malloc((unsigned int )(TC_mysize___45 + 1));
                        tmp___426 = (char *)tmp___427;
                        (array___45 + TC_index___45)->ptr = tmp___426;
                        if (! tmp___426) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                      memcpy((void * __restrict  )(array___45 + TC_index___45)->ptr,
                             (void const   * __restrict  )vbuf___12, (unsigned int )TC_mysize___45);
                      *((array___45 + TC_index___45)->ptr + TC_mysize___45) = (char )'\000';
                      (array___45 + TC_index___45)->size = TC_mysize___45;
                      (res->num) ++;
                      break;
                    }
                  }
                } else {
                  tmp___433 = tctdbqryallcondmatch(qry, vbuf___12, vsiz___12);
                  if (tmp___433) {
                    while (1) {
                      TC_mysize___46 = vsiz___12;
                      TC_index___46 = res->start + res->num;
                      if (TC_index___46 >= res->anum) {
                        res->anum += res->num + 1;
                        while (1) {
                          tmp___430 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                          tmp___429 = (TCLISTDATUM *)tmp___430;
                          res->array = tmp___429;
                          if (! tmp___429) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                      }
                      array___46 = res->array;
                      while (1) {
                        tmp___432 = malloc((unsigned int )(TC_mysize___46 + 1));
                        tmp___431 = (char *)tmp___432;
                        (array___46 + TC_index___46)->ptr = tmp___431;
                        if (! tmp___431) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                      memcpy((void * __restrict  )(array___46 + TC_index___46)->ptr,
                             (void const   * __restrict  )vbuf___12, (unsigned int )TC_mysize___46);
                      *((array___46 + TC_index___46)->ptr + TC_mysize___46) = (char )'\000';
                      (array___46 + TC_index___46)->size = TC_mysize___46;
                      (res->num) ++;
                      break;
                    }
                  }
                }
              }
              tcbdbcurprev(cur___12);
            }
            tcbdbcurdel(cur___12);
          }
          rnum = res->num;
          if (rnum >= max) {
            oname = (char const   *)((void *)0);
          } else {
            tmp___435 = tcbdbrnum((TCBDB *)oidx->db);
            tmp___436 = tchdbrnum(hdb);
            if (tmp___435 >= tmp___436) {
              oname = (char const   *)((void *)0);
            } else {
              tcxstrprintf(hint, "abort the result: %d\n", rnum);
              tclistdel(res);
              res = (TCLIST *)((void *)0);
            }
          }
        }
      }
    }
  }
  if (! res) {
    tcxstrprintf(hint, "scanning the whole table\n");
    res = tclistnew();
    ucond___2 = (TDBCOND *)((void *)0);
    i___10 = 0;
    while (i___10 < cnum) {
      cond___4 = conds + i___10;
      if (! cond___4->alive) {
        goto __Cont___6;
      }
      if (ucond___2) {
        ucond___2 = (TDBCOND *)((void *)0);
        break;
      }
      ucond___2 = cond___4;
      __Cont___6: 
      i___10 ++;
    }
    lkbuf = (char *)((void *)0);
    lksiz = 0;
    all___10 = (_Bool )((unsigned int )oname != (unsigned int )((void *)0));
    if (! all___10) {
      if (max < 2147483647) {
        tcxstrprintf(hint, "limited matching: %d\n", max);
      }
    }
    while (1) {
      if (all___10) {
        goto _L___70;
      } else {
        if (res->num < max) {
          _L___70: 
          pkbuf = tchdbgetnext3(hdb, (char const   *)lkbuf, lksiz, & pksiz, & cbuf,
                                & csiz);
          if (! ((unsigned int )pkbuf != (unsigned int )((void *)0))) {
            break;
          }
        } else {
          break;
        }
      }
      if (ucond___2) {
        if (ucond___2->nsiz < 1) {
          while (1) {
            while (1) {
              tmp___438 = malloc((unsigned int )(pksiz + 1));
              tkbuf = (char *)tmp___438;
              if (! tkbuf) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )tkbuf, (void const   * __restrict  )pkbuf,
                   (unsigned int )pksiz);
            *(tkbuf + pksiz) = (char )'\000';
            break;
          }
          tmp___443 = tctdbqrycondmatch(ucond___2, (char const   *)tkbuf, pksiz);
          if ((int )tmp___443 == (int )ucond___2->sign) {
            while (1) {
              TC_mysize___47 = pksiz;
              TC_index___47 = res->start + res->num;
              if (TC_index___47 >= res->anum) {
                res->anum += res->num + 1;
                while (1) {
                  tmp___440 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                  tmp___439 = (TCLISTDATUM *)tmp___440;
                  res->array = tmp___439;
                  if (! tmp___439) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              array___47 = res->array;
              while (1) {
                tmp___442 = malloc((unsigned int )(TC_mysize___47 + 1));
                tmp___441 = (char *)tmp___442;
                (array___47 + TC_index___47)->ptr = tmp___441;
                if (! tmp___441) {
                  tcmyfatal("out of memory");
                }
                break;
              }
              memcpy((void * __restrict  )(array___47 + TC_index___47)->ptr, (void const   * __restrict  )pkbuf,
                     (unsigned int )TC_mysize___47);
              *((array___47 + TC_index___47)->ptr + TC_mysize___47) = (char )'\000';
              (array___47 + TC_index___47)->size = TC_mysize___47;
              (res->num) ++;
              break;
            }
          }
          while (1) {
            free((void *)tkbuf);
            break;
          }
        } else {
          tmp___444 = tcmaploadone((void const   *)cbuf, csiz, (void const   *)ucond___2->name,
                                   ucond___2->nsiz, & vsiz___13);
          vbuf___13 = (char *)tmp___444;
          if (vbuf___13) {
            tmp___449 = tctdbqrycondmatch(ucond___2, (char const   *)vbuf___13, vsiz___13);
            if ((int )tmp___449 == (int )ucond___2->sign) {
              while (1) {
                TC_mysize___48 = pksiz;
                TC_index___48 = res->start + res->num;
                if (TC_index___48 >= res->anum) {
                  res->anum += res->num + 1;
                  while (1) {
                    tmp___446 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                    tmp___445 = (TCLISTDATUM *)tmp___446;
                    res->array = tmp___445;
                    if (! tmp___445) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                }
                array___48 = res->array;
                while (1) {
                  tmp___448 = malloc((unsigned int )(TC_mysize___48 + 1));
                  tmp___447 = (char *)tmp___448;
                  (array___48 + TC_index___48)->ptr = tmp___447;
                  if (! tmp___447) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
                memcpy((void * __restrict  )(array___48 + TC_index___48)->ptr, (void const   * __restrict  )pkbuf,
                       (unsigned int )TC_mysize___48);
                *((array___48 + TC_index___48)->ptr + TC_mysize___48) = (char )'\000';
                (array___48 + TC_index___48)->size = TC_mysize___48;
                (res->num) ++;
                break;
              }
            }
            while (1) {
              free((void *)vbuf___13);
              break;
            }
          } else {
            if (! ucond___2->sign) {
              while (1) {
                TC_mysize___49 = pksiz;
                TC_index___49 = res->start + res->num;
                if (TC_index___49 >= res->anum) {
                  res->anum += res->num + 1;
                  while (1) {
                    tmp___451 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                    tmp___450 = (TCLISTDATUM *)tmp___451;
                    res->array = tmp___450;
                    if (! tmp___450) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                }
                array___49 = res->array;
                while (1) {
                  tmp___453 = malloc((unsigned int )(TC_mysize___49 + 1));
                  tmp___452 = (char *)tmp___453;
                  (array___49 + TC_index___49)->ptr = tmp___452;
                  if (! tmp___452) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
                memcpy((void * __restrict  )(array___49 + TC_index___49)->ptr, (void const   * __restrict  )pkbuf,
                       (unsigned int )TC_mysize___49);
                *((array___49 + TC_index___49)->ptr + TC_mysize___49) = (char )'\000';
                (array___49 + TC_index___49)->size = TC_mysize___49;
                (res->num) ++;
                break;
              }
            }
          }
        }
      } else {
        tmp___454 = tcmapload((void const   *)cbuf, csiz);
        cols = tmp___454;
        ok = (_Bool)1;
        i___11 = 0;
        while (i___11 < cnum) {
          cond___5 = conds + i___11;
          if (cond___5->nsiz < 1) {
            while (1) {
              while (1) {
                tmp___455 = malloc((unsigned int )(pksiz + 1));
                tkbuf___0 = (char *)tmp___455;
                if (! tkbuf___0) {
                  tcmyfatal("out of memory");
                }
                break;
              }
              memcpy((void * __restrict  )tkbuf___0, (void const   * __restrict  )pkbuf,
                     (unsigned int )pksiz);
              *(tkbuf___0 + pksiz) = (char )'\000';
              break;
            }
            tmp___456 = tctdbqrycondmatch(cond___5, (char const   *)tkbuf___0, pksiz);
            if ((int )tmp___456 != (int )cond___5->sign) {
              while (1) {
                free((void *)tkbuf___0);
                break;
              }
              ok = (_Bool)0;
              break;
            }
            while (1) {
              free((void *)tkbuf___0);
              break;
            }
          } else {
            tmp___457 = tcmapget((TCMAP const   *)cols, (void const   *)cond___5->name,
                                 cond___5->nsiz, & vsiz___14);
            vbuf___14 = (char const   *)tmp___457;
            if (vbuf___14) {
              tmp___458 = tctdbqrycondmatch(cond___5, vbuf___14, vsiz___14);
              if ((int )tmp___458 != (int )cond___5->sign) {
                ok = (_Bool)0;
                break;
              }
            } else {
              if (cond___5->sign) {
                ok = (_Bool)0;
                break;
              }
            }
          }
          i___11 ++;
        }
        if (ok) {
          while (1) {
            TC_mysize___50 = pksiz;
            TC_index___50 = res->start + res->num;
            if (TC_index___50 >= res->anum) {
              res->anum += res->num + 1;
              while (1) {
                tmp___460 = realloc((void *)res->array, (unsigned int )(res->anum * (int )sizeof(*(res->array + 0))));
                tmp___459 = (TCLISTDATUM *)tmp___460;
                res->array = tmp___459;
                if (! tmp___459) {
                  tcmyfatal("out of memory");
                }
                break;
              }
            }
            array___50 = res->array;
            while (1) {
              tmp___462 = malloc((unsigned int )(TC_mysize___50 + 1));
              tmp___461 = (char *)tmp___462;
              (array___50 + TC_index___50)->ptr = tmp___461;
              if (! tmp___461) {
                tcmyfatal("out of memory");
              }
              break;
            }
            memcpy((void * __restrict  )(array___50 + TC_index___50)->ptr, (void const   * __restrict  )pkbuf,
                   (unsigned int )TC_mysize___50);
            *((array___50 + TC_index___50)->ptr + TC_mysize___50) = (char )'\000';
            (array___50 + TC_index___50)->size = TC_mysize___50;
            (res->num) ++;
            break;
          }
        }
        tcmapdel(cols);
      }
      while (1) {
        free((void *)lkbuf);
        break;
      }
      lkbuf = pkbuf;
      lksiz = pksiz;
    }
    while (1) {
      free((void *)lkbuf);
      break;
    }
  }
  rnum___0 = res->num;
  tcxstrprintf(hint, "result set size: %d\n", rnum___0);
  if (oname) {
    if ((int const   )*oname == 0) {
      tcxstrprintf(hint, "sorting the result set: \"%s\"\n", oname);
      switch (otype) {
      case 0: 
      tclistsort(res);
      break;
      case 1: 
      tclistsort(res);
      tclistinvert(res);
      break;
      case 2: 
      tclistsortex(res, & tdbcmppkeynumasc);
      break;
      case 3: 
      tclistsortex(res, & tdbcmppkeynumdesc);
      break;
      }
    } else {
      tcxstrprintf(hint, "sorting the result set: \"%s\"\n", oname);
      while (1) {
        tmp___463 = malloc((unsigned int )((int )sizeof(*keys) * rnum___0 + 1));
        keys = (TDBSORTKEY *)tmp___463;
        if (! keys) {
          tcmyfatal("out of memory");
        }
        break;
      }
      tmp___464 = strlen(oname);
      onsiz = (int )tmp___464;
      i___12 = 0;
      while (i___12 < rnum___0) {
        key = keys + i___12;
        while (1) {
          kbuf___15 = (char const   *)(res->array + (i___12 + res->start))->ptr;
          ksiz___15 = (res->array + (i___12 + res->start))->size;
          break;
        }
        vbuf___15 = (char *)((void *)0);
        vsiz___15 = 0;
        tmp___465 = tchdbget(hdb, (void const   *)kbuf___15, ksiz___15, & csiz___0);
        cbuf___0 = (char *)tmp___465;
        if (cbuf___0) {
          tmp___466 = tcmaploadone((void const   *)cbuf___0, csiz___0, (void const   *)oname,
                                   onsiz, & vsiz___15);
          vbuf___15 = (char *)tmp___466;
          while (1) {
            free((void *)cbuf___0);
            break;
          }
        }
        key->kbuf = kbuf___15;
        key->ksiz = ksiz___15;
        key->vbuf = vbuf___15;
        key->vsiz = vsiz___15;
        i___12 ++;
      }
      compar = (int (*)(TDBSORTKEY const   *a , TDBSORTKEY const   *b ))((void *)0);
      switch (otype) {
      case 0: 
      compar = & tdbcmpsortkeystrasc;
      break;
      case 1: 
      compar = & tdbcmpsortkeystrdesc;
      break;
      case 2: 
      compar = & tdbcmpsortkeynumasc;
      break;
      case 3: 
      compar = & tdbcmpsortkeynumdesc;
      break;
      }
      if (compar) {
        if (max <= rnum___0 / 16) {
          tctopsort((void *)keys, (unsigned int )rnum___0, (unsigned int )((int )sizeof(*keys)),
                    (unsigned int )max, (int (*)(void const   * , void const   * ))compar);
        } else {
          qsort((void *)keys, (unsigned int )rnum___0, (unsigned int )((int )sizeof(*keys)),
                (int (*)(void const   * , void const   * ))compar);
        }
      }
      tmp___467 = tclistnew2(rnum___0);
      nres = tmp___467;
      i___13 = 0;
      while (i___13 < rnum___0) {
        key___0 = keys + i___13;
        while (1) {
          TC_mysize___51 = key___0->ksiz;
          TC_index___51 = nres->start + nres->num;
          if (TC_index___51 >= nres->anum) {
            nres->anum += nres->num + 1;
            while (1) {
              tmp___469 = realloc((void *)nres->array, (unsigned int )(nres->anum * (int )sizeof(*(nres->array + 0))));
              tmp___468 = (TCLISTDATUM *)tmp___469;
              nres->array = tmp___468;
              if (! tmp___468) {
                tcmyfatal("out of memory");
              }
              break;
            }
          }
          array___51 = nres->array;
          while (1) {
            tmp___471 = malloc((unsigned int )(TC_mysize___51 + 1));
            tmp___470 = (char *)tmp___471;
            (array___51 + TC_index___51)->ptr = tmp___470;
            if (! tmp___470) {
              tcmyfatal("out of memory");
            }
            break;
          }
          memcpy((void * __restrict  )(array___51 + TC_index___51)->ptr, (void const   * __restrict  )key___0->kbuf,
                 (unsigned int )TC_mysize___51);
          *((array___51 + TC_index___51)->ptr + TC_mysize___51) = (char )'\000';
          (array___51 + TC_index___51)->size = TC_mysize___51;
          (nres->num) ++;
          break;
        }
        while (1) {
          free((void *)key___0->vbuf);
          break;
        }
        i___13 ++;
      }
      tclistdel(res);
      res = nres;
      while (1) {
        free((void *)keys);
        break;
      }
    }
  } else {
    if (isord) {
      tcxstrprintf(hint, "leaving the index order\n");
    } else {
      tcxstrprintf(hint, "leaving the natural order\n");
    }
  }
  if (qry->skip > 0) {
    tmp___472 = tclmin((long )res->num, (long )qry->skip);
    left = (int )tmp___472;
    while (1) {
      tmp___474 = left;
      left --;
      if (! (tmp___474 > 0)) {
        break;
      }
      while (1) {
        tmp___473 = tclistshift(res, & rsiz);
        free(tmp___473);
        break;
      }
    }
    max -= qry->skip;
  }
  if (res->num > max) {
    left___0 = res->num - max;
    while (1) {
      tmp___476 = left___0;
      left___0 --;
      if (! (tmp___476 > 0)) {
        break;
      }
      while (1) {
        tmp___475 = tclistpop(res, & rsiz___0);
        free(tmp___475);
        break;
      }
    }
  }
  qry->count = res->num;
  return (res);
}
}
static TCMAP *tctdbqryidxfetch(TDBQRY *qry , TDBCOND *cond , TDBIDX *idx ) 
{ TCTDB *tdb ;
  TCHDB *hdb ;
  TCXSTR *hint ;
  char const   *expr ;
  int esiz ;
  _Bool trim ;
  TCMAP *nmap ;
  uint64_t tmp ;
  long tmp___0 ;
  TCMAP *tmp___1 ;
  BDBCUR *cur ;
  BDBCUR *tmp___2 ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___3 ;
  int tmp___4 ;
  void const   *tmp___5 ;
  BDBCUR *cur___0 ;
  BDBCUR *tmp___6 ;
  char const   *kbuf___0 ;
  int ksiz___0 ;
  int vsiz___0 ;
  char const   *vbuf___0 ;
  void const   *tmp___7 ;
  int tmp___8 ;
  void const   *tmp___9 ;
  TCLIST *tokens ;
  TCLIST *tmp___10 ;
  int i ;
  char *tmp___11 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___13 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tnum ;
  int i___0 ;
  char const   *token ;
  int tsiz ;
  BDBCUR *cur___1 ;
  BDBCUR *tmp___19 ;
  char const   *kbuf___1 ;
  int ksiz___1 ;
  int vsiz___1 ;
  char const   *vbuf___1 ;
  void const   *tmp___20 ;
  int tmp___21 ;
  void const   *tmp___22 ;
  long double xnum ;
  long double tmp___23 ;
  BDBCUR *cur___2 ;
  BDBCUR *tmp___24 ;
  char const   *kbuf___2 ;
  int ksiz___2 ;
  int vsiz___2 ;
  char const   *vbuf___2 ;
  void const   *tmp___25 ;
  long double tmp___26 ;
  void const   *tmp___27 ;
  long double xnum___0 ;
  long double tmp___28 ;
  BDBCUR *cur___3 ;
  BDBCUR *tmp___29 ;
  char const   *kbuf___3 ;
  int ksiz___3 ;
  long double knum ;
  long double tmp___30 ;
  int vsiz___3 ;
  char const   *vbuf___3 ;
  void const   *tmp___31 ;
  void const   *tmp___32 ;
  long double xnum___1 ;
  long double tmp___33 ;
  BDBCUR *cur___4 ;
  BDBCUR *tmp___34 ;
  char const   *kbuf___4 ;
  int ksiz___4 ;
  long double knum___0 ;
  long double tmp___35 ;
  int vsiz___4 ;
  char const   *vbuf___4 ;
  void const   *tmp___36 ;
  void const   *tmp___37 ;
  char const   *pv ;
  long double lower ;
  long double tmp___38 ;
  long double upper ;
  long double tmp___39 ;
  size_t tmp___40 ;
  long double swap ;
  BDBCUR *cur___5 ;
  BDBCUR *tmp___41 ;
  char const   *kbuf___5 ;
  int ksiz___5 ;
  long double tmp___42 ;
  int vsiz___5 ;
  char const   *vbuf___5 ;
  void const   *tmp___43 ;
  void const   *tmp___44 ;
  BDBCUR *cur___6 ;
  BDBCUR *tmp___45 ;
  TCLIST *tokens___0 ;
  TCLIST *tmp___46 ;
  int i___1 ;
  char *tmp___47 ;
  long double tmp___48 ;
  long double tmp___49 ;
  int tnum___0 ;
  int i___2 ;
  char const   *token___0 ;
  int tsiz___0 ;
  long double xnum___2 ;
  long double tmp___50 ;
  char const   *kbuf___6 ;
  int ksiz___6 ;
  int vsiz___6 ;
  char const   *vbuf___6 ;
  void const   *tmp___51 ;
  long double tmp___52 ;
  void const   *tmp___53 ;
  char const   *tmp___54 ;
  TCLIST *tokens___1 ;
  TCLIST *tmp___55 ;
  int i___3 ;
  char *tmp___56 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___58 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;

  {
  tdb = qry->tdb;
  hdb = tdb->hdb;
  hint = qry->hint;
  expr = (char const   *)cond->expr;
  esiz = cond->esiz;
  trim = (_Bool )((int )*(idx->name) != 0);
  tmp = tchdbrnum(hdb);
  tmp___0 = tclmin(131071L, (long )tmp);
  tmp___1 = tcmapnew2((unsigned int )(tmp___0 / 4L + 1L));
  nmap = tmp___1;
  if (cond->op == 0) {
    tcxstrprintf(hint, "using an auxiliary index: \"%s\" one (STREQ)\n", cond->name);
    tmp___2 = tcbdbcurnew((TCBDB *)idx->db);
    cur = tmp___2;
    tcbdbcurjump(cur, (void const   *)expr, esiz + (int )trim);
    while (1) {
      tmp___5 = tcbdbcurkey3(cur, & ksiz);
      kbuf = (char const   *)tmp___5;
      if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
        break;
      }
      if (trim) {
        ksiz -= 3;
      }
      if (ksiz == esiz) {
        tmp___4 = memcmp((void const   *)kbuf, (void const   *)expr, (unsigned int )esiz);
        if (tmp___4) {
          break;
        } else {
          tmp___3 = tcbdbcurval3(cur, & vsiz);
          vbuf = (char const   *)tmp___3;
          tcmapputkeep(nmap, (void const   *)vbuf, vsiz, (void const   *)"", 0);
        }
      } else {
        break;
      }
      tcbdbcurnext(cur);
    }
    tcbdbcurdel(cur);
  } else {
    if (cond->op == 2) {
      tcxstrprintf(hint, "using an auxiliary index: \"%s\" asc (STRBW)\n", cond->name);
      tmp___6 = tcbdbcurnew((TCBDB *)idx->db);
      cur___0 = tmp___6;
      tcbdbcurjump(cur___0, (void const   *)expr, esiz + (int )trim);
      while (1) {
        tmp___9 = tcbdbcurkey3(cur___0, & ksiz___0);
        kbuf___0 = (char const   *)tmp___9;
        if (! ((unsigned int )kbuf___0 != (unsigned int )((void *)0))) {
          break;
        }
        if (trim) {
          ksiz___0 -= 3;
        }
        if (ksiz___0 >= esiz) {
          tmp___8 = memcmp((void const   *)kbuf___0, (void const   *)expr, (unsigned int )esiz);
          if (tmp___8) {
            break;
          } else {
            tmp___7 = tcbdbcurval3(cur___0, & vsiz___0);
            vbuf___0 = (char const   *)tmp___7;
            tcmapputkeep(nmap, (void const   *)vbuf___0, vsiz___0, (void const   *)"",
                         0);
          }
        } else {
          break;
        }
        tcbdbcurnext(cur___0);
      }
      tcbdbcurdel(cur___0);
    } else {
      if (cond->op == 6) {
        tcxstrprintf(hint, "using an auxiliary index: \"%s\" skip (STROREQ)\n", cond->name);
        tmp___10 = tcstrsplit(expr, "\t\n\r ,");
        tokens = tmp___10;
        tclistsort(tokens);
        i = 1;
        while (i < tokens->num) {
          if (0) {
            __s1_len = strlen((char const   *)((void *)(tokens->array + (i + tokens->start))->ptr));
            __s2_len = strlen((char const   *)((void *)(tokens->array + ((i - 1) + tokens->start))->ptr));
            if (! ((unsigned int )((void const   *)((void *)(tokens->array + (i + tokens->start))->ptr + 1)) - (unsigned int )((void const   *)((void *)(tokens->array + (i + tokens->start))->ptr)) == 1U)) {
              goto _L___0;
            } else {
              if (__s1_len >= 4U) {
                _L___0: 
                if (! ((unsigned int )((void const   *)((void *)(tokens->array + ((i - 1) + tokens->start))->ptr + 1)) - (unsigned int )((void const   *)((void *)(tokens->array + ((i - 1) + tokens->start))->ptr)) == 1U)) {
                  tmp___18 = 1;
                } else {
                  if (__s2_len >= 4U) {
                    tmp___18 = 1;
                  } else {
                    tmp___18 = 0;
                  }
                }
              } else {
                tmp___18 = 0;
              }
            }
            if (tmp___18) {
              tmp___13 = __builtin_strcmp((char const   *)((void *)(tokens->array + (i + tokens->start))->ptr),
                                          (char const   *)((void *)(tokens->array + ((i - 1) + tokens->start))->ptr));
              tmp___17 = tmp___13;
            } else {
              tmp___16 = __builtin_strcmp((char const   *)((void *)(tokens->array + (i + tokens->start))->ptr),
                                          (char const   *)((void *)(tokens->array + ((i - 1) + tokens->start))->ptr));
              tmp___17 = tmp___16;
            }
          } else {
            tmp___16 = __builtin_strcmp((char const   *)((void *)(tokens->array + (i + tokens->start))->ptr),
                                        (char const   *)((void *)(tokens->array + ((i - 1) + tokens->start))->ptr));
            tmp___17 = tmp___16;
          }
          if (! tmp___17) {
            while (1) {
              tmp___11 = tclistremove2(tokens, i);
              free((void *)tmp___11);
              break;
            }
            i --;
          }
          i ++;
        }
        tnum = tokens->num;
        i___0 = 0;
        while (i___0 < tnum) {
          while (1) {
            token = (char const   *)(tokens->array + (i___0 + tokens->start))->ptr;
            tsiz = (tokens->array + (i___0 + tokens->start))->size;
            break;
          }
          if (tsiz < 1) {
            goto __Cont;
          }
          tmp___19 = tcbdbcurnew((TCBDB *)idx->db);
          cur___1 = tmp___19;
          tcbdbcurjump(cur___1, (void const   *)token, tsiz + (int )trim);
          while (1) {
            tmp___22 = tcbdbcurkey3(cur___1, & ksiz___1);
            kbuf___1 = (char const   *)tmp___22;
            if (! ((unsigned int )kbuf___1 != (unsigned int )((void *)0))) {
              break;
            }
            if (trim) {
              ksiz___1 -= 3;
            }
            if (ksiz___1 == tsiz) {
              tmp___21 = memcmp((void const   *)kbuf___1, (void const   *)token, (unsigned int )tsiz);
              if (tmp___21) {
                break;
              } else {
                tmp___20 = tcbdbcurval3(cur___1, & vsiz___1);
                vbuf___1 = (char const   *)tmp___20;
                tcmapputkeep(nmap, (void const   *)vbuf___1, vsiz___1, (void const   *)"",
                             0);
              }
            } else {
              break;
            }
            tcbdbcurnext(cur___1);
          }
          tcbdbcurdel(cur___1);
          __Cont: 
          i___0 ++;
        }
        tclistdel(tokens);
      } else {
        if (cond->op == 8) {
          tcxstrprintf(hint, "using an auxiliary index: \"%s\" asc (NUMEQ)\n", cond->name);
          tmp___23 = tctdbatof(expr);
          xnum = tmp___23;
          tmp___24 = tcbdbcurnew((TCBDB *)idx->db);
          cur___2 = tmp___24;
          tctdbqryidxcurjumpnum(cur___2, expr, esiz, (_Bool)1);
          while (1) {
            tmp___27 = tcbdbcurkey3(cur___2, & ksiz___2);
            kbuf___2 = (char const   *)tmp___27;
            if (! ((unsigned int )kbuf___2 != (unsigned int )((void *)0))) {
              break;
            }
            tmp___26 = tctdbatof(kbuf___2);
            if (tmp___26 == xnum) {
              tmp___25 = tcbdbcurval3(cur___2, & vsiz___2);
              vbuf___2 = (char const   *)tmp___25;
              tcmapputkeep(nmap, (void const   *)vbuf___2, vsiz___2, (void const   *)"",
                           0);
            } else {
              break;
            }
            tcbdbcurnext(cur___2);
          }
          tcbdbcurdel(cur___2);
        } else {
          if (cond->op == 9) {
            goto _L___5;
          } else {
            if (cond->op == 10) {
              _L___5: 
              tcxstrprintf(hint, "using an auxiliary index: \"%s\" asc (NUMGT/NUMGE)\n",
                           cond->name);
              tmp___28 = tctdbatof(expr);
              xnum___0 = tmp___28;
              tmp___29 = tcbdbcurnew((TCBDB *)idx->db);
              cur___3 = tmp___29;
              tctdbqryidxcurjumpnum(cur___3, expr, esiz, (_Bool)1);
              while (1) {
                tmp___32 = tcbdbcurkey3(cur___3, & ksiz___3);
                kbuf___3 = (char const   *)tmp___32;
                if (! ((unsigned int )kbuf___3 != (unsigned int )((void *)0))) {
                  break;
                }
                tmp___30 = tctdbatof(kbuf___3);
                knum = tmp___30;
                if (knum > xnum___0) {
                  tmp___31 = tcbdbcurval3(cur___3, & vsiz___3);
                  vbuf___3 = (char const   *)tmp___31;
                  tcmapputkeep(nmap, (void const   *)vbuf___3, vsiz___3, (void const   *)"",
                               0);
                } else {
                  if (knum >= xnum___0) {
                    if (cond->op == 10) {
                      tmp___31 = tcbdbcurval3(cur___3, & vsiz___3);
                      vbuf___3 = (char const   *)tmp___31;
                      tcmapputkeep(nmap, (void const   *)vbuf___3, vsiz___3, (void const   *)"",
                                   0);
                    }
                  }
                }
                tcbdbcurnext(cur___3);
              }
              tcbdbcurdel(cur___3);
            } else {
              if (cond->op == 11) {
                goto _L___4;
              } else {
                if (cond->op == 12) {
                  _L___4: 
                  tcxstrprintf(hint, "using an auxiliary index: \"%s\" desc (NUMLT/NUMLE)\n",
                               cond->name);
                  tmp___33 = tctdbatof(expr);
                  xnum___1 = tmp___33;
                  tmp___34 = tcbdbcurnew((TCBDB *)idx->db);
                  cur___4 = tmp___34;
                  tctdbqryidxcurjumpnum(cur___4, expr, esiz, (_Bool)0);
                  while (1) {
                    tmp___37 = tcbdbcurkey3(cur___4, & ksiz___4);
                    kbuf___4 = (char const   *)tmp___37;
                    if (! ((unsigned int )kbuf___4 != (unsigned int )((void *)0))) {
                      break;
                    }
                    tmp___35 = tctdbatof(kbuf___4);
                    knum___0 = tmp___35;
                    if (knum___0 < xnum___1) {
                      tmp___36 = tcbdbcurval3(cur___4, & vsiz___4);
                      vbuf___4 = (char const   *)tmp___36;
                      tcmapputkeep(nmap, (void const   *)vbuf___4, vsiz___4, (void const   *)"",
                                   0);
                    } else {
                      if (knum___0 <= xnum___1) {
                        if (cond->op == 12) {
                          tmp___36 = tcbdbcurval3(cur___4, & vsiz___4);
                          vbuf___4 = (char const   *)tmp___36;
                          tcmapputkeep(nmap, (void const   *)vbuf___4, vsiz___4, (void const   *)"",
                                       0);
                        }
                      }
                    }
                    tcbdbcurprev(cur___4);
                  }
                  tcbdbcurdel(cur___4);
                } else {
                  if (cond->op == 13) {
                    tcxstrprintf(hint, "using an auxiliary index: \"%s\" asc (NUMBT)\n",
                                 cond->name);
                    while (1) {
                      if (! ((int const   )*expr == 32)) {
                        if (! ((int const   )*expr == 44)) {
                          break;
                        }
                      }
                      expr ++;
                    }
                    pv = expr;
                    while (1) {
                      if ((int const   )*pv != 0) {
                        if ((int const   )*pv != 32) {
                          if (! ((int const   )*pv != 44)) {
                            break;
                          }
                        } else {
                          break;
                        }
                      } else {
                        break;
                      }
                      pv ++;
                    }
                    esiz = pv - expr;
                    if ((int const   )*pv != 32) {
                      if ((int const   )*pv != 44) {
                        pv = " ";
                      }
                    }
                    pv ++;
                    while (1) {
                      if (! ((int const   )*pv == 32)) {
                        if (! ((int const   )*pv == 44)) {
                          break;
                        }
                      }
                      pv ++;
                    }
                    tmp___38 = tctdbatof(expr);
                    lower = tmp___38;
                    tmp___39 = tctdbatof(pv);
                    upper = tmp___39;
                    if (lower > upper) {
                      expr = pv;
                      tmp___40 = strlen(expr);
                      esiz = (int )tmp___40;
                      swap = lower;
                      lower = upper;
                      upper = swap;
                    }
                    tmp___41 = tcbdbcurnew((TCBDB *)idx->db);
                    cur___5 = tmp___41;
                    tctdbqryidxcurjumpnum(cur___5, expr, esiz, (_Bool)1);
                    while (1) {
                      tmp___44 = tcbdbcurkey3(cur___5, & ksiz___5);
                      kbuf___5 = (char const   *)tmp___44;
                      if (! ((unsigned int )kbuf___5 != (unsigned int )((void *)0))) {
                        break;
                      }
                      tmp___42 = tctdbatof(kbuf___5);
                      if (tmp___42 > upper) {
                        break;
                      }
                      tmp___43 = tcbdbcurval3(cur___5, & vsiz___5);
                      vbuf___5 = (char const   *)tmp___43;
                      tcmapputkeep(nmap, (void const   *)vbuf___5, vsiz___5, (void const   *)"",
                                   0);
                      tcbdbcurnext(cur___5);
                    }
                    tcbdbcurdel(cur___5);
                  } else {
                    if (cond->op == 14) {
                      tcxstrprintf(hint, "using an auxiliary index: \"%s\" skip (NUMOREQ)\n",
                                   cond->name);
                      tmp___45 = tcbdbcurnew((TCBDB *)idx->db);
                      cur___6 = tmp___45;
                      tmp___46 = tcstrsplit(expr, "\t\n\r ,");
                      tokens___0 = tmp___46;
                      tclistsortex(tokens___0, & tdbcmppkeynumasc);
                      i___1 = 1;
                      while (i___1 < tokens___0->num) {
                        tmp___48 = tctdbatof((char const   *)((void *)(tokens___0->array + (i___1 + tokens___0->start))->ptr));
                        tmp___49 = tctdbatof((char const   *)((void *)(tokens___0->array + ((i___1 - 1) + tokens___0->start))->ptr));
                        if (tmp___48 == tmp___49) {
                          while (1) {
                            tmp___47 = tclistremove2(tokens___0, i___1);
                            free((void *)tmp___47);
                            break;
                          }
                          i___1 --;
                        }
                        i___1 ++;
                      }
                      tnum___0 = tokens___0->num;
                      i___2 = 0;
                      while (i___2 < tnum___0) {
                        while (1) {
                          token___0 = (char const   *)(tokens___0->array + (i___2 + tokens___0->start))->ptr;
                          tsiz___0 = (tokens___0->array + (i___2 + tokens___0->start))->size;
                          break;
                        }
                        if (tsiz___0 < 1) {
                          goto __Cont___0;
                        }
                        tmp___50 = tctdbatof(token___0);
                        xnum___2 = tmp___50;
                        tctdbqryidxcurjumpnum(cur___6, token___0, tsiz___0, (_Bool)1);
                        while (1) {
                          tmp___53 = tcbdbcurkey3(cur___6, & ksiz___6);
                          kbuf___6 = (char const   *)tmp___53;
                          if (! ((unsigned int )kbuf___6 != (unsigned int )((void *)0))) {
                            break;
                          }
                          tmp___52 = tctdbatof(kbuf___6);
                          if (tmp___52 == xnum___2) {
                            tmp___51 = tcbdbcurval3(cur___6, & vsiz___6);
                            vbuf___6 = (char const   *)tmp___51;
                            tcmapputkeep(nmap, (void const   *)vbuf___6, vsiz___6,
                                         (void const   *)"", 0);
                          } else {
                            break;
                          }
                          tcbdbcurnext(cur___6);
                        }
                        __Cont___0: 
                        i___2 ++;
                      }
                      tclistdel(tokens___0);
                      tcbdbcurdel(cur___6);
                    } else {
                      if (cond->op == 4) {
                        goto _L___3;
                      } else {
                        if (cond->op == 5) {
                          _L___3: 
                          if (cond->op == 4) {
                            tmp___54 = "STRAND";
                          } else {
                            tmp___54 = "STROR";
                          }
                          tcxstrprintf(hint, "using an auxiliary index: \"%s\" inverted (%s)\n",
                                       cond->name, tmp___54);
                          tmp___55 = tcstrsplit(expr, "\t\n\r ,");
                          tokens___1 = tmp___55;
                          tclistsort(tokens___1);
                          i___3 = 1;
                          while (i___3 < tokens___1->num) {
                            if (0) {
                              __s1_len___0 = strlen((char const   *)((void *)(tokens___1->array + (i___3 + tokens___1->start))->ptr));
                              __s2_len___0 = strlen((char const   *)((void *)(tokens___1->array + ((i___3 - 1) + tokens___1->start))->ptr));
                              if (! ((unsigned int )((void const   *)((void *)(tokens___1->array + (i___3 + tokens___1->start))->ptr + 1)) - (unsigned int )((void const   *)((void *)(tokens___1->array + (i___3 + tokens___1->start))->ptr)) == 1U)) {
                                goto _L___2;
                              } else {
                                if (__s1_len___0 >= 4U) {
                                  _L___2: 
                                  if (! ((unsigned int )((void const   *)((void *)(tokens___1->array + ((i___3 - 1) + tokens___1->start))->ptr + 1)) - (unsigned int )((void const   *)((void *)(tokens___1->array + ((i___3 - 1) + tokens___1->start))->ptr)) == 1U)) {
                                    tmp___63 = 1;
                                  } else {
                                    if (__s2_len___0 >= 4U) {
                                      tmp___63 = 1;
                                    } else {
                                      tmp___63 = 0;
                                    }
                                  }
                                } else {
                                  tmp___63 = 0;
                                }
                              }
                              if (tmp___63) {
                                tmp___58 = __builtin_strcmp((char const   *)((void *)(tokens___1->array + (i___3 + tokens___1->start))->ptr),
                                                            (char const   *)((void *)(tokens___1->array + ((i___3 - 1) + tokens___1->start))->ptr));
                                tmp___62 = tmp___58;
                              } else {
                                tmp___61 = __builtin_strcmp((char const   *)((void *)(tokens___1->array + (i___3 + tokens___1->start))->ptr),
                                                            (char const   *)((void *)(tokens___1->array + ((i___3 - 1) + tokens___1->start))->ptr));
                                tmp___62 = tmp___61;
                              }
                            } else {
                              tmp___61 = __builtin_strcmp((char const   *)((void *)(tokens___1->array + (i___3 + tokens___1->start))->ptr),
                                                          (char const   *)((void *)(tokens___1->array + ((i___3 - 1) + tokens___1->start))->ptr));
                              tmp___62 = tmp___61;
                            }
                            if (! tmp___62) {
                              while (1) {
                                tmp___56 = tclistremove2(tokens___1, i___3);
                                free((void *)tmp___56);
                                break;
                              }
                              i___3 --;
                            }
                            i___3 ++;
                          }
                          tcmapdel(nmap);
                          nmap = tctdbidxgetbytokens(tdb, idx, (TCLIST const   *)tokens___1,
                                                     cond->op, hint);
                          tclistdel(tokens___1);
                        } else {
                          if (cond->op == 15) {
                            tcxstrprintf(hint, "using an auxiliary index: \"%s\" inverted (FTS)\n",
                                         cond->name);
                            tcmapdel(nmap);
                            nmap = tctdbidxgetbyfts(tdb, idx, cond, hint);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  tcxstrprintf(hint, "auxiliary result set size: %lld\n", (long long )nmap->rnum);
  return (nmap);
}
}
static long double tctdbatof(char const   *str ) 
{ int sign ;
  long double tmp ;
  _Bool tmp___0 ;
  long double tmp___1 ;
  _Bool tmp___2 ;
  long double num ;
  int col ;
  long double fract ;
  long double base ;

  {
  while (1) {
    if ((int const   )*str > 0) {
      if (! ((int const   )*str <= 32)) {
        break;
      }
    } else {
      break;
    }
    str ++;
  }
  sign = 1;
  if ((int const   )*str == 45) {
    str ++;
    sign = -1;
  } else {
    if ((int const   )*str == 43) {
      str ++;
    }
  }
  tmp___0 = tcstrifwm(str, "inf");
  if (tmp___0) {
    tmp = __builtin_huge_vall();
    return (tmp * (long double )sign);
  }
  tmp___2 = tcstrifwm(str, "nan");
  if (tmp___2) {
    tmp___1 = nanl("");
    return (tmp___1);
  }
  num = (long double )0;
  col = 0;
  while ((int const   )*str != 0) {
    if ((int const   )*str < 48) {
      break;
    } else {
      if ((int const   )*str > 57) {
        break;
      }
    }
    num = (num * (long double )10 + (long double )*str) - (long double )48;
    str ++;
    if (num > (long double )0) {
      col ++;
    }
  }
  if ((int const   )*str == 46) {
    str ++;
    fract = (long double )0.0;
    base = (long double )10;
    while (1) {
      if (col < 16) {
        if (! ((int const   )*str != 0)) {
          break;
        }
      } else {
        break;
      }
      if ((int const   )*str < 48) {
        break;
      } else {
        if ((int const   )*str > 57) {
          break;
        }
      }
      fract += (long double )((int const   )*str - 48) / base;
      str ++;
      col ++;
      base *= (long double )10;
    }
    num += fract;
  }
  return (num * (long double )sign);
}
}
static _Bool tctdbqryidxcurjumpnum(BDBCUR *cur , char const   *expr , int esiz , _Bool first ) 
{ char stack[32] ;
  char *rbuf ;
  void *tmp ;
  _Bool err ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  if (esiz < (int )sizeof(stack)) {
    rbuf = stack;
  } else {
    while (1) {
      tmp = malloc((unsigned int )(esiz + 1));
      rbuf = (char *)tmp;
      if (! rbuf) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  if (first) {
    *(rbuf + 0) = (char)0;
  } else {
    *(rbuf + 0) = (char)127;
  }
  memcpy((void * __restrict  )(rbuf + 1), (void const   * __restrict  )expr, (unsigned int )esiz);
  err = (_Bool)0;
  if (first) {
    tmp___0 = tcbdbcurjump(cur, (void const   *)rbuf, esiz + 1);
    if (! tmp___0) {
      err = (_Bool)1;
    }
  } else {
    tmp___1 = tcbdbcurjumpback(cur, (void const   *)rbuf, esiz + 1);
    if (! tmp___1) {
      err = (_Bool)1;
    }
  }
  if ((unsigned int )rbuf != (unsigned int )(stack)) {
    while (1) {
      free((void *)rbuf);
      break;
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbqryonecondmatch(TDBQRY *qry , TDBCOND *cond , char const   *pkbuf ,
                                  int pksiz ) 
{ _Bool tmp ;
  int csiz ;
  char *cbuf ;
  void *tmp___0 ;
  _Bool rv ;
  int vsiz ;
  char *vbuf ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
  if (cond->nsiz < 1) {
    tmp = tctdbqrycondmatch(cond, pkbuf, pksiz);
    return ((_Bool )((int )tmp == (int )cond->sign));
  }
  tmp___0 = tchdbget((qry->tdb)->hdb, (void const   *)pkbuf, pksiz, & csiz);
  cbuf = (char *)tmp___0;
  if (! cbuf) {
    return ((_Bool)0);
  }
  tmp___1 = tcmaploadone((void const   *)cbuf, csiz, (void const   *)cond->name, cond->nsiz,
                         & vsiz);
  vbuf = (char *)tmp___1;
  if (vbuf) {
    tmp___2 = tctdbqrycondmatch(cond, (char const   *)vbuf, vsiz);
    rv = (_Bool )((int )tmp___2 == (int )cond->sign);
    while (1) {
      free((void *)vbuf);
      break;
    }
  } else {
    rv = (_Bool )(! cond->sign);
  }
  while (1) {
    free((void *)cbuf);
    break;
  }
  return (rv);
}
}
static _Bool tctdbqryallcondmatch(TDBQRY *qry , char const   *pkbuf , int pksiz ) 
{ TCTDB *tdb ;
  TDBCOND *conds ;
  int cnum ;
  int csiz ;
  char *cbuf ;
  void *tmp ;
  TCMAP *cols ;
  TCMAP *tmp___0 ;
  _Bool ok ;
  int i ;
  TDBCOND *cond ;
  _Bool tmp___1 ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___2 ;
  _Bool tmp___3 ;

  {
  tdb = qry->tdb;
  conds = qry->conds;
  cnum = qry->cnum;
  tmp = tchdbget(tdb->hdb, (void const   *)pkbuf, pksiz, & csiz);
  cbuf = (char *)tmp;
  if (! cbuf) {
    return ((_Bool)0);
  }
  tmp___0 = tcmapload((void const   *)cbuf, csiz);
  cols = tmp___0;
  ok = (_Bool)1;
  i = 0;
  while (i < cnum) {
    cond = conds + i;
    if (! cond->alive) {
      goto __Cont;
    }
    if (cond->nsiz < 1) {
      tmp___1 = tctdbqrycondmatch(cond, pkbuf, pksiz);
      if ((int )tmp___1 != (int )cond->sign) {
        ok = (_Bool)0;
        break;
      }
    } else {
      tmp___2 = tcmapget((TCMAP const   *)cols, (void const   *)cond->name, cond->nsiz,
                         & vsiz);
      vbuf = (char const   *)tmp___2;
      if (vbuf) {
        tmp___3 = tctdbqrycondmatch(cond, vbuf, vsiz);
        if ((int )tmp___3 != (int )cond->sign) {
          ok = (_Bool)0;
          break;
        }
      } else {
        if (cond->sign) {
          ok = (_Bool)0;
          break;
        }
      }
    }
    __Cont: 
    i ++;
  }
  tcmapdel(cols);
  while (1) {
    free((void *)cbuf);
    break;
  }
  return (ok);
}
}
static _Bool tctdbqrycondmatch(TDBCOND *cond , char const   *vbuf , int vsiz ) 
{ _Bool hit ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long double tmp___4 ;
  long double tmp___5 ;
  long double tmp___6 ;
  long double tmp___7 ;
  long double tmp___8 ;
  long double tmp___9 ;
  long double tmp___10 ;
  long double tmp___11 ;
  long double tmp___12 ;
  long double tmp___13 ;

  {
  hit = (_Bool)0;
  switch (cond->op) {
  case 0: 
  if (vsiz == cond->esiz) {
    tmp = memcmp((void const   *)vbuf, (void const   *)cond->expr, (unsigned int )cond->esiz);
    if (tmp) {
      tmp___0 = 0;
    } else {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  hit = (_Bool )tmp___0;
  break;
  case 1: 
  tmp___1 = strstr(vbuf, (char const   *)cond->expr);
  hit = (_Bool )((unsigned int )tmp___1 != (unsigned int )((void *)0));
  break;
  case 2: 
  hit = tcstrfwm(vbuf, (char const   *)cond->expr);
  break;
  case 3: 
  hit = tcstrbwm(vbuf, (char const   *)cond->expr);
  break;
  case 4: 
  hit = tctdbqrycondcheckstrand(vbuf, (char const   *)cond->expr);
  break;
  case 5: 
  hit = tctdbqrycondcheckstror(vbuf, (char const   *)cond->expr);
  break;
  case 6: 
  hit = tctdbqrycondcheckstroreq(vbuf, (char const   *)cond->expr);
  break;
  case 7: 
  if (cond->regex) {
    tmp___2 = regexec((regex_t const   * __restrict  )cond->regex, (char const   * __restrict  )vbuf,
                      0U, (regmatch_t * __restrict  )((void *)0), 0);
    if (tmp___2 == 0) {
      tmp___3 = 1;
    } else {
      tmp___3 = 0;
    }
  } else {
    tmp___3 = 0;
  }
  hit = (_Bool )tmp___3;
  break;
  case 8: 
  tmp___4 = tctdbatof(vbuf);
  tmp___5 = tctdbatof((char const   *)cond->expr);
  hit = (_Bool )(tmp___4 == tmp___5);
  break;
  case 9: 
  tmp___6 = tctdbatof(vbuf);
  tmp___7 = tctdbatof((char const   *)cond->expr);
  hit = (_Bool )(tmp___6 > tmp___7);
  break;
  case 10: 
  tmp___8 = tctdbatof(vbuf);
  tmp___9 = tctdbatof((char const   *)cond->expr);
  hit = (_Bool )(tmp___8 >= tmp___9);
  break;
  case 11: 
  tmp___10 = tctdbatof(vbuf);
  tmp___11 = tctdbatof((char const   *)cond->expr);
  hit = (_Bool )(tmp___10 < tmp___11);
  break;
  case 12: 
  tmp___12 = tctdbatof(vbuf);
  tmp___13 = tctdbatof((char const   *)cond->expr);
  hit = (_Bool )(tmp___12 <= tmp___13);
  break;
  case 13: 
  hit = tctdbqrycondchecknumbt(vbuf, (char const   *)cond->expr);
  break;
  case 14: 
  hit = tctdbqrycondchecknumoreq(vbuf, (char const   *)cond->expr);
  break;
  case 15: 
  hit = tctdbqrycondcheckfts(vbuf, vsiz, cond);
  break;
  }
  return (hit);
}
}
static _Bool tctdbqrycondcheckstrand(char const   *vbuf , char const   *expr ) 
{ unsigned char const   *sp ;
  unsigned char const   *ep ;
  _Bool hit ;
  unsigned char const   *rp ;
  unsigned char const   *pp ;

  {
  sp = (unsigned char const   *)((unsigned char *)expr);
  while ((int const   )*sp != 0) {
    while (1) {
      if ((int const   )*sp != 0) {
        if (! ((int const   )*sp <= 32)) {
          goto _L;
        }
      } else {
        _L: 
        if (! ((int const   )*sp == 44)) {
          break;
        }
      }
      sp ++;
    }
    ep = sp;
    while (1) {
      if ((int const   )*ep > 32) {
        if (! ((int const   )*ep != 44)) {
          break;
        }
      } else {
        break;
      }
      ep ++;
    }
    if ((unsigned int )ep > (unsigned int )sp) {
      hit = (_Bool)0;
      rp = (unsigned char const   *)((unsigned char *)vbuf);
      while ((int const   )*rp != 0) {
        pp = sp;
        while ((unsigned int )pp < (unsigned int )ep) {
          if ((int const   )*pp != (int const   )*rp) {
            break;
          }
          pp ++;
          rp ++;
        }
        if ((unsigned int )pp == (unsigned int )ep) {
          if ((int const   )*rp <= 32) {
            hit = (_Bool)1;
            break;
          } else {
            if ((int const   )*rp == 44) {
              hit = (_Bool)1;
              break;
            }
          }
        }
        while (1) {
          if ((int const   )*rp > 32) {
            if (! ((int const   )*rp != 44)) {
              break;
            }
          } else {
            break;
          }
          rp ++;
        }
        while (1) {
          if ((int const   )*rp != 0) {
            if (! ((int const   )*rp <= 32)) {
              goto _L___0;
            }
          } else {
            _L___0: 
            if (! ((int const   )*rp == 44)) {
              break;
            }
          }
          rp ++;
        }
      }
      if (! hit) {
        return ((_Bool)0);
      }
    }
    sp = ep;
  }
  return ((_Bool)1);
}
}
static _Bool tctdbqrycondcheckstror(char const   *vbuf , char const   *expr ) 
{ unsigned char const   *sp ;
  unsigned char const   *ep ;
  _Bool hit ;
  unsigned char const   *rp ;
  unsigned char const   *pp ;

  {
  sp = (unsigned char const   *)((unsigned char *)expr);
  while ((int const   )*sp != 0) {
    while (1) {
      if ((int const   )*sp != 0) {
        if (! ((int const   )*sp <= 32)) {
          goto _L;
        }
      } else {
        _L: 
        if (! ((int const   )*sp == 44)) {
          break;
        }
      }
      sp ++;
    }
    ep = sp;
    while (1) {
      if ((int const   )*ep > 32) {
        if (! ((int const   )*ep != 44)) {
          break;
        }
      } else {
        break;
      }
      ep ++;
    }
    if ((unsigned int )ep > (unsigned int )sp) {
      hit = (_Bool)0;
      rp = (unsigned char const   *)((unsigned char *)vbuf);
      while ((int const   )*rp != 0) {
        pp = sp;
        while ((unsigned int )pp < (unsigned int )ep) {
          if ((int const   )*pp != (int const   )*rp) {
            break;
          }
          pp ++;
          rp ++;
        }
        if ((unsigned int )pp == (unsigned int )ep) {
          if ((int const   )*rp <= 32) {
            hit = (_Bool)1;
            break;
          } else {
            if ((int const   )*rp == 44) {
              hit = (_Bool)1;
              break;
            }
          }
        }
        while (1) {
          if ((int const   )*rp > 32) {
            if (! ((int const   )*rp != 44)) {
              break;
            }
          } else {
            break;
          }
          rp ++;
        }
        while (1) {
          if ((int const   )*rp != 0) {
            if (! ((int const   )*rp <= 32)) {
              goto _L___0;
            }
          } else {
            _L___0: 
            if (! ((int const   )*rp == 44)) {
              break;
            }
          }
          rp ++;
        }
      }
      if (hit) {
        return ((_Bool)1);
      }
    }
    sp = ep;
  }
  return ((_Bool)0);
}
}
static _Bool tctdbqrycondcheckstroreq(char const   *vbuf , char const   *expr ) 
{ unsigned char const   *sp ;
  unsigned char const   *ep ;
  unsigned char const   *rp ;

  {
  sp = (unsigned char const   *)((unsigned char *)expr);
  while ((int const   )*sp != 0) {
    while (1) {
      if ((int const   )*sp != 0) {
        if (! ((int const   )*sp <= 32)) {
          goto _L;
        }
      } else {
        _L: 
        if (! ((int const   )*sp == 44)) {
          break;
        }
      }
      sp ++;
    }
    ep = sp;
    while (1) {
      if ((int const   )*ep > 32) {
        if (! ((int const   )*ep != 44)) {
          break;
        }
      } else {
        break;
      }
      ep ++;
    }
    if ((unsigned int )ep > (unsigned int )sp) {
      rp = (unsigned char const   *)((unsigned char *)vbuf);
      while ((int const   )*rp != 0) {
        if ((int const   )*sp != (int const   )*rp) {
          break;
        } else {
          if ((unsigned int )sp >= (unsigned int )ep) {
            break;
          }
        }
        sp ++;
        rp ++;
      }
      if ((int const   )*rp == 0) {
        if ((unsigned int )sp == (unsigned int )ep) {
          return ((_Bool)1);
        }
      }
    }
    sp = ep;
  }
  return ((_Bool)0);
}
}
static _Bool tctdbqrycondchecknumbt(char const   *vbuf , char const   *expr ) 
{ char const   *pv ;
  long double val ;
  long double tmp ;
  long double lower ;
  long double tmp___0 ;
  long double upper ;
  long double tmp___1 ;
  long double swap ;
  int tmp___2 ;

  {
  while (1) {
    if (! ((int const   )*expr == 32)) {
      if (! ((int const   )*expr == 44)) {
        break;
      }
    }
    expr ++;
  }
  pv = expr;
  while (1) {
    if ((int const   )*pv != 0) {
      if ((int const   )*pv != 32) {
        if (! ((int const   )*pv != 44)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    pv ++;
  }
  if ((int const   )*pv != 32) {
    if ((int const   )*pv != 44) {
      pv = " ";
    }
  }
  pv ++;
  while (1) {
    if (! ((int const   )*pv == 32)) {
      if (! ((int const   )*pv == 44)) {
        break;
      }
    }
    pv ++;
  }
  tmp = tctdbatof(vbuf);
  val = tmp;
  tmp___0 = tctdbatof(expr);
  lower = tmp___0;
  tmp___1 = tctdbatof(pv);
  upper = tmp___1;
  if (lower > upper) {
    swap = lower;
    lower = upper;
    upper = swap;
  }
  if (val >= lower) {
    if (val <= upper) {
      tmp___2 = 1;
    } else {
      tmp___2 = 0;
    }
  } else {
    tmp___2 = 0;
  }
  return ((_Bool )tmp___2);
}
}
static _Bool tctdbqrycondchecknumoreq(char const   *vbuf , char const   *expr ) 
{ long double vnum ;
  long double tmp ;
  char const   *sp ;
  char const   *ep ;
  long double tmp___0 ;

  {
  tmp = tctdbatof(vbuf);
  vnum = tmp;
  sp = expr;
  while ((int const   )*sp != 0) {
    while (1) {
      if (! ((int const   )*sp == 32)) {
        if (! ((int const   )*sp == 44)) {
          break;
        }
      }
      sp ++;
    }
    ep = sp;
    while (1) {
      if ((int const   )*ep != 0) {
        if ((int const   )*ep != 32) {
          if (! ((int const   )*ep != 44)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      ep ++;
    }
    if ((unsigned int )ep > (unsigned int )sp) {
      tmp___0 = tctdbatof(sp);
      if (vnum == tmp___0) {
        return ((_Bool)1);
      }
    }
    sp = ep;
  }
  return ((_Bool)0);
}
}
static _Bool tctdbqrycondcheckfts(char const   *vbuf , int vsiz , TDBCOND *cond ) 
{ TDBFTSUNIT *ftsunits ;
  int ftsnum ;
  char astack[1024] ;
  uint16_t *ary ;
  int asiz ;
  void *tmp ;
  int anum ;
  char sstack[1024] ;
  char *str ;
  int ssiz ;
  void *tmp___0 ;
  _Bool ok ;
  int i ;
  TDBFTSUNIT *ftsunit ;
  TCLIST *tokens ;
  int tnum ;
  _Bool hit ;
  int j ;
  char *tmp___1 ;

  {
  ftsunits = (TDBFTSUNIT *)cond->ftsunits;
  ftsnum = cond->ftsnum;
  if (ftsnum < 1) {
    return ((_Bool)0);
  }
  if (! (ftsunits + 0)->sign) {
    return ((_Bool)0);
  }
  asiz = (int )sizeof(*ary) * (vsiz + 1);
  if (asiz < (int )sizeof(astack)) {
    ary = (uint16_t *)(astack);
  } else {
    while (1) {
      tmp = malloc((unsigned int )(asiz + 1));
      ary = (uint16_t *)tmp;
      if (! ary) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  tcstrutftoucs(vbuf, ary, & anum);
  anum = tcstrucsnorm(ary, anum, 15);
  ssiz = anum * 3 + 1;
  if (ssiz < (int )sizeof(sstack)) {
    str = sstack;
  } else {
    while (1) {
      tmp___0 = malloc((unsigned int )(ssiz + 1));
      str = (char *)tmp___0;
      if (! str) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  tcstrucstoutf((uint16_t const   *)ary, anum, str);
  ok = (_Bool)1;
  i = 0;
  while (i < ftsnum) {
    ftsunit = ftsunits + i;
    tokens = ftsunit->tokens;
    tnum = tokens->num;
    hit = (_Bool)0;
    j = 0;
    while (j < tnum) {
      tmp___1 = strstr((char const   *)str, (char const   *)((void *)(tokens->array + (j + tokens->start))->ptr));
      if (tmp___1) {
        hit = (_Bool)1;
        break;
      }
      j ++;
    }
    if ((int )hit != (int )ftsunit->sign) {
      ok = (_Bool)0;
    }
    i ++;
  }
  if ((unsigned int )str != (unsigned int )(sstack)) {
    while (1) {
      free((void *)str);
      break;
    }
  }
  if ((unsigned int )ary != (unsigned int )((uint16_t *)(astack))) {
    while (1) {
      free((void *)ary);
      break;
    }
  }
  return (ok);
}
}
static int tdbcmppkeynumasc(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) 
{ int tmp ;

  {
  tmp = tccmpdecimal((char const   *)a->ptr, (int )a->size, (char const   *)b->ptr,
                     (int )b->size, (void *)0);
  return (tmp);
}
}
static int tdbcmppkeynumdesc(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) 
{ int tmp ;

  {
  tmp = tccmpdecimal((char const   *)b->ptr, (int )b->size, (char const   *)a->ptr,
                     (int )a->size, (void *)0);
  return (tmp);
}
}
static int tdbcmpsortkeystrasc(TDBSORTKEY const   *a , TDBSORTKEY const   *b ) 
{ int rv ;
  int _TC_min ;
  int tmp ;
  int _TC_i ;

  {
  if (! a->vbuf) {
    if (! b->vbuf) {
      return (0);
    }
    return (1);
  }
  if (! b->vbuf) {
    if (! a->vbuf) {
      return (0);
    }
    return (-1);
  }
  while (1) {
    rv = 0;
    if (a->vsiz < b->vsiz) {
      tmp = (int )a->vsiz;
    } else {
      tmp = (int )b->vsiz;
    }
    _TC_min = tmp;
    _TC_i = 0;
    while (_TC_i < _TC_min) {
      if ((int )*((unsigned char *)a->vbuf + _TC_i) != (int )*((unsigned char *)b->vbuf + _TC_i)) {
        rv = (int )*((unsigned char *)a->vbuf + _TC_i) - (int )*((unsigned char *)b->vbuf + _TC_i);
        break;
      }
      _TC_i ++;
    }
    if (rv == 0) {
      rv = (int )(a->vsiz - b->vsiz);
    }
    break;
  }
  return (rv);
}
}
static int tdbcmpsortkeystrdesc(TDBSORTKEY const   *a , TDBSORTKEY const   *b ) 
{ int rv ;
  int _TC_min ;
  int tmp ;
  int _TC_i ;

  {
  if (! a->vbuf) {
    if (! b->vbuf) {
      return (0);
    }
    return (1);
  }
  if (! b->vbuf) {
    if (! a->vbuf) {
      return (0);
    }
    return (-1);
  }
  while (1) {
    rv = 0;
    if (a->vsiz < b->vsiz) {
      tmp = (int )a->vsiz;
    } else {
      tmp = (int )b->vsiz;
    }
    _TC_min = tmp;
    _TC_i = 0;
    while (_TC_i < _TC_min) {
      if ((int )*((unsigned char *)a->vbuf + _TC_i) != (int )*((unsigned char *)b->vbuf + _TC_i)) {
        rv = (int )*((unsigned char *)a->vbuf + _TC_i) - (int )*((unsigned char *)b->vbuf + _TC_i);
        break;
      }
      _TC_i ++;
    }
    if (rv == 0) {
      rv = (int )(a->vsiz - b->vsiz);
    }
    break;
  }
  return (- rv);
}
}
static int tdbcmpsortkeynumasc(TDBSORTKEY const   *a , TDBSORTKEY const   *b ) 
{ long double anum ;
  long double tmp ;
  long double bnum ;
  long double tmp___0 ;

  {
  if (! a->vbuf) {
    if (! b->vbuf) {
      return (0);
    }
    return (1);
  }
  if (! b->vbuf) {
    if (! a->vbuf) {
      return (0);
    }
    return (-1);
  }
  tmp = tctdbatof((char const   *)a->vbuf);
  anum = tmp;
  tmp___0 = tctdbatof((char const   *)b->vbuf);
  bnum = tmp___0;
  if (anum < bnum) {
    return (-1);
  }
  if (anum > bnum) {
    return (1);
  }
  return (0);
}
}
static int tdbcmpsortkeynumdesc(TDBSORTKEY const   *a , TDBSORTKEY const   *b ) 
{ long double anum ;
  long double tmp ;
  long double bnum ;
  long double tmp___0 ;

  {
  if (! a->vbuf) {
    if (! b->vbuf) {
      return (0);
    }
    return (1);
  }
  if (! b->vbuf) {
    if (! a->vbuf) {
      return (0);
    }
    return (-1);
  }
  tmp = tctdbatof((char const   *)a->vbuf);
  anum = tmp;
  tmp___0 = tctdbatof((char const   *)b->vbuf);
  bnum = tmp___0;
  if (anum < bnum) {
    return (1);
  }
  if (anum > bnum) {
    return (-1);
  }
  return (0);
}
}
static uint16_t tctdbidxhash(char const   *pkbuf , int pksiz ) 
{ uint32_t hash ;
  char const   *tmp ;
  int tmp___0 ;

  {
  hash = 19780211U;
  while (1) {
    tmp___0 = pksiz;
    pksiz --;
    if (! tmp___0) {
      break;
    }
    tmp = pkbuf;
    pkbuf ++;
    hash = hash * 37U + (unsigned int )*((uint8_t *)tmp);
  }
  return ((unsigned short )hash);
}
}
static _Bool tctdbidxput(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ) 
{ _Bool err ;
  uint16_t hash ;
  uint16_t tmp ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  char stack[1024] ;
  char *rbuf ;
  void *tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___5 ;
  int i___0 ;
  TDBIDX *idx___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  void const   *tmp___16 ;

  {
  err = (_Bool)0;
  tmp = tctdbidxhash((char const   *)pkbuf, pksiz);
  hash = tmp;
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    if ((int )*(idx->name) != 0) {
      goto __Cont;
    }
    if (pksiz < (int )sizeof(stack)) {
      rbuf = stack;
    } else {
      while (1) {
        tmp___0 = malloc((unsigned int )(pksiz + 1));
        rbuf = (char *)tmp___0;
        if (! rbuf) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    memcpy((void * __restrict  )rbuf, (void const   * __restrict  )pkbuf, (unsigned int )pksiz);
    *(rbuf + pksiz) = (char )'\000';
    switch (idx->type) {
    case 0: 
    case 1: 
    tmp___2 = tcbdbput((TCBDB *)idx->db, pkbuf, pksiz, (void const   *)rbuf, pksiz);
    if (! tmp___2) {
      tmp___1 = tcbdbecode((TCBDB *)idx->db);
      tctdbsetecode(tdb, tmp___1, "tctdb.c", 4533, "tctdbidxput");
      err = (_Bool)1;
    }
    break;
    case 2: 
    tmp___3 = tctdbidxputtoken(tdb, idx, (char const   *)pkbuf, pksiz, (char const   *)pkbuf,
                               pksiz);
    if (! tmp___3) {
      err = (_Bool)1;
    }
    break;
    case 3: 
    tmp___4 = tctdbidxputqgram(tdb, idx, (char const   *)pkbuf, pksiz, (char const   *)pkbuf,
                               pksiz);
    if (! tmp___4) {
      err = (_Bool)1;
    }
    break;
    }
    if ((unsigned int )rbuf != (unsigned int )(stack)) {
      while (1) {
        free((void *)rbuf);
        break;
      }
    }
    __Cont: 
    i ++;
  }
  tcmapiterinit(cols);
  while (1) {
    tmp___16 = tcmapiternext(cols, & ksiz);
    kbuf = (char const   *)tmp___16;
    if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
      break;
    }
    tmp___5 = tcmapiterval((void const   *)kbuf, & vsiz);
    vbuf = (char const   *)tmp___5;
    i___0 = 0;
    while (i___0 < inum) {
      idx___0 = idxs + i___0;
      if (0) {
        __s1_len = strlen((char const   *)idx___0->name);
        __s2_len = strlen(kbuf);
        if (! ((unsigned int )((void const   *)(idx___0->name + 1)) - (unsigned int )((void const   *)idx___0->name) == 1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)(kbuf + 1)) - (unsigned int )((void const   *)kbuf) == 1U)) {
              tmp___12 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___12 = 1;
              } else {
                tmp___12 = 0;
              }
            }
          } else {
            tmp___12 = 0;
          }
        }
        if (tmp___12) {
          tmp___7 = __builtin_strcmp((char const   *)idx___0->name, kbuf);
          tmp___11 = tmp___7;
        } else {
          tmp___10 = __builtin_strcmp((char const   *)idx___0->name, kbuf);
          tmp___11 = tmp___10;
        }
      } else {
        tmp___10 = __builtin_strcmp((char const   *)idx___0->name, kbuf);
        tmp___11 = tmp___10;
      }
      if (tmp___11) {
        goto __Cont___0;
      }
      switch (idx___0->type) {
      case 0: 
      case 1: 
      tmp___13 = tctdbidxputone(tdb, idx___0, (char const   *)pkbuf, pksiz, hash,
                                vbuf, vsiz);
      if (! tmp___13) {
        err = (_Bool)1;
      }
      break;
      case 2: 
      tmp___14 = tctdbidxputtoken(tdb, idx___0, (char const   *)pkbuf, pksiz, vbuf,
                                  vsiz);
      if (! tmp___14) {
        err = (_Bool)1;
      }
      break;
      case 3: 
      tmp___15 = tctdbidxputqgram(tdb, idx___0, (char const   *)pkbuf, pksiz, vbuf,
                                  vsiz);
      if (! tmp___15) {
        err = (_Bool)1;
      }
      break;
      }
      __Cont___0: 
      i___0 ++;
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbidxputone(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                            uint16_t hash , char const   *vbuf , int vsiz ) 
{ _Bool err ;
  char stack[1024] ;
  char *rbuf ;
  int rsiz ;
  void *tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  err = (_Bool)0;
  rsiz = vsiz + 3;
  if (rsiz <= (int )sizeof(stack)) {
    rbuf = stack;
  } else {
    while (1) {
      tmp = malloc((unsigned int )rsiz);
      rbuf = (char *)tmp;
      if (! rbuf) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  memcpy((void * __restrict  )rbuf, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
  *(rbuf + vsiz) = (char )'\000';
  *(rbuf + (vsiz + 1)) = (char )((int )hash >> 8);
  *(rbuf + (vsiz + 2)) = (char )((int )hash & 255);
  tmp___1 = tcbdbputdup((TCBDB *)idx->db, (void const   *)rbuf, rsiz, (void const   *)pkbuf,
                        pksiz);
  if (! tmp___1) {
    tmp___0 = tcbdbecode((TCBDB *)idx->db);
    tctdbsetecode(tdb, tmp___0, "tctdb.c", 4598, "tctdbidxputone");
    err = (_Bool)1;
  }
  if ((unsigned int )rbuf != (unsigned int )(stack)) {
    while (1) {
      free((void *)rbuf);
      break;
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbidxputtoken(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                              char const   *vbuf , int vsiz ) 
{ _Bool err ;
  TCMAP *cc ;
  char stack[1024] ;
  char *rbuf ;
  int rsiz ;
  void *tmp ;
  uint64_t pkid ;
  int i ;
  int c ;
  long long _TC_num ;
  int _TC_rem ;
  char *wp ;
  char *tmp___0 ;
  int _TC_num___0 ;
  int _TC_rem___0 ;
  unsigned char const   *sp ;
  unsigned char const   *ep ;
  uint64_t tmp___1 ;
  _Bool tmp___2 ;

  {
  err = (_Bool)0;
  cc = (TCMAP *)idx->cc;
  rsiz = pksiz + 32;
  if (rsiz < (int )sizeof(stack)) {
    rbuf = stack;
  } else {
    while (1) {
      tmp = malloc((unsigned int )rsiz);
      rbuf = (char *)tmp;
      if (! rbuf) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  pkid = 0ULL;
  i = 0;
  while (i < pksiz) {
    c = (int )*(pkbuf + i);
    if (c >= 48) {
      if (c <= 57) {
        pkid = (pkid * 10ULL + (unsigned long long )c) - 48ULL;
      } else {
        pkid = 0ULL;
        break;
      }
    } else {
      pkid = 0ULL;
      break;
    }
    i ++;
  }
  if (pksiz > 0) {
    if ((int const   )*pkbuf == 48) {
      pkid = 0ULL;
    }
  }
  if (pkid > 0ULL) {
    while (1) {
      _TC_num = (long long )pkid;
      if (_TC_num == 0LL) {
        *((signed char *)rbuf + 0) = (signed char)0;
        rsiz = 1;
      } else {
        rsiz = 0;
        while (_TC_num > 0LL) {
          _TC_rem = (int )(_TC_num & 127LL);
          _TC_num >>= 7;
          if (_TC_num > 0LL) {
            *((signed char *)rbuf + rsiz) = (signed char )(- _TC_rem - 1);
          } else {
            *((signed char *)rbuf + rsiz) = (signed char )_TC_rem;
          }
          rsiz ++;
        }
      }
      break;
    }
  } else {
    wp = rbuf;
    tmp___0 = wp;
    wp ++;
    *tmp___0 = (char )'\000';
    while (1) {
      _TC_num___0 = pksiz;
      if (_TC_num___0 == 0) {
        *((signed char *)wp + 0) = (signed char)0;
        rsiz = 1;
      } else {
        rsiz = 0;
        while (_TC_num___0 > 0) {
          _TC_rem___0 = _TC_num___0 & 127;
          _TC_num___0 >>= 7;
          if (_TC_num___0 > 0) {
            *((signed char *)wp + rsiz) = (signed char )(- _TC_rem___0 - 1);
          } else {
            *((signed char *)wp + rsiz) = (signed char )_TC_rem___0;
          }
          rsiz ++;
        }
      }
      break;
    }
    wp += rsiz;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )pkbuf, (unsigned int )pksiz);
    wp += pksiz;
    rsiz = wp - rbuf;
  }
  sp = (unsigned char const   *)((unsigned char *)vbuf);
  while ((int const   )*sp != 0) {
    while (1) {
      if ((int const   )*sp != 0) {
        if (! ((int const   )*sp <= 32)) {
          goto _L;
        }
      } else {
        _L: 
        if (! ((int const   )*sp == 44)) {
          break;
        }
      }
      sp ++;
    }
    ep = sp;
    while (1) {
      if ((int const   )*ep > 32) {
        if (! ((int const   )*ep != 44)) {
          break;
        }
      } else {
        break;
      }
      ep ++;
    }
    if ((unsigned int )ep > (unsigned int )sp) {
      tcmapputcat3(cc, (void const   *)sp, ep - sp, (void const   *)rbuf, rsiz);
    }
    sp = ep;
  }
  if ((unsigned int )rbuf != (unsigned int )(stack)) {
    while (1) {
      free((void *)rbuf);
      break;
    }
  }
  tmp___1 = tcmapmsiz((TCMAP const   *)cc);
  if (tmp___1 > (unsigned long long )tdb->iccmax) {
    tmp___2 = tctdbidxsyncicc(tdb, idx, (_Bool)0);
    if (! tmp___2) {
      err = (_Bool)1;
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbidxputqgram(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                              char const   *vbuf , int vsiz ) 
{ _Bool err ;
  TCMAP *cc ;
  char stack[1024] ;
  char *rbuf ;
  int rsiz ;
  void *tmp ;
  uint64_t pkid ;
  int i ;
  int c ;
  long long _TC_num ;
  int _TC_rem ;
  char *wp ;
  char *tmp___0 ;
  int _TC_num___0 ;
  int _TC_rem___0 ;
  uint16_t *ary ;
  void *tmp___1 ;
  int anum ;
  int i___0 ;
  char *wp___0 ;
  char token[10] ;
  int i___1 ;
  int step ;
  int _TC_num___1 ;
  int _TC_rem___1 ;
  size_t tmp___2 ;
  uint64_t tmp___3 ;
  _Bool tmp___4 ;

  {
  err = (_Bool)0;
  cc = (TCMAP *)idx->cc;
  rsiz = pksiz + 64;
  if (rsiz < (int )sizeof(stack)) {
    rbuf = stack;
  } else {
    while (1) {
      tmp = malloc((unsigned int )rsiz);
      rbuf = (char *)tmp;
      if (! rbuf) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  pkid = 0ULL;
  i = 0;
  while (i < pksiz) {
    c = (int )*(pkbuf + i);
    if (c >= 48) {
      if (c <= 57) {
        pkid = (pkid * 10ULL + (unsigned long long )c) - 48ULL;
      } else {
        pkid = 0ULL;
        break;
      }
    } else {
      pkid = 0ULL;
      break;
    }
    i ++;
  }
  if (pksiz > 0) {
    if ((int const   )*pkbuf == 48) {
      pkid = 0ULL;
    }
  }
  if (pkid > 0ULL) {
    while (1) {
      _TC_num = (long long )pkid;
      if (_TC_num == 0LL) {
        *((signed char *)rbuf + 0) = (signed char)0;
        rsiz = 1;
      } else {
        rsiz = 0;
        while (_TC_num > 0LL) {
          _TC_rem = (int )(_TC_num & 127LL);
          _TC_num >>= 7;
          if (_TC_num > 0LL) {
            *((signed char *)rbuf + rsiz) = (signed char )(- _TC_rem - 1);
          } else {
            *((signed char *)rbuf + rsiz) = (signed char )_TC_rem;
          }
          rsiz ++;
        }
      }
      break;
    }
  } else {
    wp = rbuf;
    tmp___0 = wp;
    wp ++;
    *tmp___0 = (char )'\000';
    while (1) {
      _TC_num___0 = pksiz;
      if (_TC_num___0 == 0) {
        *((signed char *)wp + 0) = (signed char)0;
        rsiz = 1;
      } else {
        rsiz = 0;
        while (_TC_num___0 > 0) {
          _TC_rem___0 = _TC_num___0 & 127;
          _TC_num___0 >>= 7;
          if (_TC_num___0 > 0) {
            *((signed char *)wp + rsiz) = (signed char )(- _TC_rem___0 - 1);
          } else {
            *((signed char *)wp + rsiz) = (signed char )_TC_rem___0;
          }
          rsiz ++;
        }
      }
      break;
    }
    wp += rsiz;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )pkbuf, (unsigned int )pksiz);
    wp += pksiz;
    rsiz = wp - rbuf;
  }
  while (1) {
    tmp___1 = malloc((unsigned int )((int )sizeof(*ary) * (vsiz + 3)));
    ary = (uint16_t *)tmp___1;
    if (! ary) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tcstrutftoucs(vbuf, ary, & anum);
  anum = tcstrucsnorm(ary, anum, 15);
  i___0 = 0;
  while (i___0 < 3) {
    *(ary + (anum + i___0)) = (unsigned short)0;
    i___0 ++;
  }
  wp___0 = rbuf + rsiz;
  i___1 = 0;
  while (i___1 < anum) {
    tcstrucstoutf((uint16_t const   *)(ary + i___1), 3, token);
    while (1) {
      _TC_num___1 = i___1;
      if (_TC_num___1 == 0) {
        *((signed char *)wp___0 + 0) = (signed char)0;
        step = 1;
      } else {
        step = 0;
        while (_TC_num___1 > 0) {
          _TC_rem___1 = _TC_num___1 & 127;
          _TC_num___1 >>= 7;
          if (_TC_num___1 > 0) {
            *((signed char *)wp___0 + step) = (signed char )(- _TC_rem___1 - 1);
          } else {
            *((signed char *)wp___0 + step) = (signed char )_TC_rem___1;
          }
          step ++;
        }
      }
      break;
    }
    tmp___2 = strlen((char const   *)(token));
    tcmapputcat3(cc, (void const   *)(token), (int )tmp___2, (void const   *)rbuf,
                 rsiz + step);
    i___1 ++;
  }
  while (1) {
    free((void *)ary);
    break;
  }
  if ((unsigned int )rbuf != (unsigned int )(stack)) {
    while (1) {
      free((void *)rbuf);
      break;
    }
  }
  tmp___3 = tcmapmsiz((TCMAP const   *)cc);
  if (tmp___3 > (unsigned long long )tdb->iccmax) {
    tmp___4 = tctdbidxsyncicc(tdb, idx, (_Bool)0);
    if (! tmp___4) {
      err = (_Bool)1;
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbidxout(TCTDB *tdb , void const   *pkbuf , int pksiz , TCMAP *cols ) 
{ _Bool err ;
  uint16_t hash ;
  uint16_t tmp ;
  TDBIDX *idxs ;
  int inum ;
  int i ;
  TDBIDX *idx ;
  char stack[1024] ;
  char *rbuf ;
  void *tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___5 ;
  int i___0 ;
  TDBIDX *idx___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  void const   *tmp___16 ;

  {
  err = (_Bool)0;
  tmp = tctdbidxhash((char const   *)pkbuf, pksiz);
  hash = tmp;
  idxs = tdb->idxs;
  inum = tdb->inum;
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    if ((int )*(idx->name) != 0) {
      goto __Cont;
    }
    if (pksiz < (int )sizeof(stack)) {
      rbuf = stack;
    } else {
      while (1) {
        tmp___0 = malloc((unsigned int )(pksiz + 1));
        rbuf = (char *)tmp___0;
        if (! rbuf) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    memcpy((void * __restrict  )rbuf, (void const   * __restrict  )pkbuf, (unsigned int )pksiz);
    *(rbuf + pksiz) = (char )'\000';
    switch (idx->type) {
    case 0: 
    case 1: 
    tmp___2 = tcbdbout((TCBDB *)idx->db, pkbuf, pksiz);
    if (! tmp___2) {
      tmp___1 = tcbdbecode((TCBDB *)idx->db);
      tctdbsetecode(tdb, tmp___1, "tctdb.c", 4758, "tctdbidxout");
      err = (_Bool)1;
    }
    break;
    case 2: 
    tmp___3 = tctdbidxouttoken(tdb, idx, (char const   *)pkbuf, pksiz, (char const   *)rbuf,
                               pksiz);
    if (! tmp___3) {
      err = (_Bool)1;
    }
    break;
    case 3: 
    tmp___4 = tctdbidxoutqgram(tdb, idx, (char const   *)pkbuf, pksiz, (char const   *)rbuf,
                               pksiz);
    if (! tmp___4) {
      err = (_Bool)1;
    }
    break;
    }
    if ((unsigned int )rbuf != (unsigned int )(stack)) {
      while (1) {
        free((void *)rbuf);
        break;
      }
    }
    __Cont: 
    i ++;
  }
  tcmapiterinit(cols);
  while (1) {
    tmp___16 = tcmapiternext(cols, & ksiz);
    kbuf = (char const   *)tmp___16;
    if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
      break;
    }
    tmp___5 = tcmapiterval((void const   *)kbuf, & vsiz);
    vbuf = (char const   *)tmp___5;
    i___0 = 0;
    while (i___0 < inum) {
      idx___0 = idxs + i___0;
      if (0) {
        __s1_len = strlen((char const   *)idx___0->name);
        __s2_len = strlen(kbuf);
        if (! ((unsigned int )((void const   *)(idx___0->name + 1)) - (unsigned int )((void const   *)idx___0->name) == 1U)) {
          goto _L___0;
        } else {
          if (__s1_len >= 4U) {
            _L___0: 
            if (! ((unsigned int )((void const   *)(kbuf + 1)) - (unsigned int )((void const   *)kbuf) == 1U)) {
              tmp___12 = 1;
            } else {
              if (__s2_len >= 4U) {
                tmp___12 = 1;
              } else {
                tmp___12 = 0;
              }
            }
          } else {
            tmp___12 = 0;
          }
        }
        if (tmp___12) {
          tmp___7 = __builtin_strcmp((char const   *)idx___0->name, kbuf);
          tmp___11 = tmp___7;
        } else {
          tmp___10 = __builtin_strcmp((char const   *)idx___0->name, kbuf);
          tmp___11 = tmp___10;
        }
      } else {
        tmp___10 = __builtin_strcmp((char const   *)idx___0->name, kbuf);
        tmp___11 = tmp___10;
      }
      if (tmp___11) {
        goto __Cont___0;
      }
      switch (idx___0->type) {
      case 0: 
      case 1: 
      tmp___13 = tctdbidxoutone(tdb, idx___0, (char const   *)pkbuf, pksiz, hash,
                                vbuf, vsiz);
      if (! tmp___13) {
        err = (_Bool)1;
      }
      break;
      case 2: 
      tmp___14 = tctdbidxouttoken(tdb, idx___0, (char const   *)pkbuf, pksiz, vbuf,
                                  vsiz);
      if (! tmp___14) {
        err = (_Bool)1;
      }
      break;
      case 3: 
      tmp___15 = tctdbidxoutqgram(tdb, idx___0, (char const   *)pkbuf, pksiz, vbuf,
                                  vsiz);
      if (! tmp___15) {
        err = (_Bool)1;
      }
      break;
      }
      __Cont___0: 
      i___0 ++;
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbidxoutone(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                            uint16_t hash , char const   *vbuf , int vsiz ) 
{ _Bool err ;
  char stack[1024] ;
  char *rbuf ;
  int rsiz ;
  void *tmp ;
  int ovsiz ;
  char const   *ovbuf ;
  void const   *tmp___0 ;
  int tmp___1 ;
  _Bool tmp___2 ;
  BDBCUR *cur ;
  BDBCUR *tmp___3 ;
  int oksiz ;
  char const   *okbuf ;
  int tmp___4 ;
  void const   *tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  void const   *tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  int tmp___12 ;

  {
  err = (_Bool)0;
  rsiz = vsiz + 3;
  if (rsiz <= (int )sizeof(stack)) {
    rbuf = stack;
  } else {
    while (1) {
      tmp = malloc((unsigned int )rsiz);
      rbuf = (char *)tmp;
      if (! rbuf) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  memcpy((void * __restrict  )rbuf, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
  *(rbuf + vsiz) = (char )'\000';
  *(rbuf + (vsiz + 1)) = (char )((int )hash >> 8);
  *(rbuf + (vsiz + 2)) = (char )((int )hash & 255);
  tmp___0 = tcbdbget3((TCBDB *)idx->db, (void const   *)rbuf, rsiz, & ovsiz);
  ovbuf = (char const   *)tmp___0;
  if (ovbuf) {
    if (ovsiz == pksiz) {
      tmp___12 = memcmp((void const   *)ovbuf, (void const   *)pkbuf, (unsigned int )ovsiz);
      if (tmp___12) {
        goto _L___0;
      } else {
        tmp___2 = tcbdbout((TCBDB *)idx->db, (void const   *)rbuf, rsiz);
        if (! tmp___2) {
          tmp___1 = tcbdbecode((TCBDB *)idx->db);
          tctdbsetecode(tdb, tmp___1, "tctdb.c", 4826, "tctdbidxoutone");
          err = (_Bool)1;
        }
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    tmp___3 = tcbdbcurnew((TCBDB *)idx->db);
    cur = tmp___3;
    tmp___11 = tcbdbcurjump(cur, (void const   *)rbuf, rsiz);
    if (tmp___11) {
      while (1) {
        tmp___9 = tcbdbcurkey3(cur, & oksiz);
        okbuf = (char const   *)tmp___9;
        if (! ((unsigned int )okbuf != (unsigned int )((void *)0))) {
          break;
        }
        if (oksiz != rsiz) {
          break;
        } else {
          tmp___4 = memcmp((void const   *)okbuf, (void const   *)rbuf, (unsigned int )oksiz);
          if (tmp___4) {
            break;
          }
        }
        tmp___5 = tcbdbcurval3(cur, & ovsiz);
        ovbuf = (char const   *)tmp___5;
        if (ovsiz == pksiz) {
          tmp___8 = memcmp((void const   *)ovbuf, (void const   *)pkbuf, (unsigned int )ovsiz);
          if (! tmp___8) {
            tmp___7 = tcbdbcurout(cur);
            if (! tmp___7) {
              tmp___6 = tcbdbecode((TCBDB *)idx->db);
              tctdbsetecode(tdb, tmp___6, "tctdb.c", 4839, "tctdbidxoutone");
              err = (_Bool)1;
            }
            break;
          }
        }
        tcbdbcurnext(cur);
      }
    } else {
      tmp___10 = tcbdbecode((TCBDB *)idx->db);
      tctdbsetecode(tdb, tmp___10, "tctdb.c", 4847, "tctdbidxoutone");
      err = (_Bool)1;
    }
    tcbdbcurdel(cur);
  }
  if ((unsigned int )rbuf != (unsigned int )(stack)) {
    while (1) {
      free((void *)rbuf);
      break;
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbidxouttoken(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                              char const   *vbuf , int vsiz ) 
{ _Bool err ;
  TCBDB *db ;
  TCMAP *cc ;
  uint64_t pkid ;
  int i ;
  int c ;
  TCXSTR *xstr ;
  TCXSTR *tmp ;
  unsigned char const   *sp ;
  unsigned char const   *ep ;
  int len ;
  int csiz ;
  char const   *cbuf ;
  void const   *tmp___0 ;
  char const   *pv ;
  _Bool ok ;
  int tsiz ;
  int step ;
  int _TC_base ;
  int _TC_i ;
  int tmp___1 ;
  int64_t tid ;
  int step___0 ;
  long long _TC_base___0 ;
  int _TC_i___0 ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___2 ;
  void *tmp___3 ;
  void const   *tmp___4 ;
  char const   *pv___0 ;
  _Bool ok___0 ;
  int tsiz___0 ;
  int step___1 ;
  int _TC_base___1 ;
  int _TC_i___1 ;
  int tmp___5 ;
  int64_t tid___0 ;
  int step___2 ;
  long long _TC_base___2 ;
  int _TC_i___2 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;
  uint64_t tmp___10 ;
  _Bool tmp___11 ;

  {
  err = (_Bool)0;
  db = (TCBDB *)idx->db;
  cc = (TCMAP *)idx->cc;
  pkid = 0ULL;
  i = 0;
  while (i < pksiz) {
    c = (int )*(pkbuf + i);
    if (c >= 48) {
      if (c <= 57) {
        pkid = (pkid * 10ULL + (unsigned long long )c) - 48ULL;
      } else {
        pkid = 0ULL;
        break;
      }
    } else {
      pkid = 0ULL;
      break;
    }
    i ++;
  }
  tmp = tcxstrnew();
  xstr = tmp;
  sp = (unsigned char const   *)((unsigned char *)vbuf);
  while ((int const   )*sp != 0) {
    while (1) {
      if ((int const   )*sp != 0) {
        if (! ((int const   )*sp <= 32)) {
          goto _L;
        }
      } else {
        _L: 
        if (! ((int const   )*sp == 44)) {
          break;
        }
      }
      sp ++;
    }
    ep = sp;
    while (1) {
      if ((int const   )*ep > 32) {
        if (! ((int const   )*ep != 44)) {
          break;
        }
      } else {
        break;
      }
      ep ++;
    }
    if ((unsigned int )ep > (unsigned int )sp) {
      tcxstrclear(xstr);
      len = ep - sp;
      tmp___0 = tcmapget((TCMAP const   *)cc, (void const   *)sp, len, & csiz);
      cbuf = (char const   *)tmp___0;
      if (cbuf) {
        while (csiz > 0) {
          pv = cbuf;
          ok = (_Bool)1;
          if ((int const   )*cbuf == 0) {
            cbuf ++;
            csiz --;
            while (1) {
              tsiz = 0;
              _TC_base = 1;
              _TC_i = 0;
              while (1) {
                if ((int )*((signed char *)cbuf + _TC_i) >= 0) {
                  tsiz += (int )*((signed char *)cbuf + _TC_i) * _TC_base;
                  break;
                }
                tsiz += (_TC_base * ((int )*((signed char *)cbuf + _TC_i) + 1)) * -1;
                _TC_base <<= 7;
                _TC_i ++;
              }
              step = _TC_i + 1;
              break;
            }
            cbuf += step;
            csiz -= step;
            if (tsiz == pksiz) {
              tmp___1 = memcmp((void const   *)cbuf, (void const   *)pkbuf, (unsigned int )tsiz);
              if (! tmp___1) {
                ok = (_Bool)0;
              }
            }
            cbuf += tsiz;
            csiz -= tsiz;
          } else {
            while (1) {
              tid = 0LL;
              _TC_base___0 = 1LL;
              _TC_i___0 = 0;
              while (1) {
                if ((int )*((signed char *)cbuf + _TC_i___0) >= 0) {
                  tid += (long long )*((signed char *)cbuf + _TC_i___0) * _TC_base___0;
                  break;
                }
                tid += (_TC_base___0 * (long long )((int )*((signed char *)cbuf + _TC_i___0) + 1)) * -1LL;
                _TC_base___0 <<= 7;
                _TC_i___0 ++;
              }
              step___0 = _TC_i___0 + 1;
              break;
            }
            if ((unsigned long long )tid == pkid) {
              ok = (_Bool)0;
            }
            cbuf += step___0;
            csiz -= step___0;
          }
          if (ok) {
            while (1) {
              TC_mysize = cbuf - pv;
              TC_nsize = (xstr->size + TC_mysize) + 1;
              if (xstr->asize < TC_nsize) {
                while (xstr->asize < TC_nsize) {
                  xstr->asize *= 2;
                  if (xstr->asize < TC_nsize) {
                    xstr->asize = TC_nsize;
                  }
                }
                while (1) {
                  tmp___3 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                  tmp___2 = (char *)tmp___3;
                  xstr->ptr = tmp___2;
                  if (! tmp___2) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )pv,
                     (unsigned int )TC_mysize);
              xstr->size += TC_mysize;
              *(xstr->ptr + xstr->size) = (char )'\000';
              break;
            }
          }
        }
        if (csiz != 0) {
          tctdbsetecode(tdb, 9999, "tctdb.c", 4921, "tctdbidxouttoken");
          err = (_Bool)1;
        }
      }
      tmp___4 = tcbdbget3(db, (void const   *)sp, len, & csiz);
      cbuf = (char const   *)tmp___4;
      if (cbuf) {
        while (csiz > 0) {
          pv___0 = cbuf;
          ok___0 = (_Bool)1;
          if ((int const   )*cbuf == 0) {
            cbuf ++;
            csiz --;
            while (1) {
              tsiz___0 = 0;
              _TC_base___1 = 1;
              _TC_i___1 = 0;
              while (1) {
                if ((int )*((signed char *)cbuf + _TC_i___1) >= 0) {
                  tsiz___0 += (int )*((signed char *)cbuf + _TC_i___1) * _TC_base___1;
                  break;
                }
                tsiz___0 += (_TC_base___1 * ((int )*((signed char *)cbuf + _TC_i___1) + 1)) * -1;
                _TC_base___1 <<= 7;
                _TC_i___1 ++;
              }
              step___1 = _TC_i___1 + 1;
              break;
            }
            cbuf += step___1;
            csiz -= step___1;
            if (tsiz___0 == pksiz) {
              tmp___5 = memcmp((void const   *)cbuf, (void const   *)pkbuf, (unsigned int )tsiz___0);
              if (! tmp___5) {
                ok___0 = (_Bool)0;
              }
            }
            cbuf += tsiz___0;
            csiz -= tsiz___0;
          } else {
            while (1) {
              tid___0 = 0LL;
              _TC_base___2 = 1LL;
              _TC_i___2 = 0;
              while (1) {
                if ((int )*((signed char *)cbuf + _TC_i___2) >= 0) {
                  tid___0 += (long long )*((signed char *)cbuf + _TC_i___2) * _TC_base___2;
                  break;
                }
                tid___0 += (_TC_base___2 * (long long )((int )*((signed char *)cbuf + _TC_i___2) + 1)) * -1LL;
                _TC_base___2 <<= 7;
                _TC_i___2 ++;
              }
              step___2 = _TC_i___2 + 1;
              break;
            }
            if ((unsigned long long )tid___0 == pkid) {
              ok___0 = (_Bool)0;
            }
            cbuf += step___2;
            csiz -= step___2;
          }
          if (ok___0) {
            while (1) {
              TC_mysize___0 = cbuf - pv___0;
              TC_nsize___0 = (xstr->size + TC_mysize___0) + 1;
              if (xstr->asize < TC_nsize___0) {
                while (xstr->asize < TC_nsize___0) {
                  xstr->asize *= 2;
                  if (xstr->asize < TC_nsize___0) {
                    xstr->asize = TC_nsize___0;
                  }
                }
                while (1) {
                  tmp___7 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                  tmp___6 = (char *)tmp___7;
                  xstr->ptr = tmp___6;
                  if (! tmp___6) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )pv___0,
                     (unsigned int )TC_mysize___0);
              xstr->size += TC_mysize___0;
              *(xstr->ptr + xstr->size) = (char )'\000';
              break;
            }
          }
        }
        if (csiz != 0) {
          tctdbsetecode(tdb, 9999, "tctdb.c", 4951, "tctdbidxouttoken");
          err = (_Bool)1;
        }
        tmp___9 = tcbdbout(db, (void const   *)sp, len);
        if (! tmp___9) {
          tmp___8 = tcbdbecode(db);
          tctdbsetecode(tdb, tmp___8, "tctdb.c", 4955, "tctdbidxouttoken");
          err = (_Bool)1;
        }
      }
      tcmapput(cc, (void const   *)sp, len, (void const   *)xstr->ptr, xstr->size);
    }
    sp = ep;
  }
  tcxstrdel(xstr);
  tmp___10 = tcmapmsiz((TCMAP const   *)cc);
  if (tmp___10 > (unsigned long long )tdb->iccmax) {
    tmp___11 = tctdbidxsyncicc(tdb, idx, (_Bool)0);
    if (! tmp___11) {
      err = (_Bool)1;
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbidxoutqgram(TCTDB *tdb , TDBIDX *idx , char const   *pkbuf , int pksiz ,
                              char const   *vbuf , int vsiz ) 
{ _Bool err ;
  TCBDB *db ;
  TCMAP *cc ;
  uint64_t pkid ;
  int i ;
  int c ;
  TCXSTR *xstr ;
  TCXSTR *tmp ;
  uint16_t *ary ;
  void *tmp___0 ;
  int anum ;
  int i___0 ;
  char token[10] ;
  int i___1 ;
  int tsiz ;
  size_t tmp___1 ;
  int csiz ;
  char const   *cbuf ;
  void const   *tmp___2 ;
  char const   *pv ;
  _Bool ok ;
  int tsiz___0 ;
  int step ;
  int _TC_base ;
  int _TC_i ;
  int tmp___3 ;
  int64_t tid ;
  int step___0 ;
  long long _TC_base___0 ;
  int _TC_i___0 ;
  int off ;
  int step___1 ;
  int _TC_base___1 ;
  int _TC_i___1 ;
  int TC_mysize ;
  int TC_nsize ;
  char *tmp___4 ;
  void *tmp___5 ;
  void const   *tmp___6 ;
  char const   *pv___0 ;
  _Bool ok___0 ;
  int tsiz___1 ;
  int step___2 ;
  int _TC_base___2 ;
  int _TC_i___2 ;
  int tmp___7 ;
  int64_t tid___0 ;
  int step___3 ;
  long long _TC_base___3 ;
  int _TC_i___3 ;
  int off___0 ;
  int step___4 ;
  int _TC_base___4 ;
  int _TC_i___4 ;
  int TC_mysize___0 ;
  int TC_nsize___0 ;
  char *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  uint64_t tmp___12 ;
  _Bool tmp___13 ;

  {
  err = (_Bool)0;
  db = (TCBDB *)idx->db;
  cc = (TCMAP *)idx->cc;
  pkid = 0ULL;
  i = 0;
  while (i < pksiz) {
    c = (int )*(pkbuf + i);
    if (c >= 48) {
      if (c <= 57) {
        pkid = (pkid * 10ULL + (unsigned long long )c) - 48ULL;
      } else {
        pkid = 0ULL;
        break;
      }
    } else {
      pkid = 0ULL;
      break;
    }
    i ++;
  }
  tmp = tcxstrnew();
  xstr = tmp;
  while (1) {
    tmp___0 = malloc((unsigned int )((int )sizeof(*ary) * (vsiz + 3)));
    ary = (uint16_t *)tmp___0;
    if (! ary) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tcstrutftoucs(vbuf, ary, & anum);
  anum = tcstrucsnorm(ary, anum, 15);
  i___0 = 0;
  while (i___0 < 3) {
    *(ary + (anum + i___0)) = (unsigned short)0;
    i___0 ++;
  }
  i___1 = 0;
  while (i___1 < anum) {
    tcstrucstoutf((uint16_t const   *)(ary + i___1), 3, token);
    tmp___1 = strlen((char const   *)(token));
    tsiz = (int )tmp___1;
    tcxstrclear(xstr);
    tmp___2 = tcmapget((TCMAP const   *)cc, (void const   *)(token), tsiz, & csiz);
    cbuf = (char const   *)tmp___2;
    if (cbuf) {
      while (csiz > 0) {
        pv = cbuf;
        ok = (_Bool)1;
        if ((int const   )*cbuf == 0) {
          cbuf ++;
          csiz --;
          while (1) {
            tsiz___0 = 0;
            _TC_base = 1;
            _TC_i = 0;
            while (1) {
              if ((int )*((signed char *)cbuf + _TC_i) >= 0) {
                tsiz___0 += (int )*((signed char *)cbuf + _TC_i) * _TC_base;
                break;
              }
              tsiz___0 += (_TC_base * ((int )*((signed char *)cbuf + _TC_i) + 1)) * -1;
              _TC_base <<= 7;
              _TC_i ++;
            }
            step = _TC_i + 1;
            break;
          }
          cbuf += step;
          csiz -= step;
          if (tsiz___0 == pksiz) {
            tmp___3 = memcmp((void const   *)cbuf, (void const   *)pkbuf, (unsigned int )tsiz___0);
            if (! tmp___3) {
              ok = (_Bool)0;
            }
          }
          cbuf += tsiz___0;
          csiz -= tsiz___0;
        } else {
          while (1) {
            tid = 0LL;
            _TC_base___0 = 1LL;
            _TC_i___0 = 0;
            while (1) {
              if ((int )*((signed char *)cbuf + _TC_i___0) >= 0) {
                tid += (long long )*((signed char *)cbuf + _TC_i___0) * _TC_base___0;
                break;
              }
              tid += (_TC_base___0 * (long long )((int )*((signed char *)cbuf + _TC_i___0) + 1)) * -1LL;
              _TC_base___0 <<= 7;
              _TC_i___0 ++;
            }
            step___0 = _TC_i___0 + 1;
            break;
          }
          if ((unsigned long long )tid == pkid) {
            ok = (_Bool)0;
          }
          cbuf += step___0;
          csiz -= step___0;
        }
        if (csiz > 0) {
          while (1) {
            off = 0;
            _TC_base___1 = 1;
            _TC_i___1 = 0;
            while (1) {
              if ((int )*((signed char *)cbuf + _TC_i___1) >= 0) {
                off += (int )*((signed char *)cbuf + _TC_i___1) * _TC_base___1;
                break;
              }
              off += (_TC_base___1 * ((int )*((signed char *)cbuf + _TC_i___1) + 1)) * -1;
              _TC_base___1 <<= 7;
              _TC_i___1 ++;
            }
            step___1 = _TC_i___1 + 1;
            break;
          }
          cbuf += step___1;
          csiz -= step___1;
          if (ok) {
            while (1) {
              TC_mysize = cbuf - pv;
              TC_nsize = (xstr->size + TC_mysize) + 1;
              if (xstr->asize < TC_nsize) {
                while (xstr->asize < TC_nsize) {
                  xstr->asize *= 2;
                  if (xstr->asize < TC_nsize) {
                    xstr->asize = TC_nsize;
                  }
                }
                while (1) {
                  tmp___5 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                  tmp___4 = (char *)tmp___5;
                  xstr->ptr = tmp___4;
                  if (! tmp___4) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )pv,
                     (unsigned int )TC_mysize);
              xstr->size += TC_mysize;
              *(xstr->ptr + xstr->size) = (char )'\000';
              break;
            }
          }
        }
      }
      if (csiz != 0) {
        tctdbsetecode(tdb, 9999, "tctdb.c", 5040, "tctdbidxoutqgram");
        err = (_Bool)1;
      }
    }
    tmp___6 = tcbdbget3(db, (void const   *)(token), tsiz, & csiz);
    cbuf = (char const   *)tmp___6;
    if (cbuf) {
      while (csiz > 0) {
        pv___0 = cbuf;
        ok___0 = (_Bool)1;
        if ((int const   )*cbuf == 0) {
          cbuf ++;
          csiz --;
          while (1) {
            tsiz___1 = 0;
            _TC_base___2 = 1;
            _TC_i___2 = 0;
            while (1) {
              if ((int )*((signed char *)cbuf + _TC_i___2) >= 0) {
                tsiz___1 += (int )*((signed char *)cbuf + _TC_i___2) * _TC_base___2;
                break;
              }
              tsiz___1 += (_TC_base___2 * ((int )*((signed char *)cbuf + _TC_i___2) + 1)) * -1;
              _TC_base___2 <<= 7;
              _TC_i___2 ++;
            }
            step___2 = _TC_i___2 + 1;
            break;
          }
          cbuf += step___2;
          csiz -= step___2;
          if (tsiz___1 == pksiz) {
            tmp___7 = memcmp((void const   *)cbuf, (void const   *)pkbuf, (unsigned int )tsiz___1);
            if (! tmp___7) {
              ok___0 = (_Bool)0;
            }
          }
          cbuf += tsiz___1;
          csiz -= tsiz___1;
        } else {
          while (1) {
            tid___0 = 0LL;
            _TC_base___3 = 1LL;
            _TC_i___3 = 0;
            while (1) {
              if ((int )*((signed char *)cbuf + _TC_i___3) >= 0) {
                tid___0 += (long long )*((signed char *)cbuf + _TC_i___3) * _TC_base___3;
                break;
              }
              tid___0 += (_TC_base___3 * (long long )((int )*((signed char *)cbuf + _TC_i___3) + 1)) * -1LL;
              _TC_base___3 <<= 7;
              _TC_i___3 ++;
            }
            step___3 = _TC_i___3 + 1;
            break;
          }
          if ((unsigned long long )tid___0 == pkid) {
            ok___0 = (_Bool)0;
          }
          cbuf += step___3;
          csiz -= step___3;
        }
        if (csiz > 0) {
          while (1) {
            off___0 = 0;
            _TC_base___4 = 1;
            _TC_i___4 = 0;
            while (1) {
              if ((int )*((signed char *)cbuf + _TC_i___4) >= 0) {
                off___0 += (int )*((signed char *)cbuf + _TC_i___4) * _TC_base___4;
                break;
              }
              off___0 += (_TC_base___4 * ((int )*((signed char *)cbuf + _TC_i___4) + 1)) * -1;
              _TC_base___4 <<= 7;
              _TC_i___4 ++;
            }
            step___4 = _TC_i___4 + 1;
            break;
          }
          cbuf += step___4;
          csiz -= step___4;
          if (ok___0) {
            while (1) {
              TC_mysize___0 = cbuf - pv___0;
              TC_nsize___0 = (xstr->size + TC_mysize___0) + 1;
              if (xstr->asize < TC_nsize___0) {
                while (xstr->asize < TC_nsize___0) {
                  xstr->asize *= 2;
                  if (xstr->asize < TC_nsize___0) {
                    xstr->asize = TC_nsize___0;
                  }
                }
                while (1) {
                  tmp___9 = realloc((void *)xstr->ptr, (unsigned int )xstr->asize);
                  tmp___8 = (char *)tmp___9;
                  xstr->ptr = tmp___8;
                  if (! tmp___8) {
                    tcmyfatal("out of memory");
                  }
                  break;
                }
              }
              memcpy((void * __restrict  )(xstr->ptr + xstr->size), (void const   * __restrict  )pv___0,
                     (unsigned int )TC_mysize___0);
              xstr->size += TC_mysize___0;
              *(xstr->ptr + xstr->size) = (char )'\000';
              break;
            }
          }
        }
      }
      if (csiz != 0) {
        tctdbsetecode(tdb, 9999, "tctdb.c", 5076, "tctdbidxoutqgram");
        err = (_Bool)1;
      }
      tmp___11 = tcbdbout(db, (void const   *)(token), tsiz);
      if (! tmp___11) {
        tmp___10 = tcbdbecode(db);
        tctdbsetecode(tdb, tmp___10, "tctdb.c", 5080, "tctdbidxoutqgram");
        err = (_Bool)1;
      }
    }
    tcmapput(cc, (void const   *)(token), tsiz, (void const   *)xstr->ptr, xstr->size);
    i___1 ++;
  }
  while (1) {
    free((void *)ary);
    break;
  }
  tcxstrdel(xstr);
  tmp___12 = tcmapmsiz((TCMAP const   *)cc);
  if (tmp___12 > (unsigned long long )tdb->iccmax) {
    tmp___13 = tctdbidxsyncicc(tdb, idx, (_Bool)0);
    if (! tmp___13) {
      err = (_Bool)1;
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbidxsyncicc(TCTDB *tdb , TDBIDX *idx , _Bool all ) 
{ TCBDB *db ;
  TCMAP *cc ;
  int rnum ;
  _Bool err ;
  char const   **keys ;
  void *tmp ;
  int knum ;
  int64_t usiz ;
  uint64_t tmp___0 ;
  int64_t max ;
  double tmp___1 ;
  int64_t sum ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  int tmp___2 ;
  void const   *tmp___3 ;
  int i ;
  char const   *kbuf___0 ;
  int ksiz___0 ;
  size_t tmp___4 ;
  int vsiz___0 ;
  char const   *vbuf ;
  void const   *tmp___5 ;
  int tmp___6 ;
  _Bool tmp___7 ;

  {
  db = (TCBDB *)idx->db;
  cc = (TCMAP *)idx->cc;
  rnum = (int )cc->rnum;
  if (rnum < 1) {
    return ((_Bool)1);
  }
  err = (_Bool)0;
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*keys) * rnum));
    keys = (char const   **)tmp;
    if (! keys) {
      tcmyfatal("out of memory");
    }
    break;
  }
  knum = 0;
  tmp___0 = tcmapmsiz((TCMAP const   *)cc);
  usiz = (long long )(tmp___0 - (unsigned long long )((int )sizeof(void *) * 262139));
  if (all) {
    tmp___1 = (double )9223372036854775807LL;
  } else {
    tmp___1 = (double )usiz * tdb->iccsync;
  }
  max = (long long )tmp___1;
  sum = 0LL;
  tcmapiterinit(cc);
  while (1) {
    if (sum < max) {
      tmp___3 = tcmapiternext(cc, & ksiz);
      kbuf = (char const   *)tmp___3;
      if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
        break;
      }
    } else {
      break;
    }
    tcmapiterval((void const   *)kbuf, & vsiz);
    tmp___2 = knum;
    knum ++;
    *(keys + tmp___2) = kbuf;
    sum += (long long )((((int )sizeof(TCMAPREC ) + (int )sizeof(void *)) + ksiz) + vsiz);
  }
  qsort((void *)keys, (unsigned int )knum, (unsigned int )((int )sizeof(*keys)), (int (*)(void const   * ,
                                                                                          void const   * ))(& tctdbidxcmpkey));
  i = 0;
  while (i < knum) {
    kbuf___0 = *(keys + i);
    tmp___4 = strlen(kbuf___0);
    ksiz___0 = (int )tmp___4;
    tmp___5 = tcmapget((TCMAP const   *)cc, (void const   *)kbuf___0, ksiz___0, & vsiz___0);
    vbuf = (char const   *)tmp___5;
    if (vsiz___0 > 0) {
      tmp___7 = tcbdbputcat(db, (void const   *)kbuf___0, ksiz___0, (void const   *)vbuf,
                            vsiz___0);
      if (! tmp___7) {
        tmp___6 = tcbdbecode(db);
        tctdbsetecode(tdb, tmp___6, "tctdb.c", 5127, "tctdbidxsyncicc");
        err = (_Bool)1;
      }
    }
    tcmapout(cc, (void const   *)kbuf___0, ksiz___0);
    i ++;
  }
  while (1) {
    free((void *)keys);
    break;
  }
  return ((_Bool )(! err));
}
}
static int tctdbidxcmpkey(char const   **a , char const   **b ) 
{ unsigned char const   *ap ;
  unsigned char const   *bp ;
  int tmp ;
  int tmp___0 ;

  {
  ap = (unsigned char const   *)((unsigned char *)*a);
  bp = (unsigned char const   *)((unsigned char *)*b);
  while (1) {
    if ((int const   )*ap == 0) {
      if ((int const   )*bp == 0) {
        tmp = 0;
      } else {
        tmp = -1;
      }
      return (tmp);
    }
    if ((int const   )*bp == 0) {
      if ((int const   )*ap == 0) {
        tmp___0 = 0;
      } else {
        tmp___0 = 1;
      }
      return (tmp___0);
    }
    if ((int const   )*ap != (int const   )*bp) {
      return ((int )((int const   )*ap - (int const   )*bp));
    }
    ap ++;
    bp ++;
  }
  return (0);
}
}
static TCMAP *tctdbidxgetbytokens(TCTDB *tdb , TDBIDX *idx , TCLIST const   *tokens ,
                                  int op , TCXSTR *hint ) 
{ TCBDB *db ;
  TCMAP *cc ;
  int tnum ;
  TCMAP *res ;
  TCMAP *tmp ;
  int cnt___0 ;
  int i ;
  char const   *token ;
  int tsiz ;
  int onum ;
  TCMAP *wring ;
  TCMAP *tmp___0 ;
  TCMAP *tmp___1 ;
  int csiz ;
  char const   *cbuf ;
  void const   *tmp___2 ;
  int tsiz___0 ;
  int step ;
  int _TC_base ;
  int _TC_i ;
  int rsiz ;
  void const   *tmp___3 ;
  int64_t tid ;
  int step___0 ;
  long long _TC_base___0 ;
  int _TC_i___0 ;
  char pkbuf[32] ;
  int pksiz ;
  int tmp___4 ;
  int rsiz___0 ;
  void const   *tmp___5 ;
  void const   *tmp___6 ;
  int tsiz___1 ;
  int step___1 ;
  int _TC_base___1 ;
  int _TC_i___1 ;
  int rsiz___1 ;
  void const   *tmp___7 ;
  int64_t tid___0 ;
  int step___2 ;
  long long _TC_base___2 ;
  int _TC_i___2 ;
  char pkbuf___0[32] ;
  int pksiz___0 ;
  int tmp___8 ;
  int rsiz___2 ;
  void const   *tmp___9 ;

  {
  db = (TCBDB *)idx->db;
  cc = (TCMAP *)idx->cc;
  tnum = (int )tokens->num;
  tmp = tcmapnew();
  res = tmp;
  cnt___0 = 0;
  i = 0;
  while (i < tnum) {
    while (1) {
      token = (char const   *)(tokens->array + (i + (int )tokens->start))->ptr;
      tsiz = (tokens->array + (i + (int )tokens->start))->size;
      break;
    }
    if (tsiz < 1) {
      goto __Cont;
    }
    onum = 0;
    if (cnt___0 > 0) {
      if (op == 4) {
        tmp___0 = tcmapnew();
        tmp___1 = tmp___0;
      } else {
        tmp___1 = (TCMAP *)((void *)0);
      }
    } else {
      tmp___1 = (TCMAP *)((void *)0);
    }
    wring = tmp___1;
    tmp___2 = tcmapget((TCMAP const   *)cc, (void const   *)token, tsiz, & csiz);
    cbuf = (char const   *)tmp___2;
    if (cbuf) {
      while (csiz > 0) {
        if ((int const   )*cbuf == 0) {
          cbuf ++;
          csiz --;
          while (1) {
            tsiz___0 = 0;
            _TC_base = 1;
            _TC_i = 0;
            while (1) {
              if ((int )*((signed char *)cbuf + _TC_i) >= 0) {
                tsiz___0 += (int )*((signed char *)cbuf + _TC_i) * _TC_base;
                break;
              }
              tsiz___0 += (_TC_base * ((int )*((signed char *)cbuf + _TC_i) + 1)) * -1;
              _TC_base <<= 7;
              _TC_i ++;
            }
            step = _TC_i + 1;
            break;
          }
          cbuf += step;
          csiz -= step;
          if (cnt___0 < 1) {
            tcmapput(res, (void const   *)cbuf, tsiz___0, (void const   *)"", 0);
          } else {
            if (wring) {
              tmp___3 = tcmapget((TCMAP const   *)res, (void const   *)cbuf, tsiz___0,
                                 & rsiz);
              if (tmp___3) {
                tcmapput(wring, (void const   *)cbuf, tsiz___0, (void const   *)"",
                         0);
              }
            } else {
              tcmapput(res, (void const   *)cbuf, tsiz___0, (void const   *)"", 0);
            }
          }
          cbuf += tsiz___0;
          csiz -= tsiz___0;
        } else {
          while (1) {
            tid = 0LL;
            _TC_base___0 = 1LL;
            _TC_i___0 = 0;
            while (1) {
              if ((int )*((signed char *)cbuf + _TC_i___0) >= 0) {
                tid += (long long )*((signed char *)cbuf + _TC_i___0) * _TC_base___0;
                break;
              }
              tid += (_TC_base___0 * (long long )((int )*((signed char *)cbuf + _TC_i___0) + 1)) * -1LL;
              _TC_base___0 <<= 7;
              _TC_i___0 ++;
            }
            step___0 = _TC_i___0 + 1;
            break;
          }
          tmp___4 = sprintf((char * __restrict  )(pkbuf), (char const   * __restrict  )"%lld",
                            tid);
          pksiz = tmp___4;
          if (cnt___0 < 1) {
            tcmapput(res, (void const   *)(pkbuf), pksiz, (void const   *)"", 0);
          } else {
            if (wring) {
              tmp___5 = tcmapget((TCMAP const   *)res, (void const   *)(pkbuf), pksiz,
                                 & rsiz___0);
              if (tmp___5) {
                tcmapput(wring, (void const   *)(pkbuf), pksiz, (void const   *)"",
                         0);
              }
            } else {
              tcmapput(res, (void const   *)(pkbuf), pksiz, (void const   *)"", 0);
            }
          }
          cbuf += step___0;
          csiz -= step___0;
        }
        onum ++;
      }
    }
    tmp___6 = tcbdbget3(db, (void const   *)token, tsiz, & csiz);
    cbuf = (char const   *)tmp___6;
    if (cbuf) {
      while (csiz > 0) {
        if ((int const   )*cbuf == 0) {
          cbuf ++;
          csiz --;
          while (1) {
            tsiz___1 = 0;
            _TC_base___1 = 1;
            _TC_i___1 = 0;
            while (1) {
              if ((int )*((signed char *)cbuf + _TC_i___1) >= 0) {
                tsiz___1 += (int )*((signed char *)cbuf + _TC_i___1) * _TC_base___1;
                break;
              }
              tsiz___1 += (_TC_base___1 * ((int )*((signed char *)cbuf + _TC_i___1) + 1)) * -1;
              _TC_base___1 <<= 7;
              _TC_i___1 ++;
            }
            step___1 = _TC_i___1 + 1;
            break;
          }
          cbuf += step___1;
          csiz -= step___1;
          if (cnt___0 < 1) {
            tcmapput(res, (void const   *)cbuf, tsiz___1, (void const   *)"", 0);
          } else {
            if (wring) {
              tmp___7 = tcmapget((TCMAP const   *)res, (void const   *)cbuf, tsiz___1,
                                 & rsiz___1);
              if (tmp___7) {
                tcmapput(wring, (void const   *)cbuf, tsiz___1, (void const   *)"",
                         0);
              }
            } else {
              tcmapput(res, (void const   *)cbuf, tsiz___1, (void const   *)"", 0);
            }
          }
          cbuf += tsiz___1;
          csiz -= tsiz___1;
        } else {
          while (1) {
            tid___0 = 0LL;
            _TC_base___2 = 1LL;
            _TC_i___2 = 0;
            while (1) {
              if ((int )*((signed char *)cbuf + _TC_i___2) >= 0) {
                tid___0 += (long long )*((signed char *)cbuf + _TC_i___2) * _TC_base___2;
                break;
              }
              tid___0 += (_TC_base___2 * (long long )((int )*((signed char *)cbuf + _TC_i___2) + 1)) * -1LL;
              _TC_base___2 <<= 7;
              _TC_i___2 ++;
            }
            step___2 = _TC_i___2 + 1;
            break;
          }
          tmp___8 = sprintf((char * __restrict  )(pkbuf___0), (char const   * __restrict  )"%lld",
                            tid___0);
          pksiz___0 = tmp___8;
          if (cnt___0 < 1) {
            tcmapput(res, (void const   *)(pkbuf___0), pksiz___0, (void const   *)"",
                     0);
          } else {
            if (wring) {
              tmp___9 = tcmapget((TCMAP const   *)res, (void const   *)(pkbuf___0),
                                 pksiz___0, & rsiz___2);
              if (tmp___9) {
                tcmapput(wring, (void const   *)(pkbuf___0), pksiz___0, (void const   *)"",
                         0);
              }
            } else {
              tcmapput(res, (void const   *)(pkbuf___0), pksiz___0, (void const   *)"",
                       0);
            }
          }
          cbuf += step___2;
          csiz -= step___2;
        }
        onum ++;
      }
    }
    if (wring) {
      tcmapdel(res);
      res = wring;
    }
    tcxstrprintf(hint, "token occurrence: \"%s\" %d\n", token, onum);
    cnt___0 ++;
    __Cont: 
    i ++;
  }
  return (res);
}
}
static TCMAP *tctdbidxgetbyfts(TCTDB *tdb , TDBIDX *idx , TDBCOND *cond , TCXSTR *hint ) 
{ TDBFTSUNIT *ftsunits ;
  int ftsnum ;
  TCMAP *tmp ;
  TCMAP *tmp___0 ;
  TCMAP *res ;
  TCMAP *tmp___1 ;
  int i ;
  TDBFTSUNIT *ftsunit ;
  TCMAP *nres ;
  TCMAP *tmp___2 ;

  {
  ftsunits = (TDBFTSUNIT *)cond->ftsunits;
  ftsnum = cond->ftsnum;
  if (ftsnum < 1) {
    tmp = tcmapnew2(1U);
    return (tmp);
  }
  if (! (ftsunits + 0)->sign) {
    tmp___0 = tcmapnew2(1U);
    return (tmp___0);
  }
  tmp___1 = tcmapnew();
  res = tmp___1;
  tctdbidxgetbyftsunion(idx, (TCLIST const   *)ftsunits->tokens, (_Bool)1, (TCMAP *)((void *)0),
                        res, hint);
  i = 1;
  while (i < ftsnum) {
    ftsunit = ftsunits + i;
    if (ftsunit->sign) {
      tmp___2 = tcmapnew2((unsigned int )(res->rnum + 1ULL));
      nres = tmp___2;
      tctdbidxgetbyftsunion(idx, (TCLIST const   *)ftsunit->tokens, (_Bool)1, res,
                            nres, hint);
      tcmapdel(res);
      res = nres;
    } else {
      tctdbidxgetbyftsunion(idx, (TCLIST const   *)ftsunit->tokens, (_Bool)0, res,
                            (TCMAP *)((void *)0), hint);
    }
    i ++;
  }
  return (res);
}
}
static void tctdbidxgetbyftsunion(TDBIDX *idx , TCLIST const   *tokens , _Bool sign ,
                                  TCMAP *ores , TCMAP *nres , TCXSTR *hint ) 
{ TCBDB *db ;
  TCMAP *cc ;
  int tnum ;
  int i ;
  char const   *word ;
  int wsiz ;
  uint16_t *ary ;
  void *tmp ;
  int anum ;
  int j ;
  TDBFTSSTROCR *socrs ;
  void *tmp___0 ;
  int sonum ;
  int soanum ;
  int sobase ;
  TDBFTSNUMOCR *nocrs ;
  void *tmp___1 ;
  int nonum ;
  int noanum ;
  int nobase ;
  TCBITMAP *pkmap ;
  void *tmp___2 ;
  char token[10] ;
  uint16_t seq ;
  int j___0 ;
  int diff ;
  int tsiz ;
  size_t tmp___3 ;
  int csiz ;
  char const   *cbuf ;
  void const   *tmp___4 ;
  char const   *pkbuf ;
  int32_t pksiz ;
  int64_t pkid ;
  int step ;
  int _TC_base ;
  int _TC_i ;
  int step___0 ;
  long long _TC_base___0 ;
  int _TC_i___0 ;
  int off ;
  int step___1 ;
  int _TC_base___1 ;
  int _TC_i___1 ;
  unsigned int hash ;
  int k ;
  void *tmp___5 ;
  TDBFTSSTROCR *ocr ;
  unsigned int hash___0 ;
  void *tmp___6 ;
  TDBFTSNUMOCR *ocr___0 ;
  void const   *tmp___7 ;
  char const   *pkbuf___0 ;
  int32_t pksiz___0 ;
  int64_t pkid___0 ;
  int step___2 ;
  int _TC_base___2 ;
  int _TC_i___2 ;
  int step___3 ;
  long long _TC_base___3 ;
  int _TC_i___3 ;
  int off___0 ;
  int step___4 ;
  int _TC_base___4 ;
  int _TC_i___4 ;
  unsigned int hash___1 ;
  int k___0 ;
  void *tmp___8 ;
  TDBFTSSTROCR *ocr___1 ;
  unsigned int hash___2 ;
  void *tmp___9 ;
  TDBFTSNUMOCR *ocr___2 ;
  int flnum ;
  TCBITMAP *flmap ;
  void *tmp___10 ;
  int j___1 ;
  TDBFTSSTROCR *ocr___3 ;
  uint32_t hash___3 ;
  int wi ;
  int j___2 ;
  TDBFTSSTROCR *ocr___4 ;
  int rem ;
  uint32_t hash___4 ;
  int tmp___11 ;
  int j___3 ;
  int tmp___12 ;
  TDBFTSSTROCR *rocrs ;
  void *tmp___13 ;
  uint32_t *counts ;
  void *tmp___14 ;
  int j___4 ;
  int j___5 ;
  int j___6 ;
  int j___7 ;
  int num ;
  int num___0 ;
  int flnum___0 ;
  TCBITMAP *flmap___0 ;
  void *tmp___15 ;
  int j___8 ;
  TDBFTSNUMOCR *ocr___5 ;
  uint32_t hash___5 ;
  int wi___0 ;
  int j___9 ;
  TDBFTSNUMOCR *ocr___6 ;
  int rem___0 ;
  uint32_t hash___6 ;
  int tmp___16 ;
  int j___10 ;
  int tmp___17 ;
  TDBFTSNUMOCR *rocrs___0 ;
  void *tmp___18 ;
  uint32_t *counts___0 ;
  void *tmp___19 ;
  int j___11 ;
  int j___12 ;
  int j___13 ;
  int j___14 ;
  int num___1 ;
  int num___2 ;
  int rem___1 ;
  int onum ;
  int ri ;
  TDBFTSSTROCR *ocr___7 ;
  char const   *pkbuf___1 ;
  int32_t pksiz___1 ;
  int32_t off___1 ;
  uint16_t seq___0 ;
  int j___15 ;
  TDBFTSSTROCR *tocr ;
  int tmp___20 ;
  int rsiz ;
  void const   *tmp___21 ;
  int tmp___22 ;
  TDBFTSNUMOCR *ocr___8 ;
  int64_t pkid___1 ;
  int32_t off___2 ;
  uint16_t seq___1 ;
  int j___16 ;
  TDBFTSNUMOCR *tocr___0 ;
  char pkbuf___2[32] ;
  int pksiz___2 ;
  int tmp___23 ;
  int rsiz___0 ;
  void const   *tmp___24 ;
  int onum___0 ;
  TCMAP *uniq ;
  TCMAP *tmp___25 ;
  TCMAP *tmp___26 ;
  char const   *kbuf ;
  int ksiz ;
  int tmp___27 ;
  int csiz___0 ;
  char const   *cbuf___0 ;
  void const   *tmp___28 ;
  char const   *pkbuf___3 ;
  int32_t pksiz___3 ;
  int64_t pkid___2 ;
  int step___5 ;
  int _TC_base___5 ;
  int _TC_i___5 ;
  int step___6 ;
  long long _TC_base___6 ;
  int _TC_i___6 ;
  int off___3 ;
  int step___7 ;
  int _TC_base___7 ;
  int _TC_i___7 ;
  int rsiz___1 ;
  void const   *tmp___29 ;
  _Bool tmp___30 ;
  char numbuf[32] ;
  int pksiz___4 ;
  int tmp___31 ;
  int rsiz___2 ;
  void const   *tmp___32 ;
  _Bool tmp___33 ;
  void const   *tmp___34 ;
  BDBCUR *cur ;
  BDBCUR *tmp___35 ;
  TCXSTR *key ;
  TCXSTR *tmp___36 ;
  TCXSTR *val ;
  TCXSTR *tmp___37 ;
  char const   *kbuf___0 ;
  int ksiz___0 ;
  int tmp___38 ;
  char const   *cbuf___1 ;
  int csiz___1 ;
  char const   *pkbuf___4 ;
  int32_t pksiz___5 ;
  int64_t pkid___3 ;
  int step___8 ;
  int _TC_base___8 ;
  int _TC_i___8 ;
  int step___9 ;
  long long _TC_base___9 ;
  int _TC_i___9 ;
  int off___4 ;
  int step___10 ;
  int _TC_base___10 ;
  int _TC_i___10 ;
  int rsiz___3 ;
  void const   *tmp___39 ;
  _Bool tmp___40 ;
  char numbuf___0[32] ;
  int pksiz___6 ;
  int tmp___41 ;
  int rsiz___4 ;
  void const   *tmp___42 ;
  _Bool tmp___43 ;
  _Bool tmp___44 ;
  uint64_t tmp___45 ;
  int tmp___46 ;

  {
  db = (TCBDB *)idx->db;
  cc = (TCMAP *)idx->cc;
  tnum = (int )tokens->num;
  i = 0;
  while (i < tnum) {
    while (1) {
      word = (char const   *)(tokens->array + (i + (int )tokens->start))->ptr;
      wsiz = (tokens->array + (i + (int )tokens->start))->size;
      break;
    }
    while (1) {
      tmp = malloc((unsigned int )((int )sizeof(*ary) * (wsiz + 3)));
      ary = (uint16_t *)tmp;
      if (! ary) {
        tcmyfatal("out of memory");
      }
      break;
    }
    tcstrutftoucs(word, ary, & anum);
    j = 0;
    while (j < 3) {
      *(ary + (anum + j)) = (unsigned short)0;
      j ++;
    }
    if (anum >= 3) {
      while (1) {
        tmp___0 = malloc((unsigned int )(8192 * (int )sizeof(*socrs)));
        socrs = (TDBFTSSTROCR *)tmp___0;
        if (! socrs) {
          tcmyfatal("out of memory");
        }
        break;
      }
      sonum = 0;
      soanum = 8192;
      sobase = 0;
      while (1) {
        tmp___1 = malloc((unsigned int )(8192 * (int )sizeof(*nocrs)));
        nocrs = (TDBFTSNUMOCR *)tmp___1;
        if (! nocrs) {
          tcmyfatal("out of memory");
        }
        break;
      }
      nonum = 0;
      noanum = 8192;
      nobase = 0;
      tmp___2 = tccalloc((unsigned int )((524287 >> 3) + 1), 1U);
      pkmap = (TCBITMAP *)tmp___2;
      seq = (unsigned short)0;
      j___0 = 0;
      while (j___0 < anum) {
        sobase = sonum;
        nobase = nonum;
        diff = (anum - j___0) - 3;
        if (diff < 0) {
          j___0 += diff;
          diff = - diff;
        } else {
          diff = 0;
        }
        tcstrucstoutf((uint16_t const   *)(ary + j___0), 3, token);
        tmp___3 = strlen((char const   *)(token));
        tsiz = (int )tmp___3;
        tmp___4 = tcmapget((TCMAP const   *)cc, (void const   *)(token), tsiz, & csiz);
        cbuf = (char const   *)tmp___4;
        if (cbuf) {
          while (csiz > 0) {
            pkbuf = (char const   *)((void *)0);
            pksiz = 0;
            pkid = 0LL;
            if ((int const   )*cbuf == 0) {
              cbuf ++;
              csiz --;
              while (1) {
                pksiz = 0;
                _TC_base = 1;
                _TC_i = 0;
                while (1) {
                  if ((int )*((signed char *)cbuf + _TC_i) >= 0) {
                    pksiz += (int )*((signed char *)cbuf + _TC_i) * _TC_base;
                    break;
                  }
                  pksiz += (_TC_base * ((int )*((signed char *)cbuf + _TC_i) + 1)) * -1;
                  _TC_base <<= 7;
                  _TC_i ++;
                }
                step = _TC_i + 1;
                break;
              }
              cbuf += step;
              csiz -= step;
              pkbuf = cbuf;
              cbuf += pksiz;
              csiz -= pksiz;
            } else {
              while (1) {
                pkid = 0LL;
                _TC_base___0 = 1LL;
                _TC_i___0 = 0;
                while (1) {
                  if ((int )*((signed char *)cbuf + _TC_i___0) >= 0) {
                    pkid += (long long )*((signed char *)cbuf + _TC_i___0) * _TC_base___0;
                    break;
                  }
                  pkid += (_TC_base___0 * (long long )((int )*((signed char *)cbuf + _TC_i___0) + 1)) * -1LL;
                  _TC_base___0 <<= 7;
                  _TC_i___0 ++;
                }
                step___0 = _TC_i___0 + 1;
                break;
              }
              cbuf += step___0;
              csiz -= step___0;
            }
            if (csiz > 0) {
              while (1) {
                off = 0;
                _TC_base___1 = 1;
                _TC_i___1 = 0;
                while (1) {
                  if ((int )*((signed char *)cbuf + _TC_i___1) >= 0) {
                    off += (int )*((signed char *)cbuf + _TC_i___1) * _TC_base___1;
                    break;
                  }
                  off += (_TC_base___1 * ((int )*((signed char *)cbuf + _TC_i___1) + 1)) * -1;
                  _TC_base___1 <<= 7;
                  _TC_i___1 ++;
                }
                step___1 = _TC_i___1 + 1;
                break;
              }
              cbuf += step___1;
              csiz -= step___1;
              off += diff;
              if (pkbuf) {
                hash = 19780211U;
                k = 0;
                while (k < pksiz) {
                  hash = hash * 37U + (unsigned int )*((unsigned char *)pkbuf + k);
                  k ++;
                }
                hash %= 524287U;
                if (j___0 == 0) {
                  goto _L;
                } else {
                  if ((int )*(pkmap + (hash >> 3)) & (1 << (hash & 7U))) {
                    _L: 
                    if (sonum >= soanum) {
                      soanum *= 2;
                      while (1) {
                        tmp___5 = realloc((void *)socrs, (unsigned int )(soanum * (int )sizeof(*socrs)));
                        socrs = (TDBFTSSTROCR *)tmp___5;
                        if (! socrs) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    ocr = socrs + sonum;
                    ocr->pkbuf = pkbuf;
                    ocr->pksiz = pksiz;
                    ocr->off = off;
                    ocr->seq = seq;
                    ocr->hash = (unsigned short )hash;
                    sonum ++;
                    if (j___0 == 0) {
                      while (1) {
                        *(pkmap + (hash >> 3)) = (unsigned char )((int )*(pkmap + (hash >> 3)) | (1 << (hash & 7U)));
                        break;
                      }
                    }
                  }
                }
              } else {
                hash___0 = (unsigned int )(pkid % 524287LL);
                if (j___0 == 0) {
                  goto _L___0;
                } else {
                  if ((int )*(pkmap + (hash___0 >> 3)) & (1 << (hash___0 & 7U))) {
                    _L___0: 
                    if (nonum >= noanum) {
                      noanum *= 2;
                      while (1) {
                        tmp___6 = realloc((void *)nocrs, (unsigned int )(noanum * (int )sizeof(*nocrs)));
                        nocrs = (TDBFTSNUMOCR *)tmp___6;
                        if (! nocrs) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    ocr___0 = nocrs + nonum;
                    ocr___0->pkid = pkid;
                    ocr___0->off = off;
                    ocr___0->seq = seq;
                    ocr___0->hash = (unsigned short )hash___0;
                    nonum ++;
                    if (j___0 == 0) {
                      while (1) {
                        *(pkmap + (hash___0 >> 3)) = (unsigned char )((int )*(pkmap + (hash___0 >> 3)) | (1 << (hash___0 & 7U)));
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        tmp___7 = tcbdbget3(db, (void const   *)(token), tsiz, & csiz);
        cbuf = (char const   *)tmp___7;
        if (cbuf) {
          while (csiz > 0) {
            pkbuf___0 = (char const   *)((void *)0);
            pksiz___0 = 0;
            pkid___0 = 0LL;
            if ((int const   )*cbuf == 0) {
              cbuf ++;
              csiz --;
              while (1) {
                pksiz___0 = 0;
                _TC_base___2 = 1;
                _TC_i___2 = 0;
                while (1) {
                  if ((int )*((signed char *)cbuf + _TC_i___2) >= 0) {
                    pksiz___0 += (int )*((signed char *)cbuf + _TC_i___2) * _TC_base___2;
                    break;
                  }
                  pksiz___0 += (_TC_base___2 * ((int )*((signed char *)cbuf + _TC_i___2) + 1)) * -1;
                  _TC_base___2 <<= 7;
                  _TC_i___2 ++;
                }
                step___2 = _TC_i___2 + 1;
                break;
              }
              cbuf += step___2;
              csiz -= step___2;
              pkbuf___0 = cbuf;
              cbuf += pksiz___0;
              csiz -= pksiz___0;
            } else {
              while (1) {
                pkid___0 = 0LL;
                _TC_base___3 = 1LL;
                _TC_i___3 = 0;
                while (1) {
                  if ((int )*((signed char *)cbuf + _TC_i___3) >= 0) {
                    pkid___0 += (long long )*((signed char *)cbuf + _TC_i___3) * _TC_base___3;
                    break;
                  }
                  pkid___0 += (_TC_base___3 * (long long )((int )*((signed char *)cbuf + _TC_i___3) + 1)) * -1LL;
                  _TC_base___3 <<= 7;
                  _TC_i___3 ++;
                }
                step___3 = _TC_i___3 + 1;
                break;
              }
              cbuf += step___3;
              csiz -= step___3;
            }
            if (csiz > 0) {
              while (1) {
                off___0 = 0;
                _TC_base___4 = 1;
                _TC_i___4 = 0;
                while (1) {
                  if ((int )*((signed char *)cbuf + _TC_i___4) >= 0) {
                    off___0 += (int )*((signed char *)cbuf + _TC_i___4) * _TC_base___4;
                    break;
                  }
                  off___0 += (_TC_base___4 * ((int )*((signed char *)cbuf + _TC_i___4) + 1)) * -1;
                  _TC_base___4 <<= 7;
                  _TC_i___4 ++;
                }
                step___4 = _TC_i___4 + 1;
                break;
              }
              cbuf += step___4;
              csiz -= step___4;
              off___0 += diff;
              if (pkbuf___0) {
                hash___1 = 19780211U;
                k___0 = 0;
                while (k___0 < pksiz___0) {
                  hash___1 = hash___1 * 37U + (unsigned int )*((unsigned char *)pkbuf___0 + k___0);
                  k___0 ++;
                }
                hash___1 %= 524287U;
                if (j___0 == 0) {
                  goto _L___1;
                } else {
                  if ((int )*(pkmap + (hash___1 >> 3)) & (1 << (hash___1 & 7U))) {
                    _L___1: 
                    if (sonum >= soanum) {
                      soanum *= 2;
                      while (1) {
                        tmp___8 = realloc((void *)socrs, (unsigned int )(soanum * (int )sizeof(*socrs)));
                        socrs = (TDBFTSSTROCR *)tmp___8;
                        if (! socrs) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    ocr___1 = socrs + sonum;
                    ocr___1->pkbuf = pkbuf___0;
                    ocr___1->pksiz = pksiz___0;
                    ocr___1->off = off___0;
                    ocr___1->seq = seq;
                    ocr___1->hash = (unsigned short )hash___1;
                    sonum ++;
                    if (j___0 == 0) {
                      while (1) {
                        *(pkmap + (hash___1 >> 3)) = (unsigned char )((int )*(pkmap + (hash___1 >> 3)) | (1 << (hash___1 & 7U)));
                        break;
                      }
                    }
                  }
                }
              } else {
                hash___2 = (unsigned int )(pkid___0 % 524287LL);
                if (j___0 == 0) {
                  goto _L___2;
                } else {
                  if ((int )*(pkmap + (hash___2 >> 3)) & (1 << (hash___2 & 7U))) {
                    _L___2: 
                    if (nonum >= noanum) {
                      noanum *= 2;
                      while (1) {
                        tmp___9 = realloc((void *)nocrs, (unsigned int )(noanum * (int )sizeof(*nocrs)));
                        nocrs = (TDBFTSNUMOCR *)tmp___9;
                        if (! nocrs) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    ocr___2 = nocrs + nonum;
                    ocr___2->pkid = pkid___0;
                    ocr___2->off = off___0;
                    ocr___2->seq = seq;
                    ocr___2->hash = (unsigned short )hash___2;
                    nonum ++;
                    if (j___0 == 0) {
                      while (1) {
                        *(pkmap + (hash___2 >> 3)) = (unsigned char )((int )*(pkmap + (hash___2 >> 3)) | (1 << (hash___2 & 7U)));
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        seq = (unsigned short )((int )seq + 1);
        if (sonum <= sobase) {
          if (nonum <= nobase) {
            sonum = 0;
            nonum = 0;
            break;
          }
        }
        j___0 += 3;
      }
      while (1) {
        tcfree((void *)pkmap);
        break;
      }
      if ((int )seq > 1) {
        if (sonum > 65535) {
          flnum = sonum * 16 + 1;
          tmp___10 = tccalloc((unsigned int )((flnum >> 3) + 1), 1U);
          flmap = (TCBITMAP *)tmp___10;
          j___1 = sobase;
          while (j___1 < sonum) {
            ocr___3 = socrs + j___1;
            hash___3 = (((unsigned int )ocr___3->off << 16) | (unsigned int )ocr___3->hash) % (unsigned int )flnum;
            while (1) {
              *(flmap + (hash___3 >> 3)) = (unsigned char )((int )*(flmap + (hash___3 >> 3)) | (1 << (hash___3 & 7U)));
              break;
            }
            j___1 ++;
          }
          wi = 0;
          j___2 = 0;
          while (j___2 < sobase) {
            ocr___4 = socrs + j___2;
            rem = (((int )seq - (int )ocr___4->seq) - 1) * 3;
            hash___4 = (((unsigned int )(ocr___4->off + rem) << 16) | (unsigned int )ocr___4->hash) % (unsigned int )flnum;
            if ((int )*(flmap + (hash___4 >> 3)) & (1 << (hash___4 & 7U))) {
              tmp___11 = wi;
              wi ++;
              *(socrs + tmp___11) = *ocr___4;
            }
            j___2 ++;
          }
          j___3 = sobase;
          while (j___3 < sonum) {
            tmp___12 = wi;
            wi ++;
            *(socrs + tmp___12) = *(socrs + j___3);
            j___3 ++;
          }
          sonum = wi;
          while (1) {
            tcfree((void *)flmap);
            break;
          }
        }
        if (sonum > 131070) {
          while (1) {
            tmp___13 = malloc((unsigned int )((int )sizeof(*rocrs) * sonum));
            rocrs = (TDBFTSSTROCR *)tmp___13;
            if (! rocrs) {
              tcmyfatal("out of memory");
            }
            break;
          }
          while (1) {
            tmp___14 = calloc((unsigned int )((int )sizeof(*counts)), 65536U);
            counts = (uint32_t *)tmp___14;
            if (! counts) {
              tcmyfatal("out of memory");
            }
            break;
          }
          j___4 = 0;
          while (j___4 < sonum) {
            (*(counts + (int )(socrs + j___4)->hash)) ++;
            j___4 ++;
          }
          j___5 = 0;
          while (j___5 < 65535) {
            *(counts + (j___5 + 1)) += *(counts + j___5);
            j___5 ++;
          }
          j___6 = sonum - 1;
          while (j___6 >= 0) {
            (*(counts + (int )(socrs + j___6)->hash)) --;
            *(rocrs + *(counts + (int )(socrs + j___6)->hash)) = *(socrs + j___6);
            j___6 --;
          }
          j___7 = 0;
          while (j___7 < 65535) {
            num = (int )(*(counts + (j___7 + 1)) - *(counts + j___7));
            if (num > 1) {
              qsort((void *)(rocrs + *(counts + j___7)), (unsigned int )num, (unsigned int )((int )sizeof(*rocrs)),
                    (int (*)(void const   * , void const   * ))(& tctdbidxftscmpstrocr));
            }
            j___7 ++;
          }
          num___0 = (int )((unsigned int )sonum - *(counts + 65535));
          if (num___0 > 1) {
            qsort((void *)(rocrs + *(counts + 65535)), (unsigned int )num___0, (unsigned int )((int )sizeof(*rocrs)),
                  (int (*)(void const   * , void const   * ))(& tctdbidxftscmpstrocr));
          }
          while (1) {
            free((void *)counts);
            break;
          }
          while (1) {
            free((void *)socrs);
            break;
          }
          socrs = rocrs;
        } else {
          if (sonum > 1) {
            qsort((void *)socrs, (unsigned int )sonum, (unsigned int )((int )sizeof(*socrs)),
                  (int (*)(void const   * , void const   * ))(& tctdbidxftscmpstrocr));
          }
        }
        if (nonum > 65535) {
          flnum___0 = nonum * 16 + 1;
          tmp___15 = tccalloc((unsigned int )((flnum___0 >> 3) + 1), 1U);
          flmap___0 = (TCBITMAP *)tmp___15;
          j___8 = nobase;
          while (j___8 < nonum) {
            ocr___5 = nocrs + j___8;
            hash___5 = (((unsigned int )ocr___5->off << 16) | (unsigned int )ocr___5->hash) % (unsigned int )flnum___0;
            while (1) {
              *(flmap___0 + (hash___5 >> 3)) = (unsigned char )((int )*(flmap___0 + (hash___5 >> 3)) | (1 << (hash___5 & 7U)));
              break;
            }
            j___8 ++;
          }
          wi___0 = 0;
          j___9 = 0;
          while (j___9 < nobase) {
            ocr___6 = nocrs + j___9;
            rem___0 = (((int )seq - (int )ocr___6->seq) - 1) * 3;
            hash___6 = (((unsigned int )(ocr___6->off + rem___0) << 16) | (unsigned int )ocr___6->hash) % (unsigned int )flnum___0;
            if ((int )*(flmap___0 + (hash___6 >> 3)) & (1 << (hash___6 & 7U))) {
              tmp___16 = wi___0;
              wi___0 ++;
              *(nocrs + tmp___16) = *ocr___6;
            }
            j___9 ++;
          }
          j___10 = nobase;
          while (j___10 < nonum) {
            tmp___17 = wi___0;
            wi___0 ++;
            *(nocrs + tmp___17) = *(nocrs + j___10);
            j___10 ++;
          }
          nonum = wi___0;
          while (1) {
            tcfree((void *)flmap___0);
            break;
          }
        }
        if (nonum > 131070) {
          while (1) {
            tmp___18 = malloc((unsigned int )((int )sizeof(*rocrs___0) * nonum));
            rocrs___0 = (TDBFTSNUMOCR *)tmp___18;
            if (! rocrs___0) {
              tcmyfatal("out of memory");
            }
            break;
          }
          while (1) {
            tmp___19 = calloc((unsigned int )((int )sizeof(*counts___0)), 65536U);
            counts___0 = (uint32_t *)tmp___19;
            if (! counts___0) {
              tcmyfatal("out of memory");
            }
            break;
          }
          j___11 = 0;
          while (j___11 < nonum) {
            (*(counts___0 + (int )(nocrs + j___11)->hash)) ++;
            j___11 ++;
          }
          j___12 = 0;
          while (j___12 < 65535) {
            *(counts___0 + (j___12 + 1)) += *(counts___0 + j___12);
            j___12 ++;
          }
          j___13 = nonum - 1;
          while (j___13 >= 0) {
            (*(counts___0 + (int )(nocrs + j___13)->hash)) --;
            *(rocrs___0 + *(counts___0 + (int )(nocrs + j___13)->hash)) = *(nocrs + j___13);
            j___13 --;
          }
          j___14 = 0;
          while (j___14 < 65535) {
            num___1 = (int )(*(counts___0 + (j___14 + 1)) - *(counts___0 + j___14));
            if (num___1 > 1) {
              qsort((void *)(rocrs___0 + *(counts___0 + j___14)), (unsigned int )num___1,
                    (unsigned int )((int )sizeof(*rocrs___0)), (int (*)(void const   * ,
                                                                        void const   * ))(& tctdbidxftscmpnumocr));
            }
            j___14 ++;
          }
          num___2 = (int )((unsigned int )nonum - *(counts___0 + 65535));
          if (num___2 > 1) {
            qsort((void *)(rocrs___0 + *(counts___0 + 65535)), (unsigned int )num___2,
                  (unsigned int )((int )sizeof(*rocrs___0)), (int (*)(void const   * ,
                                                                      void const   * ))(& tctdbidxftscmpnumocr));
          }
          while (1) {
            free((void *)counts___0);
            break;
          }
          while (1) {
            free((void *)nocrs);
            break;
          }
          nocrs = rocrs___0;
        } else {
          if (nonum > 1) {
            qsort((void *)nocrs, (unsigned int )nonum, (unsigned int )((int )sizeof(*nocrs)),
                  (int (*)(void const   * , void const   * ))(& tctdbidxftscmpnumocr));
          }
        }
      }
      rem___1 = ((int )seq - 1) * 3;
      onum = 0;
      ri = 0;
      while (ri < sonum) {
        ocr___7 = socrs + ri;
        ri ++;
        if ((int )ocr___7->seq > 0) {
          continue;
        }
        pkbuf___1 = ocr___7->pkbuf;
        pksiz___1 = ocr___7->pksiz;
        off___1 = ocr___7->off;
        seq___0 = (unsigned short)1;
        j___15 = ri;
        while (j___15 < sonum) {
          tocr = socrs + j___15;
          if (! tocr->pkbuf) {
            break;
          } else {
            if (tocr->pksiz != pksiz___1) {
              break;
            } else {
              tmp___20 = memcmp((void const   *)tocr->pkbuf, (void const   *)pkbuf___1,
                                (unsigned int )pksiz___1);
              if (tmp___20) {
                break;
              } else {
                if (tocr->off > off___1 + 3) {
                  break;
                }
              }
            }
          }
          if ((int )tocr->seq == (int )seq___0) {
            if (tocr->off == off___1 + 3) {
              off___1 = tocr->off;
              seq___0 = (unsigned short )((int )seq___0 + 1);
            }
          }
          j___15 ++;
        }
        if (off___1 == ocr___7->off + rem___1) {
          onum ++;
          if (ores) {
            tmp___21 = tcmapget((TCMAP const   *)ores, (void const   *)pkbuf___1,
                                pksiz___1, & rsiz);
            if (tmp___21) {
              if (sign) {
                tcmapputkeep(nres, (void const   *)pkbuf___1, pksiz___1, (void const   *)"",
                             0);
              } else {
                tcmapout(ores, (void const   *)pkbuf___1, pksiz___1);
              }
            }
          } else {
            tcmapputkeep(nres, (void const   *)pkbuf___1, pksiz___1, (void const   *)"",
                         0);
          }
          while (ri < sonum) {
            ocr___7 = socrs + ri;
            if (! ocr___7->pkbuf) {
              break;
            } else {
              if (ocr___7->pksiz != pksiz___1) {
                break;
              } else {
                tmp___22 = memcmp((void const   *)ocr___7->pkbuf, (void const   *)pkbuf___1,
                                  (unsigned int )pksiz___1);
                if (tmp___22) {
                  break;
                }
              }
            }
            ri ++;
          }
        }
      }
      ri = 0;
      while (ri < nonum) {
        ocr___8 = nocrs + ri;
        ri ++;
        if ((int )ocr___8->seq > 0) {
          continue;
        }
        pkid___1 = ocr___8->pkid;
        off___2 = ocr___8->off;
        seq___1 = (unsigned short)1;
        j___16 = ri;
        while (j___16 < nonum) {
          tocr___0 = nocrs + j___16;
          if (tocr___0->pkid != pkid___1) {
            break;
          } else {
            if (tocr___0->off > off___2 + 3) {
              break;
            }
          }
          if ((int )tocr___0->seq == (int )seq___1) {
            if (tocr___0->off == off___2 + 3) {
              off___2 = tocr___0->off;
              seq___1 = (unsigned short )((int )seq___1 + 1);
            }
          }
          j___16 ++;
        }
        if (off___2 == ocr___8->off + rem___1) {
          onum ++;
          tmp___23 = sprintf((char * __restrict  )(pkbuf___2), (char const   * __restrict  )"%lld",
                             pkid___1);
          pksiz___2 = tmp___23;
          if (ores) {
            tmp___24 = tcmapget((TCMAP const   *)ores, (void const   *)(pkbuf___2),
                                pksiz___2, & rsiz___0);
            if (tmp___24) {
              if (sign) {
                tcmapputkeep(nres, (void const   *)(pkbuf___2), pksiz___2, (void const   *)"",
                             0);
              } else {
                tcmapout(ores, (void const   *)(pkbuf___2), pksiz___2);
              }
            }
          } else {
            tcmapputkeep(nres, (void const   *)(pkbuf___2), pksiz___2, (void const   *)"",
                         0);
          }
          while (1) {
            if (ri < nonum) {
              if (! ((nocrs + ri)->pkid == pkid___1)) {
                break;
              }
            } else {
              break;
            }
            ri ++;
          }
        }
      }
      tcxstrprintf(hint, "token occurrence: \"%s\" %d\n", word, onum);
      while (1) {
        free((void *)nocrs);
        break;
      }
      while (1) {
        free((void *)socrs);
        break;
      }
    } else {
      onum___0 = 0;
      if (i > 0) {
        tmp___25 = tcmapnew2(65535U);
        tmp___26 = tmp___25;
      } else {
        if (ores) {
          tmp___25 = tcmapnew2(65535U);
          tmp___26 = tmp___25;
        } else {
          tmp___26 = (TCMAP *)((void *)0);
        }
      }
      uniq = tmp___26;
      tcmapiterinit(cc);
      while (1) {
        tmp___34 = tcmapiternext(cc, & ksiz);
        kbuf = (char const   *)tmp___34;
        if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
          break;
        }
        if (ksiz < wsiz) {
          continue;
        } else {
          tmp___27 = memcmp((void const   *)kbuf, (void const   *)word, (unsigned int )wsiz);
          if (tmp___27) {
            continue;
          }
        }
        tmp___28 = tcmapiterval((void const   *)kbuf, & csiz___0);
        cbuf___0 = (char const   *)tmp___28;
        while (csiz___0 > 0) {
          pkbuf___3 = (char const   *)((void *)0);
          pksiz___3 = 0;
          pkid___2 = 0LL;
          if ((int const   )*cbuf___0 == 0) {
            cbuf___0 ++;
            csiz___0 --;
            while (1) {
              pksiz___3 = 0;
              _TC_base___5 = 1;
              _TC_i___5 = 0;
              while (1) {
                if ((int )*((signed char *)cbuf___0 + _TC_i___5) >= 0) {
                  pksiz___3 += (int )*((signed char *)cbuf___0 + _TC_i___5) * _TC_base___5;
                  break;
                }
                pksiz___3 += (_TC_base___5 * ((int )*((signed char *)cbuf___0 + _TC_i___5) + 1)) * -1;
                _TC_base___5 <<= 7;
                _TC_i___5 ++;
              }
              step___5 = _TC_i___5 + 1;
              break;
            }
            cbuf___0 += step___5;
            csiz___0 -= step___5;
            pkbuf___3 = cbuf___0;
            cbuf___0 += pksiz___3;
            csiz___0 -= pksiz___3;
          } else {
            while (1) {
              pkid___2 = 0LL;
              _TC_base___6 = 1LL;
              _TC_i___6 = 0;
              while (1) {
                if ((int )*((signed char *)cbuf___0 + _TC_i___6) >= 0) {
                  pkid___2 += (long long )*((signed char *)cbuf___0 + _TC_i___6) * _TC_base___6;
                  break;
                }
                pkid___2 += (_TC_base___6 * (long long )((int )*((signed char *)cbuf___0 + _TC_i___6) + 1)) * -1LL;
                _TC_base___6 <<= 7;
                _TC_i___6 ++;
              }
              step___6 = _TC_i___6 + 1;
              break;
            }
            cbuf___0 += step___6;
            csiz___0 -= step___6;
          }
          if (csiz___0 > 0) {
            while (1) {
              off___3 = 0;
              _TC_base___7 = 1;
              _TC_i___7 = 0;
              while (1) {
                if ((int )*((signed char *)cbuf___0 + _TC_i___7) >= 0) {
                  off___3 += (int )*((signed char *)cbuf___0 + _TC_i___7) * _TC_base___7;
                  break;
                }
                off___3 += (_TC_base___7 * ((int )*((signed char *)cbuf___0 + _TC_i___7) + 1)) * -1;
                _TC_base___7 <<= 7;
                _TC_i___7 ++;
              }
              step___7 = _TC_i___7 + 1;
              break;
            }
            cbuf___0 += step___7;
            csiz___0 -= step___7;
            if (pkbuf___3) {
              if (ores) {
                tmp___29 = tcmapget((TCMAP const   *)ores, (void const   *)pkbuf___3,
                                    pksiz___3, & rsiz___1);
                if (tmp___29) {
                  if (sign) {
                    tcmapputkeep(nres, (void const   *)pkbuf___3, pksiz___3, (void const   *)"",
                                 0);
                  } else {
                    tcmapout(ores, (void const   *)pkbuf___3, pksiz___3);
                  }
                }
              } else {
                tmp___30 = tcmapputkeep(nres, (void const   *)pkbuf___3, pksiz___3,
                                        (void const   *)"", 0);
                if (tmp___30) {
                  onum___0 ++;
                }
              }
              if (uniq) {
                tcmapputkeep(uniq, (void const   *)pkbuf___3, pksiz___3, (void const   *)"",
                             0);
              }
            } else {
              tmp___31 = sprintf((char * __restrict  )(numbuf), (char const   * __restrict  )"%lld",
                                 pkid___2);
              pksiz___4 = tmp___31;
              if (ores) {
                tmp___32 = tcmapget((TCMAP const   *)ores, (void const   *)(numbuf),
                                    pksiz___4, & rsiz___2);
                if (tmp___32) {
                  if (sign) {
                    tcmapputkeep(nres, (void const   *)(numbuf), pksiz___4, (void const   *)"",
                                 0);
                  } else {
                    tcmapout(ores, (void const   *)(numbuf), pksiz___4);
                  }
                }
              } else {
                tmp___33 = tcmapputkeep(nres, (void const   *)(numbuf), pksiz___4,
                                        (void const   *)"", 0);
                if (tmp___33) {
                  onum___0 ++;
                }
              }
              if (uniq) {
                tcmapputkeep(uniq, (void const   *)(numbuf), pksiz___4, (void const   *)"",
                             0);
              }
            }
          }
        }
      }
      tmp___35 = tcbdbcurnew(db);
      cur = tmp___35;
      tcbdbcurjump(cur, (void const   *)word, wsiz);
      tmp___36 = tcxstrnew();
      key = tmp___36;
      tmp___37 = tcxstrnew();
      val = tmp___37;
      while (1) {
        tmp___44 = tcbdbcurrec(cur, key, val);
        if (! tmp___44) {
          break;
        }
        kbuf___0 = (char const   *)key->ptr;
        ksiz___0 = key->size;
        if (ksiz___0 < wsiz) {
          break;
        } else {
          tmp___38 = memcmp((void const   *)kbuf___0, (void const   *)word, (unsigned int )wsiz);
          if (tmp___38) {
            break;
          }
        }
        cbuf___1 = (char const   *)val->ptr;
        csiz___1 = val->size;
        while (csiz___1 > 0) {
          pkbuf___4 = (char const   *)((void *)0);
          pksiz___5 = 0;
          pkid___3 = 0LL;
          if ((int const   )*cbuf___1 == 0) {
            cbuf___1 ++;
            csiz___1 --;
            while (1) {
              pksiz___5 = 0;
              _TC_base___8 = 1;
              _TC_i___8 = 0;
              while (1) {
                if ((int )*((signed char *)cbuf___1 + _TC_i___8) >= 0) {
                  pksiz___5 += (int )*((signed char *)cbuf___1 + _TC_i___8) * _TC_base___8;
                  break;
                }
                pksiz___5 += (_TC_base___8 * ((int )*((signed char *)cbuf___1 + _TC_i___8) + 1)) * -1;
                _TC_base___8 <<= 7;
                _TC_i___8 ++;
              }
              step___8 = _TC_i___8 + 1;
              break;
            }
            cbuf___1 += step___8;
            csiz___1 -= step___8;
            pkbuf___4 = cbuf___1;
            cbuf___1 += pksiz___5;
            csiz___1 -= pksiz___5;
          } else {
            while (1) {
              pkid___3 = 0LL;
              _TC_base___9 = 1LL;
              _TC_i___9 = 0;
              while (1) {
                if ((int )*((signed char *)cbuf___1 + _TC_i___9) >= 0) {
                  pkid___3 += (long long )*((signed char *)cbuf___1 + _TC_i___9) * _TC_base___9;
                  break;
                }
                pkid___3 += (_TC_base___9 * (long long )((int )*((signed char *)cbuf___1 + _TC_i___9) + 1)) * -1LL;
                _TC_base___9 <<= 7;
                _TC_i___9 ++;
              }
              step___9 = _TC_i___9 + 1;
              break;
            }
            cbuf___1 += step___9;
            csiz___1 -= step___9;
          }
          if (csiz___1 > 0) {
            while (1) {
              off___4 = 0;
              _TC_base___10 = 1;
              _TC_i___10 = 0;
              while (1) {
                if ((int )*((signed char *)cbuf___1 + _TC_i___10) >= 0) {
                  off___4 += (int )*((signed char *)cbuf___1 + _TC_i___10) * _TC_base___10;
                  break;
                }
                off___4 += (_TC_base___10 * ((int )*((signed char *)cbuf___1 + _TC_i___10) + 1)) * -1;
                _TC_base___10 <<= 7;
                _TC_i___10 ++;
              }
              step___10 = _TC_i___10 + 1;
              break;
            }
            cbuf___1 += step___10;
            csiz___1 -= step___10;
            if (pkbuf___4) {
              if (ores) {
                tmp___39 = tcmapget((TCMAP const   *)ores, (void const   *)pkbuf___4,
                                    pksiz___5, & rsiz___3);
                if (tmp___39) {
                  if (sign) {
                    tcmapputkeep(nres, (void const   *)pkbuf___4, pksiz___5, (void const   *)"",
                                 0);
                  } else {
                    tcmapout(ores, (void const   *)pkbuf___4, pksiz___5);
                  }
                }
              } else {
                tmp___40 = tcmapputkeep(nres, (void const   *)pkbuf___4, pksiz___5,
                                        (void const   *)"", 0);
                if (tmp___40) {
                  onum___0 ++;
                }
              }
              if (uniq) {
                tcmapputkeep(uniq, (void const   *)pkbuf___4, pksiz___5, (void const   *)"",
                             0);
              }
            } else {
              tmp___41 = sprintf((char * __restrict  )(numbuf___0), (char const   * __restrict  )"%lld",
                                 pkid___3);
              pksiz___6 = tmp___41;
              if (ores) {
                tmp___42 = tcmapget((TCMAP const   *)ores, (void const   *)(numbuf___0),
                                    pksiz___6, & rsiz___4);
                if (tmp___42) {
                  if (sign) {
                    tcmapputkeep(nres, (void const   *)(numbuf___0), pksiz___6, (void const   *)"",
                                 0);
                  } else {
                    tcmapout(ores, (void const   *)(numbuf___0), pksiz___6);
                  }
                }
              } else {
                tmp___43 = tcmapputkeep(nres, (void const   *)(numbuf___0), pksiz___6,
                                        (void const   *)"", 0);
                if (tmp___43) {
                  onum___0 ++;
                }
              }
              if (uniq) {
                tcmapputkeep(uniq, (void const   *)(numbuf___0), pksiz___6, (void const   *)"",
                             0);
              }
            }
          }
        }
        tcbdbcurnext(cur);
      }
      tcxstrdel(val);
      tcxstrdel(key);
      tcbdbcurdel(cur);
      if (uniq) {
        tmp___45 = tcmaprnum((TCMAP const   *)uniq);
        tmp___46 = (int )tmp___45;
      } else {
        tmp___46 = onum___0;
      }
      tcxstrprintf(hint, "token occurrence: \"%s\" %d\n", word, tmp___46);
      if (uniq) {
        tcmapdel(uniq);
      }
    }
    while (1) {
      free((void *)ary);
      break;
    }
    i ++;
  }
  return;
}
}
static int tctdbidxftscmpstrocr(TDBFTSSTROCR *a , TDBFTSSTROCR *b ) 
{ int diff ;
  int tmp ;

  {
  if (a->pksiz > b->pksiz) {
    return (1);
  }
  if (a->pksiz < b->pksiz) {
    return (-1);
  }
  tmp = memcmp((void const   *)a->pkbuf, (void const   *)b->pkbuf, (unsigned int )a->pksiz);
  diff = tmp;
  if (diff != 0) {
    return (diff);
  }
  return (a->off - b->off);
}
}
static int tctdbidxftscmpnumocr(TDBFTSNUMOCR *a , TDBFTSNUMOCR *b ) 
{ 

  {
  if (a->pkid > b->pkid) {
    return (1);
  }
  if (a->pkid < b->pkid) {
    return (-1);
  }
  return (a->off - b->off);
}
}
static TDBFTSUNIT *tctdbftsparseexpr(char const   *expr , int esiz , int op , int *np ) 
{ TDBFTSUNIT *ftsunits ;
  void *tmp ;
  int ftsnum ;
  uint16_t *ary ;
  void *tmp___0 ;
  int anum ;
  char *str ;
  void *tmp___1 ;
  TCLIST *tokens ;
  TCLIST *tmp___2 ;
  TCLIST *tokens___0 ;
  TCLIST *tmp___3 ;
  int tnum ;
  int i ;
  char const   *token ;
  TCLIST *ttokens ;
  TCLIST *tmp___4 ;
  TCLIST *tokens___1 ;
  TCLIST *tmp___5 ;
  int tnum___0 ;
  TCLIST *ttokens___0 ;
  TCLIST *tmp___6 ;
  int i___0 ;
  char const   *token___0 ;
  TCLIST *tokens___2 ;
  TCLIST *tmp___7 ;
  int op___0 ;
  int i___1 ;
  char const   *token___1 ;
  TCLIST *ttokens___1 ;
  TCLIST *tmp___8 ;
  TCLIST *ttokens___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
  while (1) {
    tmp = malloc((unsigned int )(32 * (int )sizeof(*ftsunits)));
    ftsunits = (TDBFTSUNIT *)tmp;
    if (! ftsunits) {
      tcmyfatal("out of memory");
    }
    break;
  }
  ftsnum = 0;
  while (1) {
    tmp___0 = malloc((unsigned int )((int )sizeof(*ary) * esiz + 1));
    ary = (uint16_t *)tmp___0;
    if (! ary) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tcstrutftoucs(expr, ary, & anum);
  anum = tcstrucsnorm(ary, anum, 15);
  while (1) {
    tmp___1 = malloc((unsigned int )(esiz + 1));
    str = (char *)tmp___1;
    if (! str) {
      tcmyfatal("out of memory");
    }
    break;
  }
  tcstrucstoutf((uint16_t const   *)ary, anum, str);
  if (op == 15) {
    tmp___2 = tclistnew2(1);
    tokens = tmp___2;
    tclistpush2(tokens, (char const   *)str);
    (ftsunits + ftsnum)->tokens = tokens;
    (ftsunits + ftsnum)->sign = (_Bool)1;
    ftsnum ++;
  } else {
    if (op == 16) {
      tmp___3 = tcstrsplit(expr, "\t\n\r ,");
      tokens___0 = tmp___3;
      tnum = tokens___0->num;
      i = 0;
      while (1) {
        if (i < tnum) {
          if (! (ftsnum < 32)) {
            break;
          }
        } else {
          break;
        }
        token = (char const   *)((void *)(tokens___0->array + (i + tokens___0->start))->ptr);
        if ((int const   )*token == 0) {
          goto __Cont;
        }
        tmp___4 = tclistnew2(1);
        ttokens = tmp___4;
        tclistpush2(ttokens, token);
        (ftsunits + ftsnum)->tokens = ttokens;
        (ftsunits + ftsnum)->sign = (_Bool)1;
        ftsnum ++;
        __Cont: 
        i ++;
      }
      tclistdel(tokens___0);
    } else {
      if (op == 17) {
        tmp___5 = tcstrsplit(expr, "\t\n\r ,");
        tokens___1 = tmp___5;
        tnum___0 = tokens___1->num;
        tmp___6 = tclistnew2(tnum___0);
        ttokens___0 = tmp___6;
        i___0 = 0;
        while (i___0 < tnum___0) {
          token___0 = (char const   *)((void *)(tokens___1->array + (i___0 + tokens___1->start))->ptr);
          if ((int const   )*token___0 == 0) {
            goto __Cont___0;
          }
          tclistpush2(ttokens___0, token___0);
          __Cont___0: 
          i___0 ++;
        }
        (ftsunits + ftsnum)->tokens = ttokens___0;
        (ftsunits + ftsnum)->sign = (_Bool)1;
        ftsnum ++;
        tclistdel(tokens___1);
      } else {
        if (op == 18) {
          tmp___7 = tcstrtokenize((char const   *)str);
          tokens___2 = tmp___7;
          op___0 = 0;
          i___1 = 0;
          while (1) {
            tmp___30 = tclistnum((TCLIST const   *)tokens___2);
            if (! (i___1 < tmp___30)) {
              break;
            }
            token___1 = (char const   *)((void *)(tokens___2->array + (i___1 + tokens___2->start))->ptr);
            if (0) {
              __s1_len___1 = strlen(token___1);
              __s2_len___1 = strlen("&&");
              if (! ((unsigned int )((void const   *)(token___1 + 1)) - (unsigned int )((void const   *)token___1) == 1U)) {
                goto _L___5;
              } else {
                if (__s1_len___1 >= 4U) {
                  _L___5: 
                  if (! ((unsigned int )((void const   *)("&&" + 1)) - (unsigned int )((void const   *)"&&") == 1U)) {
                    tmp___29 = 1;
                  } else {
                    if (__s2_len___1 >= 4U) {
                      tmp___29 = 1;
                    } else {
                      tmp___29 = 0;
                    }
                  }
                } else {
                  tmp___29 = 0;
                }
              }
              if (tmp___29) {
                tmp___24 = __builtin_strcmp(token___1, "&&");
                tmp___28 = tmp___24;
              } else {
                tmp___27 = __builtin_strcmp(token___1, "&&");
                tmp___28 = tmp___27;
              }
            } else {
              tmp___27 = __builtin_strcmp(token___1, "&&");
              tmp___28 = tmp___27;
            }
            if (tmp___28) {
              if (0) {
                __s1_len___0 = strlen(token___1);
                __s2_len___0 = strlen("||");
                if (! ((unsigned int )((void const   *)(token___1 + 1)) - (unsigned int )((void const   *)token___1) == 1U)) {
                  goto _L___3;
                } else {
                  if (__s1_len___0 >= 4U) {
                    _L___3: 
                    if (! ((unsigned int )((void const   *)("||" + 1)) - (unsigned int )((void const   *)"||") == 1U)) {
                      tmp___22 = 1;
                    } else {
                      if (__s2_len___0 >= 4U) {
                        tmp___22 = 1;
                      } else {
                        tmp___22 = 0;
                      }
                    }
                  } else {
                    tmp___22 = 0;
                  }
                }
                if (tmp___22) {
                  tmp___17 = __builtin_strcmp(token___1, "||");
                  tmp___21 = tmp___17;
                } else {
                  tmp___20 = __builtin_strcmp(token___1, "||");
                  tmp___21 = tmp___20;
                }
              } else {
                tmp___20 = __builtin_strcmp(token___1, "||");
                tmp___21 = tmp___20;
              }
              if (tmp___21) {
                if (0) {
                  __s1_len = strlen(token___1);
                  __s2_len = strlen("!!");
                  if (! ((unsigned int )((void const   *)(token___1 + 1)) - (unsigned int )((void const   *)token___1) == 1U)) {
                    goto _L___1;
                  } else {
                    if (__s1_len >= 4U) {
                      _L___1: 
                      if (! ((unsigned int )((void const   *)("!!" + 1)) - (unsigned int )((void const   *)"!!") == 1U)) {
                        tmp___15 = 1;
                      } else {
                        if (__s2_len >= 4U) {
                          tmp___15 = 1;
                        } else {
                          tmp___15 = 0;
                        }
                      }
                    } else {
                      tmp___15 = 0;
                    }
                  }
                  if (tmp___15) {
                    tmp___10 = __builtin_strcmp(token___1, "!!");
                    tmp___14 = tmp___10;
                  } else {
                    tmp___13 = __builtin_strcmp(token___1, "!!");
                    tmp___14 = tmp___13;
                  }
                } else {
                  tmp___13 = __builtin_strcmp(token___1, "!!");
                  tmp___14 = tmp___13;
                }
                if (tmp___14) {
                  if (op___0 == 0) {
                    goto _L;
                  } else {
                    if (op___0 == 2) {
                      _L: 
                      if (ftsnum >= 32) {
                        break;
                      }
                      tmp___8 = tclistnew2(2);
                      ttokens___1 = tmp___8;
                      tclistpush2(ttokens___1, token___1);
                      (ftsunits + ftsnum)->tokens = ttokens___1;
                      (ftsunits + ftsnum)->sign = (_Bool )(op___0 == 0);
                      ftsnum ++;
                    } else {
                      if (op___0 == 1) {
                        if (ftsnum < 1) {
                          (ftsunits + ftsnum)->tokens = tclistnew2(2);
                          (ftsunits + ftsnum)->sign = (_Bool )(op___0 == 0);
                          ftsnum ++;
                        }
                        ttokens___2 = (ftsunits + (ftsnum - 1))->tokens;
                        tclistpush2(ttokens___2, token___1);
                      }
                    }
                  }
                  op___0 = 0;
                } else {
                  op___0 = 2;
                }
              } else {
                op___0 = 1;
              }
            } else {
              op___0 = 0;
            }
            i___1 ++;
          }
          tclistdel(tokens___2);
        }
      }
    }
  }
  while (1) {
    free((void *)str);
    break;
  }
  while (1) {
    free((void *)ary);
    break;
  }
  *np = ftsnum;
  return (ftsunits);
}
}
static _Bool tctdbdefragimpl(TCTDB *tdb , int64_t step ) 
{ _Bool err ;
  TCHDB *hdb ;
  TDBIDX *idxs ;
  int inum ;
  _Bool tmp ;
  int i ;
  TDBIDX *idx ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
  err = (_Bool)0;
  hdb = tdb->hdb;
  idxs = tdb->idxs;
  inum = tdb->inum;
  tmp = tchdbdefrag(hdb, step);
  if (! tmp) {
    err = (_Bool)1;
  }
  i = 0;
  while (i < inum) {
    idx = idxs + i;
    switch (idx->type) {
    case 0: 
    case 1: 
    case 2: 
    case 3: 
    tmp___1 = tcbdbdefrag((TCBDB *)idx->db, step);
    if (! tmp___1) {
      tmp___0 = tcbdbecode((TCBDB *)idx->db);
      tctdbsetecode(tdb, tmp___0, "tctdb.c", 5965, "tctdbdefragimpl");
      err = (_Bool)1;
    }
    break;
    }
    i ++;
  }
  return ((_Bool )(! err));
}
}
static _Bool tctdbforeachimpl(TCTDB *tdb , _Bool (*iter)(void const   *kbuf , int ksiz ,
                                                         void const   *vbuf , int vsiz ,
                                                         void *op ) , void *op ) 
{ TCHDB *hdb ;
  char *lkbuf ;
  int lksiz ;
  char *pkbuf ;
  char stack[32768] ;
  char *rbuf ;
  int pksiz ;
  char const   *cbuf ;
  int csiz ;
  void *tmp ;
  TCMAP *cols ;
  TCMAP *tmp___0 ;
  int zsiz ;
  char *zbuf ;
  void *tmp___1 ;
  _Bool rv ;
  _Bool tmp___2 ;

  {
  hdb = tdb->hdb;
  lkbuf = (char *)((void *)0);
  lksiz = 0;
  while (1) {
    pkbuf = tchdbgetnext3(hdb, (char const   *)lkbuf, lksiz, & pksiz, & cbuf, & csiz);
    if (! ((unsigned int )pkbuf != (unsigned int )((void *)0))) {
      break;
    }
    if (pksiz < 32768) {
      rbuf = stack;
    } else {
      while (1) {
        tmp = malloc((unsigned int )(pksiz + 1));
        rbuf = (char *)tmp;
        if (! rbuf) {
          tcmyfatal("out of memory");
        }
        break;
      }
    }
    memcpy((void * __restrict  )rbuf, (void const   * __restrict  )pkbuf, (unsigned int )pksiz);
    stack[pksiz] = (char )'\000';
    tmp___0 = tcmapload((void const   *)cbuf, csiz);
    cols = tmp___0;
    tmp___1 = tcstrjoin4((TCMAP const   *)cols, & zsiz);
    zbuf = (char *)tmp___1;
    tmp___2 = (*iter)((void const   *)rbuf, pksiz, (void const   *)zbuf, zsiz, op);
    rv = tmp___2;
    while (1) {
      free((void *)zbuf);
      break;
    }
    if ((unsigned int )rbuf != (unsigned int )(stack)) {
      while (1) {
        free((void *)rbuf);
        break;
      }
    }
    tcmapdel(cols);
    while (1) {
      free((void *)lkbuf);
      break;
    }
    lkbuf = pkbuf;
    lksiz = pksiz;
    if (! rv) {
      break;
    }
  }
  while (1) {
    free((void *)lkbuf);
    break;
  }
  return ((_Bool)1);
}
}
static int tctdbqryprocoutcb(void const   *pkbuf , int pksiz , TCMAP *cols , void *op ) 
{ 

  {
  return (2);
}
}
static _Bool tctdblockmethod(TCTDB *tdb , _Bool wr ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if (wr) {
    tmp = pthread_rwlock_wrlock((pthread_rwlock_t *)tdb->mmtx);
    tmp___1 = tmp != 0;
  } else {
    tmp___0 = pthread_rwlock_rdlock((pthread_rwlock_t *)tdb->mmtx);
    tmp___1 = tmp___0 != 0;
  }
  if (tmp___1) {
    tctdbsetecode(tdb, 1, "tctdb.c", 6032, "tctdblockmethod");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
static _Bool tctdbunlockmethod(TCTDB *tdb ) 
{ int tmp ;

  {
  tmp = pthread_rwlock_unlock((pthread_rwlock_t *)tdb->mmtx);
  if (tmp != 0) {
    tctdbsetecode(tdb, 1, "tctdb.c", 6046, "tctdbunlockmethod");
    return ((_Bool)0);
  }
  while (1) {
    break;
  }
  return ((_Bool)1);
}
}
void tctdbprintmeta(TCTDB *tdb ) 
{ int dbgfd ;
  int tmp ;
  char buf[32768] ;
  char *wp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
  tmp = tchdbdbgfd(tdb->hdb);
  dbgfd = tmp;
  if (dbgfd < 0) {
    return;
  }
  if (dbgfd == 65535) {
    dbgfd = 1;
  }
  wp = buf;
  tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"META:");
  wp += tmp___0;
  tmp___1 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" mmtx=%p",
                    tdb->mmtx);
  wp += tmp___1;
  tmp___2 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" hdb=%p",
                    (void *)tdb->hdb);
  wp += tmp___2;
  tmp___3 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" open=%d",
                    tdb->open);
  wp += tmp___3;
  tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" wmode=%d",
                    tdb->wmode);
  wp += tmp___4;
  tmp___5 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" opts=%u",
                    tdb->opts);
  wp += tmp___5;
  tmp___6 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" lcnum=%d",
                    tdb->lcnum);
  wp += tmp___6;
  tmp___7 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" ncnum=%d",
                    tdb->ncnum);
  wp += tmp___7;
  tmp___8 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" iccmax=%lld",
                    tdb->iccmax);
  wp += tmp___8;
  tmp___9 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" iccsync=%f",
                    tdb->iccsync);
  wp += tmp___9;
  tmp___10 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" idxs=%p",
                     (void *)tdb->idxs);
  wp += tmp___10;
  tmp___11 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" inum=%d",
                     tdb->inum);
  wp += tmp___11;
  tmp___12 = sprintf((char * __restrict  )wp, (char const   * __restrict  )" tran=%d",
                     tdb->tran);
  wp += tmp___12;
  tmp___13 = wp;
  wp ++;
  *tmp___13 = (char )'\n';
  tcwrite(dbgfd, (void const   *)(buf), (unsigned int )(wp - buf));
  return;
}
}
#pragma merger(0,"/tmp/cil-0mbWW5H5.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
TCADB *tcadbnew(void) ;
void tcadbdel(TCADB *adb ) ;
_Bool tcadbopen(TCADB *adb , char const   *name ) ;
_Bool tcadbclose(TCADB *adb ) ;
_Bool tcadbput(TCADB *adb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) ;
_Bool tcadbput2(TCADB *adb , char const   *kstr , char const   *vstr ) ;
_Bool tcadbputkeep(TCADB *adb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) ;
_Bool tcadbputkeep2(TCADB *adb , char const   *kstr , char const   *vstr ) ;
_Bool tcadbputcat(TCADB *adb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) ;
_Bool tcadbputcat2(TCADB *adb , char const   *kstr , char const   *vstr ) ;
_Bool tcadbout(TCADB *adb , void const   *kbuf , int ksiz ) ;
_Bool tcadbout2(TCADB *adb , char const   *kstr ) ;
void *tcadbget(TCADB *adb , void const   *kbuf , int ksiz , int *sp ) ;
char *tcadbget2(TCADB *adb , char const   *kstr ) ;
int tcadbvsiz(TCADB *adb , void const   *kbuf , int ksiz ) ;
int tcadbvsiz2(TCADB *adb , char const   *kstr ) ;
_Bool tcadbiterinit(TCADB *adb ) ;
void *tcadbiternext(TCADB *adb , int *sp ) ;
char *tcadbiternext2(TCADB *adb ) ;
TCLIST *tcadbfwmkeys(TCADB *adb , void const   *pbuf , int psiz , int max ) ;
TCLIST *tcadbfwmkeys2(TCADB *adb , char const   *pstr , int max ) ;
int tcadbaddint(TCADB *adb , void const   *kbuf , int ksiz , int num ) ;
double tcadbadddouble(TCADB *adb , void const   *kbuf , int ksiz , double num ) ;
_Bool tcadbsync(TCADB *adb ) ;
_Bool tcadboptimize(TCADB *adb , char const   *params ) ;
_Bool tcadbvanish(TCADB *adb ) ;
_Bool tcadbcopy(TCADB *adb , char const   *path ) ;
_Bool tcadbtranbegin(TCADB *adb ) ;
_Bool tcadbtrancommit(TCADB *adb ) ;
_Bool tcadbtranabort(TCADB *adb ) ;
char const   *tcadbpath(TCADB *adb ) ;
uint64_t tcadbrnum(TCADB *adb ) ;
uint64_t tcadbsize(TCADB *adb ) ;
TCLIST *tcadbmisc(TCADB *adb , char const   *name , TCLIST const   *args ) ;
_Bool tcadbsetskel(TCADB *adb , ADBSKEL *skel ) ;
int tcadbomode(TCADB *adb ) ;
void *tcadbreveal(TCADB *adb ) ;
_Bool tcadbputproc(TCADB *adb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) ;
_Bool tcadbforeach(TCADB *adb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                              int vsiz , void *op ) , void *op ) ;
_Bool tcadbmapbdb(TCADB *adb , TCLIST *keys , TCBDB *bdb , _Bool (*proc___0)(void *map ,
                                                                             char const   *kbuf ,
                                                                             int ksiz ,
                                                                             char const   *vbuf ,
                                                                             int vsiz ,
                                                                             void *op ) ,
                  void *op , int64_t csiz ) ;
_Bool tcadbmapbdbemit(void *map , char const   *kbuf , int ksiz , char const   *vbuf ,
                      int vsiz ) ;
static _Bool tcadbmapbdbiter(void const   *kbuf , int ksiz , void const   *vbuf ,
                             int vsiz , void *op ) ;
static _Bool tcadbmapbdbdump(ADBMAPBDB *map ) ;
static int tcadbmapreccmplexical(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) ;
static int tcadbmapreccmpdecimal(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) ;
static int tcadbmapreccmpint32(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) ;
static int tcadbmapreccmpint64(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) ;
static int tcadbtdbqrygetout(void const   *pkbuf , int pksiz , TCMAP *cols , void *op ) ;
TCADB *tcadbnew(void) 
{ TCADB *adb ;
  void *tmp ;

  {
  while (1) {
    tmp = malloc((unsigned int )((int )sizeof(*adb)));
    adb = (TCADB *)tmp;
    if (! adb) {
      tcmyfatal("out of memory");
    }
    break;
  }
  adb->omode = 0;
  adb->mdb = (TCMDB *)((void *)0);
  adb->ndb = (TCNDB *)((void *)0);
  adb->hdb = (TCHDB *)((void *)0);
  adb->bdb = (TCBDB *)((void *)0);
  adb->fdb = (TCFDB *)((void *)0);
  adb->tdb = (TCTDB *)((void *)0);
  adb->capnum = -1LL;
  adb->capsiz = -1LL;
  adb->capcnt = 0U;
  adb->cur = (BDBCUR *)((void *)0);
  adb->skel = (void *)0;
  return (adb);
}
}
void tcadbdel(TCADB *adb ) 
{ ADBSKEL *skel ;

  {
  if (adb->omode != 0) {
    tcadbclose(adb);
  }
  if (adb->skel) {
    skel = (ADBSKEL *)adb->skel;
    if (skel->del) {
      (*(skel->del))(skel->opq);
    }
    while (1) {
      free((void *)skel);
      break;
    }
  }
  while (1) {
    free((void *)adb);
    break;
  }
  return;
}
}
_Bool tcadbopen(TCADB *adb , char const   *name ) 
{ TCLIST *elems ;
  TCLIST *tmp ;
  char *path ;
  char *tmp___0 ;
  int dbgfd ;
  int64_t bnum ;
  int64_t capnum ;
  int64_t capsiz ;
  _Bool owmode ;
  _Bool ocmode ;
  _Bool otmode ;
  _Bool onlmode ;
  _Bool onbmode ;
  int8_t apow ;
  int8_t fpow ;
  _Bool tlmode ;
  _Bool tdmode ;
  _Bool tbmode ;
  _Bool ttmode ;
  int32_t rcnum ;
  int64_t xmsiz ;
  int32_t dfunit ;
  int32_t lmemb ;
  int32_t nmemb ;
  int32_t lcnum ;
  int32_t ncnum ;
  int32_t width ;
  int64_t limsiz ;
  TCLIST *idxs ;
  int ln ;
  int i ;
  char const   *elem ;
  char *pv ;
  char *tmp___2 ;
  char *tmp___3 ;
  int64_t tmp___4 ;
  char *tmp___6 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___11 ;
  char *tmp___13 ;
  int tmp___14 ;
  char *tmp___16 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___21 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___26 ;
  char *tmp___28 ;
  int tmp___29 ;
  int64_t tmp___30 ;
  int64_t tmp___31 ;
  char *tmp___33 ;
  char *tmp___35 ;
  char *tmp___37 ;
  char *tmp___39 ;
  char *tmp___41 ;
  char *tmp___43 ;
  char *tmp___45 ;
  char *tmp___47 ;
  int64_t tmp___48 ;
  int64_t tmp___49 ;
  int64_t tmp___50 ;
  int64_t tmp___51 ;
  int64_t tmp___52 ;
  int64_t tmp___53 ;
  int64_t tmp___54 ;
  int TC_mysize ;
  size_t tmp___55 ;
  int TC_index ;
  TCLISTDATUM *tmp___56 ;
  void *tmp___57 ;
  TCLISTDATUM *array ;
  char *tmp___58 ;
  void *tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  ADBSKEL *skel ;
  _Bool tmp___78 ;
  TCMDB *tmp___79 ;
  TCMDB *tmp___80 ;
  TCHDB *hdb ;
  TCHDB *tmp___81 ;
  int opts ;
  int omode ;
  int tmp___82 ;
  _Bool tmp___83 ;
  TCBDB *bdb ;
  TCBDB *tmp___84 ;
  int opts___0 ;
  int omode___0 ;
  int tmp___85 ;
  _Bool tmp___86 ;
  TCFDB *fdb ;
  TCFDB *tmp___87 ;
  int omode___1 ;
  int tmp___88 ;
  _Bool tmp___89 ;
  TCTDB *tdb ;
  TCTDB *tmp___90 ;
  int opts___1 ;
  int omode___2 ;
  int tmp___91 ;
  _Bool tmp___92 ;
  int xnum ;
  int i___0 ;
  char const   *expr ;
  int type ;
  char *pv___0 ;
  char *tmp___94 ;
  char *tmp___95 ;
  _Bool tmp___96 ;
  _Bool tmp___97 ;
  _Bool tmp___98 ;
  _Bool tmp___99 ;
  _Bool tmp___100 ;
  _Bool tmp___101 ;
  _Bool tmp___102 ;
  _Bool tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;

  {
  if (adb->omode != 0) {
    return ((_Bool)0);
  }
  tmp = tcstrsplit(name, "#");
  elems = tmp;
  tmp___0 = tclistshift2(elems);
  path = tmp___0;
  if (! path) {
    tclistdel(elems);
    return ((_Bool)0);
  }
  dbgfd = -1;
  bnum = -1LL;
  capnum = -1LL;
  capsiz = -1LL;
  owmode = (_Bool)1;
  ocmode = (_Bool)1;
  otmode = (_Bool)0;
  onlmode = (_Bool)0;
  onbmode = (_Bool)0;
  apow = (signed char)-1;
  fpow = (signed char)-1;
  tlmode = (_Bool)0;
  tdmode = (_Bool)0;
  tbmode = (_Bool)0;
  ttmode = (_Bool)0;
  rcnum = -1;
  xmsiz = -1LL;
  dfunit = -1;
  lmemb = -1;
  nmemb = -1;
  lcnum = -1;
  ncnum = -1;
  width = -1;
  limsiz = -1LL;
  idxs = (TCLIST *)((void *)0);
  ln = elems->num;
  i = 0;
  while (i < ln) {
    elem = (char const   *)((void *)(elems->array + (i + elems->start))->ptr);
    tmp___2 = __builtin_strchr((char *)elem, '=');
    pv = tmp___2;
    if (! pv) {
      goto __Cont;
    }
    tmp___3 = pv;
    pv ++;
    *tmp___3 = (char )'\000';
    tmp___77 = tcstricmp(elem, "dbgfd");
    if (tmp___77) {
      tmp___76 = tcstricmp(elem, "bnum");
      if (tmp___76) {
        tmp___75 = tcstricmp(elem, "capnum");
        if (tmp___75) {
          tmp___74 = tcstricmp(elem, "capsiz");
          if (tmp___74) {
            tmp___73 = tcstricmp(elem, "mode");
            if (tmp___73) {
              tmp___72 = tcstricmp(elem, "apow");
              if (tmp___72) {
                tmp___71 = tcstricmp(elem, "fpow");
                if (tmp___71) {
                  tmp___70 = tcstricmp(elem, "opts");
                  if (tmp___70) {
                    tmp___69 = tcstricmp(elem, "rcnum");
                    if (tmp___69) {
                      tmp___68 = tcstricmp(elem, "xmsiz");
                      if (tmp___68) {
                        tmp___67 = tcstricmp(elem, "dfunit");
                        if (tmp___67) {
                          tmp___66 = tcstricmp(elem, "lmemb");
                          if (tmp___66) {
                            tmp___65 = tcstricmp(elem, "nmemb");
                            if (tmp___65) {
                              tmp___64 = tcstricmp(elem, "lcnum");
                              if (tmp___64) {
                                tmp___63 = tcstricmp(elem, "ncnum");
                                if (tmp___63) {
                                  tmp___62 = tcstricmp(elem, "width");
                                  if (tmp___62) {
                                    tmp___61 = tcstricmp(elem, "limsiz");
                                    if (tmp___61) {
                                      tmp___60 = tcstricmp(elem, "idx");
                                      if (! tmp___60) {
                                        if (! idxs) {
                                          idxs = tclistnew();
                                        }
                                        while (1) {
                                          tmp___55 = strlen((char const   *)pv);
                                          TC_mysize = (int )tmp___55;
                                          TC_index = idxs->start + idxs->num;
                                          if (TC_index >= idxs->anum) {
                                            idxs->anum += idxs->num + 1;
                                            while (1) {
                                              tmp___57 = realloc((void *)idxs->array,
                                                                 (unsigned int )(idxs->anum * (int )sizeof(*(idxs->array + 0))));
                                              tmp___56 = (TCLISTDATUM *)tmp___57;
                                              idxs->array = tmp___56;
                                              if (! tmp___56) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          array = idxs->array;
                                          while (1) {
                                            tmp___59 = malloc((unsigned int )(TC_mysize + 1));
                                            tmp___58 = (char *)tmp___59;
                                            (array + TC_index)->ptr = tmp___58;
                                            if (! tmp___58) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                          memcpy((void * __restrict  )(array + TC_index)->ptr,
                                                 (void const   * __restrict  )pv,
                                                 (unsigned int )TC_mysize);
                                          *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
                                          (array + TC_index)->size = TC_mysize;
                                          (idxs->num) ++;
                                          break;
                                        }
                                      }
                                    } else {
                                      limsiz = tcatoix((char const   *)pv);
                                    }
                                  } else {
                                    tmp___54 = tcatoix((char const   *)pv);
                                    width = (int )tmp___54;
                                  }
                                } else {
                                  tmp___53 = tcatoix((char const   *)pv);
                                  ncnum = (int )tmp___53;
                                }
                              } else {
                                tmp___52 = tcatoix((char const   *)pv);
                                lcnum = (int )tmp___52;
                              }
                            } else {
                              tmp___51 = tcatoix((char const   *)pv);
                              nmemb = (int )tmp___51;
                            }
                          } else {
                            tmp___50 = tcatoix((char const   *)pv);
                            lmemb = (int )tmp___50;
                          }
                        } else {
                          tmp___49 = tcatoix((char const   *)pv);
                          dfunit = (int )tmp___49;
                        }
                      } else {
                        xmsiz = tcatoix((char const   *)pv);
                      }
                    } else {
                      tmp___48 = tcatoix((char const   *)pv);
                      rcnum = (int )tmp___48;
                    }
                  } else {
                    tmp___33 = __builtin_strchr(pv, 'l');
                    if (tmp___33) {
                      tlmode = (_Bool)1;
                    } else {
                      tmp___35 = __builtin_strchr(pv, 'L');
                      if (tmp___35) {
                        tlmode = (_Bool)1;
                      }
                    }
                    tmp___37 = __builtin_strchr(pv, 'd');
                    if (tmp___37) {
                      tdmode = (_Bool)1;
                    } else {
                      tmp___39 = __builtin_strchr(pv, 'D');
                      if (tmp___39) {
                        tdmode = (_Bool)1;
                      }
                    }
                    tmp___41 = __builtin_strchr(pv, 'b');
                    if (tmp___41) {
                      tbmode = (_Bool)1;
                    } else {
                      tmp___43 = __builtin_strchr(pv, 'B');
                      if (tmp___43) {
                        tbmode = (_Bool)1;
                      }
                    }
                    tmp___45 = __builtin_strchr(pv, 't');
                    if (tmp___45) {
                      ttmode = (_Bool)1;
                    } else {
                      tmp___47 = __builtin_strchr(pv, 'T');
                      if (tmp___47) {
                        ttmode = (_Bool)1;
                      }
                    }
                  }
                } else {
                  tmp___31 = tcatoix((char const   *)pv);
                  fpow = (signed char )tmp___31;
                }
              } else {
                tmp___30 = tcatoix((char const   *)pv);
                apow = (signed char )tmp___30;
              }
            } else {
              tmp___6 = __builtin_strchr(pv, 'w');
              if (tmp___6) {
                tmp___9 = 1;
              } else {
                tmp___8 = __builtin_strchr(pv, 'W');
                if (tmp___8) {
                  tmp___9 = 1;
                } else {
                  tmp___9 = 0;
                }
              }
              owmode = (_Bool )tmp___9;
              tmp___11 = __builtin_strchr(pv, 'c');
              if (tmp___11) {
                tmp___14 = 1;
              } else {
                tmp___13 = __builtin_strchr(pv, 'C');
                if (tmp___13) {
                  tmp___14 = 1;
                } else {
                  tmp___14 = 0;
                }
              }
              ocmode = (_Bool )tmp___14;
              tmp___16 = __builtin_strchr(pv, 't');
              if (tmp___16) {
                tmp___19 = 1;
              } else {
                tmp___18 = __builtin_strchr(pv, 'T');
                if (tmp___18) {
                  tmp___19 = 1;
                } else {
                  tmp___19 = 0;
                }
              }
              otmode = (_Bool )tmp___19;
              tmp___21 = __builtin_strchr(pv, 'e');
              if (tmp___21) {
                tmp___24 = 1;
              } else {
                tmp___23 = __builtin_strchr(pv, 'E');
                if (tmp___23) {
                  tmp___24 = 1;
                } else {
                  tmp___24 = 0;
                }
              }
              onlmode = (_Bool )tmp___24;
              tmp___26 = __builtin_strchr(pv, 'f');
              if (tmp___26) {
                tmp___29 = 1;
              } else {
                tmp___28 = __builtin_strchr(pv, 'F');
                if (tmp___28) {
                  tmp___29 = 1;
                } else {
                  tmp___29 = 0;
                }
              }
              onbmode = (_Bool )tmp___29;
            }
          } else {
            capsiz = tcatoix((char const   *)pv);
          }
        } else {
          capnum = tcatoix((char const   *)pv);
        }
      } else {
        bnum = tcatoix((char const   *)pv);
      }
    } else {
      tmp___4 = tcatoi((char const   *)pv);
      dbgfd = (int )tmp___4;
    }
    __Cont: 
    i ++;
  }
  tclistdel(elems);
  adb->omode = 0;
  if (adb->skel) {
    skel = (ADBSKEL *)adb->skel;
    if (! skel->open) {
      return ((_Bool)0);
    }
    tmp___78 = (*(skel->open))(skel->opq, name);
    if (! tmp___78) {
      if (idxs) {
        tclistdel(idxs);
      }
      while (1) {
        free((void *)path);
        break;
      }
      return ((_Bool)0);
    }
    adb->omode = 7;
  } else {
    tmp___105 = tcstricmp((char const   *)path, "*");
    if (tmp___105) {
      tmp___104 = tcstricmp((char const   *)path, "+");
      if (tmp___104) {
        tmp___102 = tcstribwm((char const   *)path, ".tch");
        if (tmp___102) {
          goto _L___2;
        } else {
          tmp___103 = tcstribwm((char const   *)path, ".hdb");
          if (tmp___103) {
            _L___2: 
            tmp___81 = tchdbnew();
            hdb = tmp___81;
            if (dbgfd >= 0) {
              tchdbsetdbgfd(hdb, dbgfd);
            }
            tchdbsetmutex(hdb);
            opts = 0;
            if (tlmode) {
              opts |= 1;
            }
            if (tdmode) {
              opts |= 2;
            }
            if (tbmode) {
              opts |= 4;
            }
            if (ttmode) {
              opts |= 8;
            }
            tchdbtune(hdb, bnum, apow, fpow, (unsigned char )opts);
            tchdbsetcache(hdb, rcnum);
            if (xmsiz >= 0LL) {
              tchdbsetxmsiz(hdb, xmsiz);
            }
            if (dfunit >= 0) {
              tchdbsetdfunit(hdb, dfunit);
            }
            if (owmode) {
              tmp___82 = 2;
            } else {
              tmp___82 = 1;
            }
            omode = tmp___82;
            if (ocmode) {
              omode |= 4;
            }
            if (otmode) {
              omode |= 8;
            }
            if (onlmode) {
              omode |= 16;
            }
            if (onbmode) {
              omode |= 32;
            }
            tmp___83 = tchdbopen(hdb, (char const   *)path, omode);
            if (! tmp___83) {
              tchdbdel(hdb);
              if (idxs) {
                tclistdel(idxs);
              }
              while (1) {
                free((void *)path);
                break;
              }
              return ((_Bool)0);
            }
            adb->hdb = hdb;
            adb->omode = 3;
          } else {
            tmp___100 = tcstribwm((char const   *)path, ".tcb");
            if (tmp___100) {
              goto _L___1;
            } else {
              tmp___101 = tcstribwm((char const   *)path, ".bdb");
              if (tmp___101) {
                _L___1: 
                tmp___84 = tcbdbnew();
                bdb = tmp___84;
                if (dbgfd >= 0) {
                  tcbdbsetdbgfd(bdb, dbgfd);
                }
                tcbdbsetmutex(bdb);
                opts___0 = 0;
                if (tlmode) {
                  opts___0 |= 1;
                }
                if (tdmode) {
                  opts___0 |= 2;
                }
                if (tbmode) {
                  opts___0 |= 4;
                }
                if (ttmode) {
                  opts___0 |= 8;
                }
                tcbdbtune(bdb, lmemb, nmemb, bnum, apow, fpow, (unsigned char )opts___0);
                tcbdbsetcache(bdb, lcnum, ncnum);
                if (xmsiz >= 0LL) {
                  tcbdbsetxmsiz(bdb, xmsiz);
                }
                if (dfunit >= 0) {
                  tcbdbsetdfunit(bdb, dfunit);
                }
                if (capnum > 0LL) {
                  tcbdbsetcapnum(bdb, (unsigned long long )capnum);
                }
                if (owmode) {
                  tmp___85 = 2;
                } else {
                  tmp___85 = 1;
                }
                omode___0 = tmp___85;
                if (ocmode) {
                  omode___0 |= 4;
                }
                if (otmode) {
                  omode___0 |= 8;
                }
                if (onlmode) {
                  omode___0 |= 16;
                }
                if (onbmode) {
                  omode___0 |= 32;
                }
                tmp___86 = tcbdbopen(bdb, (char const   *)path, omode___0);
                if (! tmp___86) {
                  tcbdbdel(bdb);
                  if (idxs) {
                    tclistdel(idxs);
                  }
                  while (1) {
                    free((void *)path);
                    break;
                  }
                  return ((_Bool)0);
                }
                adb->bdb = bdb;
                adb->cur = tcbdbcurnew(bdb);
                adb->omode = 4;
              } else {
                tmp___98 = tcstribwm((char const   *)path, ".tcf");
                if (tmp___98) {
                  goto _L___0;
                } else {
                  tmp___99 = tcstribwm((char const   *)path, ".fdb");
                  if (tmp___99) {
                    _L___0: 
                    tmp___87 = tcfdbnew();
                    fdb = tmp___87;
                    if (dbgfd >= 0) {
                      tcfdbsetdbgfd(fdb, dbgfd);
                    }
                    tcfdbsetmutex(fdb);
                    tcfdbtune(fdb, width, limsiz);
                    if (owmode) {
                      tmp___88 = 2;
                    } else {
                      tmp___88 = 1;
                    }
                    omode___1 = tmp___88;
                    if (ocmode) {
                      omode___1 |= 4;
                    }
                    if (otmode) {
                      omode___1 |= 8;
                    }
                    if (onlmode) {
                      omode___1 |= 16;
                    }
                    if (onbmode) {
                      omode___1 |= 32;
                    }
                    tmp___89 = tcfdbopen(fdb, (char const   *)path, omode___1);
                    if (! tmp___89) {
                      tcfdbdel(fdb);
                      if (idxs) {
                        tclistdel(idxs);
                      }
                      while (1) {
                        free((void *)path);
                        break;
                      }
                      return ((_Bool)0);
                    }
                    adb->fdb = fdb;
                    adb->omode = 5;
                  } else {
                    tmp___96 = tcstribwm((char const   *)path, ".tct");
                    if (tmp___96) {
                      goto _L;
                    } else {
                      tmp___97 = tcstribwm((char const   *)path, ".tdb");
                      if (tmp___97) {
                        _L: 
                        tmp___90 = tctdbnew();
                        tdb = tmp___90;
                        if (dbgfd >= 0) {
                          tctdbsetdbgfd(tdb, dbgfd);
                        }
                        tctdbsetmutex(tdb);
                        opts___1 = 0;
                        if (tlmode) {
                          opts___1 |= 1;
                        }
                        if (tdmode) {
                          opts___1 |= 2;
                        }
                        if (tbmode) {
                          opts___1 |= 4;
                        }
                        if (ttmode) {
                          opts___1 |= 8;
                        }
                        tctdbtune(tdb, bnum, apow, fpow, (unsigned char )opts___1);
                        tctdbsetcache(tdb, rcnum, lcnum, ncnum);
                        if (xmsiz >= 0LL) {
                          tctdbsetxmsiz(tdb, xmsiz);
                        }
                        if (dfunit >= 0) {
                          tctdbsetdfunit(tdb, dfunit);
                        }
                        if (owmode) {
                          tmp___91 = 2;
                        } else {
                          tmp___91 = 1;
                        }
                        omode___2 = tmp___91;
                        if (ocmode) {
                          omode___2 |= 4;
                        }
                        if (otmode) {
                          omode___2 |= 8;
                        }
                        if (onlmode) {
                          omode___2 |= 16;
                        }
                        if (onbmode) {
                          omode___2 |= 32;
                        }
                        tmp___92 = tctdbopen(tdb, (char const   *)path, omode___2);
                        if (! tmp___92) {
                          tctdbdel(tdb);
                          if (idxs) {
                            tclistdel(idxs);
                          }
                          while (1) {
                            free((void *)path);
                            break;
                          }
                          return ((_Bool)0);
                        }
                        if (idxs) {
                          xnum = idxs->num;
                          i___0 = 0;
                          while (i___0 < xnum) {
                            expr = (char const   *)((void *)(idxs->array + (i___0 + idxs->start))->ptr);
                            type = 0;
                            tmp___94 = __builtin_strchr((char *)expr, ':');
                            pv___0 = tmp___94;
                            if (pv___0) {
                              tmp___95 = pv___0;
                              pv___0 ++;
                              *tmp___95 = (char )'\000';
                              type = tctdbstrtoindextype((char const   *)pv___0);
                            }
                            if (type >= 0) {
                              tctdbsetindex(tdb, expr, type | 16777216);
                            }
                            i___0 ++;
                          }
                        }
                        adb->tdb = tdb;
                        adb->omode = 6;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        adb->ndb = tcndbnew();
        adb->capnum = capnum;
        adb->capsiz = capsiz;
        adb->capcnt = 0U;
        adb->omode = 2;
      }
    } else {
      if (bnum > 0LL) {
        tmp___79 = tcmdbnew2((unsigned int )bnum);
        adb->mdb = tmp___79;
      } else {
        tmp___80 = tcmdbnew();
        adb->mdb = tmp___80;
      }
      adb->capnum = capnum;
      adb->capsiz = capsiz;
      adb->capcnt = 0U;
      adb->omode = 1;
    }
  }
  if (idxs) {
    tclistdel(idxs);
  }
  while (1) {
    free((void *)path);
    break;
  }
  if (adb->omode == 0) {
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
_Bool tcadbclose(TCADB *adb ) 
{ int err ;
  ADBSKEL *skel ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  err = 0;
  switch (adb->omode) {
  case 1: 
  tcmdbdel(adb->mdb);
  adb->mdb = (TCMDB *)((void *)0);
  break;
  case 2: 
  tcndbdel(adb->ndb);
  adb->ndb = (TCNDB *)((void *)0);
  break;
  case 3: 
  tmp = tchdbclose(adb->hdb);
  if (! tmp) {
    err = 1;
  }
  tchdbdel(adb->hdb);
  adb->hdb = (TCHDB *)((void *)0);
  break;
  case 4: 
  tcbdbcurdel(adb->cur);
  tmp___0 = tcbdbclose(adb->bdb);
  if (! tmp___0) {
    err = 1;
  }
  tcbdbdel(adb->bdb);
  adb->bdb = (TCBDB *)((void *)0);
  break;
  case 5: 
  tmp___1 = tcfdbclose(adb->fdb);
  if (! tmp___1) {
    err = 1;
  }
  tcfdbdel(adb->fdb);
  adb->fdb = (TCFDB *)((void *)0);
  break;
  case 6: 
  tmp___2 = tctdbclose(adb->tdb);
  if (! tmp___2) {
    err = 1;
  }
  tctdbdel(adb->tdb);
  adb->tdb = (TCTDB *)((void *)0);
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->close) {
    tmp___3 = (*(skel->close))(skel->opq);
    if (! tmp___3) {
      err = 1;
    }
  } else {
    err = 1;
  }
  break;
  default: 
  err = 1;
  break;
  }
  adb->omode = 0;
  return ((_Bool )(! err));
}
}
_Bool tcadbput(TCADB *adb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) 
{ _Bool err ;
  char numbuf[32] ;
  ADBSKEL *skel ;
  uint64_t tmp ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;
  uint64_t tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int64_t tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  if (adb->capnum > 0LL) {
    goto _L;
  } else {
    if (adb->capsiz > 0LL) {
      _L: 
      tcmdbput3(adb->mdb, kbuf, ksiz, (char const   *)vbuf, vsiz);
      (adb->capcnt) ++;
      if ((adb->capcnt & 255U) == 0U) {
        if (adb->capnum > 0LL) {
          tmp = tcmdbrnum(adb->mdb);
          if (tmp > (unsigned long long )(adb->capnum + 256LL)) {
            tcmdbcutfront(adb->mdb, 256);
          }
        }
        if (adb->capsiz > 0LL) {
          tmp___0 = tcmdbmsiz(adb->mdb);
          if (tmp___0 > (unsigned long long )adb->capsiz) {
            tcmdbcutfront(adb->mdb, 512);
          }
        }
      }
    } else {
      tcmdbput(adb->mdb, kbuf, ksiz, vbuf, vsiz);
    }
  }
  break;
  case 2: 
  tcndbput(adb->ndb, kbuf, ksiz, vbuf, vsiz);
  if (adb->capnum > 0LL) {
    goto _L___0;
  } else {
    if (adb->capsiz > 0LL) {
      _L___0: 
      (adb->capcnt) ++;
      if ((adb->capcnt & 255U) == 0U) {
        if (adb->capnum > 0LL) {
          tmp___1 = tcndbrnum(adb->ndb);
          if (tmp___1 > (unsigned long long )(adb->capnum + 256LL)) {
            tcndbcutfringe(adb->ndb, 256);
          }
        }
        if (adb->capsiz > 0LL) {
          tmp___2 = tcndbmsiz(adb->ndb);
          if (tmp___2 > (unsigned long long )adb->capsiz) {
            tcndbcutfringe(adb->ndb, 512);
          }
        }
      }
    }
  }
  break;
  case 3: 
  tmp___3 = tchdbput(adb->hdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___3) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___4 = tcbdbput(adb->bdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___4) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___5 = tcfdbput2(adb->fdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___5) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  if (ksiz < 1) {
    tmp___6 = tctdbgenuid(adb->tdb);
    ksiz = sprintf((char * __restrict  )(numbuf), (char const   * __restrict  )"%lld",
                   tmp___6);
    kbuf = (void const   *)(numbuf);
  }
  tmp___7 = tctdbput2(adb->tdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___7) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->put) {
    tmp___8 = (*(skel->put))(skel->opq, kbuf, ksiz, vbuf, vsiz);
    if (! tmp___8) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadbput2(TCADB *adb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcadbput(adb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                     (int )tmp);
  return (tmp___1);
}
}
_Bool tcadbputkeep(TCADB *adb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) 
{ _Bool err ;
  char numbuf[32] ;
  ADBSKEL *skel ;
  uint64_t tmp ;
  uint64_t tmp___0 ;
  _Bool tmp___1 ;
  uint64_t tmp___2 ;
  uint64_t tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  int64_t tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  tmp___1 = tcmdbputkeep(adb->mdb, kbuf, ksiz, vbuf, vsiz);
  if (tmp___1) {
    if (adb->capnum > 0LL) {
      goto _L;
    } else {
      if (adb->capsiz > 0LL) {
        _L: 
        (adb->capcnt) ++;
        if ((adb->capcnt & 255U) == 0U) {
          if (adb->capnum > 0LL) {
            tmp = tcmdbrnum(adb->mdb);
            if (tmp > (unsigned long long )(adb->capnum + 256LL)) {
              tcmdbcutfront(adb->mdb, 256);
            }
          }
          if (adb->capsiz > 0LL) {
            tmp___0 = tcmdbmsiz(adb->mdb);
            if (tmp___0 > (unsigned long long )adb->capsiz) {
              tcmdbcutfront(adb->mdb, 512);
            }
          }
        }
      }
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 2: 
  tmp___4 = tcndbputkeep(adb->ndb, kbuf, ksiz, vbuf, vsiz);
  if (tmp___4) {
    if (adb->capnum > 0LL) {
      goto _L___0;
    } else {
      if (adb->capsiz > 0LL) {
        _L___0: 
        (adb->capcnt) ++;
        if ((adb->capcnt & 255U) == 0U) {
          if (adb->capnum > 0LL) {
            tmp___2 = tcndbrnum(adb->ndb);
            if (tmp___2 > (unsigned long long )(adb->capnum + 256LL)) {
              tcndbcutfringe(adb->ndb, 256);
            }
          }
          if (adb->capsiz > 0LL) {
            tmp___3 = tcndbmsiz(adb->ndb);
            if (tmp___3 > (unsigned long long )adb->capsiz) {
              tcndbcutfringe(adb->ndb, 512);
            }
          }
        }
      }
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 3: 
  tmp___5 = tchdbputkeep(adb->hdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___5) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___6 = tcbdbputkeep(adb->bdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___6) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___7 = tcfdbputkeep2(adb->fdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___7) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  if (ksiz < 1) {
    tmp___8 = tctdbgenuid(adb->tdb);
    ksiz = sprintf((char * __restrict  )(numbuf), (char const   * __restrict  )"%lld",
                   tmp___8);
    kbuf = (void const   *)(numbuf);
  }
  tmp___9 = tctdbputkeep2(adb->tdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___9) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->putkeep) {
    tmp___10 = (*(skel->putkeep))(skel->opq, kbuf, ksiz, vbuf, vsiz);
    if (! tmp___10) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadbputkeep2(TCADB *adb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcadbputkeep(adb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                         (int )tmp);
  return (tmp___1);
}
}
_Bool tcadbputcat(TCADB *adb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) 
{ _Bool err ;
  char numbuf[32] ;
  ADBSKEL *skel ;
  uint64_t tmp ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;
  uint64_t tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int64_t tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  if (adb->capnum > 0LL) {
    goto _L;
  } else {
    if (adb->capsiz > 0LL) {
      _L: 
      tcmdbputcat3(adb->mdb, kbuf, ksiz, vbuf, vsiz);
      (adb->capcnt) ++;
      if ((adb->capcnt & 255U) == 0U) {
        if (adb->capnum > 0LL) {
          tmp = tcmdbrnum(adb->mdb);
          if (tmp > (unsigned long long )(adb->capnum + 256LL)) {
            tcmdbcutfront(adb->mdb, 256);
          }
        }
        if (adb->capsiz > 0LL) {
          tmp___0 = tcmdbmsiz(adb->mdb);
          if (tmp___0 > (unsigned long long )adb->capsiz) {
            tcmdbcutfront(adb->mdb, 512);
          }
        }
      }
    } else {
      tcmdbputcat(adb->mdb, kbuf, ksiz, vbuf, vsiz);
    }
  }
  break;
  case 2: 
  tcndbputcat(adb->ndb, kbuf, ksiz, vbuf, vsiz);
  if (adb->capnum > 0LL) {
    goto _L___0;
  } else {
    if (adb->capsiz > 0LL) {
      _L___0: 
      (adb->capcnt) ++;
      if ((adb->capcnt & 255U) == 0U) {
        if (adb->capnum > 0LL) {
          tmp___1 = tcndbrnum(adb->ndb);
          if (tmp___1 > (unsigned long long )(adb->capnum + 256LL)) {
            tcndbcutfringe(adb->ndb, 256);
          }
        }
        if (adb->capsiz > 0LL) {
          tmp___2 = tcndbmsiz(adb->ndb);
          if (tmp___2 > (unsigned long long )adb->capsiz) {
            tcndbcutfringe(adb->ndb, 512);
          }
        }
      }
    }
  }
  break;
  case 3: 
  tmp___3 = tchdbputcat(adb->hdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___3) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___4 = tcbdbputcat(adb->bdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___4) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___5 = tcfdbputcat2(adb->fdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___5) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  if (ksiz < 1) {
    tmp___6 = tctdbgenuid(adb->tdb);
    ksiz = sprintf((char * __restrict  )(numbuf), (char const   * __restrict  )"%lld",
                   tmp___6);
    kbuf = (void const   *)(numbuf);
  }
  tmp___7 = tctdbputcat2(adb->tdb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___7) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->putcat) {
    tmp___8 = (*(skel->putcat))(skel->opq, kbuf, ksiz, vbuf, vsiz);
    if (! tmp___8) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadbputcat2(TCADB *adb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcadbputcat(adb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                        (int )tmp);
  return (tmp___1);
}
}
_Bool tcadbout(TCADB *adb , void const   *kbuf , int ksiz ) 
{ _Bool err ;
  ADBSKEL *skel ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  tmp = tcmdbout(adb->mdb, kbuf, ksiz);
  if (! tmp) {
    err = (_Bool)1;
  }
  break;
  case 2: 
  tmp___0 = tcndbout(adb->ndb, kbuf, ksiz);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  break;
  case 3: 
  tmp___1 = tchdbout(adb->hdb, kbuf, ksiz);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___2 = tcbdbout(adb->bdb, kbuf, ksiz);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___3 = tcfdbout2(adb->fdb, kbuf, ksiz);
  if (! tmp___3) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  tmp___4 = tctdbout(adb->tdb, kbuf, ksiz);
  if (! tmp___4) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->out) {
    tmp___5 = (*(skel->out))(skel->opq, kbuf, ksiz);
    if (! tmp___5) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadbout2(TCADB *adb , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcadbout(adb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
void *tcadbget(TCADB *adb , void const   *kbuf , int ksiz , int *sp ) 
{ char *rv ;
  ADBSKEL *skel ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  switch (adb->omode) {
  case 1: 
  tmp = tcmdbget(adb->mdb, kbuf, ksiz, sp);
  rv = (char *)tmp;
  break;
  case 2: 
  tmp___0 = tcndbget(adb->ndb, kbuf, ksiz, sp);
  rv = (char *)tmp___0;
  break;
  case 3: 
  tmp___1 = tchdbget(adb->hdb, kbuf, ksiz, sp);
  rv = (char *)tmp___1;
  break;
  case 4: 
  tmp___2 = tcbdbget(adb->bdb, kbuf, ksiz, sp);
  rv = (char *)tmp___2;
  break;
  case 5: 
  tmp___3 = tcfdbget2(adb->fdb, kbuf, ksiz, sp);
  rv = (char *)tmp___3;
  break;
  case 6: 
  rv = tctdbget2(adb->tdb, kbuf, ksiz, sp);
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->get) {
    tmp___4 = (*(skel->get))(skel->opq, kbuf, ksiz, sp);
    rv = (char *)tmp___4;
  } else {
    rv = (char *)((void *)0);
  }
  break;
  default: 
  rv = (char *)((void *)0);
  break;
  }
  return ((void *)rv);
}
}
char *tcadbget2(TCADB *adb , char const   *kstr ) 
{ int vsiz ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcadbget(adb, (void const   *)kstr, (int )tmp, & vsiz);
  return ((char *)tmp___0);
}
}
int tcadbvsiz(TCADB *adb , void const   *kbuf , int ksiz ) 
{ int rv ;
  ADBSKEL *skel ;

  {
  switch (adb->omode) {
  case 1: 
  rv = tcmdbvsiz(adb->mdb, kbuf, ksiz);
  break;
  case 2: 
  rv = tcndbvsiz(adb->ndb, kbuf, ksiz);
  break;
  case 3: 
  rv = tchdbvsiz(adb->hdb, kbuf, ksiz);
  break;
  case 4: 
  rv = tcbdbvsiz(adb->bdb, kbuf, ksiz);
  break;
  case 5: 
  rv = tcfdbvsiz2(adb->fdb, kbuf, ksiz);
  break;
  case 6: 
  rv = tctdbvsiz(adb->tdb, kbuf, ksiz);
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->vsiz) {
    rv = (*(skel->vsiz))(skel->opq, kbuf, ksiz);
  } else {
    rv = -1;
  }
  break;
  default: 
  rv = -1;
  break;
  }
  return (rv);
}
}
int tcadbvsiz2(TCADB *adb , char const   *kstr ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcadbvsiz(adb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
_Bool tcadbiterinit(TCADB *adb ) 
{ _Bool err ;
  ADBSKEL *skel ;
  _Bool tmp ;
  int ecode ;
  int tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  tcmdbiterinit(adb->mdb);
  break;
  case 2: 
  tcndbiterinit(adb->ndb);
  break;
  case 3: 
  tmp = tchdbiterinit(adb->hdb);
  if (! tmp) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___1 = tcbdbcurfirst(adb->cur);
  if (! tmp___1) {
    tmp___0 = tcbdbecode(adb->bdb);
    ecode = tmp___0;
    if (ecode != 0) {
      if (ecode != 2) {
        if (ecode != 21) {
          if (ecode != 22) {
            err = (_Bool)1;
          }
        }
      }
    }
  }
  break;
  case 5: 
  tmp___2 = tcfdbiterinit(adb->fdb);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  tmp___3 = tctdbiterinit(adb->tdb);
  if (! tmp___3) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->iterinit) {
    tmp___4 = (*(skel->iterinit))(skel->opq);
    if (! tmp___4) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
void *tcadbiternext(TCADB *adb , int *sp ) 
{ char *rv ;
  ADBSKEL *skel ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  switch (adb->omode) {
  case 1: 
  tmp = tcmdbiternext(adb->mdb, sp);
  rv = (char *)tmp;
  break;
  case 2: 
  tmp___0 = tcndbiternext(adb->ndb, sp);
  rv = (char *)tmp___0;
  break;
  case 3: 
  tmp___1 = tchdbiternext(adb->hdb, sp);
  rv = (char *)tmp___1;
  break;
  case 4: 
  tmp___2 = tcbdbcurkey(adb->cur, sp);
  rv = (char *)tmp___2;
  tcbdbcurnext(adb->cur);
  break;
  case 5: 
  tmp___3 = tcfdbiternext2(adb->fdb, sp);
  rv = (char *)tmp___3;
  break;
  case 6: 
  tmp___4 = tctdbiternext(adb->tdb, sp);
  rv = (char *)tmp___4;
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->iternext) {
    tmp___5 = (*(skel->iternext))(skel->opq, sp);
    rv = (char *)tmp___5;
  } else {
    rv = (char *)((void *)0);
  }
  break;
  default: 
  rv = (char *)((void *)0);
  break;
  }
  return ((void *)rv);
}
}
char *tcadbiternext2(TCADB *adb ) 
{ int vsiz ;
  void *tmp ;

  {
  tmp = tcadbiternext(adb, & vsiz);
  return ((char *)tmp);
}
}
TCLIST *tcadbfwmkeys(TCADB *adb , void const   *pbuf , int psiz , int max ) 
{ TCLIST *rv ;
  ADBSKEL *skel ;

  {
  switch (adb->omode) {
  case 1: 
  rv = tcmdbfwmkeys(adb->mdb, pbuf, psiz, max);
  break;
  case 2: 
  rv = tcndbfwmkeys(adb->ndb, pbuf, psiz, max);
  break;
  case 3: 
  rv = tchdbfwmkeys(adb->hdb, pbuf, psiz, max);
  break;
  case 4: 
  rv = tcbdbfwmkeys(adb->bdb, pbuf, psiz, max);
  break;
  case 5: 
  rv = tcfdbrange4(adb->fdb, pbuf, psiz, max);
  break;
  case 6: 
  rv = tctdbfwmkeys(adb->tdb, pbuf, psiz, max);
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->fwmkeys) {
    rv = (*(skel->fwmkeys))(skel->opq, pbuf, psiz, max);
  } else {
    rv = (TCLIST *)((void *)0);
  }
  break;
  default: 
  rv = tclistnew();
  break;
  }
  return (rv);
}
}
TCLIST *tcadbfwmkeys2(TCADB *adb , char const   *pstr , int max ) 
{ size_t tmp ;
  TCLIST *tmp___0 ;

  {
  tmp = strlen(pstr);
  tmp___0 = tcadbfwmkeys(adb, (void const   *)pstr, (int )tmp, max);
  return (tmp___0);
}
}
int tcadbaddint(TCADB *adb , void const   *kbuf , int ksiz , int num ) 
{ int rv ;
  char numbuf[32] ;
  ADBSKEL *skel ;
  uint64_t tmp ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;
  uint64_t tmp___2 ;
  int64_t tmp___3 ;
  int64_t tmp___4 ;

  {
  switch (adb->omode) {
  case 1: 
  rv = tcmdbaddint(adb->mdb, kbuf, ksiz, num);
  if (adb->capnum > 0LL) {
    goto _L;
  } else {
    if (adb->capsiz > 0LL) {
      _L: 
      (adb->capcnt) ++;
      if ((adb->capcnt & 255U) == 0U) {
        if (adb->capnum > 0LL) {
          tmp = tcmdbrnum(adb->mdb);
          if (tmp > (unsigned long long )(adb->capnum + 256LL)) {
            tcmdbcutfront(adb->mdb, 256);
          }
        }
        if (adb->capsiz > 0LL) {
          tmp___0 = tcmdbmsiz(adb->mdb);
          if (tmp___0 > (unsigned long long )adb->capsiz) {
            tcmdbcutfront(adb->mdb, 512);
          }
        }
      }
    }
  }
  break;
  case 2: 
  rv = tcndbaddint(adb->ndb, kbuf, ksiz, num);
  if (adb->capnum > 0LL) {
    goto _L___0;
  } else {
    if (adb->capsiz > 0LL) {
      _L___0: 
      (adb->capcnt) ++;
      if ((adb->capcnt & 255U) == 0U) {
        if (adb->capnum > 0LL) {
          tmp___1 = tcndbrnum(adb->ndb);
          if (tmp___1 > (unsigned long long )(adb->capnum + 256LL)) {
            tcndbcutfringe(adb->ndb, 256);
          }
        }
        if (adb->capsiz > 0LL) {
          tmp___2 = tcndbmsiz(adb->ndb);
          if (tmp___2 > (unsigned long long )adb->capsiz) {
            tcndbcutfringe(adb->ndb, 512);
          }
        }
      }
    }
  }
  break;
  case 3: 
  rv = tchdbaddint(adb->hdb, kbuf, ksiz, num);
  break;
  case 4: 
  rv = tcbdbaddint(adb->bdb, kbuf, ksiz, num);
  break;
  case 5: 
  tmp___3 = tcfdbkeytoid((char const   *)kbuf, ksiz);
  rv = tcfdbaddint(adb->fdb, tmp___3, num);
  break;
  case 6: 
  if (ksiz < 1) {
    tmp___4 = tctdbgenuid(adb->tdb);
    ksiz = sprintf((char * __restrict  )(numbuf), (char const   * __restrict  )"%lld",
                   tmp___4);
    kbuf = (void const   *)(numbuf);
  }
  rv = tctdbaddint(adb->tdb, kbuf, ksiz, num);
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->addint) {
    rv = (*(skel->addint))(skel->opq, kbuf, ksiz, num);
  } else {
    rv = (-0x7FFFFFFF-1);
  }
  break;
  default: 
  rv = (-0x7FFFFFFF-1);
  break;
  }
  return (rv);
}
}
double tcadbadddouble(TCADB *adb , void const   *kbuf , int ksiz , double num ) 
{ double rv ;
  char numbuf[32] ;
  ADBSKEL *skel ;
  uint64_t tmp ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;
  uint64_t tmp___2 ;
  int64_t tmp___3 ;
  int64_t tmp___4 ;

  {
  switch (adb->omode) {
  case 1: 
  rv = tcmdbadddouble(adb->mdb, kbuf, ksiz, num);
  if (adb->capnum > 0LL) {
    goto _L;
  } else {
    if (adb->capsiz > 0LL) {
      _L: 
      (adb->capcnt) ++;
      if ((adb->capcnt & 255U) == 0U) {
        if (adb->capnum > 0LL) {
          tmp = tcmdbrnum(adb->mdb);
          if (tmp > (unsigned long long )(adb->capnum + 256LL)) {
            tcmdbcutfront(adb->mdb, 256);
          }
        }
        if (adb->capsiz > 0LL) {
          tmp___0 = tcmdbmsiz(adb->mdb);
          if (tmp___0 > (unsigned long long )adb->capsiz) {
            tcmdbcutfront(adb->mdb, 512);
          }
        }
      }
    }
  }
  break;
  case 2: 
  rv = tcndbadddouble(adb->ndb, kbuf, ksiz, num);
  if (adb->capnum > 0LL) {
    goto _L___0;
  } else {
    if (adb->capsiz > 0LL) {
      _L___0: 
      (adb->capcnt) ++;
      if ((adb->capcnt & 255U) == 0U) {
        if (adb->capnum > 0LL) {
          tmp___1 = tcndbrnum(adb->ndb);
          if (tmp___1 > (unsigned long long )(adb->capnum + 256LL)) {
            tcndbcutfringe(adb->ndb, 256);
          }
        }
        if (adb->capsiz > 0LL) {
          tmp___2 = tcndbmsiz(adb->ndb);
          if (tmp___2 > (unsigned long long )adb->capsiz) {
            tcndbcutfringe(adb->ndb, 512);
          }
        }
      }
    }
  }
  break;
  case 3: 
  rv = tchdbadddouble(adb->hdb, kbuf, ksiz, num);
  break;
  case 4: 
  rv = tcbdbadddouble(adb->bdb, kbuf, ksiz, num);
  break;
  case 5: 
  tmp___3 = tcfdbkeytoid((char const   *)kbuf, ksiz);
  rv = tcfdbadddouble(adb->fdb, tmp___3, num);
  break;
  case 6: 
  if (ksiz < 1) {
    tmp___4 = tctdbgenuid(adb->tdb);
    ksiz = sprintf((char * __restrict  )(numbuf), (char const   * __restrict  )"%lld",
                   tmp___4);
    kbuf = (void const   *)(numbuf);
  }
  rv = tctdbadddouble(adb->tdb, kbuf, ksiz, num);
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->adddouble) {
    rv = (*(skel->adddouble))(skel->opq, kbuf, ksiz, num);
  } else {
    rv = nan("");
  }
  break;
  default: 
  rv = nan("");
  break;
  }
  return (rv);
}
}
_Bool tcadbsync(TCADB *adb ) 
{ _Bool err ;
  ADBSKEL *skel ;
  uint64_t tmp ;
  uint64_t tmp___0 ;
  uint64_t tmp___1 ;
  uint64_t tmp___2 ;
  uint64_t tmp___3 ;
  uint64_t tmp___4 ;
  uint64_t tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  if (adb->capnum > 0LL) {
    while (1) {
      tmp = tcmdbrnum(adb->mdb);
      if (! (tmp > (unsigned long long )adb->capnum)) {
        break;
      }
      tcmdbcutfront(adb->mdb, 1);
    }
  }
  if (adb->capsiz > 0LL) {
    while (1) {
      tmp___0 = tcmdbmsiz(adb->mdb);
      if (tmp___0 > (unsigned long long )adb->capsiz) {
        tmp___1 = tcmdbrnum(adb->mdb);
        if (! (tmp___1 > 0ULL)) {
          break;
        }
      } else {
        break;
      }
      tcmdbcutfront(adb->mdb, 1);
    }
  }
  adb->capcnt = 0U;
  break;
  case 2: 
  if (adb->capnum > 0LL) {
    tmp___3 = tcndbrnum(adb->ndb);
    if (tmp___3 > (unsigned long long )adb->capnum) {
      tmp___2 = tcndbrnum(adb->ndb);
      tcndbcutfringe(adb->ndb, (int )(tmp___2 - (unsigned long long )adb->capnum));
    }
  }
  if (adb->capsiz > 0LL) {
    while (1) {
      tmp___4 = tcndbmsiz(adb->ndb);
      if (tmp___4 > (unsigned long long )adb->capsiz) {
        tmp___5 = tcndbrnum(adb->ndb);
        if (! (tmp___5 > 0ULL)) {
          break;
        }
      } else {
        break;
      }
      tcndbcutfringe(adb->ndb, 256);
    }
  }
  adb->capcnt = 0U;
  break;
  case 3: 
  tmp___6 = tchdbsync(adb->hdb);
  if (! tmp___6) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___7 = tcbdbsync(adb->bdb);
  if (! tmp___7) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___8 = tcfdbsync(adb->fdb);
  if (! tmp___8) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  tmp___9 = tctdbsync(adb->tdb);
  if (! tmp___9) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->sync) {
    tmp___10 = (*(skel->sync))(skel->opq);
    if (! tmp___10) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadboptimize(TCADB *adb , char const   *params ) 
{ TCLIST *elems ;
  TCLIST *tmp ;
  TCLIST *tmp___0 ;
  TCLIST *tmp___1 ;
  int64_t bnum ;
  int64_t capnum ;
  int64_t capsiz ;
  int8_t apow ;
  int8_t fpow ;
  _Bool tdefault ;
  _Bool tlmode ;
  _Bool tdmode ;
  _Bool tbmode ;
  _Bool ttmode ;
  int32_t lmemb ;
  int32_t nmemb ;
  int32_t width ;
  int64_t limsiz ;
  int ln ;
  int i ;
  char const   *elem ;
  char *pv ;
  char *tmp___3 ;
  char *tmp___4 ;
  int64_t tmp___5 ;
  int64_t tmp___6 ;
  char *tmp___8 ;
  char *tmp___10 ;
  char *tmp___12 ;
  char *tmp___14 ;
  char *tmp___16 ;
  char *tmp___18 ;
  char *tmp___20 ;
  char *tmp___22 ;
  int64_t tmp___23 ;
  int64_t tmp___24 ;
  int64_t tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  _Bool err ;
  int opts ;
  ADBSKEL *skel ;
  _Bool tmp___36 ;
  _Bool tmp___37 ;
  _Bool tmp___38 ;
  _Bool tmp___39 ;
  _Bool tmp___40 ;

  {
  if (params) {
    tmp = tcstrsplit(params, "#");
    tmp___1 = tmp;
  } else {
    tmp___0 = tclistnew();
    tmp___1 = tmp___0;
  }
  elems = tmp___1;
  bnum = -1LL;
  capnum = -1LL;
  capsiz = -1LL;
  apow = (signed char)-1;
  fpow = (signed char)-1;
  tdefault = (_Bool)1;
  tlmode = (_Bool)0;
  tdmode = (_Bool)0;
  tbmode = (_Bool)0;
  ttmode = (_Bool)0;
  lmemb = -1;
  nmemb = -1;
  width = -1;
  limsiz = -1LL;
  ln = elems->num;
  i = 0;
  while (i < ln) {
    elem = (char const   *)((void *)(elems->array + (i + elems->start))->ptr);
    tmp___3 = __builtin_strchr((char *)elem, '=');
    pv = tmp___3;
    if (! pv) {
      goto __Cont;
    }
    tmp___4 = pv;
    pv ++;
    *tmp___4 = (char )'\000';
    tmp___35 = tcstricmp(elem, "bnum");
    if (tmp___35) {
      tmp___34 = tcstricmp(elem, "capnum");
      if (tmp___34) {
        tmp___33 = tcstricmp(elem, "capsiz");
        if (tmp___33) {
          tmp___32 = tcstricmp(elem, "apow");
          if (tmp___32) {
            tmp___31 = tcstricmp(elem, "fpow");
            if (tmp___31) {
              tmp___30 = tcstricmp(elem, "opts");
              if (tmp___30) {
                tmp___29 = tcstricmp(elem, "lmemb");
                if (tmp___29) {
                  tmp___28 = tcstricmp(elem, "nmemb");
                  if (tmp___28) {
                    tmp___27 = tcstricmp(elem, "width");
                    if (tmp___27) {
                      tmp___26 = tcstricmp(elem, "limsiz");
                      if (! tmp___26) {
                        limsiz = tcatoix((char const   *)pv);
                      }
                    } else {
                      tmp___25 = tcatoix((char const   *)pv);
                      width = (int )tmp___25;
                    }
                  } else {
                    tmp___24 = tcatoix((char const   *)pv);
                    nmemb = (int )tmp___24;
                  }
                } else {
                  tmp___23 = tcatoix((char const   *)pv);
                  lmemb = (int )tmp___23;
                }
              } else {
                tdefault = (_Bool)0;
                tmp___8 = __builtin_strchr(pv, 'l');
                if (tmp___8) {
                  tlmode = (_Bool)1;
                } else {
                  tmp___10 = __builtin_strchr(pv, 'L');
                  if (tmp___10) {
                    tlmode = (_Bool)1;
                  }
                }
                tmp___12 = __builtin_strchr(pv, 'd');
                if (tmp___12) {
                  tdmode = (_Bool)1;
                } else {
                  tmp___14 = __builtin_strchr(pv, 'D');
                  if (tmp___14) {
                    tdmode = (_Bool)1;
                  }
                }
                tmp___16 = __builtin_strchr(pv, 'b');
                if (tmp___16) {
                  tbmode = (_Bool)1;
                } else {
                  tmp___18 = __builtin_strchr(pv, 'B');
                  if (tmp___18) {
                    tbmode = (_Bool)1;
                  }
                }
                tmp___20 = __builtin_strchr(pv, 't');
                if (tmp___20) {
                  ttmode = (_Bool)1;
                } else {
                  tmp___22 = __builtin_strchr(pv, 'T');
                  if (tmp___22) {
                    ttmode = (_Bool)1;
                  }
                }
              }
            } else {
              tmp___6 = tcatoix((char const   *)pv);
              fpow = (signed char )tmp___6;
            }
          } else {
            tmp___5 = tcatoix((char const   *)pv);
            apow = (signed char )tmp___5;
          }
        } else {
          capsiz = tcatoix((char const   *)pv);
        }
      } else {
        capnum = tcatoix((char const   *)pv);
      }
    } else {
      bnum = tcatoix((char const   *)pv);
    }
    __Cont: 
    i ++;
  }
  tclistdel(elems);
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  adb->capnum = capnum;
  adb->capsiz = capsiz;
  tcadbsync(adb);
  break;
  case 2: 
  adb->capnum = capnum;
  adb->capsiz = capsiz;
  tcadbsync(adb);
  break;
  case 3: 
  opts = 0;
  if (tdefault) {
    opts = 255;
  } else {
    if (tlmode) {
      opts |= 1;
    }
    if (tdmode) {
      opts |= 2;
    }
    if (tbmode) {
      opts |= 4;
    }
    if (ttmode) {
      opts |= 8;
    }
  }
  tmp___36 = tchdboptimize(adb->hdb, bnum, apow, fpow, (unsigned char )opts);
  if (! tmp___36) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  opts = 0;
  if (tdefault) {
    opts = 255;
  } else {
    if (tlmode) {
      opts |= 1;
    }
    if (tdmode) {
      opts |= 2;
    }
    if (tbmode) {
      opts |= 4;
    }
    if (ttmode) {
      opts |= 8;
    }
  }
  tmp___37 = tcbdboptimize(adb->bdb, lmemb, nmemb, bnum, apow, fpow, (unsigned char )opts);
  if (! tmp___37) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___38 = tcfdboptimize(adb->fdb, width, limsiz);
  if (! tmp___38) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  opts = 0;
  if (tdefault) {
    opts = 255;
  } else {
    if (tlmode) {
      opts |= 1;
    }
    if (tdmode) {
      opts |= 2;
    }
    if (tbmode) {
      opts |= 4;
    }
    if (ttmode) {
      opts |= 8;
    }
  }
  tmp___39 = tctdboptimize(adb->tdb, bnum, apow, fpow, (unsigned char )opts);
  if (! tmp___39) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->optimize) {
    tmp___40 = (*(skel->optimize))(skel->opq, params);
    if (! tmp___40) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadbvanish(TCADB *adb ) 
{ _Bool err ;
  ADBSKEL *skel ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  tcmdbvanish(adb->mdb);
  break;
  case 2: 
  tcndbvanish(adb->ndb);
  break;
  case 3: 
  tmp = tchdbvanish(adb->hdb);
  if (! tmp) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___0 = tcbdbvanish(adb->bdb);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___1 = tcfdbvanish(adb->fdb);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  tmp___2 = tctdbvanish(adb->tdb);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->vanish) {
    tmp___3 = (*(skel->vanish))(skel->opq);
    if (! tmp___3) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadbcopy(TCADB *adb , char const   *path ) 
{ _Bool err ;
  ADBSKEL *skel ;
  char tsbuf[32] ;
  double tmp ;
  char const   *args[2] ;
  int tmp___0 ;
  TCADB *tadb ;
  TCADB *tmp___1 ;
  char *kbuf ;
  int ksiz ;
  int vsiz ;
  char *vbuf ;
  void *tmp___2 ;
  _Bool tmp___3 ;
  void *tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  case 2: 
  if ((int const   )*path == 64) {
    tmp = tctime();
    sprintf((char * __restrict  )(tsbuf), (char const   * __restrict  )"%llu", (unsigned long long )(tmp * (double )1000000));
    args[0] = path + 1;
    args[1] = (char const   *)(tsbuf);
    tmp___0 = tcsystem(args, (int )sizeof(args) / (int )sizeof(args[0]));
    if (tmp___0 != 0) {
      err = (_Bool)1;
    }
  } else {
    tmp___1 = tcadbnew();
    tadb = tmp___1;
    tmp___6 = tcadbopen(tadb, path);
    if (tmp___6) {
      tcadbiterinit(adb);
      while (1) {
        tmp___4 = tcadbiternext(adb, & ksiz);
        kbuf = (char *)tmp___4;
        if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
          break;
        }
        tmp___2 = tcadbget(adb, (void const   *)kbuf, ksiz, & vsiz);
        vbuf = (char *)tmp___2;
        if (vbuf) {
          tmp___3 = tcadbput(tadb, (void const   *)kbuf, ksiz, (void const   *)vbuf,
                             vsiz);
          if (! tmp___3) {
            err = (_Bool)1;
          }
          while (1) {
            free((void *)vbuf);
            break;
          }
        }
        while (1) {
          free((void *)kbuf);
          break;
        }
      }
      tmp___5 = tcadbclose(tadb);
      if (! tmp___5) {
        err = (_Bool)1;
      }
    } else {
      err = (_Bool)1;
    }
    tcadbdel(tadb);
  }
  break;
  case 3: 
  tmp___7 = tchdbcopy(adb->hdb, path);
  if (! tmp___7) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___8 = tcbdbcopy(adb->bdb, path);
  if (! tmp___8) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___9 = tcfdbcopy(adb->fdb, path);
  if (! tmp___9) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  tmp___10 = tctdbcopy(adb->tdb, path);
  if (! tmp___10) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->copy) {
    tmp___11 = (*(skel->copy))(skel->opq, path);
    if (! tmp___11) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadbtranbegin(TCADB *adb ) 
{ _Bool err ;
  ADBSKEL *skel ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  err = (_Bool)1;
  break;
  case 2: 
  err = (_Bool)1;
  break;
  case 3: 
  tmp = tchdbtranbegin(adb->hdb);
  if (! tmp) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___0 = tcbdbtranbegin(adb->bdb);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___1 = tcfdbtranbegin(adb->fdb);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  tmp___2 = tctdbtranbegin(adb->tdb);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->tranbegin) {
    tmp___3 = (*(skel->tranbegin))(skel->opq);
    if (! tmp___3) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadbtrancommit(TCADB *adb ) 
{ _Bool err ;
  ADBSKEL *skel ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  err = (_Bool)1;
  break;
  case 2: 
  err = (_Bool)1;
  break;
  case 3: 
  tmp = tchdbtrancommit(adb->hdb);
  if (! tmp) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___0 = tcbdbtrancommit(adb->bdb);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___1 = tcfdbtrancommit(adb->fdb);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  tmp___2 = tctdbtrancommit(adb->tdb);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->trancommit) {
    tmp___3 = (*(skel->trancommit))(skel->opq);
    if (! tmp___3) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadbtranabort(TCADB *adb ) 
{ _Bool err ;
  ADBSKEL *skel ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  err = (_Bool)1;
  break;
  case 2: 
  err = (_Bool)1;
  break;
  case 3: 
  tmp = tchdbtranabort(adb->hdb);
  if (! tmp) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___0 = tcbdbtranabort(adb->bdb);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___1 = tcfdbtranabort(adb->fdb);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  tmp___2 = tctdbtranabort(adb->tdb);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->tranabort) {
    tmp___3 = (*(skel->tranabort))(skel->opq);
    if (! tmp___3) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
char const   *tcadbpath(TCADB *adb ) 
{ char const   *rv ;
  ADBSKEL *skel ;

  {
  switch (adb->omode) {
  case 1: 
  rv = "*";
  break;
  case 2: 
  rv = "+";
  break;
  case 3: 
  rv = tchdbpath(adb->hdb);
  break;
  case 4: 
  rv = tcbdbpath(adb->bdb);
  break;
  case 5: 
  rv = tcfdbpath(adb->fdb);
  break;
  case 6: 
  rv = tctdbpath(adb->tdb);
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->path) {
    rv = (*(skel->path))(skel->opq);
  } else {
    rv = (char const   *)((void *)0);
  }
  break;
  default: 
  rv = (char const   *)((void *)0);
  break;
  }
  return (rv);
}
}
uint64_t tcadbrnum(TCADB *adb ) 
{ uint64_t rv ;
  ADBSKEL *skel ;

  {
  switch (adb->omode) {
  case 1: 
  rv = tcmdbrnum(adb->mdb);
  break;
  case 2: 
  rv = tcndbrnum(adb->ndb);
  break;
  case 3: 
  rv = tchdbrnum(adb->hdb);
  break;
  case 4: 
  rv = tcbdbrnum(adb->bdb);
  break;
  case 5: 
  rv = tcfdbrnum(adb->fdb);
  break;
  case 6: 
  rv = tctdbrnum(adb->tdb);
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->rnum) {
    rv = (*(skel->rnum))(skel->opq);
  } else {
    rv = 0ULL;
  }
  break;
  default: 
  rv = 0ULL;
  break;
  }
  return (rv);
}
}
uint64_t tcadbsize(TCADB *adb ) 
{ uint64_t rv ;
  ADBSKEL *skel ;

  {
  switch (adb->omode) {
  case 1: 
  rv = tcmdbmsiz(adb->mdb);
  break;
  case 2: 
  rv = tcndbmsiz(adb->ndb);
  break;
  case 3: 
  rv = tchdbfsiz(adb->hdb);
  break;
  case 4: 
  rv = tcbdbfsiz(adb->bdb);
  break;
  case 5: 
  rv = tcfdbfsiz(adb->fdb);
  break;
  case 6: 
  rv = tctdbfsiz(adb->tdb);
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->size) {
    rv = (*(skel->size))(skel->opq);
  } else {
    rv = 0ULL;
  }
  break;
  default: 
  rv = 0ULL;
  break;
  }
  return (rv);
}
}
TCLIST *tcadbmisc(TCADB *adb , char const   *name , TCLIST const   *args ) 
{ int argc ;
  TCLIST *rv ;
  ADBSKEL *skel ;
  char const   *kbuf ;
  int ksiz ;
  char const   *vbuf ;
  int vsiz ;
  _Bool err ;
  _Bool tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  char const   *kbuf___0 ;
  int ksiz___0 ;
  _Bool tmp___21 ;
  char const   *kbuf___1 ;
  int ksiz___1 ;
  int vsiz___0 ;
  char *vbuf___0 ;
  void *tmp___22 ;
  int TC_mysize ;
  int TC_index ;
  TCLISTDATUM *tmp___23 ;
  void *tmp___24 ;
  TCLISTDATUM *array ;
  char *tmp___25 ;
  void *tmp___26 ;
  int i ;
  char const   *kbuf___2 ;
  int ksiz___2 ;
  int vsiz___1 ;
  char const   *vbuf___1 ;
  void const   *tmp___27 ;
  int i___0 ;
  char const   *kbuf___3 ;
  int ksiz___3 ;
  int i___1 ;
  char const   *kbuf___4 ;
  int ksiz___4 ;
  int vsiz___2 ;
  char *vbuf___2 ;
  void *tmp___28 ;
  int TC_mysize___0 ;
  int TC_index___0 ;
  TCLISTDATUM *tmp___29 ;
  void *tmp___30 ;
  TCLISTDATUM *array___0 ;
  char *tmp___31 ;
  void *tmp___32 ;
  int TC_mysize___1 ;
  int TC_index___1 ;
  TCLISTDATUM *tmp___33 ;
  void *tmp___34 ;
  TCLISTDATUM *array___1 ;
  char *tmp___35 ;
  void *tmp___36 ;
  char const   *kbuf___5 ;
  int ksiz___5 ;
  int ksiz___6 ;
  char *kbuf___6 ;
  void *tmp___37 ;
  int TC_mysize___2 ;
  int TC_index___2 ;
  TCLISTDATUM *tmp___38 ;
  void *tmp___39 ;
  TCLISTDATUM *array___2 ;
  char *tmp___40 ;
  void *tmp___41 ;
  int vsiz___3 ;
  char *vbuf___3 ;
  void *tmp___42 ;
  int TC_mysize___3 ;
  int TC_index___3 ;
  TCLISTDATUM *tmp___43 ;
  void *tmp___44 ;
  TCLISTDATUM *array___3 ;
  char *tmp___45 ;
  void *tmp___46 ;
  _Bool tmp___47 ;
  char const   *params ;
  void *tmp___48 ;
  _Bool tmp___49 ;
  _Bool tmp___50 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___52 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___59 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___66 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___73 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___80 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___87 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___94 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___101 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___108 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___115 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___122 ;
  int tmp___125 ;
  int tmp___126 ;
  int tmp___127 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___129 ;
  int tmp___132 ;
  int tmp___133 ;
  int tmp___134 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___136 ;
  int tmp___139 ;
  int tmp___140 ;
  int tmp___141 ;
  char const   *kbuf___7 ;
  int ksiz___7 ;
  char const   *vbuf___4 ;
  int vsiz___4 ;
  _Bool err___0 ;
  _Bool tmp___142 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___144 ;
  int tmp___147 ;
  int tmp___148 ;
  int tmp___149 ;
  size_t __s1_len___16 ;
  size_t __s2_len___16 ;
  int tmp___151 ;
  int tmp___154 ;
  int tmp___155 ;
  int tmp___156 ;
  size_t __s1_len___17 ;
  size_t __s2_len___17 ;
  int tmp___158 ;
  int tmp___161 ;
  int tmp___162 ;
  int tmp___163 ;
  char const   *kbuf___8 ;
  int ksiz___8 ;
  _Bool tmp___164 ;
  char const   *kbuf___9 ;
  int ksiz___9 ;
  int vsiz___5 ;
  char *vbuf___5 ;
  void *tmp___165 ;
  int TC_mysize___4 ;
  int TC_index___4 ;
  TCLISTDATUM *tmp___166 ;
  void *tmp___167 ;
  TCLISTDATUM *array___4 ;
  char *tmp___168 ;
  void *tmp___169 ;
  int i___2 ;
  char const   *kbuf___10 ;
  int ksiz___10 ;
  int vsiz___6 ;
  char const   *vbuf___6 ;
  void const   *tmp___170 ;
  int i___3 ;
  char const   *kbuf___11 ;
  int ksiz___11 ;
  int i___4 ;
  char const   *kbuf___12 ;
  int ksiz___12 ;
  int vsiz___7 ;
  char *vbuf___7 ;
  void *tmp___171 ;
  int TC_mysize___5 ;
  int TC_index___5 ;
  TCLISTDATUM *tmp___172 ;
  void *tmp___173 ;
  TCLISTDATUM *array___5 ;
  char *tmp___174 ;
  void *tmp___175 ;
  int TC_mysize___6 ;
  int TC_index___6 ;
  TCLISTDATUM *tmp___176 ;
  void *tmp___177 ;
  TCLISTDATUM *array___6 ;
  char *tmp___178 ;
  void *tmp___179 ;
  char const   *kbuf___13 ;
  int ksiz___13 ;
  int ksiz___14 ;
  char *kbuf___14 ;
  void *tmp___180 ;
  int TC_mysize___7 ;
  int TC_index___7 ;
  TCLISTDATUM *tmp___181 ;
  void *tmp___182 ;
  TCLISTDATUM *array___7 ;
  char *tmp___183 ;
  void *tmp___184 ;
  int vsiz___8 ;
  char *vbuf___8 ;
  void *tmp___185 ;
  int TC_mysize___8 ;
  int TC_index___8 ;
  TCLISTDATUM *tmp___186 ;
  void *tmp___187 ;
  TCLISTDATUM *array___8 ;
  char *tmp___188 ;
  void *tmp___189 ;
  _Bool tmp___190 ;
  char const   *params___0 ;
  void *tmp___191 ;
  _Bool tmp___192 ;
  _Bool tmp___193 ;
  size_t __s1_len___18 ;
  size_t __s2_len___18 ;
  int tmp___195 ;
  int tmp___198 ;
  int tmp___199 ;
  int tmp___200 ;
  size_t __s1_len___19 ;
  size_t __s2_len___19 ;
  int tmp___202 ;
  int tmp___205 ;
  int tmp___206 ;
  int tmp___207 ;
  size_t __s1_len___20 ;
  size_t __s2_len___20 ;
  int tmp___209 ;
  int tmp___212 ;
  int tmp___213 ;
  int tmp___214 ;
  size_t __s1_len___21 ;
  size_t __s2_len___21 ;
  int tmp___216 ;
  int tmp___219 ;
  int tmp___220 ;
  int tmp___221 ;
  size_t __s1_len___22 ;
  size_t __s2_len___22 ;
  int tmp___223 ;
  int tmp___226 ;
  int tmp___227 ;
  int tmp___228 ;
  size_t __s1_len___23 ;
  size_t __s2_len___23 ;
  int tmp___230 ;
  int tmp___233 ;
  int tmp___234 ;
  int tmp___235 ;
  size_t __s1_len___24 ;
  size_t __s2_len___24 ;
  int tmp___237 ;
  int tmp___240 ;
  int tmp___241 ;
  int tmp___242 ;
  size_t __s1_len___25 ;
  size_t __s2_len___25 ;
  int tmp___244 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  size_t __s1_len___26 ;
  size_t __s2_len___26 ;
  int tmp___251 ;
  int tmp___254 ;
  int tmp___255 ;
  int tmp___256 ;
  size_t __s1_len___27 ;
  size_t __s2_len___27 ;
  int tmp___258 ;
  int tmp___261 ;
  int tmp___262 ;
  int tmp___263 ;
  size_t __s1_len___28 ;
  size_t __s2_len___28 ;
  int tmp___265 ;
  int tmp___268 ;
  int tmp___269 ;
  int tmp___270 ;
  size_t __s1_len___29 ;
  size_t __s2_len___29 ;
  int tmp___272 ;
  int tmp___275 ;
  int tmp___276 ;
  int tmp___277 ;
  size_t __s1_len___30 ;
  size_t __s2_len___30 ;
  int tmp___279 ;
  int tmp___282 ;
  int tmp___283 ;
  int tmp___284 ;
  char const   *kbuf___15 ;
  int ksiz___15 ;
  char const   *vbuf___9 ;
  int vsiz___9 ;
  _Bool err___1 ;
  _Bool tmp___285 ;
  _Bool tmp___286 ;
  _Bool tmp___287 ;
  size_t __s1_len___31 ;
  size_t __s2_len___31 ;
  int tmp___289 ;
  int tmp___292 ;
  int tmp___293 ;
  int tmp___294 ;
  size_t __s1_len___32 ;
  size_t __s2_len___32 ;
  int tmp___296 ;
  int tmp___299 ;
  int tmp___300 ;
  int tmp___301 ;
  size_t __s1_len___33 ;
  size_t __s2_len___33 ;
  int tmp___303 ;
  int tmp___306 ;
  int tmp___307 ;
  int tmp___308 ;
  char const   *kbuf___16 ;
  int ksiz___16 ;
  _Bool tmp___309 ;
  char const   *kbuf___17 ;
  int ksiz___17 ;
  int vsiz___10 ;
  char *vbuf___10 ;
  void *tmp___310 ;
  int TC_mysize___9 ;
  int TC_index___9 ;
  TCLISTDATUM *tmp___311 ;
  void *tmp___312 ;
  TCLISTDATUM *array___9 ;
  char *tmp___313 ;
  void *tmp___314 ;
  _Bool err___2 ;
  int i___5 ;
  char const   *kbuf___18 ;
  int ksiz___18 ;
  int vsiz___11 ;
  char const   *vbuf___11 ;
  void const   *tmp___315 ;
  _Bool tmp___316 ;
  _Bool err___3 ;
  int i___6 ;
  char const   *kbuf___19 ;
  int ksiz___19 ;
  _Bool tmp___317 ;
  int tmp___318 ;
  _Bool err___4 ;
  int i___7 ;
  char const   *kbuf___20 ;
  int ksiz___20 ;
  int vsiz___12 ;
  char *vbuf___12 ;
  void *tmp___319 ;
  int TC_mysize___10 ;
  int TC_index___10 ;
  TCLISTDATUM *tmp___320 ;
  void *tmp___321 ;
  TCLISTDATUM *array___10 ;
  char *tmp___322 ;
  void *tmp___323 ;
  int TC_mysize___11 ;
  int TC_index___11 ;
  TCLISTDATUM *tmp___324 ;
  void *tmp___325 ;
  TCLISTDATUM *array___11 ;
  char *tmp___326 ;
  void *tmp___327 ;
  int tmp___328 ;
  _Bool err___5 ;
  char const   *kbuf___21 ;
  int ksiz___21 ;
  _Bool tmp___329 ;
  _Bool tmp___330 ;
  int ksiz___22 ;
  char *kbuf___22 ;
  void *tmp___331 ;
  int TC_mysize___12 ;
  int TC_index___12 ;
  TCLISTDATUM *tmp___332 ;
  void *tmp___333 ;
  TCLISTDATUM *array___12 ;
  char *tmp___334 ;
  void *tmp___335 ;
  int vsiz___13 ;
  char *vbuf___13 ;
  void *tmp___336 ;
  int TC_mysize___13 ;
  int TC_index___13 ;
  TCLISTDATUM *tmp___337 ;
  void *tmp___338 ;
  TCLISTDATUM *array___13 ;
  char *tmp___339 ;
  void *tmp___340 ;
  _Bool tmp___341 ;
  char const   *params___1 ;
  void *tmp___342 ;
  _Bool tmp___343 ;
  _Bool tmp___344 ;
  int64_t step ;
  int64_t tmp___345 ;
  int64_t tmp___346 ;
  _Bool tmp___347 ;
  size_t __s1_len___34 ;
  size_t __s2_len___34 ;
  int tmp___349 ;
  int tmp___352 ;
  int tmp___353 ;
  int tmp___354 ;
  size_t __s1_len___35 ;
  size_t __s2_len___35 ;
  int tmp___356 ;
  int tmp___359 ;
  int tmp___360 ;
  int tmp___361 ;
  size_t __s1_len___36 ;
  size_t __s2_len___36 ;
  int tmp___363 ;
  int tmp___366 ;
  int tmp___367 ;
  int tmp___368 ;
  size_t __s1_len___37 ;
  size_t __s2_len___37 ;
  int tmp___370 ;
  int tmp___373 ;
  int tmp___374 ;
  int tmp___375 ;
  size_t __s1_len___38 ;
  size_t __s2_len___38 ;
  int tmp___377 ;
  int tmp___380 ;
  int tmp___381 ;
  int tmp___382 ;
  size_t __s1_len___39 ;
  size_t __s2_len___39 ;
  int tmp___384 ;
  int tmp___387 ;
  int tmp___388 ;
  int tmp___389 ;
  size_t __s1_len___40 ;
  size_t __s2_len___40 ;
  int tmp___391 ;
  int tmp___394 ;
  int tmp___395 ;
  int tmp___396 ;
  size_t __s1_len___41 ;
  size_t __s2_len___41 ;
  int tmp___398 ;
  int tmp___401 ;
  int tmp___402 ;
  int tmp___403 ;
  size_t __s1_len___42 ;
  size_t __s2_len___42 ;
  int tmp___405 ;
  int tmp___408 ;
  int tmp___409 ;
  int tmp___410 ;
  size_t __s1_len___43 ;
  size_t __s2_len___43 ;
  int tmp___412 ;
  int tmp___415 ;
  int tmp___416 ;
  int tmp___417 ;
  size_t __s1_len___44 ;
  size_t __s2_len___44 ;
  int tmp___419 ;
  int tmp___422 ;
  int tmp___423 ;
  int tmp___424 ;
  size_t __s1_len___45 ;
  size_t __s2_len___45 ;
  int tmp___426 ;
  int tmp___429 ;
  int tmp___430 ;
  int tmp___431 ;
  size_t __s1_len___46 ;
  size_t __s2_len___46 ;
  int tmp___433 ;
  int tmp___436 ;
  int tmp___437 ;
  int tmp___438 ;
  size_t __s1_len___47 ;
  size_t __s2_len___47 ;
  int tmp___440 ;
  int tmp___443 ;
  int tmp___444 ;
  int tmp___445 ;
  char const   *kbuf___23 ;
  int ksiz___23 ;
  char const   *vbuf___14 ;
  int vsiz___14 ;
  _Bool err___6 ;
  _Bool tmp___446 ;
  _Bool tmp___447 ;
  _Bool tmp___448 ;
  _Bool tmp___449 ;
  _Bool tmp___450 ;
  size_t __s1_len___48 ;
  size_t __s2_len___48 ;
  int tmp___452 ;
  int tmp___455 ;
  int tmp___456 ;
  int tmp___457 ;
  size_t __s1_len___49 ;
  size_t __s2_len___49 ;
  int tmp___459 ;
  int tmp___462 ;
  int tmp___463 ;
  int tmp___464 ;
  size_t __s1_len___50 ;
  size_t __s2_len___50 ;
  int tmp___466 ;
  int tmp___469 ;
  int tmp___470 ;
  int tmp___471 ;
  size_t __s1_len___51 ;
  size_t __s2_len___51 ;
  int tmp___473 ;
  int tmp___476 ;
  int tmp___477 ;
  int tmp___478 ;
  size_t __s1_len___52 ;
  size_t __s2_len___52 ;
  int tmp___480 ;
  int tmp___483 ;
  int tmp___484 ;
  int tmp___485 ;
  char const   *kbuf___24 ;
  int ksiz___24 ;
  _Bool tmp___486 ;
  char const   *kbuf___25 ;
  int ksiz___25 ;
  TCLIST *vals ;
  TCLIST *tmp___487 ;
  _Bool err___7 ;
  int i___8 ;
  char const   *kbuf___26 ;
  int ksiz___26 ;
  int vsiz___15 ;
  char const   *vbuf___15 ;
  void const   *tmp___488 ;
  _Bool tmp___489 ;
  _Bool err___8 ;
  int i___9 ;
  char const   *kbuf___27 ;
  int ksiz___27 ;
  _Bool tmp___490 ;
  int tmp___491 ;
  _Bool err___9 ;
  int i___10 ;
  char const   *kbuf___28 ;
  int ksiz___28 ;
  TCLIST *vals___0 ;
  TCLIST *tmp___492 ;
  int vnum ;
  int j ;
  int TC_mysize___14 ;
  int TC_index___14 ;
  TCLISTDATUM *tmp___493 ;
  void *tmp___494 ;
  TCLISTDATUM *array___14 ;
  char *tmp___495 ;
  void *tmp___496 ;
  char const   *vbuf___16 ;
  int vsiz___16 ;
  int TC_mysize___15 ;
  int TC_index___15 ;
  TCLISTDATUM *tmp___497 ;
  void *tmp___498 ;
  TCLISTDATUM *array___15 ;
  char *tmp___499 ;
  void *tmp___500 ;
  int tmp___501 ;
  _Bool err___10 ;
  char const   *kbuf___29 ;
  int ksiz___29 ;
  _Bool tmp___502 ;
  _Bool tmp___503 ;
  int ksiz___30 ;
  char const   *kbuf___30 ;
  void const   *tmp___504 ;
  int TC_mysize___16 ;
  int TC_index___16 ;
  TCLISTDATUM *tmp___505 ;
  void *tmp___506 ;
  TCLISTDATUM *array___16 ;
  char *tmp___507 ;
  void *tmp___508 ;
  int vsiz___17 ;
  char const   *vbuf___17 ;
  void const   *tmp___509 ;
  int TC_mysize___17 ;
  int TC_index___17 ;
  TCLISTDATUM *tmp___510 ;
  void *tmp___511 ;
  TCLISTDATUM *array___17 ;
  char *tmp___512 ;
  void *tmp___513 ;
  _Bool tmp___514 ;
  char const   *params___2 ;
  void *tmp___515 ;
  _Bool tmp___516 ;
  _Bool tmp___517 ;
  int64_t step___0 ;
  int64_t tmp___518 ;
  int64_t tmp___519 ;
  _Bool tmp___520 ;
  size_t __s1_len___53 ;
  size_t __s2_len___53 ;
  int tmp___522 ;
  int tmp___525 ;
  int tmp___526 ;
  int tmp___527 ;
  size_t __s1_len___54 ;
  size_t __s2_len___54 ;
  int tmp___529 ;
  int tmp___532 ;
  int tmp___533 ;
  int tmp___534 ;
  size_t __s1_len___55 ;
  size_t __s2_len___55 ;
  int tmp___536 ;
  int tmp___539 ;
  int tmp___540 ;
  int tmp___541 ;
  size_t __s1_len___56 ;
  size_t __s2_len___56 ;
  int tmp___543 ;
  int tmp___546 ;
  int tmp___547 ;
  int tmp___548 ;
  size_t __s1_len___57 ;
  size_t __s2_len___57 ;
  int tmp___550 ;
  int tmp___553 ;
  int tmp___554 ;
  int tmp___555 ;
  size_t __s1_len___58 ;
  size_t __s2_len___58 ;
  int tmp___557 ;
  int tmp___560 ;
  int tmp___561 ;
  int tmp___562 ;
  size_t __s1_len___59 ;
  size_t __s2_len___59 ;
  int tmp___564 ;
  int tmp___567 ;
  int tmp___568 ;
  int tmp___569 ;
  size_t __s1_len___60 ;
  size_t __s2_len___60 ;
  int tmp___571 ;
  int tmp___574 ;
  int tmp___575 ;
  int tmp___576 ;
  size_t __s1_len___61 ;
  size_t __s2_len___61 ;
  int tmp___578 ;
  int tmp___581 ;
  int tmp___582 ;
  int tmp___583 ;
  size_t __s1_len___62 ;
  size_t __s2_len___62 ;
  int tmp___585 ;
  int tmp___588 ;
  int tmp___589 ;
  int tmp___590 ;
  size_t __s1_len___63 ;
  size_t __s2_len___63 ;
  int tmp___592 ;
  int tmp___595 ;
  int tmp___596 ;
  int tmp___597 ;
  size_t __s1_len___64 ;
  size_t __s2_len___64 ;
  int tmp___599 ;
  int tmp___602 ;
  int tmp___603 ;
  int tmp___604 ;
  size_t __s1_len___65 ;
  size_t __s2_len___65 ;
  int tmp___606 ;
  int tmp___609 ;
  int tmp___610 ;
  int tmp___611 ;
  size_t __s1_len___66 ;
  size_t __s2_len___66 ;
  int tmp___613 ;
  int tmp___616 ;
  int tmp___617 ;
  int tmp___618 ;
  size_t __s1_len___67 ;
  size_t __s2_len___67 ;
  int tmp___620 ;
  int tmp___623 ;
  int tmp___624 ;
  int tmp___625 ;
  size_t __s1_len___68 ;
  size_t __s2_len___68 ;
  int tmp___627 ;
  int tmp___630 ;
  int tmp___631 ;
  int tmp___632 ;
  char const   *kbuf___31 ;
  int ksiz___31 ;
  char const   *vbuf___18 ;
  int vsiz___18 ;
  _Bool err___11 ;
  _Bool tmp___633 ;
  _Bool tmp___634 ;
  _Bool tmp___635 ;
  size_t __s1_len___69 ;
  size_t __s2_len___69 ;
  int tmp___637 ;
  int tmp___640 ;
  int tmp___641 ;
  int tmp___642 ;
  size_t __s1_len___70 ;
  size_t __s2_len___70 ;
  int tmp___644 ;
  int tmp___647 ;
  int tmp___648 ;
  int tmp___649 ;
  size_t __s1_len___71 ;
  size_t __s2_len___71 ;
  int tmp___651 ;
  int tmp___654 ;
  int tmp___655 ;
  int tmp___656 ;
  char const   *kbuf___32 ;
  int ksiz___32 ;
  _Bool tmp___657 ;
  char const   *kbuf___33 ;
  int ksiz___33 ;
  int vsiz___19 ;
  char *vbuf___19 ;
  void *tmp___658 ;
  int TC_mysize___18 ;
  int TC_index___18 ;
  TCLISTDATUM *tmp___659 ;
  void *tmp___660 ;
  TCLISTDATUM *array___18 ;
  char *tmp___661 ;
  void *tmp___662 ;
  _Bool err___12 ;
  int i___11 ;
  char const   *kbuf___34 ;
  int ksiz___34 ;
  int vsiz___20 ;
  char const   *vbuf___20 ;
  void const   *tmp___663 ;
  _Bool tmp___664 ;
  _Bool err___13 ;
  int i___12 ;
  char const   *kbuf___35 ;
  int ksiz___35 ;
  _Bool tmp___665 ;
  int tmp___666 ;
  _Bool err___14 ;
  int i___13 ;
  char const   *kbuf___36 ;
  int ksiz___36 ;
  int vsiz___21 ;
  char *vbuf___21 ;
  void *tmp___667 ;
  int TC_mysize___19 ;
  int TC_index___19 ;
  TCLISTDATUM *tmp___668 ;
  void *tmp___669 ;
  TCLISTDATUM *array___19 ;
  char *tmp___670 ;
  void *tmp___671 ;
  int TC_mysize___20 ;
  int TC_index___20 ;
  TCLISTDATUM *tmp___672 ;
  void *tmp___673 ;
  TCLISTDATUM *array___20 ;
  char *tmp___674 ;
  void *tmp___675 ;
  int tmp___676 ;
  _Bool err___15 ;
  char const   *kbuf___37 ;
  int ksiz___37 ;
  _Bool tmp___677 ;
  _Bool tmp___678 ;
  int ksiz___38 ;
  char *kbuf___38 ;
  void *tmp___679 ;
  int TC_mysize___21 ;
  int TC_index___21 ;
  TCLISTDATUM *tmp___680 ;
  void *tmp___681 ;
  TCLISTDATUM *array___21 ;
  char *tmp___682 ;
  void *tmp___683 ;
  int vsiz___22 ;
  char *vbuf___22 ;
  void *tmp___684 ;
  int TC_mysize___22 ;
  int TC_index___22 ;
  TCLISTDATUM *tmp___685 ;
  void *tmp___686 ;
  TCLISTDATUM *array___22 ;
  char *tmp___687 ;
  void *tmp___688 ;
  _Bool tmp___689 ;
  char const   *params___3 ;
  void *tmp___690 ;
  _Bool tmp___691 ;
  _Bool tmp___692 ;
  size_t __s1_len___72 ;
  size_t __s2_len___72 ;
  int tmp___694 ;
  int tmp___697 ;
  int tmp___698 ;
  int tmp___699 ;
  size_t __s1_len___73 ;
  size_t __s2_len___73 ;
  int tmp___701 ;
  int tmp___704 ;
  int tmp___705 ;
  int tmp___706 ;
  size_t __s1_len___74 ;
  size_t __s2_len___74 ;
  int tmp___708 ;
  int tmp___711 ;
  int tmp___712 ;
  int tmp___713 ;
  size_t __s1_len___75 ;
  size_t __s2_len___75 ;
  int tmp___715 ;
  int tmp___718 ;
  int tmp___719 ;
  int tmp___720 ;
  size_t __s1_len___76 ;
  size_t __s2_len___76 ;
  int tmp___722 ;
  int tmp___725 ;
  int tmp___726 ;
  int tmp___727 ;
  size_t __s1_len___77 ;
  size_t __s2_len___77 ;
  int tmp___729 ;
  int tmp___732 ;
  int tmp___733 ;
  int tmp___734 ;
  size_t __s1_len___78 ;
  size_t __s2_len___78 ;
  int tmp___736 ;
  int tmp___739 ;
  int tmp___740 ;
  int tmp___741 ;
  size_t __s1_len___79 ;
  size_t __s2_len___79 ;
  int tmp___743 ;
  int tmp___746 ;
  int tmp___747 ;
  int tmp___748 ;
  size_t __s1_len___80 ;
  size_t __s2_len___80 ;
  int tmp___750 ;
  int tmp___753 ;
  int tmp___754 ;
  int tmp___755 ;
  size_t __s1_len___81 ;
  size_t __s2_len___81 ;
  int tmp___757 ;
  int tmp___760 ;
  int tmp___761 ;
  int tmp___762 ;
  size_t __s1_len___82 ;
  size_t __s2_len___82 ;
  int tmp___764 ;
  int tmp___767 ;
  int tmp___768 ;
  int tmp___769 ;
  size_t __s1_len___83 ;
  size_t __s2_len___83 ;
  int tmp___771 ;
  int tmp___774 ;
  int tmp___775 ;
  int tmp___776 ;
  size_t __s1_len___84 ;
  size_t __s2_len___84 ;
  int tmp___778 ;
  int tmp___781 ;
  int tmp___782 ;
  int tmp___783 ;
  char *pkbuf ;
  int pksiz ;
  TCMAP *cols ;
  TCMAP *tmp___784 ;
  int i___14 ;
  char const   *kbuf___39 ;
  int ksiz___39 ;
  int vsiz___23 ;
  char const   *vbuf___23 ;
  void const   *tmp___785 ;
  _Bool err___16 ;
  _Bool tmp___786 ;
  _Bool tmp___787 ;
  _Bool tmp___788 ;
  size_t __s1_len___85 ;
  size_t __s2_len___85 ;
  int tmp___790 ;
  int tmp___793 ;
  int tmp___794 ;
  int tmp___795 ;
  size_t __s1_len___86 ;
  size_t __s2_len___86 ;
  int tmp___797 ;
  int tmp___800 ;
  int tmp___801 ;
  int tmp___802 ;
  size_t __s1_len___87 ;
  size_t __s2_len___87 ;
  int tmp___804 ;
  int tmp___807 ;
  int tmp___808 ;
  int tmp___809 ;
  char *pkbuf___0 ;
  int pksiz___0 ;
  _Bool tmp___810 ;
  char *pkbuf___1 ;
  int pksiz___1 ;
  TCMAP *cols___0 ;
  TCMAP *tmp___811 ;
  char const   *kbuf___40 ;
  int ksiz___40 ;
  int vsiz___24 ;
  char const   *vbuf___24 ;
  void const   *tmp___812 ;
  int TC_mysize___23 ;
  int TC_index___23 ;
  TCLISTDATUM *tmp___813 ;
  void *tmp___814 ;
  TCLISTDATUM *array___23 ;
  char *tmp___815 ;
  void *tmp___816 ;
  int TC_mysize___24 ;
  int TC_index___24 ;
  TCLISTDATUM *tmp___817 ;
  void *tmp___818 ;
  TCLISTDATUM *array___24 ;
  char *tmp___819 ;
  void *tmp___820 ;
  void const   *tmp___821 ;
  _Bool err___17 ;
  int i___15 ;
  char const   *kbuf___41 ;
  int ksiz___41 ;
  int vsiz___25 ;
  char const   *vbuf___25 ;
  void const   *tmp___822 ;
  _Bool tmp___823 ;
  _Bool err___18 ;
  int i___16 ;
  char const   *kbuf___42 ;
  int ksiz___42 ;
  _Bool tmp___824 ;
  int tmp___825 ;
  _Bool err___19 ;
  int i___17 ;
  char const   *kbuf___43 ;
  int ksiz___43 ;
  int vsiz___26 ;
  char *vbuf___26 ;
  char *tmp___826 ;
  int TC_mysize___25 ;
  int TC_index___25 ;
  TCLISTDATUM *tmp___827 ;
  void *tmp___828 ;
  TCLISTDATUM *array___25 ;
  char *tmp___829 ;
  void *tmp___830 ;
  int TC_mysize___26 ;
  int TC_index___26 ;
  TCLISTDATUM *tmp___831 ;
  void *tmp___832 ;
  TCLISTDATUM *array___26 ;
  char *tmp___833 ;
  void *tmp___834 ;
  int tmp___835 ;
  _Bool err___20 ;
  char const   *pkbuf___2 ;
  int pksiz___2 ;
  _Bool tmp___836 ;
  _Bool tmp___837 ;
  int pksiz___3 ;
  char *pkbuf___3 ;
  void *tmp___838 ;
  int TC_mysize___27 ;
  int TC_index___27 ;
  TCLISTDATUM *tmp___839 ;
  void *tmp___840 ;
  TCLISTDATUM *array___27 ;
  char *tmp___841 ;
  void *tmp___842 ;
  int csiz ;
  char *cbuf ;
  char *tmp___843 ;
  int TC_mysize___28 ;
  int TC_index___28 ;
  TCLISTDATUM *tmp___844 ;
  void *tmp___845 ;
  TCLISTDATUM *array___28 ;
  char *tmp___846 ;
  void *tmp___847 ;
  _Bool tmp___848 ;
  char const   *params___4 ;
  void *tmp___849 ;
  _Bool tmp___850 ;
  _Bool tmp___851 ;
  int64_t step___1 ;
  int64_t tmp___852 ;
  int64_t tmp___853 ;
  _Bool tmp___854 ;
  _Bool err___21 ;
  int i___18 ;
  char const   *kbuf___44 ;
  int ksiz___44 ;
  int vsiz___27 ;
  char const   *vbuf___27 ;
  void const   *tmp___855 ;
  int type ;
  int tmp___856 ;
  _Bool tmp___857 ;
  _Bool toout ;
  _Bool tocnt ;
  _Bool tohint ;
  TDBQRY *qry ;
  TDBQRY *tmp___858 ;
  TDBQRY **qrys ;
  int qnum ;
  int mstype ;
  TCLIST *cnames ;
  int i___19 ;
  char const   *arg ;
  int asiz ;
  TCLIST *tokens ;
  TCLIST *tmp___859 ;
  int tnum ;
  char const   *cmd ;
  char const   *name___0 ;
  char const   *opstr ;
  char const   *expr ;
  int op ;
  int tmp___860 ;
  char const   *name___1 ;
  char const   *typestr ;
  int type___0 ;
  int tmp___861 ;
  char const   *maxstr ;
  int max ;
  int64_t tmp___862 ;
  int skip ;
  int64_t tmp___863 ;
  int j___0 ;
  char const   *token ;
  int tsiz ;
  int TC_mysize___29 ;
  int TC_index___29 ;
  TCLISTDATUM *tmp___864 ;
  void *tmp___865 ;
  TCLISTDATUM *array___29 ;
  char *tmp___866 ;
  void *tmp___867 ;
  void *tmp___868 ;
  void *tmp___869 ;
  int tmp___870 ;
  char const   *typestr___0 ;
  size_t __s1_len___88 ;
  size_t __s2_len___88 ;
  int tmp___872 ;
  int tmp___875 ;
  int tmp___876 ;
  int tmp___877 ;
  size_t __s1_len___89 ;
  size_t __s2_len___89 ;
  int tmp___879 ;
  int tmp___882 ;
  int tmp___883 ;
  int tmp___884 ;
  size_t __s1_len___90 ;
  size_t __s2_len___90 ;
  int tmp___886 ;
  int tmp___889 ;
  int tmp___890 ;
  int tmp___891 ;
  size_t __s1_len___91 ;
  size_t __s2_len___91 ;
  int tmp___893 ;
  int tmp___896 ;
  int tmp___897 ;
  int tmp___898 ;
  size_t __s1_len___92 ;
  size_t __s2_len___92 ;
  int tmp___900 ;
  int tmp___903 ;
  int tmp___904 ;
  int tmp___905 ;
  size_t __s1_len___93 ;
  size_t __s2_len___93 ;
  int tmp___907 ;
  int tmp___910 ;
  int tmp___911 ;
  int tmp___912 ;
  size_t __s1_len___94 ;
  size_t __s2_len___94 ;
  int tmp___914 ;
  int tmp___917 ;
  int tmp___918 ;
  int tmp___919 ;
  size_t __s1_len___95 ;
  size_t __s2_len___95 ;
  int tmp___921 ;
  int tmp___924 ;
  int tmp___925 ;
  int tmp___926 ;
  size_t __s1_len___96 ;
  size_t __s2_len___96 ;
  int tmp___928 ;
  int tmp___931 ;
  int tmp___932 ;
  int tmp___933 ;
  size_t __s1_len___97 ;
  size_t __s2_len___97 ;
  int tmp___935 ;
  int tmp___938 ;
  int tmp___939 ;
  int tmp___940 ;
  size_t __s1_len___98 ;
  size_t __s2_len___98 ;
  int tmp___942 ;
  int tmp___945 ;
  int tmp___946 ;
  int tmp___947 ;
  size_t __s1_len___99 ;
  size_t __s2_len___99 ;
  int tmp___949 ;
  int tmp___952 ;
  int tmp___953 ;
  int tmp___954 ;
  size_t __s1_len___100 ;
  size_t __s2_len___100 ;
  int tmp___956 ;
  int tmp___959 ;
  int tmp___960 ;
  int tmp___961 ;
  size_t __s1_len___101 ;
  size_t __s2_len___101 ;
  int tmp___963 ;
  int tmp___966 ;
  int tmp___967 ;
  int tmp___968 ;
  size_t __s1_len___102 ;
  size_t __s2_len___102 ;
  int tmp___970 ;
  int tmp___973 ;
  int tmp___974 ;
  int tmp___975 ;
  size_t __s1_len___103 ;
  size_t __s2_len___103 ;
  int tmp___977 ;
  int tmp___980 ;
  int tmp___981 ;
  int tmp___982 ;
  void *opq[2] ;
  _Bool tmp___983 ;
  _Bool tmp___984 ;
  int cnnum ;
  int rnum ;
  TCLIST *nrv ;
  TCLIST *tmp___985 ;
  int i___20 ;
  char const   *pkbuf___4 ;
  int pksiz___4 ;
  TCMAP *cols___1 ;
  TCMAP *tmp___986 ;
  TCMAP *ncols ;
  TCMAP *tmp___987 ;
  int j___1 ;
  char const   *cname ;
  int cnsiz ;
  int cvsiz ;
  char const   *cvalue ;
  void const   *tmp___988 ;
  int csiz___0 ;
  char *cbuf___0 ;
  void *tmp___989 ;
  char numbuf[32] ;
  int len ;
  int tmp___990 ;
  int tmp___991 ;
  TCXSTR *hbuf ;
  TCXSTR *tmp___992 ;
  int TC_mysize___30 ;
  int TC_nsize ;
  char *tmp___993 ;
  void *tmp___994 ;
  int TC_mysize___31 ;
  int TC_nsize___0 ;
  char *tmp___995 ;
  void *tmp___996 ;
  int TC_mysize___32 ;
  int TC_nsize___1 ;
  char *tmp___997 ;
  void *tmp___998 ;
  char const   *hint ;
  TDBQRY *tmp___999 ;
  char const   *tmp___1000 ;
  int TC_mysize___33 ;
  size_t tmp___1001 ;
  int TC_nsize___2 ;
  char *tmp___1002 ;
  void *tmp___1003 ;
  int TC_mysize___34 ;
  int TC_index___30 ;
  TCLISTDATUM *tmp___1004 ;
  void *tmp___1005 ;
  TCLISTDATUM *array___30 ;
  char *tmp___1006 ;
  void *tmp___1007 ;
  int i___21 ;
  char numbuf___0[32] ;
  int nsiz ;
  int64_t tmp___1008 ;
  int tmp___1009 ;
  int TC_mysize___35 ;
  int TC_index___31 ;
  TCLISTDATUM *tmp___1010 ;
  void *tmp___1011 ;
  TCLISTDATUM *array___31 ;
  char *tmp___1012 ;
  void *tmp___1013 ;
  size_t __s1_len___104 ;
  size_t __s2_len___104 ;
  int tmp___1015 ;
  int tmp___1018 ;
  int tmp___1019 ;
  int tmp___1020 ;
  size_t __s1_len___105 ;
  size_t __s2_len___105 ;
  int tmp___1022 ;
  int tmp___1025 ;
  int tmp___1026 ;
  int tmp___1027 ;
  size_t __s1_len___106 ;
  size_t __s2_len___106 ;
  int tmp___1029 ;
  int tmp___1032 ;
  int tmp___1033 ;
  int tmp___1034 ;
  size_t __s1_len___107 ;
  size_t __s2_len___107 ;
  int tmp___1036 ;
  int tmp___1039 ;
  int tmp___1040 ;
  int tmp___1041 ;
  size_t __s1_len___108 ;
  size_t __s2_len___108 ;
  int tmp___1043 ;
  int tmp___1046 ;
  int tmp___1047 ;
  int tmp___1048 ;
  size_t __s1_len___109 ;
  size_t __s2_len___109 ;
  int tmp___1050 ;
  int tmp___1053 ;
  int tmp___1054 ;
  int tmp___1055 ;
  size_t __s1_len___110 ;
  size_t __s2_len___110 ;
  int tmp___1057 ;
  int tmp___1060 ;
  int tmp___1061 ;
  int tmp___1062 ;
  size_t __s1_len___111 ;
  size_t __s2_len___111 ;
  int tmp___1064 ;
  int tmp___1067 ;
  int tmp___1068 ;
  int tmp___1069 ;
  size_t __s1_len___112 ;
  size_t __s2_len___112 ;
  int tmp___1071 ;
  int tmp___1074 ;
  int tmp___1075 ;
  int tmp___1076 ;
  size_t __s1_len___113 ;
  size_t __s2_len___113 ;
  int tmp___1078 ;
  int tmp___1081 ;
  int tmp___1082 ;
  int tmp___1083 ;
  size_t __s1_len___114 ;
  size_t __s2_len___114 ;
  int tmp___1085 ;
  int tmp___1088 ;
  int tmp___1089 ;
  int tmp___1090 ;
  size_t __s1_len___115 ;
  size_t __s2_len___115 ;
  int tmp___1092 ;
  int tmp___1095 ;
  int tmp___1096 ;
  int tmp___1097 ;
  size_t __s1_len___116 ;
  size_t __s2_len___116 ;
  int tmp___1099 ;
  int tmp___1102 ;
  int tmp___1103 ;
  int tmp___1104 ;
  size_t __s1_len___117 ;
  size_t __s2_len___117 ;
  int tmp___1106 ;
  int tmp___1109 ;
  int tmp___1110 ;
  int tmp___1111 ;
  size_t __s1_len___118 ;
  size_t __s2_len___118 ;
  int tmp___1113 ;
  int tmp___1116 ;
  int tmp___1117 ;
  int tmp___1118 ;
  size_t __s1_len___119 ;
  size_t __s2_len___119 ;
  int tmp___1120 ;
  int tmp___1123 ;
  int tmp___1124 ;
  int tmp___1125 ;
  size_t __s1_len___120 ;
  size_t __s2_len___120 ;
  int tmp___1127 ;
  int tmp___1130 ;
  int tmp___1131 ;
  int tmp___1132 ;
  size_t __s1_len___121 ;
  size_t __s2_len___121 ;
  int tmp___1134 ;
  int tmp___1137 ;
  int tmp___1138 ;
  int tmp___1139 ;

  {
  argc = (int )args->num;
  switch (adb->omode) {
  case 1: 
  if (0) {
    __s1_len___12 = strlen(name);
    __s2_len___12 = strlen("put");
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___26;
    } else {
      if (__s1_len___12 >= 4U) {
        _L___26: 
        if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
          tmp___127 = 1;
        } else {
          if (__s2_len___12 >= 4U) {
            tmp___127 = 1;
          } else {
            tmp___127 = 0;
          }
        }
      } else {
        tmp___127 = 0;
      }
    }
    if (tmp___127) {
      tmp___122 = __builtin_strcmp(name, "put");
      tmp___126 = tmp___122;
    } else {
      tmp___125 = __builtin_strcmp(name, "put");
      tmp___126 = tmp___125;
    }
  } else {
    tmp___125 = __builtin_strcmp(name, "put");
    tmp___126 = tmp___125;
  }
  if (tmp___126) {
    if (0) {
      __s1_len___13 = strlen(name);
      __s2_len___13 = strlen("putkeep");
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___28;
      } else {
        if (__s1_len___13 >= 4U) {
          _L___28: 
          if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
            tmp___134 = 1;
          } else {
            if (__s2_len___13 >= 4U) {
              tmp___134 = 1;
            } else {
              tmp___134 = 0;
            }
          }
        } else {
          tmp___134 = 0;
        }
      }
      if (tmp___134) {
        tmp___129 = __builtin_strcmp(name, "putkeep");
        tmp___133 = tmp___129;
      } else {
        tmp___132 = __builtin_strcmp(name, "putkeep");
        tmp___133 = tmp___132;
      }
    } else {
      tmp___132 = __builtin_strcmp(name, "putkeep");
      tmp___133 = tmp___132;
    }
    if (tmp___133) {
      if (0) {
        __s1_len___14 = strlen(name);
        __s2_len___14 = strlen("putcat");
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___30;
        } else {
          if (__s1_len___14 >= 4U) {
            _L___30: 
            if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
              tmp___141 = 1;
            } else {
              if (__s2_len___14 >= 4U) {
                tmp___141 = 1;
              } else {
                tmp___141 = 0;
              }
            }
          } else {
            tmp___141 = 0;
          }
        }
        if (tmp___141) {
          tmp___136 = __builtin_strcmp(name, "putcat");
          tmp___140 = tmp___136;
        } else {
          tmp___139 = __builtin_strcmp(name, "putcat");
          tmp___140 = tmp___139;
        }
      } else {
        tmp___139 = __builtin_strcmp(name, "putcat");
        tmp___140 = tmp___139;
      }
      if (tmp___140) {
        if (0) {
          __s1_len___11 = strlen(name);
          __s2_len___11 = strlen("out");
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___24;
          } else {
            if (__s1_len___11 >= 4U) {
              _L___24: 
              if (! ((unsigned int )((void const   *)("out" + 1)) - (unsigned int )((void const   *)"out") == 1U)) {
                tmp___120 = 1;
              } else {
                if (__s2_len___11 >= 4U) {
                  tmp___120 = 1;
                } else {
                  tmp___120 = 0;
                }
              }
            } else {
              tmp___120 = 0;
            }
          }
          if (tmp___120) {
            tmp___115 = __builtin_strcmp(name, "out");
            tmp___119 = tmp___115;
          } else {
            tmp___118 = __builtin_strcmp(name, "out");
            tmp___119 = tmp___118;
          }
        } else {
          tmp___118 = __builtin_strcmp(name, "out");
          tmp___119 = tmp___118;
        }
        if (tmp___119) {
          if (0) {
            __s1_len___10 = strlen(name);
            __s2_len___10 = strlen("get");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___22;
            } else {
              if (__s1_len___10 >= 4U) {
                _L___22: 
                if (! ((unsigned int )((void const   *)("get" + 1)) - (unsigned int )((void const   *)"get") == 1U)) {
                  tmp___113 = 1;
                } else {
                  if (__s2_len___10 >= 4U) {
                    tmp___113 = 1;
                  } else {
                    tmp___113 = 0;
                  }
                }
              } else {
                tmp___113 = 0;
              }
            }
            if (tmp___113) {
              tmp___108 = __builtin_strcmp(name, "get");
              tmp___112 = tmp___108;
            } else {
              tmp___111 = __builtin_strcmp(name, "get");
              tmp___112 = tmp___111;
            }
          } else {
            tmp___111 = __builtin_strcmp(name, "get");
            tmp___112 = tmp___111;
          }
          if (tmp___112) {
            if (0) {
              __s1_len___9 = strlen(name);
              __s2_len___9 = strlen("putlist");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___20;
              } else {
                if (__s1_len___9 >= 4U) {
                  _L___20: 
                  if (! ((unsigned int )((void const   *)("putlist" + 1)) - (unsigned int )((void const   *)"putlist") == 1U)) {
                    tmp___106 = 1;
                  } else {
                    if (__s2_len___9 >= 4U) {
                      tmp___106 = 1;
                    } else {
                      tmp___106 = 0;
                    }
                  }
                } else {
                  tmp___106 = 0;
                }
              }
              if (tmp___106) {
                tmp___101 = __builtin_strcmp(name, "putlist");
                tmp___105 = tmp___101;
              } else {
                tmp___104 = __builtin_strcmp(name, "putlist");
                tmp___105 = tmp___104;
              }
            } else {
              tmp___104 = __builtin_strcmp(name, "putlist");
              tmp___105 = tmp___104;
            }
            if (tmp___105) {
              if (0) {
                __s1_len___8 = strlen(name);
                __s2_len___8 = strlen("outlist");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___18;
                } else {
                  if (__s1_len___8 >= 4U) {
                    _L___18: 
                    if (! ((unsigned int )((void const   *)("outlist" + 1)) - (unsigned int )((void const   *)"outlist") == 1U)) {
                      tmp___99 = 1;
                    } else {
                      if (__s2_len___8 >= 4U) {
                        tmp___99 = 1;
                      } else {
                        tmp___99 = 0;
                      }
                    }
                  } else {
                    tmp___99 = 0;
                  }
                }
                if (tmp___99) {
                  tmp___94 = __builtin_strcmp(name, "outlist");
                  tmp___98 = tmp___94;
                } else {
                  tmp___97 = __builtin_strcmp(name, "outlist");
                  tmp___98 = tmp___97;
                }
              } else {
                tmp___97 = __builtin_strcmp(name, "outlist");
                tmp___98 = tmp___97;
              }
              if (tmp___98) {
                if (0) {
                  __s1_len___7 = strlen(name);
                  __s2_len___7 = strlen("getlist");
                  if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                    goto _L___16;
                  } else {
                    if (__s1_len___7 >= 4U) {
                      _L___16: 
                      if (! ((unsigned int )((void const   *)("getlist" + 1)) - (unsigned int )((void const   *)"getlist") == 1U)) {
                        tmp___92 = 1;
                      } else {
                        if (__s2_len___7 >= 4U) {
                          tmp___92 = 1;
                        } else {
                          tmp___92 = 0;
                        }
                      }
                    } else {
                      tmp___92 = 0;
                    }
                  }
                  if (tmp___92) {
                    tmp___87 = __builtin_strcmp(name, "getlist");
                    tmp___91 = tmp___87;
                  } else {
                    tmp___90 = __builtin_strcmp(name, "getlist");
                    tmp___91 = tmp___90;
                  }
                } else {
                  tmp___90 = __builtin_strcmp(name, "getlist");
                  tmp___91 = tmp___90;
                }
                if (tmp___91) {
                  if (0) {
                    __s1_len___6 = strlen(name);
                    __s2_len___6 = strlen("iterinit");
                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                      goto _L___14;
                    } else {
                      if (__s1_len___6 >= 4U) {
                        _L___14: 
                        if (! ((unsigned int )((void const   *)("iterinit" + 1)) - (unsigned int )((void const   *)"iterinit") == 1U)) {
                          tmp___85 = 1;
                        } else {
                          if (__s2_len___6 >= 4U) {
                            tmp___85 = 1;
                          } else {
                            tmp___85 = 0;
                          }
                        }
                      } else {
                        tmp___85 = 0;
                      }
                    }
                    if (tmp___85) {
                      tmp___80 = __builtin_strcmp(name, "iterinit");
                      tmp___84 = tmp___80;
                    } else {
                      tmp___83 = __builtin_strcmp(name, "iterinit");
                      tmp___84 = tmp___83;
                    }
                  } else {
                    tmp___83 = __builtin_strcmp(name, "iterinit");
                    tmp___84 = tmp___83;
                  }
                  if (tmp___84) {
                    if (0) {
                      __s1_len___5 = strlen(name);
                      __s2_len___5 = strlen("iternext");
                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                        goto _L___12;
                      } else {
                        if (__s1_len___5 >= 4U) {
                          _L___12: 
                          if (! ((unsigned int )((void const   *)("iternext" + 1)) - (unsigned int )((void const   *)"iternext") == 1U)) {
                            tmp___78 = 1;
                          } else {
                            if (__s2_len___5 >= 4U) {
                              tmp___78 = 1;
                            } else {
                              tmp___78 = 0;
                            }
                          }
                        } else {
                          tmp___78 = 0;
                        }
                      }
                      if (tmp___78) {
                        tmp___73 = __builtin_strcmp(name, "iternext");
                        tmp___77 = tmp___73;
                      } else {
                        tmp___76 = __builtin_strcmp(name, "iternext");
                        tmp___77 = tmp___76;
                      }
                    } else {
                      tmp___76 = __builtin_strcmp(name, "iternext");
                      tmp___77 = tmp___76;
                    }
                    if (tmp___77) {
                      if (0) {
                        __s1_len___4 = strlen(name);
                        __s2_len___4 = strlen("sync");
                        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                          goto _L___10;
                        } else {
                          if (__s1_len___4 >= 4U) {
                            _L___10: 
                            if (! ((unsigned int )((void const   *)("sync" + 1)) - (unsigned int )((void const   *)"sync") == 1U)) {
                              tmp___71 = 1;
                            } else {
                              if (__s2_len___4 >= 4U) {
                                tmp___71 = 1;
                              } else {
                                tmp___71 = 0;
                              }
                            }
                          } else {
                            tmp___71 = 0;
                          }
                        }
                        if (tmp___71) {
                          tmp___66 = __builtin_strcmp(name, "sync");
                          tmp___70 = tmp___66;
                        } else {
                          tmp___69 = __builtin_strcmp(name, "sync");
                          tmp___70 = tmp___69;
                        }
                      } else {
                        tmp___69 = __builtin_strcmp(name, "sync");
                        tmp___70 = tmp___69;
                      }
                      if (tmp___70) {
                        if (0) {
                          __s1_len___3 = strlen(name);
                          __s2_len___3 = strlen("optimize");
                          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                            goto _L___8;
                          } else {
                            if (__s1_len___3 >= 4U) {
                              _L___8: 
                              if (! ((unsigned int )((void const   *)("optimize" + 1)) - (unsigned int )((void const   *)"optimize") == 1U)) {
                                tmp___64 = 1;
                              } else {
                                if (__s2_len___3 >= 4U) {
                                  tmp___64 = 1;
                                } else {
                                  tmp___64 = 0;
                                }
                              }
                            } else {
                              tmp___64 = 0;
                            }
                          }
                          if (tmp___64) {
                            tmp___59 = __builtin_strcmp(name, "optimize");
                            tmp___63 = tmp___59;
                          } else {
                            tmp___62 = __builtin_strcmp(name, "optimize");
                            tmp___63 = tmp___62;
                          }
                        } else {
                          tmp___62 = __builtin_strcmp(name, "optimize");
                          tmp___63 = tmp___62;
                        }
                        if (tmp___63) {
                          if (0) {
                            __s1_len___2 = strlen(name);
                            __s2_len___2 = strlen("vanish");
                            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                              goto _L___6;
                            } else {
                              if (__s1_len___2 >= 4U) {
                                _L___6: 
                                if (! ((unsigned int )((void const   *)("vanish" + 1)) - (unsigned int )((void const   *)"vanish") == 1U)) {
                                  tmp___57 = 1;
                                } else {
                                  if (__s2_len___2 >= 4U) {
                                    tmp___57 = 1;
                                  } else {
                                    tmp___57 = 0;
                                  }
                                }
                              } else {
                                tmp___57 = 0;
                              }
                            }
                            if (tmp___57) {
                              tmp___52 = __builtin_strcmp(name, "vanish");
                              tmp___56 = tmp___52;
                            } else {
                              tmp___55 = __builtin_strcmp(name, "vanish");
                              tmp___56 = tmp___55;
                            }
                          } else {
                            tmp___55 = __builtin_strcmp(name, "vanish");
                            tmp___56 = tmp___55;
                          }
                          if (tmp___56) {
                            rv = (TCLIST *)((void *)0);
                          } else {
                            rv = tclistnew2(1);
                            tmp___50 = tcadbvanish(adb);
                            if (! tmp___50) {
                              tclistdel(rv);
                              rv = (TCLIST *)((void *)0);
                            }
                          }
                        } else {
                          rv = tclistnew2(1);
                          if (argc > 0) {
                            tmp___48 = (void *)(args->array + (int )args->start)->ptr;
                          } else {
                            tmp___48 = (void *)0;
                          }
                          params = (char const   *)tmp___48;
                          tmp___49 = tcadboptimize(adb, params);
                          if (! tmp___49) {
                            tclistdel(rv);
                            rv = (TCLIST *)((void *)0);
                          }
                        }
                      } else {
                        rv = tclistnew2(1);
                        tmp___47 = tcadbsync(adb);
                        if (! tmp___47) {
                          tclistdel(rv);
                          rv = (TCLIST *)((void *)0);
                        }
                      }
                    } else {
                      rv = tclistnew2(1);
                      tmp___37 = tcmdbiternext(adb->mdb, & ksiz___6);
                      kbuf___6 = (char *)tmp___37;
                      if (kbuf___6) {
                        while (1) {
                          TC_mysize___2 = ksiz___6;
                          TC_index___2 = rv->start + rv->num;
                          if (TC_index___2 >= rv->anum) {
                            rv->anum += rv->num + 1;
                            while (1) {
                              tmp___39 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                              tmp___38 = (TCLISTDATUM *)tmp___39;
                              rv->array = tmp___38;
                              if (! tmp___38) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                          }
                          array___2 = rv->array;
                          while (1) {
                            tmp___41 = malloc((unsigned int )(TC_mysize___2 + 1));
                            tmp___40 = (char *)tmp___41;
                            (array___2 + TC_index___2)->ptr = tmp___40;
                            if (! tmp___40) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                          memcpy((void * __restrict  )(array___2 + TC_index___2)->ptr,
                                 (void const   * __restrict  )kbuf___6, (unsigned int )TC_mysize___2);
                          *((array___2 + TC_index___2)->ptr + TC_mysize___2) = (char )'\000';
                          (array___2 + TC_index___2)->size = TC_mysize___2;
                          (rv->num) ++;
                          break;
                        }
                        tmp___42 = tcmdbget(adb->mdb, (void const   *)kbuf___6, ksiz___6,
                                            & vsiz___3);
                        vbuf___3 = (char *)tmp___42;
                        if (vbuf___3) {
                          while (1) {
                            TC_mysize___3 = vsiz___3;
                            TC_index___3 = rv->start + rv->num;
                            if (TC_index___3 >= rv->anum) {
                              rv->anum += rv->num + 1;
                              while (1) {
                                tmp___44 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                                tmp___43 = (TCLISTDATUM *)tmp___44;
                                rv->array = tmp___43;
                                if (! tmp___43) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                            }
                            array___3 = rv->array;
                            while (1) {
                              tmp___46 = malloc((unsigned int )(TC_mysize___3 + 1));
                              tmp___45 = (char *)tmp___46;
                              (array___3 + TC_index___3)->ptr = tmp___45;
                              if (! tmp___45) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                            memcpy((void * __restrict  )(array___3 + TC_index___3)->ptr,
                                   (void const   * __restrict  )vbuf___3, (unsigned int )TC_mysize___3);
                            *((array___3 + TC_index___3)->ptr + TC_mysize___3) = (char )'\000';
                            (array___3 + TC_index___3)->size = TC_mysize___3;
                            (rv->num) ++;
                            break;
                          }
                          while (1) {
                            free((void *)vbuf___3);
                            break;
                          }
                        }
                        while (1) {
                          free((void *)kbuf___6);
                          break;
                        }
                      } else {
                        tclistdel(rv);
                        rv = (TCLIST *)((void *)0);
                      }
                    }
                  } else {
                    rv = tclistnew2(1);
                    if (argc > 0) {
                      while (1) {
                        kbuf___5 = (char const   *)(args->array + (int )args->start)->ptr;
                        ksiz___5 = (args->array + (int )args->start)->size;
                        break;
                      }
                      tcmdbiterinit2(adb->mdb, (void const   *)kbuf___5, ksiz___5);
                    } else {
                      tcmdbiterinit(adb->mdb);
                    }
                  }
                } else {
                  rv = tclistnew2(argc * 2);
                  i___1 = 0;
                  while (i___1 < argc) {
                    while (1) {
                      kbuf___4 = (char const   *)(args->array + (i___1 + (int )args->start))->ptr;
                      ksiz___4 = (args->array + (i___1 + (int )args->start))->size;
                      break;
                    }
                    tmp___28 = tcmdbget(adb->mdb, (void const   *)kbuf___4, ksiz___4,
                                        & vsiz___2);
                    vbuf___2 = (char *)tmp___28;
                    if (vbuf___2) {
                      while (1) {
                        TC_mysize___0 = ksiz___4;
                        TC_index___0 = rv->start + rv->num;
                        if (TC_index___0 >= rv->anum) {
                          rv->anum += rv->num + 1;
                          while (1) {
                            tmp___30 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                            tmp___29 = (TCLISTDATUM *)tmp___30;
                            rv->array = tmp___29;
                            if (! tmp___29) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___0 = rv->array;
                        while (1) {
                          tmp___32 = malloc((unsigned int )(TC_mysize___0 + 1));
                          tmp___31 = (char *)tmp___32;
                          (array___0 + TC_index___0)->ptr = tmp___31;
                          if (! tmp___31) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___0 + TC_index___0)->ptr,
                               (void const   * __restrict  )kbuf___4, (unsigned int )TC_mysize___0);
                        *((array___0 + TC_index___0)->ptr + TC_mysize___0) = (char )'\000';
                        (array___0 + TC_index___0)->size = TC_mysize___0;
                        (rv->num) ++;
                        break;
                      }
                      while (1) {
                        TC_mysize___1 = vsiz___2;
                        TC_index___1 = rv->start + rv->num;
                        if (TC_index___1 >= rv->anum) {
                          rv->anum += rv->num + 1;
                          while (1) {
                            tmp___34 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                            tmp___33 = (TCLISTDATUM *)tmp___34;
                            rv->array = tmp___33;
                            if (! tmp___33) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___1 = rv->array;
                        while (1) {
                          tmp___36 = malloc((unsigned int )(TC_mysize___1 + 1));
                          tmp___35 = (char *)tmp___36;
                          (array___1 + TC_index___1)->ptr = tmp___35;
                          if (! tmp___35) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___1 + TC_index___1)->ptr,
                               (void const   * __restrict  )vbuf___2, (unsigned int )TC_mysize___1);
                        *((array___1 + TC_index___1)->ptr + TC_mysize___1) = (char )'\000';
                        (array___1 + TC_index___1)->size = TC_mysize___1;
                        (rv->num) ++;
                        break;
                      }
                      while (1) {
                        free((void *)vbuf___2);
                        break;
                      }
                    }
                    i___1 ++;
                  }
                }
              } else {
                rv = tclistnew2(1);
                i___0 = 0;
                while (i___0 < argc) {
                  while (1) {
                    kbuf___3 = (char const   *)(args->array + (i___0 + (int )args->start))->ptr;
                    ksiz___3 = (args->array + (i___0 + (int )args->start))->size;
                    break;
                  }
                  tcmdbout(adb->mdb, (void const   *)kbuf___3, ksiz___3);
                  i___0 ++;
                }
              }
            } else {
              rv = tclistnew2(1);
              argc --;
              i = 0;
              while (i < argc) {
                while (1) {
                  kbuf___2 = (char const   *)(args->array + (i + (int )args->start))->ptr;
                  ksiz___2 = (args->array + (i + (int )args->start))->size;
                  break;
                }
                tmp___27 = tclistval(args, i + 1, & vsiz___1);
                vbuf___1 = (char const   *)tmp___27;
                tcmdbput(adb->mdb, (void const   *)kbuf___2, ksiz___2, (void const   *)vbuf___1,
                         vsiz___1);
                i += 2;
              }
            }
          } else {
            if (argc > 0) {
              rv = tclistnew2(1);
              while (1) {
                kbuf___1 = (char const   *)(args->array + (int )args->start)->ptr;
                ksiz___1 = (args->array + (int )args->start)->size;
                break;
              }
              tmp___22 = tcmdbget(adb->mdb, (void const   *)kbuf___1, ksiz___1, & vsiz___0);
              vbuf___0 = (char *)tmp___22;
              if (vbuf___0) {
                while (1) {
                  TC_mysize = vsiz___0;
                  TC_index = rv->start + rv->num;
                  if (TC_index >= rv->anum) {
                    rv->anum += rv->num + 1;
                    while (1) {
                      tmp___24 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                      tmp___23 = (TCLISTDATUM *)tmp___24;
                      rv->array = tmp___23;
                      if (! tmp___23) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                  }
                  array = rv->array;
                  while (1) {
                    tmp___26 = malloc((unsigned int )(TC_mysize + 1));
                    tmp___25 = (char *)tmp___26;
                    (array + TC_index)->ptr = tmp___25;
                    if (! tmp___25) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                  memcpy((void * __restrict  )(array + TC_index)->ptr, (void const   * __restrict  )vbuf___0,
                         (unsigned int )TC_mysize);
                  *((array + TC_index)->ptr + TC_mysize) = (char )'\000';
                  (array + TC_index)->size = TC_mysize;
                  (rv->num) ++;
                  break;
                }
                while (1) {
                  free((void *)vbuf___0);
                  break;
                }
              } else {
                tclistdel(rv);
                rv = (TCLIST *)((void *)0);
              }
            } else {
              rv = (TCLIST *)((void *)0);
            }
          }
        } else {
          if (argc > 0) {
            rv = tclistnew2(1);
            while (1) {
              kbuf___0 = (char const   *)(args->array + (int )args->start)->ptr;
              ksiz___0 = (args->array + (int )args->start)->size;
              break;
            }
            tmp___21 = tcmdbout(adb->mdb, (void const   *)kbuf___0, ksiz___0);
            if (! tmp___21) {
              tclistdel(rv);
              rv = (TCLIST *)((void *)0);
            }
          } else {
            rv = (TCLIST *)((void *)0);
          }
        }
      } else {
        _L___31: 
        if (argc > 1) {
          rv = tclistnew2(1);
          while (1) {
            kbuf = (char const   *)(args->array + (int )args->start)->ptr;
            ksiz = (args->array + (int )args->start)->size;
            break;
          }
          while (1) {
            vbuf = (char const   *)(args->array + (1 + (int )args->start))->ptr;
            vsiz = (args->array + (1 + (int )args->start))->size;
            break;
          }
          err = (_Bool)0;
          if (0) {
            __s1_len___1 = strlen(name);
            __s2_len___1 = strlen("put");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___4;
            } else {
              if (__s1_len___1 >= 4U) {
                _L___4: 
                if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
                  tmp___20 = 1;
                } else {
                  if (__s2_len___1 >= 4U) {
                    tmp___20 = 1;
                  } else {
                    tmp___20 = 0;
                  }
                }
              } else {
                tmp___20 = 0;
              }
            }
            if (tmp___20) {
              tmp___15 = __builtin_strcmp(name, "put");
              tmp___19 = tmp___15;
            } else {
              tmp___18 = __builtin_strcmp(name, "put");
              tmp___19 = tmp___18;
            }
          } else {
            tmp___18 = __builtin_strcmp(name, "put");
            tmp___19 = tmp___18;
          }
          if (tmp___19) {
            if (0) {
              __s1_len___0 = strlen(name);
              __s2_len___0 = strlen("putkeep");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___2;
              } else {
                if (__s1_len___0 >= 4U) {
                  _L___2: 
                  if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
                    tmp___13 = 1;
                  } else {
                    if (__s2_len___0 >= 4U) {
                      tmp___13 = 1;
                    } else {
                      tmp___13 = 0;
                    }
                  }
                } else {
                  tmp___13 = 0;
                }
              }
              if (tmp___13) {
                tmp___8 = __builtin_strcmp(name, "putkeep");
                tmp___12 = tmp___8;
              } else {
                tmp___11 = __builtin_strcmp(name, "putkeep");
                tmp___12 = tmp___11;
              }
            } else {
              tmp___11 = __builtin_strcmp(name, "putkeep");
              tmp___12 = tmp___11;
            }
            if (tmp___12) {
              if (0) {
                __s1_len = strlen(name);
                __s2_len = strlen("putcat");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___0;
                } else {
                  if (__s1_len >= 4U) {
                    _L___0: 
                    if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
                      tmp___6 = 1;
                    } else {
                      if (__s2_len >= 4U) {
                        tmp___6 = 1;
                      } else {
                        tmp___6 = 0;
                      }
                    }
                  } else {
                    tmp___6 = 0;
                  }
                }
                if (tmp___6) {
                  tmp___1 = __builtin_strcmp(name, "putcat");
                  tmp___5 = tmp___1;
                } else {
                  tmp___4 = __builtin_strcmp(name, "putcat");
                  tmp___5 = tmp___4;
                }
              } else {
                tmp___4 = __builtin_strcmp(name, "putcat");
                tmp___5 = tmp___4;
              }
              if (! tmp___5) {
                tcmdbputcat(adb->mdb, (void const   *)kbuf, ksiz, (void const   *)vbuf,
                            vsiz);
              }
            } else {
              tmp = tcmdbputkeep(adb->mdb, (void const   *)kbuf, ksiz, (void const   *)vbuf,
                                 vsiz);
              if (! tmp) {
                err = (_Bool)1;
              }
            }
          } else {
            tcmdbput(adb->mdb, (void const   *)kbuf, ksiz, (void const   *)vbuf, vsiz);
          }
          if (err) {
            tclistdel(rv);
            rv = (TCLIST *)((void *)0);
          }
        } else {
          rv = (TCLIST *)((void *)0);
        }
      }
    } else {
      goto _L___31;
    }
  } else {
    goto _L___31;
  }
  break;
  case 2: 
  if (0) {
    __s1_len___28 = strlen(name);
    __s2_len___28 = strlen("put");
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___59;
    } else {
      if (__s1_len___28 >= 4U) {
        _L___59: 
        if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
          tmp___270 = 1;
        } else {
          if (__s2_len___28 >= 4U) {
            tmp___270 = 1;
          } else {
            tmp___270 = 0;
          }
        }
      } else {
        tmp___270 = 0;
      }
    }
    if (tmp___270) {
      tmp___265 = __builtin_strcmp(name, "put");
      tmp___269 = tmp___265;
    } else {
      tmp___268 = __builtin_strcmp(name, "put");
      tmp___269 = tmp___268;
    }
  } else {
    tmp___268 = __builtin_strcmp(name, "put");
    tmp___269 = tmp___268;
  }
  if (tmp___269) {
    if (0) {
      __s1_len___29 = strlen(name);
      __s2_len___29 = strlen("putkeep");
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___61;
      } else {
        if (__s1_len___29 >= 4U) {
          _L___61: 
          if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
            tmp___277 = 1;
          } else {
            if (__s2_len___29 >= 4U) {
              tmp___277 = 1;
            } else {
              tmp___277 = 0;
            }
          }
        } else {
          tmp___277 = 0;
        }
      }
      if (tmp___277) {
        tmp___272 = __builtin_strcmp(name, "putkeep");
        tmp___276 = tmp___272;
      } else {
        tmp___275 = __builtin_strcmp(name, "putkeep");
        tmp___276 = tmp___275;
      }
    } else {
      tmp___275 = __builtin_strcmp(name, "putkeep");
      tmp___276 = tmp___275;
    }
    if (tmp___276) {
      if (0) {
        __s1_len___30 = strlen(name);
        __s2_len___30 = strlen("putcat");
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___63;
        } else {
          if (__s1_len___30 >= 4U) {
            _L___63: 
            if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
              tmp___284 = 1;
            } else {
              if (__s2_len___30 >= 4U) {
                tmp___284 = 1;
              } else {
                tmp___284 = 0;
              }
            }
          } else {
            tmp___284 = 0;
          }
        }
        if (tmp___284) {
          tmp___279 = __builtin_strcmp(name, "putcat");
          tmp___283 = tmp___279;
        } else {
          tmp___282 = __builtin_strcmp(name, "putcat");
          tmp___283 = tmp___282;
        }
      } else {
        tmp___282 = __builtin_strcmp(name, "putcat");
        tmp___283 = tmp___282;
      }
      if (tmp___283) {
        if (0) {
          __s1_len___27 = strlen(name);
          __s2_len___27 = strlen("out");
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___57;
          } else {
            if (__s1_len___27 >= 4U) {
              _L___57: 
              if (! ((unsigned int )((void const   *)("out" + 1)) - (unsigned int )((void const   *)"out") == 1U)) {
                tmp___263 = 1;
              } else {
                if (__s2_len___27 >= 4U) {
                  tmp___263 = 1;
                } else {
                  tmp___263 = 0;
                }
              }
            } else {
              tmp___263 = 0;
            }
          }
          if (tmp___263) {
            tmp___258 = __builtin_strcmp(name, "out");
            tmp___262 = tmp___258;
          } else {
            tmp___261 = __builtin_strcmp(name, "out");
            tmp___262 = tmp___261;
          }
        } else {
          tmp___261 = __builtin_strcmp(name, "out");
          tmp___262 = tmp___261;
        }
        if (tmp___262) {
          if (0) {
            __s1_len___26 = strlen(name);
            __s2_len___26 = strlen("get");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___55;
            } else {
              if (__s1_len___26 >= 4U) {
                _L___55: 
                if (! ((unsigned int )((void const   *)("get" + 1)) - (unsigned int )((void const   *)"get") == 1U)) {
                  tmp___256 = 1;
                } else {
                  if (__s2_len___26 >= 4U) {
                    tmp___256 = 1;
                  } else {
                    tmp___256 = 0;
                  }
                }
              } else {
                tmp___256 = 0;
              }
            }
            if (tmp___256) {
              tmp___251 = __builtin_strcmp(name, "get");
              tmp___255 = tmp___251;
            } else {
              tmp___254 = __builtin_strcmp(name, "get");
              tmp___255 = tmp___254;
            }
          } else {
            tmp___254 = __builtin_strcmp(name, "get");
            tmp___255 = tmp___254;
          }
          if (tmp___255) {
            if (0) {
              __s1_len___25 = strlen(name);
              __s2_len___25 = strlen("putlist");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___53;
              } else {
                if (__s1_len___25 >= 4U) {
                  _L___53: 
                  if (! ((unsigned int )((void const   *)("putlist" + 1)) - (unsigned int )((void const   *)"putlist") == 1U)) {
                    tmp___249 = 1;
                  } else {
                    if (__s2_len___25 >= 4U) {
                      tmp___249 = 1;
                    } else {
                      tmp___249 = 0;
                    }
                  }
                } else {
                  tmp___249 = 0;
                }
              }
              if (tmp___249) {
                tmp___244 = __builtin_strcmp(name, "putlist");
                tmp___248 = tmp___244;
              } else {
                tmp___247 = __builtin_strcmp(name, "putlist");
                tmp___248 = tmp___247;
              }
            } else {
              tmp___247 = __builtin_strcmp(name, "putlist");
              tmp___248 = tmp___247;
            }
            if (tmp___248) {
              if (0) {
                __s1_len___24 = strlen(name);
                __s2_len___24 = strlen("outlist");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___51;
                } else {
                  if (__s1_len___24 >= 4U) {
                    _L___51: 
                    if (! ((unsigned int )((void const   *)("outlist" + 1)) - (unsigned int )((void const   *)"outlist") == 1U)) {
                      tmp___242 = 1;
                    } else {
                      if (__s2_len___24 >= 4U) {
                        tmp___242 = 1;
                      } else {
                        tmp___242 = 0;
                      }
                    }
                  } else {
                    tmp___242 = 0;
                  }
                }
                if (tmp___242) {
                  tmp___237 = __builtin_strcmp(name, "outlist");
                  tmp___241 = tmp___237;
                } else {
                  tmp___240 = __builtin_strcmp(name, "outlist");
                  tmp___241 = tmp___240;
                }
              } else {
                tmp___240 = __builtin_strcmp(name, "outlist");
                tmp___241 = tmp___240;
              }
              if (tmp___241) {
                if (0) {
                  __s1_len___23 = strlen(name);
                  __s2_len___23 = strlen("getlist");
                  if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                    goto _L___49;
                  } else {
                    if (__s1_len___23 >= 4U) {
                      _L___49: 
                      if (! ((unsigned int )((void const   *)("getlist" + 1)) - (unsigned int )((void const   *)"getlist") == 1U)) {
                        tmp___235 = 1;
                      } else {
                        if (__s2_len___23 >= 4U) {
                          tmp___235 = 1;
                        } else {
                          tmp___235 = 0;
                        }
                      }
                    } else {
                      tmp___235 = 0;
                    }
                  }
                  if (tmp___235) {
                    tmp___230 = __builtin_strcmp(name, "getlist");
                    tmp___234 = tmp___230;
                  } else {
                    tmp___233 = __builtin_strcmp(name, "getlist");
                    tmp___234 = tmp___233;
                  }
                } else {
                  tmp___233 = __builtin_strcmp(name, "getlist");
                  tmp___234 = tmp___233;
                }
                if (tmp___234) {
                  if (0) {
                    __s1_len___22 = strlen(name);
                    __s2_len___22 = strlen("iterinit");
                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                      goto _L___47;
                    } else {
                      if (__s1_len___22 >= 4U) {
                        _L___47: 
                        if (! ((unsigned int )((void const   *)("iterinit" + 1)) - (unsigned int )((void const   *)"iterinit") == 1U)) {
                          tmp___228 = 1;
                        } else {
                          if (__s2_len___22 >= 4U) {
                            tmp___228 = 1;
                          } else {
                            tmp___228 = 0;
                          }
                        }
                      } else {
                        tmp___228 = 0;
                      }
                    }
                    if (tmp___228) {
                      tmp___223 = __builtin_strcmp(name, "iterinit");
                      tmp___227 = tmp___223;
                    } else {
                      tmp___226 = __builtin_strcmp(name, "iterinit");
                      tmp___227 = tmp___226;
                    }
                  } else {
                    tmp___226 = __builtin_strcmp(name, "iterinit");
                    tmp___227 = tmp___226;
                  }
                  if (tmp___227) {
                    if (0) {
                      __s1_len___21 = strlen(name);
                      __s2_len___21 = strlen("iternext");
                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                        goto _L___45;
                      } else {
                        if (__s1_len___21 >= 4U) {
                          _L___45: 
                          if (! ((unsigned int )((void const   *)("iternext" + 1)) - (unsigned int )((void const   *)"iternext") == 1U)) {
                            tmp___221 = 1;
                          } else {
                            if (__s2_len___21 >= 4U) {
                              tmp___221 = 1;
                            } else {
                              tmp___221 = 0;
                            }
                          }
                        } else {
                          tmp___221 = 0;
                        }
                      }
                      if (tmp___221) {
                        tmp___216 = __builtin_strcmp(name, "iternext");
                        tmp___220 = tmp___216;
                      } else {
                        tmp___219 = __builtin_strcmp(name, "iternext");
                        tmp___220 = tmp___219;
                      }
                    } else {
                      tmp___219 = __builtin_strcmp(name, "iternext");
                      tmp___220 = tmp___219;
                    }
                    if (tmp___220) {
                      if (0) {
                        __s1_len___20 = strlen(name);
                        __s2_len___20 = strlen("sync");
                        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                          goto _L___43;
                        } else {
                          if (__s1_len___20 >= 4U) {
                            _L___43: 
                            if (! ((unsigned int )((void const   *)("sync" + 1)) - (unsigned int )((void const   *)"sync") == 1U)) {
                              tmp___214 = 1;
                            } else {
                              if (__s2_len___20 >= 4U) {
                                tmp___214 = 1;
                              } else {
                                tmp___214 = 0;
                              }
                            }
                          } else {
                            tmp___214 = 0;
                          }
                        }
                        if (tmp___214) {
                          tmp___209 = __builtin_strcmp(name, "sync");
                          tmp___213 = tmp___209;
                        } else {
                          tmp___212 = __builtin_strcmp(name, "sync");
                          tmp___213 = tmp___212;
                        }
                      } else {
                        tmp___212 = __builtin_strcmp(name, "sync");
                        tmp___213 = tmp___212;
                      }
                      if (tmp___213) {
                        if (0) {
                          __s1_len___19 = strlen(name);
                          __s2_len___19 = strlen("optimize");
                          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                            goto _L___41;
                          } else {
                            if (__s1_len___19 >= 4U) {
                              _L___41: 
                              if (! ((unsigned int )((void const   *)("optimize" + 1)) - (unsigned int )((void const   *)"optimize") == 1U)) {
                                tmp___207 = 1;
                              } else {
                                if (__s2_len___19 >= 4U) {
                                  tmp___207 = 1;
                                } else {
                                  tmp___207 = 0;
                                }
                              }
                            } else {
                              tmp___207 = 0;
                            }
                          }
                          if (tmp___207) {
                            tmp___202 = __builtin_strcmp(name, "optimize");
                            tmp___206 = tmp___202;
                          } else {
                            tmp___205 = __builtin_strcmp(name, "optimize");
                            tmp___206 = tmp___205;
                          }
                        } else {
                          tmp___205 = __builtin_strcmp(name, "optimize");
                          tmp___206 = tmp___205;
                        }
                        if (tmp___206) {
                          if (0) {
                            __s1_len___18 = strlen(name);
                            __s2_len___18 = strlen("vanish");
                            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                              goto _L___39;
                            } else {
                              if (__s1_len___18 >= 4U) {
                                _L___39: 
                                if (! ((unsigned int )((void const   *)("vanish" + 1)) - (unsigned int )((void const   *)"vanish") == 1U)) {
                                  tmp___200 = 1;
                                } else {
                                  if (__s2_len___18 >= 4U) {
                                    tmp___200 = 1;
                                  } else {
                                    tmp___200 = 0;
                                  }
                                }
                              } else {
                                tmp___200 = 0;
                              }
                            }
                            if (tmp___200) {
                              tmp___195 = __builtin_strcmp(name, "vanish");
                              tmp___199 = tmp___195;
                            } else {
                              tmp___198 = __builtin_strcmp(name, "vanish");
                              tmp___199 = tmp___198;
                            }
                          } else {
                            tmp___198 = __builtin_strcmp(name, "vanish");
                            tmp___199 = tmp___198;
                          }
                          if (tmp___199) {
                            rv = (TCLIST *)((void *)0);
                          } else {
                            rv = tclistnew2(1);
                            tmp___193 = tcadbvanish(adb);
                            if (! tmp___193) {
                              tclistdel(rv);
                              rv = (TCLIST *)((void *)0);
                            }
                          }
                        } else {
                          rv = tclistnew2(1);
                          if (argc > 0) {
                            tmp___191 = (void *)(args->array + (int )args->start)->ptr;
                          } else {
                            tmp___191 = (void *)0;
                          }
                          params___0 = (char const   *)tmp___191;
                          tmp___192 = tcadboptimize(adb, params___0);
                          if (! tmp___192) {
                            tclistdel(rv);
                            rv = (TCLIST *)((void *)0);
                          }
                        }
                      } else {
                        rv = tclistnew2(1);
                        tmp___190 = tcadbsync(adb);
                        if (! tmp___190) {
                          tclistdel(rv);
                          rv = (TCLIST *)((void *)0);
                        }
                      }
                    } else {
                      rv = tclistnew2(1);
                      tmp___180 = tcndbiternext(adb->ndb, & ksiz___14);
                      kbuf___14 = (char *)tmp___180;
                      if (kbuf___14) {
                        while (1) {
                          TC_mysize___7 = ksiz___14;
                          TC_index___7 = rv->start + rv->num;
                          if (TC_index___7 >= rv->anum) {
                            rv->anum += rv->num + 1;
                            while (1) {
                              tmp___182 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                              tmp___181 = (TCLISTDATUM *)tmp___182;
                              rv->array = tmp___181;
                              if (! tmp___181) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                          }
                          array___7 = rv->array;
                          while (1) {
                            tmp___184 = malloc((unsigned int )(TC_mysize___7 + 1));
                            tmp___183 = (char *)tmp___184;
                            (array___7 + TC_index___7)->ptr = tmp___183;
                            if (! tmp___183) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                          memcpy((void * __restrict  )(array___7 + TC_index___7)->ptr,
                                 (void const   * __restrict  )kbuf___14, (unsigned int )TC_mysize___7);
                          *((array___7 + TC_index___7)->ptr + TC_mysize___7) = (char )'\000';
                          (array___7 + TC_index___7)->size = TC_mysize___7;
                          (rv->num) ++;
                          break;
                        }
                        tmp___185 = tcndbget(adb->ndb, (void const   *)kbuf___14,
                                             ksiz___14, & vsiz___8);
                        vbuf___8 = (char *)tmp___185;
                        if (vbuf___8) {
                          while (1) {
                            TC_mysize___8 = vsiz___8;
                            TC_index___8 = rv->start + rv->num;
                            if (TC_index___8 >= rv->anum) {
                              rv->anum += rv->num + 1;
                              while (1) {
                                tmp___187 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                                tmp___186 = (TCLISTDATUM *)tmp___187;
                                rv->array = tmp___186;
                                if (! tmp___186) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                            }
                            array___8 = rv->array;
                            while (1) {
                              tmp___189 = malloc((unsigned int )(TC_mysize___8 + 1));
                              tmp___188 = (char *)tmp___189;
                              (array___8 + TC_index___8)->ptr = tmp___188;
                              if (! tmp___188) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                            memcpy((void * __restrict  )(array___8 + TC_index___8)->ptr,
                                   (void const   * __restrict  )vbuf___8, (unsigned int )TC_mysize___8);
                            *((array___8 + TC_index___8)->ptr + TC_mysize___8) = (char )'\000';
                            (array___8 + TC_index___8)->size = TC_mysize___8;
                            (rv->num) ++;
                            break;
                          }
                          while (1) {
                            free((void *)vbuf___8);
                            break;
                          }
                        }
                        while (1) {
                          free((void *)kbuf___14);
                          break;
                        }
                      } else {
                        tclistdel(rv);
                        rv = (TCLIST *)((void *)0);
                      }
                    }
                  } else {
                    rv = tclistnew2(1);
                    if (argc > 0) {
                      while (1) {
                        kbuf___13 = (char const   *)(args->array + (int )args->start)->ptr;
                        ksiz___13 = (args->array + (int )args->start)->size;
                        break;
                      }
                      tcndbiterinit2(adb->ndb, (void const   *)kbuf___13, ksiz___13);
                    } else {
                      tcndbiterinit(adb->ndb);
                    }
                  }
                } else {
                  rv = tclistnew2(argc * 2);
                  i___4 = 0;
                  while (i___4 < argc) {
                    while (1) {
                      kbuf___12 = (char const   *)(args->array + (i___4 + (int )args->start))->ptr;
                      ksiz___12 = (args->array + (i___4 + (int )args->start))->size;
                      break;
                    }
                    tmp___171 = tcndbget(adb->ndb, (void const   *)kbuf___12, ksiz___12,
                                         & vsiz___7);
                    vbuf___7 = (char *)tmp___171;
                    if (vbuf___7) {
                      while (1) {
                        TC_mysize___5 = ksiz___12;
                        TC_index___5 = rv->start + rv->num;
                        if (TC_index___5 >= rv->anum) {
                          rv->anum += rv->num + 1;
                          while (1) {
                            tmp___173 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                            tmp___172 = (TCLISTDATUM *)tmp___173;
                            rv->array = tmp___172;
                            if (! tmp___172) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___5 = rv->array;
                        while (1) {
                          tmp___175 = malloc((unsigned int )(TC_mysize___5 + 1));
                          tmp___174 = (char *)tmp___175;
                          (array___5 + TC_index___5)->ptr = tmp___174;
                          if (! tmp___174) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___5 + TC_index___5)->ptr,
                               (void const   * __restrict  )kbuf___12, (unsigned int )TC_mysize___5);
                        *((array___5 + TC_index___5)->ptr + TC_mysize___5) = (char )'\000';
                        (array___5 + TC_index___5)->size = TC_mysize___5;
                        (rv->num) ++;
                        break;
                      }
                      while (1) {
                        TC_mysize___6 = vsiz___7;
                        TC_index___6 = rv->start + rv->num;
                        if (TC_index___6 >= rv->anum) {
                          rv->anum += rv->num + 1;
                          while (1) {
                            tmp___177 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                            tmp___176 = (TCLISTDATUM *)tmp___177;
                            rv->array = tmp___176;
                            if (! tmp___176) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___6 = rv->array;
                        while (1) {
                          tmp___179 = malloc((unsigned int )(TC_mysize___6 + 1));
                          tmp___178 = (char *)tmp___179;
                          (array___6 + TC_index___6)->ptr = tmp___178;
                          if (! tmp___178) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___6 + TC_index___6)->ptr,
                               (void const   * __restrict  )vbuf___7, (unsigned int )TC_mysize___6);
                        *((array___6 + TC_index___6)->ptr + TC_mysize___6) = (char )'\000';
                        (array___6 + TC_index___6)->size = TC_mysize___6;
                        (rv->num) ++;
                        break;
                      }
                      while (1) {
                        free((void *)vbuf___7);
                        break;
                      }
                    }
                    i___4 ++;
                  }
                }
              } else {
                rv = tclistnew2(1);
                i___3 = 0;
                while (i___3 < argc) {
                  while (1) {
                    kbuf___11 = (char const   *)(args->array + (i___3 + (int )args->start))->ptr;
                    ksiz___11 = (args->array + (i___3 + (int )args->start))->size;
                    break;
                  }
                  tcndbout(adb->ndb, (void const   *)kbuf___11, ksiz___11);
                  i___3 ++;
                }
              }
            } else {
              rv = tclistnew2(1);
              argc --;
              i___2 = 0;
              while (i___2 < argc) {
                while (1) {
                  kbuf___10 = (char const   *)(args->array + (i___2 + (int )args->start))->ptr;
                  ksiz___10 = (args->array + (i___2 + (int )args->start))->size;
                  break;
                }
                tmp___170 = tclistval(args, i___2 + 1, & vsiz___6);
                vbuf___6 = (char const   *)tmp___170;
                tcndbput(adb->ndb, (void const   *)kbuf___10, ksiz___10, (void const   *)vbuf___6,
                         vsiz___6);
                i___2 += 2;
              }
            }
          } else {
            if (argc > 0) {
              rv = tclistnew2(1);
              while (1) {
                kbuf___9 = (char const   *)(args->array + (int )args->start)->ptr;
                ksiz___9 = (args->array + (int )args->start)->size;
                break;
              }
              tmp___165 = tcndbget(adb->ndb, (void const   *)kbuf___9, ksiz___9, & vsiz___5);
              vbuf___5 = (char *)tmp___165;
              if (vbuf___5) {
                while (1) {
                  TC_mysize___4 = vsiz___5;
                  TC_index___4 = rv->start + rv->num;
                  if (TC_index___4 >= rv->anum) {
                    rv->anum += rv->num + 1;
                    while (1) {
                      tmp___167 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                      tmp___166 = (TCLISTDATUM *)tmp___167;
                      rv->array = tmp___166;
                      if (! tmp___166) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                  }
                  array___4 = rv->array;
                  while (1) {
                    tmp___169 = malloc((unsigned int )(TC_mysize___4 + 1));
                    tmp___168 = (char *)tmp___169;
                    (array___4 + TC_index___4)->ptr = tmp___168;
                    if (! tmp___168) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                  memcpy((void * __restrict  )(array___4 + TC_index___4)->ptr, (void const   * __restrict  )vbuf___5,
                         (unsigned int )TC_mysize___4);
                  *((array___4 + TC_index___4)->ptr + TC_mysize___4) = (char )'\000';
                  (array___4 + TC_index___4)->size = TC_mysize___4;
                  (rv->num) ++;
                  break;
                }
                while (1) {
                  free((void *)vbuf___5);
                  break;
                }
              } else {
                tclistdel(rv);
                rv = (TCLIST *)((void *)0);
              }
            } else {
              rv = (TCLIST *)((void *)0);
            }
          }
        } else {
          if (argc > 0) {
            rv = tclistnew2(1);
            while (1) {
              kbuf___8 = (char const   *)(args->array + (int )args->start)->ptr;
              ksiz___8 = (args->array + (int )args->start)->size;
              break;
            }
            tmp___164 = tcndbout(adb->ndb, (void const   *)kbuf___8, ksiz___8);
            if (! tmp___164) {
              tclistdel(rv);
              rv = (TCLIST *)((void *)0);
            }
          } else {
            rv = (TCLIST *)((void *)0);
          }
        }
      } else {
        _L___64: 
        if (argc > 1) {
          rv = tclistnew2(1);
          while (1) {
            kbuf___7 = (char const   *)(args->array + (int )args->start)->ptr;
            ksiz___7 = (args->array + (int )args->start)->size;
            break;
          }
          while (1) {
            vbuf___4 = (char const   *)(args->array + (1 + (int )args->start))->ptr;
            vsiz___4 = (args->array + (1 + (int )args->start))->size;
            break;
          }
          err___0 = (_Bool)0;
          if (0) {
            __s1_len___17 = strlen(name);
            __s2_len___17 = strlen("put");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___37;
            } else {
              if (__s1_len___17 >= 4U) {
                _L___37: 
                if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
                  tmp___163 = 1;
                } else {
                  if (__s2_len___17 >= 4U) {
                    tmp___163 = 1;
                  } else {
                    tmp___163 = 0;
                  }
                }
              } else {
                tmp___163 = 0;
              }
            }
            if (tmp___163) {
              tmp___158 = __builtin_strcmp(name, "put");
              tmp___162 = tmp___158;
            } else {
              tmp___161 = __builtin_strcmp(name, "put");
              tmp___162 = tmp___161;
            }
          } else {
            tmp___161 = __builtin_strcmp(name, "put");
            tmp___162 = tmp___161;
          }
          if (tmp___162) {
            if (0) {
              __s1_len___16 = strlen(name);
              __s2_len___16 = strlen("putkeep");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___35;
              } else {
                if (__s1_len___16 >= 4U) {
                  _L___35: 
                  if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
                    tmp___156 = 1;
                  } else {
                    if (__s2_len___16 >= 4U) {
                      tmp___156 = 1;
                    } else {
                      tmp___156 = 0;
                    }
                  }
                } else {
                  tmp___156 = 0;
                }
              }
              if (tmp___156) {
                tmp___151 = __builtin_strcmp(name, "putkeep");
                tmp___155 = tmp___151;
              } else {
                tmp___154 = __builtin_strcmp(name, "putkeep");
                tmp___155 = tmp___154;
              }
            } else {
              tmp___154 = __builtin_strcmp(name, "putkeep");
              tmp___155 = tmp___154;
            }
            if (tmp___155) {
              if (0) {
                __s1_len___15 = strlen(name);
                __s2_len___15 = strlen("putcat");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___33;
                } else {
                  if (__s1_len___15 >= 4U) {
                    _L___33: 
                    if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
                      tmp___149 = 1;
                    } else {
                      if (__s2_len___15 >= 4U) {
                        tmp___149 = 1;
                      } else {
                        tmp___149 = 0;
                      }
                    }
                  } else {
                    tmp___149 = 0;
                  }
                }
                if (tmp___149) {
                  tmp___144 = __builtin_strcmp(name, "putcat");
                  tmp___148 = tmp___144;
                } else {
                  tmp___147 = __builtin_strcmp(name, "putcat");
                  tmp___148 = tmp___147;
                }
              } else {
                tmp___147 = __builtin_strcmp(name, "putcat");
                tmp___148 = tmp___147;
              }
              if (! tmp___148) {
                tcndbputcat(adb->ndb, (void const   *)kbuf___7, ksiz___7, (void const   *)vbuf___4,
                            vsiz___4);
              }
            } else {
              tmp___142 = tcndbputkeep(adb->ndb, (void const   *)kbuf___7, ksiz___7,
                                       (void const   *)vbuf___4, vsiz___4);
              if (! tmp___142) {
                err___0 = (_Bool)1;
              }
            }
          } else {
            tcndbput(adb->ndb, (void const   *)kbuf___7, ksiz___7, (void const   *)vbuf___4,
                     vsiz___4);
          }
          if (err___0) {
            tclistdel(rv);
            rv = (TCLIST *)((void *)0);
          }
        } else {
          rv = (TCLIST *)((void *)0);
        }
      }
    } else {
      goto _L___64;
    }
  } else {
    goto _L___64;
  }
  break;
  case 3: 
  if (0) {
    __s1_len___45 = strlen(name);
    __s2_len___45 = strlen("put");
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___94;
    } else {
      if (__s1_len___45 >= 4U) {
        _L___94: 
        if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
          tmp___431 = 1;
        } else {
          if (__s2_len___45 >= 4U) {
            tmp___431 = 1;
          } else {
            tmp___431 = 0;
          }
        }
      } else {
        tmp___431 = 0;
      }
    }
    if (tmp___431) {
      tmp___426 = __builtin_strcmp(name, "put");
      tmp___430 = tmp___426;
    } else {
      tmp___429 = __builtin_strcmp(name, "put");
      tmp___430 = tmp___429;
    }
  } else {
    tmp___429 = __builtin_strcmp(name, "put");
    tmp___430 = tmp___429;
  }
  if (tmp___430) {
    if (0) {
      __s1_len___46 = strlen(name);
      __s2_len___46 = strlen("putkeep");
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___96;
      } else {
        if (__s1_len___46 >= 4U) {
          _L___96: 
          if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
            tmp___438 = 1;
          } else {
            if (__s2_len___46 >= 4U) {
              tmp___438 = 1;
            } else {
              tmp___438 = 0;
            }
          }
        } else {
          tmp___438 = 0;
        }
      }
      if (tmp___438) {
        tmp___433 = __builtin_strcmp(name, "putkeep");
        tmp___437 = tmp___433;
      } else {
        tmp___436 = __builtin_strcmp(name, "putkeep");
        tmp___437 = tmp___436;
      }
    } else {
      tmp___436 = __builtin_strcmp(name, "putkeep");
      tmp___437 = tmp___436;
    }
    if (tmp___437) {
      if (0) {
        __s1_len___47 = strlen(name);
        __s2_len___47 = strlen("putcat");
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___98;
        } else {
          if (__s1_len___47 >= 4U) {
            _L___98: 
            if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
              tmp___445 = 1;
            } else {
              if (__s2_len___47 >= 4U) {
                tmp___445 = 1;
              } else {
                tmp___445 = 0;
              }
            }
          } else {
            tmp___445 = 0;
          }
        }
        if (tmp___445) {
          tmp___440 = __builtin_strcmp(name, "putcat");
          tmp___444 = tmp___440;
        } else {
          tmp___443 = __builtin_strcmp(name, "putcat");
          tmp___444 = tmp___443;
        }
      } else {
        tmp___443 = __builtin_strcmp(name, "putcat");
        tmp___444 = tmp___443;
      }
      if (tmp___444) {
        if (0) {
          __s1_len___44 = strlen(name);
          __s2_len___44 = strlen("out");
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___92;
          } else {
            if (__s1_len___44 >= 4U) {
              _L___92: 
              if (! ((unsigned int )((void const   *)("out" + 1)) - (unsigned int )((void const   *)"out") == 1U)) {
                tmp___424 = 1;
              } else {
                if (__s2_len___44 >= 4U) {
                  tmp___424 = 1;
                } else {
                  tmp___424 = 0;
                }
              }
            } else {
              tmp___424 = 0;
            }
          }
          if (tmp___424) {
            tmp___419 = __builtin_strcmp(name, "out");
            tmp___423 = tmp___419;
          } else {
            tmp___422 = __builtin_strcmp(name, "out");
            tmp___423 = tmp___422;
          }
        } else {
          tmp___422 = __builtin_strcmp(name, "out");
          tmp___423 = tmp___422;
        }
        if (tmp___423) {
          if (0) {
            __s1_len___43 = strlen(name);
            __s2_len___43 = strlen("get");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___90;
            } else {
              if (__s1_len___43 >= 4U) {
                _L___90: 
                if (! ((unsigned int )((void const   *)("get" + 1)) - (unsigned int )((void const   *)"get") == 1U)) {
                  tmp___417 = 1;
                } else {
                  if (__s2_len___43 >= 4U) {
                    tmp___417 = 1;
                  } else {
                    tmp___417 = 0;
                  }
                }
              } else {
                tmp___417 = 0;
              }
            }
            if (tmp___417) {
              tmp___412 = __builtin_strcmp(name, "get");
              tmp___416 = tmp___412;
            } else {
              tmp___415 = __builtin_strcmp(name, "get");
              tmp___416 = tmp___415;
            }
          } else {
            tmp___415 = __builtin_strcmp(name, "get");
            tmp___416 = tmp___415;
          }
          if (tmp___416) {
            if (0) {
              __s1_len___42 = strlen(name);
              __s2_len___42 = strlen("putlist");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___88;
              } else {
                if (__s1_len___42 >= 4U) {
                  _L___88: 
                  if (! ((unsigned int )((void const   *)("putlist" + 1)) - (unsigned int )((void const   *)"putlist") == 1U)) {
                    tmp___410 = 1;
                  } else {
                    if (__s2_len___42 >= 4U) {
                      tmp___410 = 1;
                    } else {
                      tmp___410 = 0;
                    }
                  }
                } else {
                  tmp___410 = 0;
                }
              }
              if (tmp___410) {
                tmp___405 = __builtin_strcmp(name, "putlist");
                tmp___409 = tmp___405;
              } else {
                tmp___408 = __builtin_strcmp(name, "putlist");
                tmp___409 = tmp___408;
              }
            } else {
              tmp___408 = __builtin_strcmp(name, "putlist");
              tmp___409 = tmp___408;
            }
            if (tmp___409) {
              if (0) {
                __s1_len___41 = strlen(name);
                __s2_len___41 = strlen("outlist");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___86;
                } else {
                  if (__s1_len___41 >= 4U) {
                    _L___86: 
                    if (! ((unsigned int )((void const   *)("outlist" + 1)) - (unsigned int )((void const   *)"outlist") == 1U)) {
                      tmp___403 = 1;
                    } else {
                      if (__s2_len___41 >= 4U) {
                        tmp___403 = 1;
                      } else {
                        tmp___403 = 0;
                      }
                    }
                  } else {
                    tmp___403 = 0;
                  }
                }
                if (tmp___403) {
                  tmp___398 = __builtin_strcmp(name, "outlist");
                  tmp___402 = tmp___398;
                } else {
                  tmp___401 = __builtin_strcmp(name, "outlist");
                  tmp___402 = tmp___401;
                }
              } else {
                tmp___401 = __builtin_strcmp(name, "outlist");
                tmp___402 = tmp___401;
              }
              if (tmp___402) {
                if (0) {
                  __s1_len___40 = strlen(name);
                  __s2_len___40 = strlen("getlist");
                  if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                    goto _L___84;
                  } else {
                    if (__s1_len___40 >= 4U) {
                      _L___84: 
                      if (! ((unsigned int )((void const   *)("getlist" + 1)) - (unsigned int )((void const   *)"getlist") == 1U)) {
                        tmp___396 = 1;
                      } else {
                        if (__s2_len___40 >= 4U) {
                          tmp___396 = 1;
                        } else {
                          tmp___396 = 0;
                        }
                      }
                    } else {
                      tmp___396 = 0;
                    }
                  }
                  if (tmp___396) {
                    tmp___391 = __builtin_strcmp(name, "getlist");
                    tmp___395 = tmp___391;
                  } else {
                    tmp___394 = __builtin_strcmp(name, "getlist");
                    tmp___395 = tmp___394;
                  }
                } else {
                  tmp___394 = __builtin_strcmp(name, "getlist");
                  tmp___395 = tmp___394;
                }
                if (tmp___395) {
                  if (0) {
                    __s1_len___39 = strlen(name);
                    __s2_len___39 = strlen("iterinit");
                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                      goto _L___82;
                    } else {
                      if (__s1_len___39 >= 4U) {
                        _L___82: 
                        if (! ((unsigned int )((void const   *)("iterinit" + 1)) - (unsigned int )((void const   *)"iterinit") == 1U)) {
                          tmp___389 = 1;
                        } else {
                          if (__s2_len___39 >= 4U) {
                            tmp___389 = 1;
                          } else {
                            tmp___389 = 0;
                          }
                        }
                      } else {
                        tmp___389 = 0;
                      }
                    }
                    if (tmp___389) {
                      tmp___384 = __builtin_strcmp(name, "iterinit");
                      tmp___388 = tmp___384;
                    } else {
                      tmp___387 = __builtin_strcmp(name, "iterinit");
                      tmp___388 = tmp___387;
                    }
                  } else {
                    tmp___387 = __builtin_strcmp(name, "iterinit");
                    tmp___388 = tmp___387;
                  }
                  if (tmp___388) {
                    if (0) {
                      __s1_len___38 = strlen(name);
                      __s2_len___38 = strlen("iternext");
                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                        goto _L___80;
                      } else {
                        if (__s1_len___38 >= 4U) {
                          _L___80: 
                          if (! ((unsigned int )((void const   *)("iternext" + 1)) - (unsigned int )((void const   *)"iternext") == 1U)) {
                            tmp___382 = 1;
                          } else {
                            if (__s2_len___38 >= 4U) {
                              tmp___382 = 1;
                            } else {
                              tmp___382 = 0;
                            }
                          }
                        } else {
                          tmp___382 = 0;
                        }
                      }
                      if (tmp___382) {
                        tmp___377 = __builtin_strcmp(name, "iternext");
                        tmp___381 = tmp___377;
                      } else {
                        tmp___380 = __builtin_strcmp(name, "iternext");
                        tmp___381 = tmp___380;
                      }
                    } else {
                      tmp___380 = __builtin_strcmp(name, "iternext");
                      tmp___381 = tmp___380;
                    }
                    if (tmp___381) {
                      if (0) {
                        __s1_len___37 = strlen(name);
                        __s2_len___37 = strlen("sync");
                        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                          goto _L___78;
                        } else {
                          if (__s1_len___37 >= 4U) {
                            _L___78: 
                            if (! ((unsigned int )((void const   *)("sync" + 1)) - (unsigned int )((void const   *)"sync") == 1U)) {
                              tmp___375 = 1;
                            } else {
                              if (__s2_len___37 >= 4U) {
                                tmp___375 = 1;
                              } else {
                                tmp___375 = 0;
                              }
                            }
                          } else {
                            tmp___375 = 0;
                          }
                        }
                        if (tmp___375) {
                          tmp___370 = __builtin_strcmp(name, "sync");
                          tmp___374 = tmp___370;
                        } else {
                          tmp___373 = __builtin_strcmp(name, "sync");
                          tmp___374 = tmp___373;
                        }
                      } else {
                        tmp___373 = __builtin_strcmp(name, "sync");
                        tmp___374 = tmp___373;
                      }
                      if (tmp___374) {
                        if (0) {
                          __s1_len___36 = strlen(name);
                          __s2_len___36 = strlen("optimize");
                          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                            goto _L___76;
                          } else {
                            if (__s1_len___36 >= 4U) {
                              _L___76: 
                              if (! ((unsigned int )((void const   *)("optimize" + 1)) - (unsigned int )((void const   *)"optimize") == 1U)) {
                                tmp___368 = 1;
                              } else {
                                if (__s2_len___36 >= 4U) {
                                  tmp___368 = 1;
                                } else {
                                  tmp___368 = 0;
                                }
                              }
                            } else {
                              tmp___368 = 0;
                            }
                          }
                          if (tmp___368) {
                            tmp___363 = __builtin_strcmp(name, "optimize");
                            tmp___367 = tmp___363;
                          } else {
                            tmp___366 = __builtin_strcmp(name, "optimize");
                            tmp___367 = tmp___366;
                          }
                        } else {
                          tmp___366 = __builtin_strcmp(name, "optimize");
                          tmp___367 = tmp___366;
                        }
                        if (tmp___367) {
                          if (0) {
                            __s1_len___35 = strlen(name);
                            __s2_len___35 = strlen("vanish");
                            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                              goto _L___74;
                            } else {
                              if (__s1_len___35 >= 4U) {
                                _L___74: 
                                if (! ((unsigned int )((void const   *)("vanish" + 1)) - (unsigned int )((void const   *)"vanish") == 1U)) {
                                  tmp___361 = 1;
                                } else {
                                  if (__s2_len___35 >= 4U) {
                                    tmp___361 = 1;
                                  } else {
                                    tmp___361 = 0;
                                  }
                                }
                              } else {
                                tmp___361 = 0;
                              }
                            }
                            if (tmp___361) {
                              tmp___356 = __builtin_strcmp(name, "vanish");
                              tmp___360 = tmp___356;
                            } else {
                              tmp___359 = __builtin_strcmp(name, "vanish");
                              tmp___360 = tmp___359;
                            }
                          } else {
                            tmp___359 = __builtin_strcmp(name, "vanish");
                            tmp___360 = tmp___359;
                          }
                          if (tmp___360) {
                            if (0) {
                              __s1_len___34 = strlen(name);
                              __s2_len___34 = strlen("defrag");
                              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                                goto _L___72;
                              } else {
                                if (__s1_len___34 >= 4U) {
                                  _L___72: 
                                  if (! ((unsigned int )((void const   *)("defrag" + 1)) - (unsigned int )((void const   *)"defrag") == 1U)) {
                                    tmp___354 = 1;
                                  } else {
                                    if (__s2_len___34 >= 4U) {
                                      tmp___354 = 1;
                                    } else {
                                      tmp___354 = 0;
                                    }
                                  }
                                } else {
                                  tmp___354 = 0;
                                }
                              }
                              if (tmp___354) {
                                tmp___349 = __builtin_strcmp(name, "defrag");
                                tmp___353 = tmp___349;
                              } else {
                                tmp___352 = __builtin_strcmp(name, "defrag");
                                tmp___353 = tmp___352;
                              }
                            } else {
                              tmp___352 = __builtin_strcmp(name, "defrag");
                              tmp___353 = tmp___352;
                            }
                            if (tmp___353) {
                              rv = (TCLIST *)((void *)0);
                            } else {
                              rv = tclistnew2(1);
                              if (argc > 0) {
                                tmp___345 = tcatoi((char const   *)((void *)(args->array + (int )args->start)->ptr));
                                tmp___346 = tmp___345;
                              } else {
                                tmp___346 = -1LL;
                              }
                              step = tmp___346;
                              tmp___347 = tchdbdefrag(adb->hdb, step);
                              if (! tmp___347) {
                                tclistdel(rv);
                                rv = (TCLIST *)((void *)0);
                              }
                            }
                          } else {
                            rv = tclistnew2(1);
                            tmp___344 = tcadbvanish(adb);
                            if (! tmp___344) {
                              tclistdel(rv);
                              rv = (TCLIST *)((void *)0);
                            }
                          }
                        } else {
                          rv = tclistnew2(1);
                          if (argc > 0) {
                            tmp___342 = (void *)(args->array + (int )args->start)->ptr;
                          } else {
                            tmp___342 = (void *)0;
                          }
                          params___1 = (char const   *)tmp___342;
                          tmp___343 = tcadboptimize(adb, params___1);
                          if (! tmp___343) {
                            tclistdel(rv);
                            rv = (TCLIST *)((void *)0);
                          }
                        }
                      } else {
                        rv = tclistnew2(1);
                        tmp___341 = tcadbsync(adb);
                        if (! tmp___341) {
                          tclistdel(rv);
                          rv = (TCLIST *)((void *)0);
                        }
                      }
                    } else {
                      rv = tclistnew2(1);
                      tmp___331 = tchdbiternext(adb->hdb, & ksiz___22);
                      kbuf___22 = (char *)tmp___331;
                      if (kbuf___22) {
                        while (1) {
                          TC_mysize___12 = ksiz___22;
                          TC_index___12 = rv->start + rv->num;
                          if (TC_index___12 >= rv->anum) {
                            rv->anum += rv->num + 1;
                            while (1) {
                              tmp___333 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                              tmp___332 = (TCLISTDATUM *)tmp___333;
                              rv->array = tmp___332;
                              if (! tmp___332) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                          }
                          array___12 = rv->array;
                          while (1) {
                            tmp___335 = malloc((unsigned int )(TC_mysize___12 + 1));
                            tmp___334 = (char *)tmp___335;
                            (array___12 + TC_index___12)->ptr = tmp___334;
                            if (! tmp___334) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                          memcpy((void * __restrict  )(array___12 + TC_index___12)->ptr,
                                 (void const   * __restrict  )kbuf___22, (unsigned int )TC_mysize___12);
                          *((array___12 + TC_index___12)->ptr + TC_mysize___12) = (char )'\000';
                          (array___12 + TC_index___12)->size = TC_mysize___12;
                          (rv->num) ++;
                          break;
                        }
                        tmp___336 = tchdbget(adb->hdb, (void const   *)kbuf___22,
                                             ksiz___22, & vsiz___13);
                        vbuf___13 = (char *)tmp___336;
                        if (vbuf___13) {
                          while (1) {
                            TC_mysize___13 = vsiz___13;
                            TC_index___13 = rv->start + rv->num;
                            if (TC_index___13 >= rv->anum) {
                              rv->anum += rv->num + 1;
                              while (1) {
                                tmp___338 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                                tmp___337 = (TCLISTDATUM *)tmp___338;
                                rv->array = tmp___337;
                                if (! tmp___337) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                            }
                            array___13 = rv->array;
                            while (1) {
                              tmp___340 = malloc((unsigned int )(TC_mysize___13 + 1));
                              tmp___339 = (char *)tmp___340;
                              (array___13 + TC_index___13)->ptr = tmp___339;
                              if (! tmp___339) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                            memcpy((void * __restrict  )(array___13 + TC_index___13)->ptr,
                                   (void const   * __restrict  )vbuf___13, (unsigned int )TC_mysize___13);
                            *((array___13 + TC_index___13)->ptr + TC_mysize___13) = (char )'\000';
                            (array___13 + TC_index___13)->size = TC_mysize___13;
                            (rv->num) ++;
                            break;
                          }
                          while (1) {
                            free((void *)vbuf___13);
                            break;
                          }
                        }
                        while (1) {
                          free((void *)kbuf___22);
                          break;
                        }
                      } else {
                        tclistdel(rv);
                        rv = (TCLIST *)((void *)0);
                      }
                    }
                  } else {
                    rv = tclistnew2(1);
                    err___5 = (_Bool)0;
                    if (argc > 0) {
                      while (1) {
                        kbuf___21 = (char const   *)(args->array + (int )args->start)->ptr;
                        ksiz___21 = (args->array + (int )args->start)->size;
                        break;
                      }
                      tmp___329 = tchdbiterinit2(adb->hdb, (void const   *)kbuf___21,
                                                 ksiz___21);
                      if (! tmp___329) {
                        err___5 = (_Bool)1;
                      }
                    } else {
                      tmp___330 = tchdbiterinit(adb->hdb);
                      if (! tmp___330) {
                        err___5 = (_Bool)1;
                      }
                    }
                    if (err___5) {
                      tclistdel(rv);
                      rv = (TCLIST *)((void *)0);
                    }
                  }
                } else {
                  rv = tclistnew2(argc * 2);
                  err___4 = (_Bool)0;
                  i___7 = 0;
                  while (i___7 < argc) {
                    while (1) {
                      kbuf___20 = (char const   *)(args->array + (i___7 + (int )args->start))->ptr;
                      ksiz___20 = (args->array + (i___7 + (int )args->start))->size;
                      break;
                    }
                    tmp___319 = tchdbget(adb->hdb, (void const   *)kbuf___20, ksiz___20,
                                         & vsiz___12);
                    vbuf___12 = (char *)tmp___319;
                    if (vbuf___12) {
                      while (1) {
                        TC_mysize___10 = ksiz___20;
                        TC_index___10 = rv->start + rv->num;
                        if (TC_index___10 >= rv->anum) {
                          rv->anum += rv->num + 1;
                          while (1) {
                            tmp___321 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                            tmp___320 = (TCLISTDATUM *)tmp___321;
                            rv->array = tmp___320;
                            if (! tmp___320) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___10 = rv->array;
                        while (1) {
                          tmp___323 = malloc((unsigned int )(TC_mysize___10 + 1));
                          tmp___322 = (char *)tmp___323;
                          (array___10 + TC_index___10)->ptr = tmp___322;
                          if (! tmp___322) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___10 + TC_index___10)->ptr,
                               (void const   * __restrict  )kbuf___20, (unsigned int )TC_mysize___10);
                        *((array___10 + TC_index___10)->ptr + TC_mysize___10) = (char )'\000';
                        (array___10 + TC_index___10)->size = TC_mysize___10;
                        (rv->num) ++;
                        break;
                      }
                      while (1) {
                        TC_mysize___11 = vsiz___12;
                        TC_index___11 = rv->start + rv->num;
                        if (TC_index___11 >= rv->anum) {
                          rv->anum += rv->num + 1;
                          while (1) {
                            tmp___325 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                            tmp___324 = (TCLISTDATUM *)tmp___325;
                            rv->array = tmp___324;
                            if (! tmp___324) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___11 = rv->array;
                        while (1) {
                          tmp___327 = malloc((unsigned int )(TC_mysize___11 + 1));
                          tmp___326 = (char *)tmp___327;
                          (array___11 + TC_index___11)->ptr = tmp___326;
                          if (! tmp___326) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___11 + TC_index___11)->ptr,
                               (void const   * __restrict  )vbuf___12, (unsigned int )TC_mysize___11);
                        *((array___11 + TC_index___11)->ptr + TC_mysize___11) = (char )'\000';
                        (array___11 + TC_index___11)->size = TC_mysize___11;
                        (rv->num) ++;
                        break;
                      }
                      while (1) {
                        free((void *)vbuf___12);
                        break;
                      }
                    } else {
                      tmp___328 = tchdbecode(adb->hdb);
                      if (tmp___328 != 22) {
                        err___4 = (_Bool)1;
                      }
                    }
                    i___7 ++;
                  }
                  if (err___4) {
                    tclistdel(rv);
                    rv = (TCLIST *)((void *)0);
                  }
                }
              } else {
                rv = tclistnew2(1);
                err___3 = (_Bool)0;
                i___6 = 0;
                while (i___6 < argc) {
                  while (1) {
                    kbuf___19 = (char const   *)(args->array + (i___6 + (int )args->start))->ptr;
                    ksiz___19 = (args->array + (i___6 + (int )args->start))->size;
                    break;
                  }
                  tmp___317 = tchdbout(adb->hdb, (void const   *)kbuf___19, ksiz___19);
                  if (! tmp___317) {
                    tmp___318 = tchdbecode(adb->hdb);
                    if (tmp___318 != 22) {
                      err___3 = (_Bool)1;
                      break;
                    }
                  }
                  i___6 ++;
                }
                if (err___3) {
                  tclistdel(rv);
                  rv = (TCLIST *)((void *)0);
                }
              }
            } else {
              rv = tclistnew2(1);
              err___2 = (_Bool)0;
              argc --;
              i___5 = 0;
              while (i___5 < argc) {
                while (1) {
                  kbuf___18 = (char const   *)(args->array + (i___5 + (int )args->start))->ptr;
                  ksiz___18 = (args->array + (i___5 + (int )args->start))->size;
                  break;
                }
                tmp___315 = tclistval(args, i___5 + 1, & vsiz___11);
                vbuf___11 = (char const   *)tmp___315;
                tmp___316 = tchdbput(adb->hdb, (void const   *)kbuf___18, ksiz___18,
                                     (void const   *)vbuf___11, vsiz___11);
                if (! tmp___316) {
                  err___2 = (_Bool)1;
                  break;
                }
                i___5 += 2;
              }
              if (err___2) {
                tclistdel(rv);
                rv = (TCLIST *)((void *)0);
              }
            }
          } else {
            if (argc > 0) {
              rv = tclistnew2(1);
              while (1) {
                kbuf___17 = (char const   *)(args->array + (int )args->start)->ptr;
                ksiz___17 = (args->array + (int )args->start)->size;
                break;
              }
              tmp___310 = tchdbget(adb->hdb, (void const   *)kbuf___17, ksiz___17,
                                   & vsiz___10);
              vbuf___10 = (char *)tmp___310;
              if (vbuf___10) {
                while (1) {
                  TC_mysize___9 = vsiz___10;
                  TC_index___9 = rv->start + rv->num;
                  if (TC_index___9 >= rv->anum) {
                    rv->anum += rv->num + 1;
                    while (1) {
                      tmp___312 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                      tmp___311 = (TCLISTDATUM *)tmp___312;
                      rv->array = tmp___311;
                      if (! tmp___311) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                  }
                  array___9 = rv->array;
                  while (1) {
                    tmp___314 = malloc((unsigned int )(TC_mysize___9 + 1));
                    tmp___313 = (char *)tmp___314;
                    (array___9 + TC_index___9)->ptr = tmp___313;
                    if (! tmp___313) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                  memcpy((void * __restrict  )(array___9 + TC_index___9)->ptr, (void const   * __restrict  )vbuf___10,
                         (unsigned int )TC_mysize___9);
                  *((array___9 + TC_index___9)->ptr + TC_mysize___9) = (char )'\000';
                  (array___9 + TC_index___9)->size = TC_mysize___9;
                  (rv->num) ++;
                  break;
                }
                while (1) {
                  free((void *)vbuf___10);
                  break;
                }
              } else {
                tclistdel(rv);
                rv = (TCLIST *)((void *)0);
              }
            } else {
              rv = (TCLIST *)((void *)0);
            }
          }
        } else {
          if (argc > 0) {
            rv = tclistnew2(1);
            while (1) {
              kbuf___16 = (char const   *)(args->array + (int )args->start)->ptr;
              ksiz___16 = (args->array + (int )args->start)->size;
              break;
            }
            tmp___309 = tchdbout(adb->hdb, (void const   *)kbuf___16, ksiz___16);
            if (! tmp___309) {
              tclistdel(rv);
              rv = (TCLIST *)((void *)0);
            }
          } else {
            rv = (TCLIST *)((void *)0);
          }
        }
      } else {
        _L___99: 
        if (argc > 1) {
          rv = tclistnew2(1);
          while (1) {
            kbuf___15 = (char const   *)(args->array + (int )args->start)->ptr;
            ksiz___15 = (args->array + (int )args->start)->size;
            break;
          }
          while (1) {
            vbuf___9 = (char const   *)(args->array + (1 + (int )args->start))->ptr;
            vsiz___9 = (args->array + (1 + (int )args->start))->size;
            break;
          }
          err___1 = (_Bool)0;
          if (0) {
            __s1_len___33 = strlen(name);
            __s2_len___33 = strlen("put");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___70;
            } else {
              if (__s1_len___33 >= 4U) {
                _L___70: 
                if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
                  tmp___308 = 1;
                } else {
                  if (__s2_len___33 >= 4U) {
                    tmp___308 = 1;
                  } else {
                    tmp___308 = 0;
                  }
                }
              } else {
                tmp___308 = 0;
              }
            }
            if (tmp___308) {
              tmp___303 = __builtin_strcmp(name, "put");
              tmp___307 = tmp___303;
            } else {
              tmp___306 = __builtin_strcmp(name, "put");
              tmp___307 = tmp___306;
            }
          } else {
            tmp___306 = __builtin_strcmp(name, "put");
            tmp___307 = tmp___306;
          }
          if (tmp___307) {
            if (0) {
              __s1_len___32 = strlen(name);
              __s2_len___32 = strlen("putkeep");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___68;
              } else {
                if (__s1_len___32 >= 4U) {
                  _L___68: 
                  if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
                    tmp___301 = 1;
                  } else {
                    if (__s2_len___32 >= 4U) {
                      tmp___301 = 1;
                    } else {
                      tmp___301 = 0;
                    }
                  }
                } else {
                  tmp___301 = 0;
                }
              }
              if (tmp___301) {
                tmp___296 = __builtin_strcmp(name, "putkeep");
                tmp___300 = tmp___296;
              } else {
                tmp___299 = __builtin_strcmp(name, "putkeep");
                tmp___300 = tmp___299;
              }
            } else {
              tmp___299 = __builtin_strcmp(name, "putkeep");
              tmp___300 = tmp___299;
            }
            if (tmp___300) {
              if (0) {
                __s1_len___31 = strlen(name);
                __s2_len___31 = strlen("putcat");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___66;
                } else {
                  if (__s1_len___31 >= 4U) {
                    _L___66: 
                    if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
                      tmp___294 = 1;
                    } else {
                      if (__s2_len___31 >= 4U) {
                        tmp___294 = 1;
                      } else {
                        tmp___294 = 0;
                      }
                    }
                  } else {
                    tmp___294 = 0;
                  }
                }
                if (tmp___294) {
                  tmp___289 = __builtin_strcmp(name, "putcat");
                  tmp___293 = tmp___289;
                } else {
                  tmp___292 = __builtin_strcmp(name, "putcat");
                  tmp___293 = tmp___292;
                }
              } else {
                tmp___292 = __builtin_strcmp(name, "putcat");
                tmp___293 = tmp___292;
              }
              if (! tmp___293) {
                tmp___287 = tchdbputcat(adb->hdb, (void const   *)kbuf___15, ksiz___15,
                                        (void const   *)vbuf___9, vsiz___9);
                if (! tmp___287) {
                  err___1 = (_Bool)1;
                }
              }
            } else {
              tmp___286 = tchdbputkeep(adb->hdb, (void const   *)kbuf___15, ksiz___15,
                                       (void const   *)vbuf___9, vsiz___9);
              if (! tmp___286) {
                err___1 = (_Bool)1;
              }
            }
          } else {
            tmp___285 = tchdbput(adb->hdb, (void const   *)kbuf___15, ksiz___15, (void const   *)vbuf___9,
                                 vsiz___9);
            if (! tmp___285) {
              err___1 = (_Bool)1;
            }
          }
          if (err___1) {
            tclistdel(rv);
            rv = (TCLIST *)((void *)0);
          }
        } else {
          rv = (TCLIST *)((void *)0);
        }
      }
    } else {
      goto _L___99;
    }
  } else {
    goto _L___99;
  }
  break;
  case 4: 
  if (0) {
    __s1_len___64 = strlen(name);
    __s2_len___64 = strlen("put");
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___133;
    } else {
      if (__s1_len___64 >= 4U) {
        _L___133: 
        if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
          tmp___604 = 1;
        } else {
          if (__s2_len___64 >= 4U) {
            tmp___604 = 1;
          } else {
            tmp___604 = 0;
          }
        }
      } else {
        tmp___604 = 0;
      }
    }
    if (tmp___604) {
      tmp___599 = __builtin_strcmp(name, "put");
      tmp___603 = tmp___599;
    } else {
      tmp___602 = __builtin_strcmp(name, "put");
      tmp___603 = tmp___602;
    }
  } else {
    tmp___602 = __builtin_strcmp(name, "put");
    tmp___603 = tmp___602;
  }
  if (tmp___603) {
    if (0) {
      __s1_len___65 = strlen(name);
      __s2_len___65 = strlen("putkeep");
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___135;
      } else {
        if (__s1_len___65 >= 4U) {
          _L___135: 
          if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
            tmp___611 = 1;
          } else {
            if (__s2_len___65 >= 4U) {
              tmp___611 = 1;
            } else {
              tmp___611 = 0;
            }
          }
        } else {
          tmp___611 = 0;
        }
      }
      if (tmp___611) {
        tmp___606 = __builtin_strcmp(name, "putkeep");
        tmp___610 = tmp___606;
      } else {
        tmp___609 = __builtin_strcmp(name, "putkeep");
        tmp___610 = tmp___609;
      }
    } else {
      tmp___609 = __builtin_strcmp(name, "putkeep");
      tmp___610 = tmp___609;
    }
    if (tmp___610) {
      if (0) {
        __s1_len___66 = strlen(name);
        __s2_len___66 = strlen("putcat");
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___137;
        } else {
          if (__s1_len___66 >= 4U) {
            _L___137: 
            if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
              tmp___618 = 1;
            } else {
              if (__s2_len___66 >= 4U) {
                tmp___618 = 1;
              } else {
                tmp___618 = 0;
              }
            }
          } else {
            tmp___618 = 0;
          }
        }
        if (tmp___618) {
          tmp___613 = __builtin_strcmp(name, "putcat");
          tmp___617 = tmp___613;
        } else {
          tmp___616 = __builtin_strcmp(name, "putcat");
          tmp___617 = tmp___616;
        }
      } else {
        tmp___616 = __builtin_strcmp(name, "putcat");
        tmp___617 = tmp___616;
      }
      if (tmp___617) {
        if (0) {
          __s1_len___67 = strlen(name);
          __s2_len___67 = strlen("putdup");
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___139;
          } else {
            if (__s1_len___67 >= 4U) {
              _L___139: 
              if (! ((unsigned int )((void const   *)("putdup" + 1)) - (unsigned int )((void const   *)"putdup") == 1U)) {
                tmp___625 = 1;
              } else {
                if (__s2_len___67 >= 4U) {
                  tmp___625 = 1;
                } else {
                  tmp___625 = 0;
                }
              }
            } else {
              tmp___625 = 0;
            }
          }
          if (tmp___625) {
            tmp___620 = __builtin_strcmp(name, "putdup");
            tmp___624 = tmp___620;
          } else {
            tmp___623 = __builtin_strcmp(name, "putdup");
            tmp___624 = tmp___623;
          }
        } else {
          tmp___623 = __builtin_strcmp(name, "putdup");
          tmp___624 = tmp___623;
        }
        if (tmp___624) {
          if (0) {
            __s1_len___68 = strlen(name);
            __s2_len___68 = strlen("putdupback");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___141;
            } else {
              if (__s1_len___68 >= 4U) {
                _L___141: 
                if (! ((unsigned int )((void const   *)("putdupback" + 1)) - (unsigned int )((void const   *)"putdupback") == 1U)) {
                  tmp___632 = 1;
                } else {
                  if (__s2_len___68 >= 4U) {
                    tmp___632 = 1;
                  } else {
                    tmp___632 = 0;
                  }
                }
              } else {
                tmp___632 = 0;
              }
            }
            if (tmp___632) {
              tmp___627 = __builtin_strcmp(name, "putdupback");
              tmp___631 = tmp___627;
            } else {
              tmp___630 = __builtin_strcmp(name, "putdupback");
              tmp___631 = tmp___630;
            }
          } else {
            tmp___630 = __builtin_strcmp(name, "putdupback");
            tmp___631 = tmp___630;
          }
          if (tmp___631) {
            if (0) {
              __s1_len___63 = strlen(name);
              __s2_len___63 = strlen("out");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___131;
              } else {
                if (__s1_len___63 >= 4U) {
                  _L___131: 
                  if (! ((unsigned int )((void const   *)("out" + 1)) - (unsigned int )((void const   *)"out") == 1U)) {
                    tmp___597 = 1;
                  } else {
                    if (__s2_len___63 >= 4U) {
                      tmp___597 = 1;
                    } else {
                      tmp___597 = 0;
                    }
                  }
                } else {
                  tmp___597 = 0;
                }
              }
              if (tmp___597) {
                tmp___592 = __builtin_strcmp(name, "out");
                tmp___596 = tmp___592;
              } else {
                tmp___595 = __builtin_strcmp(name, "out");
                tmp___596 = tmp___595;
              }
            } else {
              tmp___595 = __builtin_strcmp(name, "out");
              tmp___596 = tmp___595;
            }
            if (tmp___596) {
              if (0) {
                __s1_len___62 = strlen(name);
                __s2_len___62 = strlen("get");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___129;
                } else {
                  if (__s1_len___62 >= 4U) {
                    _L___129: 
                    if (! ((unsigned int )((void const   *)("get" + 1)) - (unsigned int )((void const   *)"get") == 1U)) {
                      tmp___590 = 1;
                    } else {
                      if (__s2_len___62 >= 4U) {
                        tmp___590 = 1;
                      } else {
                        tmp___590 = 0;
                      }
                    }
                  } else {
                    tmp___590 = 0;
                  }
                }
                if (tmp___590) {
                  tmp___585 = __builtin_strcmp(name, "get");
                  tmp___589 = tmp___585;
                } else {
                  tmp___588 = __builtin_strcmp(name, "get");
                  tmp___589 = tmp___588;
                }
              } else {
                tmp___588 = __builtin_strcmp(name, "get");
                tmp___589 = tmp___588;
              }
              if (tmp___589) {
                if (0) {
                  __s1_len___61 = strlen(name);
                  __s2_len___61 = strlen("putlist");
                  if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                    goto _L___127;
                  } else {
                    if (__s1_len___61 >= 4U) {
                      _L___127: 
                      if (! ((unsigned int )((void const   *)("putlist" + 1)) - (unsigned int )((void const   *)"putlist") == 1U)) {
                        tmp___583 = 1;
                      } else {
                        if (__s2_len___61 >= 4U) {
                          tmp___583 = 1;
                        } else {
                          tmp___583 = 0;
                        }
                      }
                    } else {
                      tmp___583 = 0;
                    }
                  }
                  if (tmp___583) {
                    tmp___578 = __builtin_strcmp(name, "putlist");
                    tmp___582 = tmp___578;
                  } else {
                    tmp___581 = __builtin_strcmp(name, "putlist");
                    tmp___582 = tmp___581;
                  }
                } else {
                  tmp___581 = __builtin_strcmp(name, "putlist");
                  tmp___582 = tmp___581;
                }
                if (tmp___582) {
                  if (0) {
                    __s1_len___60 = strlen(name);
                    __s2_len___60 = strlen("outlist");
                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                      goto _L___125;
                    } else {
                      if (__s1_len___60 >= 4U) {
                        _L___125: 
                        if (! ((unsigned int )((void const   *)("outlist" + 1)) - (unsigned int )((void const   *)"outlist") == 1U)) {
                          tmp___576 = 1;
                        } else {
                          if (__s2_len___60 >= 4U) {
                            tmp___576 = 1;
                          } else {
                            tmp___576 = 0;
                          }
                        }
                      } else {
                        tmp___576 = 0;
                      }
                    }
                    if (tmp___576) {
                      tmp___571 = __builtin_strcmp(name, "outlist");
                      tmp___575 = tmp___571;
                    } else {
                      tmp___574 = __builtin_strcmp(name, "outlist");
                      tmp___575 = tmp___574;
                    }
                  } else {
                    tmp___574 = __builtin_strcmp(name, "outlist");
                    tmp___575 = tmp___574;
                  }
                  if (tmp___575) {
                    if (0) {
                      __s1_len___59 = strlen(name);
                      __s2_len___59 = strlen("getlist");
                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                        goto _L___123;
                      } else {
                        if (__s1_len___59 >= 4U) {
                          _L___123: 
                          if (! ((unsigned int )((void const   *)("getlist" + 1)) - (unsigned int )((void const   *)"getlist") == 1U)) {
                            tmp___569 = 1;
                          } else {
                            if (__s2_len___59 >= 4U) {
                              tmp___569 = 1;
                            } else {
                              tmp___569 = 0;
                            }
                          }
                        } else {
                          tmp___569 = 0;
                        }
                      }
                      if (tmp___569) {
                        tmp___564 = __builtin_strcmp(name, "getlist");
                        tmp___568 = tmp___564;
                      } else {
                        tmp___567 = __builtin_strcmp(name, "getlist");
                        tmp___568 = tmp___567;
                      }
                    } else {
                      tmp___567 = __builtin_strcmp(name, "getlist");
                      tmp___568 = tmp___567;
                    }
                    if (tmp___568) {
                      if (0) {
                        __s1_len___58 = strlen(name);
                        __s2_len___58 = strlen("iterinit");
                        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                          goto _L___121;
                        } else {
                          if (__s1_len___58 >= 4U) {
                            _L___121: 
                            if (! ((unsigned int )((void const   *)("iterinit" + 1)) - (unsigned int )((void const   *)"iterinit") == 1U)) {
                              tmp___562 = 1;
                            } else {
                              if (__s2_len___58 >= 4U) {
                                tmp___562 = 1;
                              } else {
                                tmp___562 = 0;
                              }
                            }
                          } else {
                            tmp___562 = 0;
                          }
                        }
                        if (tmp___562) {
                          tmp___557 = __builtin_strcmp(name, "iterinit");
                          tmp___561 = tmp___557;
                        } else {
                          tmp___560 = __builtin_strcmp(name, "iterinit");
                          tmp___561 = tmp___560;
                        }
                      } else {
                        tmp___560 = __builtin_strcmp(name, "iterinit");
                        tmp___561 = tmp___560;
                      }
                      if (tmp___561) {
                        if (0) {
                          __s1_len___57 = strlen(name);
                          __s2_len___57 = strlen("iternext");
                          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                            goto _L___119;
                          } else {
                            if (__s1_len___57 >= 4U) {
                              _L___119: 
                              if (! ((unsigned int )((void const   *)("iternext" + 1)) - (unsigned int )((void const   *)"iternext") == 1U)) {
                                tmp___555 = 1;
                              } else {
                                if (__s2_len___57 >= 4U) {
                                  tmp___555 = 1;
                                } else {
                                  tmp___555 = 0;
                                }
                              }
                            } else {
                              tmp___555 = 0;
                            }
                          }
                          if (tmp___555) {
                            tmp___550 = __builtin_strcmp(name, "iternext");
                            tmp___554 = tmp___550;
                          } else {
                            tmp___553 = __builtin_strcmp(name, "iternext");
                            tmp___554 = tmp___553;
                          }
                        } else {
                          tmp___553 = __builtin_strcmp(name, "iternext");
                          tmp___554 = tmp___553;
                        }
                        if (tmp___554) {
                          if (0) {
                            __s1_len___56 = strlen(name);
                            __s2_len___56 = strlen("sync");
                            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                              goto _L___117;
                            } else {
                              if (__s1_len___56 >= 4U) {
                                _L___117: 
                                if (! ((unsigned int )((void const   *)("sync" + 1)) - (unsigned int )((void const   *)"sync") == 1U)) {
                                  tmp___548 = 1;
                                } else {
                                  if (__s2_len___56 >= 4U) {
                                    tmp___548 = 1;
                                  } else {
                                    tmp___548 = 0;
                                  }
                                }
                              } else {
                                tmp___548 = 0;
                              }
                            }
                            if (tmp___548) {
                              tmp___543 = __builtin_strcmp(name, "sync");
                              tmp___547 = tmp___543;
                            } else {
                              tmp___546 = __builtin_strcmp(name, "sync");
                              tmp___547 = tmp___546;
                            }
                          } else {
                            tmp___546 = __builtin_strcmp(name, "sync");
                            tmp___547 = tmp___546;
                          }
                          if (tmp___547) {
                            if (0) {
                              __s1_len___55 = strlen(name);
                              __s2_len___55 = strlen("optimize");
                              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                                goto _L___115;
                              } else {
                                if (__s1_len___55 >= 4U) {
                                  _L___115: 
                                  if (! ((unsigned int )((void const   *)("optimize" + 1)) - (unsigned int )((void const   *)"optimize") == 1U)) {
                                    tmp___541 = 1;
                                  } else {
                                    if (__s2_len___55 >= 4U) {
                                      tmp___541 = 1;
                                    } else {
                                      tmp___541 = 0;
                                    }
                                  }
                                } else {
                                  tmp___541 = 0;
                                }
                              }
                              if (tmp___541) {
                                tmp___536 = __builtin_strcmp(name, "optimize");
                                tmp___540 = tmp___536;
                              } else {
                                tmp___539 = __builtin_strcmp(name, "optimize");
                                tmp___540 = tmp___539;
                              }
                            } else {
                              tmp___539 = __builtin_strcmp(name, "optimize");
                              tmp___540 = tmp___539;
                            }
                            if (tmp___540) {
                              if (0) {
                                __s1_len___54 = strlen(name);
                                __s2_len___54 = strlen("vanish");
                                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                                  goto _L___113;
                                } else {
                                  if (__s1_len___54 >= 4U) {
                                    _L___113: 
                                    if (! ((unsigned int )((void const   *)("vanish" + 1)) - (unsigned int )((void const   *)"vanish") == 1U)) {
                                      tmp___534 = 1;
                                    } else {
                                      if (__s2_len___54 >= 4U) {
                                        tmp___534 = 1;
                                      } else {
                                        tmp___534 = 0;
                                      }
                                    }
                                  } else {
                                    tmp___534 = 0;
                                  }
                                }
                                if (tmp___534) {
                                  tmp___529 = __builtin_strcmp(name, "vanish");
                                  tmp___533 = tmp___529;
                                } else {
                                  tmp___532 = __builtin_strcmp(name, "vanish");
                                  tmp___533 = tmp___532;
                                }
                              } else {
                                tmp___532 = __builtin_strcmp(name, "vanish");
                                tmp___533 = tmp___532;
                              }
                              if (tmp___533) {
                                if (0) {
                                  __s1_len___53 = strlen(name);
                                  __s2_len___53 = strlen("defrag");
                                  if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                                    goto _L___111;
                                  } else {
                                    if (__s1_len___53 >= 4U) {
                                      _L___111: 
                                      if (! ((unsigned int )((void const   *)("defrag" + 1)) - (unsigned int )((void const   *)"defrag") == 1U)) {
                                        tmp___527 = 1;
                                      } else {
                                        if (__s2_len___53 >= 4U) {
                                          tmp___527 = 1;
                                        } else {
                                          tmp___527 = 0;
                                        }
                                      }
                                    } else {
                                      tmp___527 = 0;
                                    }
                                  }
                                  if (tmp___527) {
                                    tmp___522 = __builtin_strcmp(name, "defrag");
                                    tmp___526 = tmp___522;
                                  } else {
                                    tmp___525 = __builtin_strcmp(name, "defrag");
                                    tmp___526 = tmp___525;
                                  }
                                } else {
                                  tmp___525 = __builtin_strcmp(name, "defrag");
                                  tmp___526 = tmp___525;
                                }
                                if (tmp___526) {
                                  rv = (TCLIST *)((void *)0);
                                } else {
                                  rv = tclistnew2(1);
                                  if (argc > 0) {
                                    tmp___518 = tcatoi((char const   *)((void *)(args->array + (int )args->start)->ptr));
                                    tmp___519 = tmp___518;
                                  } else {
                                    tmp___519 = -1LL;
                                  }
                                  step___0 = tmp___519;
                                  tmp___520 = tcbdbdefrag(adb->bdb, step___0);
                                  if (! tmp___520) {
                                    tclistdel(rv);
                                    rv = (TCLIST *)((void *)0);
                                  }
                                }
                              } else {
                                rv = tclistnew2(1);
                                tmp___517 = tcadbvanish(adb);
                                if (! tmp___517) {
                                  tclistdel(rv);
                                  rv = (TCLIST *)((void *)0);
                                }
                              }
                            } else {
                              rv = tclistnew2(1);
                              if (argc > 0) {
                                tmp___515 = (void *)(args->array + (int )args->start)->ptr;
                              } else {
                                tmp___515 = (void *)0;
                              }
                              params___2 = (char const   *)tmp___515;
                              tmp___516 = tcadboptimize(adb, params___2);
                              if (! tmp___516) {
                                tclistdel(rv);
                                rv = (TCLIST *)((void *)0);
                              }
                            }
                          } else {
                            rv = tclistnew2(1);
                            tmp___514 = tcadbsync(adb);
                            if (! tmp___514) {
                              tclistdel(rv);
                              rv = (TCLIST *)((void *)0);
                            }
                          }
                        } else {
                          rv = tclistnew2(1);
                          tmp___504 = tcbdbcurkey3(adb->cur, & ksiz___30);
                          kbuf___30 = (char const   *)tmp___504;
                          if (kbuf___30) {
                            while (1) {
                              TC_mysize___16 = ksiz___30;
                              TC_index___16 = rv->start + rv->num;
                              if (TC_index___16 >= rv->anum) {
                                rv->anum += rv->num + 1;
                                while (1) {
                                  tmp___506 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                                  tmp___505 = (TCLISTDATUM *)tmp___506;
                                  rv->array = tmp___505;
                                  if (! tmp___505) {
                                    tcmyfatal("out of memory");
                                  }
                                  break;
                                }
                              }
                              array___16 = rv->array;
                              while (1) {
                                tmp___508 = malloc((unsigned int )(TC_mysize___16 + 1));
                                tmp___507 = (char *)tmp___508;
                                (array___16 + TC_index___16)->ptr = tmp___507;
                                if (! tmp___507) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                              memcpy((void * __restrict  )(array___16 + TC_index___16)->ptr,
                                     (void const   * __restrict  )kbuf___30, (unsigned int )TC_mysize___16);
                              *((array___16 + TC_index___16)->ptr + TC_mysize___16) = (char )'\000';
                              (array___16 + TC_index___16)->size = TC_mysize___16;
                              (rv->num) ++;
                              break;
                            }
                            tmp___509 = tcbdbcurval3(adb->cur, & vsiz___17);
                            vbuf___17 = (char const   *)tmp___509;
                            if (vbuf___17) {
                              while (1) {
                                TC_mysize___17 = vsiz___17;
                                TC_index___17 = rv->start + rv->num;
                                if (TC_index___17 >= rv->anum) {
                                  rv->anum += rv->num + 1;
                                  while (1) {
                                    tmp___511 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                                    tmp___510 = (TCLISTDATUM *)tmp___511;
                                    rv->array = tmp___510;
                                    if (! tmp___510) {
                                      tcmyfatal("out of memory");
                                    }
                                    break;
                                  }
                                }
                                array___17 = rv->array;
                                while (1) {
                                  tmp___513 = malloc((unsigned int )(TC_mysize___17 + 1));
                                  tmp___512 = (char *)tmp___513;
                                  (array___17 + TC_index___17)->ptr = tmp___512;
                                  if (! tmp___512) {
                                    tcmyfatal("out of memory");
                                  }
                                  break;
                                }
                                memcpy((void * __restrict  )(array___17 + TC_index___17)->ptr,
                                       (void const   * __restrict  )vbuf___17, (unsigned int )TC_mysize___17);
                                *((array___17 + TC_index___17)->ptr + TC_mysize___17) = (char )'\000';
                                (array___17 + TC_index___17)->size = TC_mysize___17;
                                (rv->num) ++;
                                break;
                              }
                            }
                            tcbdbcurnext(adb->cur);
                          } else {
                            tclistdel(rv);
                            rv = (TCLIST *)((void *)0);
                          }
                        }
                      } else {
                        rv = tclistnew2(1);
                        err___10 = (_Bool)0;
                        if (argc > 0) {
                          while (1) {
                            kbuf___29 = (char const   *)(args->array + (int )args->start)->ptr;
                            ksiz___29 = (args->array + (int )args->start)->size;
                            break;
                          }
                          tmp___502 = tcbdbcurjump(adb->cur, (void const   *)kbuf___29,
                                                   ksiz___29);
                          if (! tmp___502) {
                            err___10 = (_Bool)1;
                          }
                        } else {
                          tmp___503 = tcbdbcurfirst(adb->cur);
                          if (! tmp___503) {
                            err___10 = (_Bool)1;
                          }
                        }
                        if (err___10) {
                          tclistdel(rv);
                          rv = (TCLIST *)((void *)0);
                        }
                      }
                    } else {
                      rv = tclistnew2(argc * 2);
                      err___9 = (_Bool)0;
                      i___10 = 0;
                      while (i___10 < argc) {
                        while (1) {
                          kbuf___28 = (char const   *)(args->array + (i___10 + (int )args->start))->ptr;
                          ksiz___28 = (args->array + (i___10 + (int )args->start))->size;
                          break;
                        }
                        tmp___492 = tcbdbget4(adb->bdb, (void const   *)kbuf___28,
                                              ksiz___28);
                        vals___0 = tmp___492;
                        if (vals___0) {
                          vnum = vals___0->num;
                          j = 0;
                          while (j < vnum) {
                            while (1) {
                              TC_mysize___14 = ksiz___28;
                              TC_index___14 = rv->start + rv->num;
                              if (TC_index___14 >= rv->anum) {
                                rv->anum += rv->num + 1;
                                while (1) {
                                  tmp___494 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                                  tmp___493 = (TCLISTDATUM *)tmp___494;
                                  rv->array = tmp___493;
                                  if (! tmp___493) {
                                    tcmyfatal("out of memory");
                                  }
                                  break;
                                }
                              }
                              array___14 = rv->array;
                              while (1) {
                                tmp___496 = malloc((unsigned int )(TC_mysize___14 + 1));
                                tmp___495 = (char *)tmp___496;
                                (array___14 + TC_index___14)->ptr = tmp___495;
                                if (! tmp___495) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                              memcpy((void * __restrict  )(array___14 + TC_index___14)->ptr,
                                     (void const   * __restrict  )kbuf___28, (unsigned int )TC_mysize___14);
                              *((array___14 + TC_index___14)->ptr + TC_mysize___14) = (char )'\000';
                              (array___14 + TC_index___14)->size = TC_mysize___14;
                              (rv->num) ++;
                              break;
                            }
                            while (1) {
                              vbuf___16 = (char const   *)(vals___0->array + (j + vals___0->start))->ptr;
                              vsiz___16 = (vals___0->array + (j + vals___0->start))->size;
                              break;
                            }
                            while (1) {
                              TC_mysize___15 = vsiz___16;
                              TC_index___15 = rv->start + rv->num;
                              if (TC_index___15 >= rv->anum) {
                                rv->anum += rv->num + 1;
                                while (1) {
                                  tmp___498 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                                  tmp___497 = (TCLISTDATUM *)tmp___498;
                                  rv->array = tmp___497;
                                  if (! tmp___497) {
                                    tcmyfatal("out of memory");
                                  }
                                  break;
                                }
                              }
                              array___15 = rv->array;
                              while (1) {
                                tmp___500 = malloc((unsigned int )(TC_mysize___15 + 1));
                                tmp___499 = (char *)tmp___500;
                                (array___15 + TC_index___15)->ptr = tmp___499;
                                if (! tmp___499) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                              memcpy((void * __restrict  )(array___15 + TC_index___15)->ptr,
                                     (void const   * __restrict  )vbuf___16, (unsigned int )TC_mysize___15);
                              *((array___15 + TC_index___15)->ptr + TC_mysize___15) = (char )'\000';
                              (array___15 + TC_index___15)->size = TC_mysize___15;
                              (rv->num) ++;
                              break;
                            }
                            j ++;
                          }
                          tclistdel(vals___0);
                        } else {
                          tmp___501 = tcbdbecode(adb->bdb);
                          if (tmp___501 != 22) {
                            err___9 = (_Bool)1;
                          }
                        }
                        i___10 ++;
                      }
                      if (err___9) {
                        tclistdel(rv);
                        rv = (TCLIST *)((void *)0);
                      }
                    }
                  } else {
                    rv = tclistnew2(1);
                    err___8 = (_Bool)0;
                    i___9 = 0;
                    while (i___9 < argc) {
                      while (1) {
                        kbuf___27 = (char const   *)(args->array + (i___9 + (int )args->start))->ptr;
                        ksiz___27 = (args->array + (i___9 + (int )args->start))->size;
                        break;
                      }
                      tmp___490 = tcbdbout3(adb->bdb, (void const   *)kbuf___27, ksiz___27);
                      if (! tmp___490) {
                        tmp___491 = tcbdbecode(adb->bdb);
                        if (tmp___491 != 22) {
                          err___8 = (_Bool)1;
                          break;
                        }
                      }
                      i___9 ++;
                    }
                    if (err___8) {
                      tclistdel(rv);
                      rv = (TCLIST *)((void *)0);
                    }
                  }
                } else {
                  rv = tclistnew2(1);
                  err___7 = (_Bool)0;
                  argc --;
                  i___8 = 0;
                  while (i___8 < argc) {
                    while (1) {
                      kbuf___26 = (char const   *)(args->array + (i___8 + (int )args->start))->ptr;
                      ksiz___26 = (args->array + (i___8 + (int )args->start))->size;
                      break;
                    }
                    tmp___488 = tclistval(args, i___8 + 1, & vsiz___15);
                    vbuf___15 = (char const   *)tmp___488;
                    tmp___489 = tcbdbputdup(adb->bdb, (void const   *)kbuf___26, ksiz___26,
                                            (void const   *)vbuf___15, vsiz___15);
                    if (! tmp___489) {
                      err___7 = (_Bool)1;
                      break;
                    }
                    i___8 += 2;
                  }
                  if (err___7) {
                    tclistdel(rv);
                    rv = (TCLIST *)((void *)0);
                  }
                }
              } else {
                if (argc > 0) {
                  rv = tclistnew2(1);
                  while (1) {
                    kbuf___25 = (char const   *)(args->array + (int )args->start)->ptr;
                    ksiz___25 = (args->array + (int )args->start)->size;
                    break;
                  }
                  tmp___487 = tcbdbget4(adb->bdb, (void const   *)kbuf___25, ksiz___25);
                  vals = tmp___487;
                  if (vals) {
                    tclistdel(rv);
                    rv = vals;
                  } else {
                    tclistdel(rv);
                    rv = (TCLIST *)((void *)0);
                  }
                } else {
                  rv = (TCLIST *)((void *)0);
                }
              }
            } else {
              if (argc > 0) {
                rv = tclistnew2(1);
                while (1) {
                  kbuf___24 = (char const   *)(args->array + (int )args->start)->ptr;
                  ksiz___24 = (args->array + (int )args->start)->size;
                  break;
                }
                tmp___486 = tcbdbout(adb->bdb, (void const   *)kbuf___24, ksiz___24);
                if (! tmp___486) {
                  tclistdel(rv);
                  rv = (TCLIST *)((void *)0);
                }
              } else {
                rv = (TCLIST *)((void *)0);
              }
            }
          } else {
            _L___142: 
            if (argc > 1) {
              rv = tclistnew2(1);
              while (1) {
                kbuf___23 = (char const   *)(args->array + (int )args->start)->ptr;
                ksiz___23 = (args->array + (int )args->start)->size;
                break;
              }
              while (1) {
                vbuf___14 = (char const   *)(args->array + (1 + (int )args->start))->ptr;
                vsiz___14 = (args->array + (1 + (int )args->start))->size;
                break;
              }
              err___6 = (_Bool)0;
              if (0) {
                __s1_len___52 = strlen(name);
                __s2_len___52 = strlen("put");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___109;
                } else {
                  if (__s1_len___52 >= 4U) {
                    _L___109: 
                    if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
                      tmp___485 = 1;
                    } else {
                      if (__s2_len___52 >= 4U) {
                        tmp___485 = 1;
                      } else {
                        tmp___485 = 0;
                      }
                    }
                  } else {
                    tmp___485 = 0;
                  }
                }
                if (tmp___485) {
                  tmp___480 = __builtin_strcmp(name, "put");
                  tmp___484 = tmp___480;
                } else {
                  tmp___483 = __builtin_strcmp(name, "put");
                  tmp___484 = tmp___483;
                }
              } else {
                tmp___483 = __builtin_strcmp(name, "put");
                tmp___484 = tmp___483;
              }
              if (tmp___484) {
                if (0) {
                  __s1_len___51 = strlen(name);
                  __s2_len___51 = strlen("putkeep");
                  if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                    goto _L___107;
                  } else {
                    if (__s1_len___51 >= 4U) {
                      _L___107: 
                      if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
                        tmp___478 = 1;
                      } else {
                        if (__s2_len___51 >= 4U) {
                          tmp___478 = 1;
                        } else {
                          tmp___478 = 0;
                        }
                      }
                    } else {
                      tmp___478 = 0;
                    }
                  }
                  if (tmp___478) {
                    tmp___473 = __builtin_strcmp(name, "putkeep");
                    tmp___477 = tmp___473;
                  } else {
                    tmp___476 = __builtin_strcmp(name, "putkeep");
                    tmp___477 = tmp___476;
                  }
                } else {
                  tmp___476 = __builtin_strcmp(name, "putkeep");
                  tmp___477 = tmp___476;
                }
                if (tmp___477) {
                  if (0) {
                    __s1_len___50 = strlen(name);
                    __s2_len___50 = strlen("putcat");
                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                      goto _L___105;
                    } else {
                      if (__s1_len___50 >= 4U) {
                        _L___105: 
                        if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
                          tmp___471 = 1;
                        } else {
                          if (__s2_len___50 >= 4U) {
                            tmp___471 = 1;
                          } else {
                            tmp___471 = 0;
                          }
                        }
                      } else {
                        tmp___471 = 0;
                      }
                    }
                    if (tmp___471) {
                      tmp___466 = __builtin_strcmp(name, "putcat");
                      tmp___470 = tmp___466;
                    } else {
                      tmp___469 = __builtin_strcmp(name, "putcat");
                      tmp___470 = tmp___469;
                    }
                  } else {
                    tmp___469 = __builtin_strcmp(name, "putcat");
                    tmp___470 = tmp___469;
                  }
                  if (tmp___470) {
                    if (0) {
                      __s1_len___49 = strlen(name);
                      __s2_len___49 = strlen("putdup");
                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                        goto _L___103;
                      } else {
                        if (__s1_len___49 >= 4U) {
                          _L___103: 
                          if (! ((unsigned int )((void const   *)("putdup" + 1)) - (unsigned int )((void const   *)"putdup") == 1U)) {
                            tmp___464 = 1;
                          } else {
                            if (__s2_len___49 >= 4U) {
                              tmp___464 = 1;
                            } else {
                              tmp___464 = 0;
                            }
                          }
                        } else {
                          tmp___464 = 0;
                        }
                      }
                      if (tmp___464) {
                        tmp___459 = __builtin_strcmp(name, "putdup");
                        tmp___463 = tmp___459;
                      } else {
                        tmp___462 = __builtin_strcmp(name, "putdup");
                        tmp___463 = tmp___462;
                      }
                    } else {
                      tmp___462 = __builtin_strcmp(name, "putdup");
                      tmp___463 = tmp___462;
                    }
                    if (tmp___463) {
                      if (0) {
                        __s1_len___48 = strlen(name);
                        __s2_len___48 = strlen("putback");
                        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                          goto _L___101;
                        } else {
                          if (__s1_len___48 >= 4U) {
                            _L___101: 
                            if (! ((unsigned int )((void const   *)("putback" + 1)) - (unsigned int )((void const   *)"putback") == 1U)) {
                              tmp___457 = 1;
                            } else {
                              if (__s2_len___48 >= 4U) {
                                tmp___457 = 1;
                              } else {
                                tmp___457 = 0;
                              }
                            }
                          } else {
                            tmp___457 = 0;
                          }
                        }
                        if (tmp___457) {
                          tmp___452 = __builtin_strcmp(name, "putback");
                          tmp___456 = tmp___452;
                        } else {
                          tmp___455 = __builtin_strcmp(name, "putback");
                          tmp___456 = tmp___455;
                        }
                      } else {
                        tmp___455 = __builtin_strcmp(name, "putback");
                        tmp___456 = tmp___455;
                      }
                      if (! tmp___456) {
                        tmp___450 = tcbdbputdupback(adb->bdb, (void const   *)kbuf___23,
                                                    ksiz___23, (void const   *)vbuf___14,
                                                    vsiz___14);
                        if (! tmp___450) {
                          err___6 = (_Bool)1;
                        }
                      }
                    } else {
                      tmp___449 = tcbdbputdup(adb->bdb, (void const   *)kbuf___23,
                                              ksiz___23, (void const   *)vbuf___14,
                                              vsiz___14);
                      if (! tmp___449) {
                        err___6 = (_Bool)1;
                      }
                    }
                  } else {
                    tmp___448 = tcbdbputcat(adb->bdb, (void const   *)kbuf___23, ksiz___23,
                                            (void const   *)vbuf___14, vsiz___14);
                    if (! tmp___448) {
                      err___6 = (_Bool)1;
                    }
                  }
                } else {
                  tmp___447 = tcbdbputkeep(adb->bdb, (void const   *)kbuf___23, ksiz___23,
                                           (void const   *)vbuf___14, vsiz___14);
                  if (! tmp___447) {
                    err___6 = (_Bool)1;
                  }
                }
              } else {
                tmp___446 = tcbdbput(adb->bdb, (void const   *)kbuf___23, ksiz___23,
                                     (void const   *)vbuf___14, vsiz___14);
                if (! tmp___446) {
                  err___6 = (_Bool)1;
                }
              }
              if (err___6) {
                tclistdel(rv);
                rv = (TCLIST *)((void *)0);
              }
            } else {
              rv = (TCLIST *)((void *)0);
            }
          }
        } else {
          goto _L___142;
        }
      } else {
        goto _L___142;
      }
    } else {
      goto _L___142;
    }
  } else {
    goto _L___142;
  }
  break;
  case 5: 
  if (0) {
    __s1_len___82 = strlen(name);
    __s2_len___82 = strlen("put");
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___170;
    } else {
      if (__s1_len___82 >= 4U) {
        _L___170: 
        if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
          tmp___769 = 1;
        } else {
          if (__s2_len___82 >= 4U) {
            tmp___769 = 1;
          } else {
            tmp___769 = 0;
          }
        }
      } else {
        tmp___769 = 0;
      }
    }
    if (tmp___769) {
      tmp___764 = __builtin_strcmp(name, "put");
      tmp___768 = tmp___764;
    } else {
      tmp___767 = __builtin_strcmp(name, "put");
      tmp___768 = tmp___767;
    }
  } else {
    tmp___767 = __builtin_strcmp(name, "put");
    tmp___768 = tmp___767;
  }
  if (tmp___768) {
    if (0) {
      __s1_len___83 = strlen(name);
      __s2_len___83 = strlen("putkeep");
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___172;
      } else {
        if (__s1_len___83 >= 4U) {
          _L___172: 
          if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
            tmp___776 = 1;
          } else {
            if (__s2_len___83 >= 4U) {
              tmp___776 = 1;
            } else {
              tmp___776 = 0;
            }
          }
        } else {
          tmp___776 = 0;
        }
      }
      if (tmp___776) {
        tmp___771 = __builtin_strcmp(name, "putkeep");
        tmp___775 = tmp___771;
      } else {
        tmp___774 = __builtin_strcmp(name, "putkeep");
        tmp___775 = tmp___774;
      }
    } else {
      tmp___774 = __builtin_strcmp(name, "putkeep");
      tmp___775 = tmp___774;
    }
    if (tmp___775) {
      if (0) {
        __s1_len___84 = strlen(name);
        __s2_len___84 = strlen("putcat");
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___174;
        } else {
          if (__s1_len___84 >= 4U) {
            _L___174: 
            if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
              tmp___783 = 1;
            } else {
              if (__s2_len___84 >= 4U) {
                tmp___783 = 1;
              } else {
                tmp___783 = 0;
              }
            }
          } else {
            tmp___783 = 0;
          }
        }
        if (tmp___783) {
          tmp___778 = __builtin_strcmp(name, "putcat");
          tmp___782 = tmp___778;
        } else {
          tmp___781 = __builtin_strcmp(name, "putcat");
          tmp___782 = tmp___781;
        }
      } else {
        tmp___781 = __builtin_strcmp(name, "putcat");
        tmp___782 = tmp___781;
      }
      if (tmp___782) {
        if (0) {
          __s1_len___81 = strlen(name);
          __s2_len___81 = strlen("out");
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___168;
          } else {
            if (__s1_len___81 >= 4U) {
              _L___168: 
              if (! ((unsigned int )((void const   *)("out" + 1)) - (unsigned int )((void const   *)"out") == 1U)) {
                tmp___762 = 1;
              } else {
                if (__s2_len___81 >= 4U) {
                  tmp___762 = 1;
                } else {
                  tmp___762 = 0;
                }
              }
            } else {
              tmp___762 = 0;
            }
          }
          if (tmp___762) {
            tmp___757 = __builtin_strcmp(name, "out");
            tmp___761 = tmp___757;
          } else {
            tmp___760 = __builtin_strcmp(name, "out");
            tmp___761 = tmp___760;
          }
        } else {
          tmp___760 = __builtin_strcmp(name, "out");
          tmp___761 = tmp___760;
        }
        if (tmp___761) {
          if (0) {
            __s1_len___80 = strlen(name);
            __s2_len___80 = strlen("get");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___166;
            } else {
              if (__s1_len___80 >= 4U) {
                _L___166: 
                if (! ((unsigned int )((void const   *)("get" + 1)) - (unsigned int )((void const   *)"get") == 1U)) {
                  tmp___755 = 1;
                } else {
                  if (__s2_len___80 >= 4U) {
                    tmp___755 = 1;
                  } else {
                    tmp___755 = 0;
                  }
                }
              } else {
                tmp___755 = 0;
              }
            }
            if (tmp___755) {
              tmp___750 = __builtin_strcmp(name, "get");
              tmp___754 = tmp___750;
            } else {
              tmp___753 = __builtin_strcmp(name, "get");
              tmp___754 = tmp___753;
            }
          } else {
            tmp___753 = __builtin_strcmp(name, "get");
            tmp___754 = tmp___753;
          }
          if (tmp___754) {
            if (0) {
              __s1_len___79 = strlen(name);
              __s2_len___79 = strlen("putlist");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___164;
              } else {
                if (__s1_len___79 >= 4U) {
                  _L___164: 
                  if (! ((unsigned int )((void const   *)("putlist" + 1)) - (unsigned int )((void const   *)"putlist") == 1U)) {
                    tmp___748 = 1;
                  } else {
                    if (__s2_len___79 >= 4U) {
                      tmp___748 = 1;
                    } else {
                      tmp___748 = 0;
                    }
                  }
                } else {
                  tmp___748 = 0;
                }
              }
              if (tmp___748) {
                tmp___743 = __builtin_strcmp(name, "putlist");
                tmp___747 = tmp___743;
              } else {
                tmp___746 = __builtin_strcmp(name, "putlist");
                tmp___747 = tmp___746;
              }
            } else {
              tmp___746 = __builtin_strcmp(name, "putlist");
              tmp___747 = tmp___746;
            }
            if (tmp___747) {
              if (0) {
                __s1_len___78 = strlen(name);
                __s2_len___78 = strlen("outlist");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___162;
                } else {
                  if (__s1_len___78 >= 4U) {
                    _L___162: 
                    if (! ((unsigned int )((void const   *)("outlist" + 1)) - (unsigned int )((void const   *)"outlist") == 1U)) {
                      tmp___741 = 1;
                    } else {
                      if (__s2_len___78 >= 4U) {
                        tmp___741 = 1;
                      } else {
                        tmp___741 = 0;
                      }
                    }
                  } else {
                    tmp___741 = 0;
                  }
                }
                if (tmp___741) {
                  tmp___736 = __builtin_strcmp(name, "outlist");
                  tmp___740 = tmp___736;
                } else {
                  tmp___739 = __builtin_strcmp(name, "outlist");
                  tmp___740 = tmp___739;
                }
              } else {
                tmp___739 = __builtin_strcmp(name, "outlist");
                tmp___740 = tmp___739;
              }
              if (tmp___740) {
                if (0) {
                  __s1_len___77 = strlen(name);
                  __s2_len___77 = strlen("getlist");
                  if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                    goto _L___160;
                  } else {
                    if (__s1_len___77 >= 4U) {
                      _L___160: 
                      if (! ((unsigned int )((void const   *)("getlist" + 1)) - (unsigned int )((void const   *)"getlist") == 1U)) {
                        tmp___734 = 1;
                      } else {
                        if (__s2_len___77 >= 4U) {
                          tmp___734 = 1;
                        } else {
                          tmp___734 = 0;
                        }
                      }
                    } else {
                      tmp___734 = 0;
                    }
                  }
                  if (tmp___734) {
                    tmp___729 = __builtin_strcmp(name, "getlist");
                    tmp___733 = tmp___729;
                  } else {
                    tmp___732 = __builtin_strcmp(name, "getlist");
                    tmp___733 = tmp___732;
                  }
                } else {
                  tmp___732 = __builtin_strcmp(name, "getlist");
                  tmp___733 = tmp___732;
                }
                if (tmp___733) {
                  if (0) {
                    __s1_len___76 = strlen(name);
                    __s2_len___76 = strlen("iterinit");
                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                      goto _L___158;
                    } else {
                      if (__s1_len___76 >= 4U) {
                        _L___158: 
                        if (! ((unsigned int )((void const   *)("iterinit" + 1)) - (unsigned int )((void const   *)"iterinit") == 1U)) {
                          tmp___727 = 1;
                        } else {
                          if (__s2_len___76 >= 4U) {
                            tmp___727 = 1;
                          } else {
                            tmp___727 = 0;
                          }
                        }
                      } else {
                        tmp___727 = 0;
                      }
                    }
                    if (tmp___727) {
                      tmp___722 = __builtin_strcmp(name, "iterinit");
                      tmp___726 = tmp___722;
                    } else {
                      tmp___725 = __builtin_strcmp(name, "iterinit");
                      tmp___726 = tmp___725;
                    }
                  } else {
                    tmp___725 = __builtin_strcmp(name, "iterinit");
                    tmp___726 = tmp___725;
                  }
                  if (tmp___726) {
                    if (0) {
                      __s1_len___75 = strlen(name);
                      __s2_len___75 = strlen("iternext");
                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                        goto _L___156;
                      } else {
                        if (__s1_len___75 >= 4U) {
                          _L___156: 
                          if (! ((unsigned int )((void const   *)("iternext" + 1)) - (unsigned int )((void const   *)"iternext") == 1U)) {
                            tmp___720 = 1;
                          } else {
                            if (__s2_len___75 >= 4U) {
                              tmp___720 = 1;
                            } else {
                              tmp___720 = 0;
                            }
                          }
                        } else {
                          tmp___720 = 0;
                        }
                      }
                      if (tmp___720) {
                        tmp___715 = __builtin_strcmp(name, "iternext");
                        tmp___719 = tmp___715;
                      } else {
                        tmp___718 = __builtin_strcmp(name, "iternext");
                        tmp___719 = tmp___718;
                      }
                    } else {
                      tmp___718 = __builtin_strcmp(name, "iternext");
                      tmp___719 = tmp___718;
                    }
                    if (tmp___719) {
                      if (0) {
                        __s1_len___74 = strlen(name);
                        __s2_len___74 = strlen("sync");
                        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                          goto _L___154;
                        } else {
                          if (__s1_len___74 >= 4U) {
                            _L___154: 
                            if (! ((unsigned int )((void const   *)("sync" + 1)) - (unsigned int )((void const   *)"sync") == 1U)) {
                              tmp___713 = 1;
                            } else {
                              if (__s2_len___74 >= 4U) {
                                tmp___713 = 1;
                              } else {
                                tmp___713 = 0;
                              }
                            }
                          } else {
                            tmp___713 = 0;
                          }
                        }
                        if (tmp___713) {
                          tmp___708 = __builtin_strcmp(name, "sync");
                          tmp___712 = tmp___708;
                        } else {
                          tmp___711 = __builtin_strcmp(name, "sync");
                          tmp___712 = tmp___711;
                        }
                      } else {
                        tmp___711 = __builtin_strcmp(name, "sync");
                        tmp___712 = tmp___711;
                      }
                      if (tmp___712) {
                        if (0) {
                          __s1_len___73 = strlen(name);
                          __s2_len___73 = strlen("optimize");
                          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                            goto _L___152;
                          } else {
                            if (__s1_len___73 >= 4U) {
                              _L___152: 
                              if (! ((unsigned int )((void const   *)("optimize" + 1)) - (unsigned int )((void const   *)"optimize") == 1U)) {
                                tmp___706 = 1;
                              } else {
                                if (__s2_len___73 >= 4U) {
                                  tmp___706 = 1;
                                } else {
                                  tmp___706 = 0;
                                }
                              }
                            } else {
                              tmp___706 = 0;
                            }
                          }
                          if (tmp___706) {
                            tmp___701 = __builtin_strcmp(name, "optimize");
                            tmp___705 = tmp___701;
                          } else {
                            tmp___704 = __builtin_strcmp(name, "optimize");
                            tmp___705 = tmp___704;
                          }
                        } else {
                          tmp___704 = __builtin_strcmp(name, "optimize");
                          tmp___705 = tmp___704;
                        }
                        if (tmp___705) {
                          if (0) {
                            __s1_len___72 = strlen(name);
                            __s2_len___72 = strlen("vanish");
                            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                              goto _L___150;
                            } else {
                              if (__s1_len___72 >= 4U) {
                                _L___150: 
                                if (! ((unsigned int )((void const   *)("vanish" + 1)) - (unsigned int )((void const   *)"vanish") == 1U)) {
                                  tmp___699 = 1;
                                } else {
                                  if (__s2_len___72 >= 4U) {
                                    tmp___699 = 1;
                                  } else {
                                    tmp___699 = 0;
                                  }
                                }
                              } else {
                                tmp___699 = 0;
                              }
                            }
                            if (tmp___699) {
                              tmp___694 = __builtin_strcmp(name, "vanish");
                              tmp___698 = tmp___694;
                            } else {
                              tmp___697 = __builtin_strcmp(name, "vanish");
                              tmp___698 = tmp___697;
                            }
                          } else {
                            tmp___697 = __builtin_strcmp(name, "vanish");
                            tmp___698 = tmp___697;
                          }
                          if (tmp___698) {
                            rv = (TCLIST *)((void *)0);
                          } else {
                            rv = tclistnew2(1);
                            tmp___692 = tcadbvanish(adb);
                            if (! tmp___692) {
                              tclistdel(rv);
                              rv = (TCLIST *)((void *)0);
                            }
                          }
                        } else {
                          rv = tclistnew2(1);
                          if (argc > 0) {
                            tmp___690 = (void *)(args->array + (int )args->start)->ptr;
                          } else {
                            tmp___690 = (void *)0;
                          }
                          params___3 = (char const   *)tmp___690;
                          tmp___691 = tcadboptimize(adb, params___3);
                          if (! tmp___691) {
                            tclistdel(rv);
                            rv = (TCLIST *)((void *)0);
                          }
                        }
                      } else {
                        rv = tclistnew2(1);
                        tmp___689 = tcadbsync(adb);
                        if (! tmp___689) {
                          tclistdel(rv);
                          rv = (TCLIST *)((void *)0);
                        }
                      }
                    } else {
                      rv = tclistnew2(1);
                      tmp___679 = tcfdbiternext2(adb->fdb, & ksiz___38);
                      kbuf___38 = (char *)tmp___679;
                      if (kbuf___38) {
                        while (1) {
                          TC_mysize___21 = ksiz___38;
                          TC_index___21 = rv->start + rv->num;
                          if (TC_index___21 >= rv->anum) {
                            rv->anum += rv->num + 1;
                            while (1) {
                              tmp___681 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                              tmp___680 = (TCLISTDATUM *)tmp___681;
                              rv->array = tmp___680;
                              if (! tmp___680) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                          }
                          array___21 = rv->array;
                          while (1) {
                            tmp___683 = malloc((unsigned int )(TC_mysize___21 + 1));
                            tmp___682 = (char *)tmp___683;
                            (array___21 + TC_index___21)->ptr = tmp___682;
                            if (! tmp___682) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                          memcpy((void * __restrict  )(array___21 + TC_index___21)->ptr,
                                 (void const   * __restrict  )kbuf___38, (unsigned int )TC_mysize___21);
                          *((array___21 + TC_index___21)->ptr + TC_mysize___21) = (char )'\000';
                          (array___21 + TC_index___21)->size = TC_mysize___21;
                          (rv->num) ++;
                          break;
                        }
                        tmp___684 = tcfdbget2(adb->fdb, (void const   *)kbuf___38,
                                              ksiz___38, & vsiz___22);
                        vbuf___22 = (char *)tmp___684;
                        if (vbuf___22) {
                          while (1) {
                            TC_mysize___22 = vsiz___22;
                            TC_index___22 = rv->start + rv->num;
                            if (TC_index___22 >= rv->anum) {
                              rv->anum += rv->num + 1;
                              while (1) {
                                tmp___686 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                                tmp___685 = (TCLISTDATUM *)tmp___686;
                                rv->array = tmp___685;
                                if (! tmp___685) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                            }
                            array___22 = rv->array;
                            while (1) {
                              tmp___688 = malloc((unsigned int )(TC_mysize___22 + 1));
                              tmp___687 = (char *)tmp___688;
                              (array___22 + TC_index___22)->ptr = tmp___687;
                              if (! tmp___687) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                            memcpy((void * __restrict  )(array___22 + TC_index___22)->ptr,
                                   (void const   * __restrict  )vbuf___22, (unsigned int )TC_mysize___22);
                            *((array___22 + TC_index___22)->ptr + TC_mysize___22) = (char )'\000';
                            (array___22 + TC_index___22)->size = TC_mysize___22;
                            (rv->num) ++;
                            break;
                          }
                          while (1) {
                            free((void *)vbuf___22);
                            break;
                          }
                        }
                        while (1) {
                          free((void *)kbuf___38);
                          break;
                        }
                      } else {
                        tclistdel(rv);
                        rv = (TCLIST *)((void *)0);
                      }
                    }
                  } else {
                    rv = tclistnew2(1);
                    err___15 = (_Bool)0;
                    if (argc > 0) {
                      while (1) {
                        kbuf___37 = (char const   *)(args->array + (int )args->start)->ptr;
                        ksiz___37 = (args->array + (int )args->start)->size;
                        break;
                      }
                      tmp___677 = tcfdbiterinit3(adb->fdb, (void const   *)kbuf___37,
                                                 ksiz___37);
                      if (! tmp___677) {
                        err___15 = (_Bool)1;
                      }
                    } else {
                      tmp___678 = tcfdbiterinit(adb->fdb);
                      if (! tmp___678) {
                        err___15 = (_Bool)1;
                      }
                    }
                    if (err___15) {
                      tclistdel(rv);
                      rv = (TCLIST *)((void *)0);
                    }
                  }
                } else {
                  rv = tclistnew2(argc * 2);
                  err___14 = (_Bool)0;
                  i___13 = 0;
                  while (i___13 < argc) {
                    while (1) {
                      kbuf___36 = (char const   *)(args->array + (i___13 + (int )args->start))->ptr;
                      ksiz___36 = (args->array + (i___13 + (int )args->start))->size;
                      break;
                    }
                    tmp___667 = tcfdbget2(adb->fdb, (void const   *)kbuf___36, ksiz___36,
                                          & vsiz___21);
                    vbuf___21 = (char *)tmp___667;
                    if (vbuf___21) {
                      while (1) {
                        TC_mysize___19 = ksiz___36;
                        TC_index___19 = rv->start + rv->num;
                        if (TC_index___19 >= rv->anum) {
                          rv->anum += rv->num + 1;
                          while (1) {
                            tmp___669 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                            tmp___668 = (TCLISTDATUM *)tmp___669;
                            rv->array = tmp___668;
                            if (! tmp___668) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___19 = rv->array;
                        while (1) {
                          tmp___671 = malloc((unsigned int )(TC_mysize___19 + 1));
                          tmp___670 = (char *)tmp___671;
                          (array___19 + TC_index___19)->ptr = tmp___670;
                          if (! tmp___670) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___19 + TC_index___19)->ptr,
                               (void const   * __restrict  )kbuf___36, (unsigned int )TC_mysize___19);
                        *((array___19 + TC_index___19)->ptr + TC_mysize___19) = (char )'\000';
                        (array___19 + TC_index___19)->size = TC_mysize___19;
                        (rv->num) ++;
                        break;
                      }
                      while (1) {
                        TC_mysize___20 = vsiz___21;
                        TC_index___20 = rv->start + rv->num;
                        if (TC_index___20 >= rv->anum) {
                          rv->anum += rv->num + 1;
                          while (1) {
                            tmp___673 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                            tmp___672 = (TCLISTDATUM *)tmp___673;
                            rv->array = tmp___672;
                            if (! tmp___672) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___20 = rv->array;
                        while (1) {
                          tmp___675 = malloc((unsigned int )(TC_mysize___20 + 1));
                          tmp___674 = (char *)tmp___675;
                          (array___20 + TC_index___20)->ptr = tmp___674;
                          if (! tmp___674) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___20 + TC_index___20)->ptr,
                               (void const   * __restrict  )vbuf___21, (unsigned int )TC_mysize___20);
                        *((array___20 + TC_index___20)->ptr + TC_mysize___20) = (char )'\000';
                        (array___20 + TC_index___20)->size = TC_mysize___20;
                        (rv->num) ++;
                        break;
                      }
                      while (1) {
                        free((void *)vbuf___21);
                        break;
                      }
                    } else {
                      tmp___676 = tcfdbecode(adb->fdb);
                      if (tmp___676 != 22) {
                        err___14 = (_Bool)1;
                      }
                    }
                    i___13 ++;
                  }
                  if (err___14) {
                    tclistdel(rv);
                    rv = (TCLIST *)((void *)0);
                  }
                }
              } else {
                rv = tclistnew2(1);
                err___13 = (_Bool)0;
                i___12 = 0;
                while (i___12 < argc) {
                  while (1) {
                    kbuf___35 = (char const   *)(args->array + (i___12 + (int )args->start))->ptr;
                    ksiz___35 = (args->array + (i___12 + (int )args->start))->size;
                    break;
                  }
                  tmp___665 = tcfdbout2(adb->fdb, (void const   *)kbuf___35, ksiz___35);
                  if (! tmp___665) {
                    tmp___666 = tcfdbecode(adb->fdb);
                    if (tmp___666 != 22) {
                      err___13 = (_Bool)1;
                      break;
                    }
                  }
                  i___12 ++;
                }
                if (err___13) {
                  tclistdel(rv);
                  rv = (TCLIST *)((void *)0);
                }
              }
            } else {
              rv = tclistnew2(1);
              err___12 = (_Bool)0;
              argc --;
              i___11 = 0;
              while (i___11 < argc) {
                while (1) {
                  kbuf___34 = (char const   *)(args->array + (i___11 + (int )args->start))->ptr;
                  ksiz___34 = (args->array + (i___11 + (int )args->start))->size;
                  break;
                }
                tmp___663 = tclistval(args, i___11 + 1, & vsiz___20);
                vbuf___20 = (char const   *)tmp___663;
                tmp___664 = tcfdbput2(adb->fdb, (void const   *)kbuf___34, ksiz___34,
                                      (void const   *)vbuf___20, vsiz___20);
                if (! tmp___664) {
                  err___12 = (_Bool)1;
                  break;
                }
                i___11 += 2;
              }
              if (err___12) {
                tclistdel(rv);
                rv = (TCLIST *)((void *)0);
              }
            }
          } else {
            if (argc > 0) {
              rv = tclistnew2(1);
              while (1) {
                kbuf___33 = (char const   *)(args->array + (int )args->start)->ptr;
                ksiz___33 = (args->array + (int )args->start)->size;
                break;
              }
              tmp___658 = tcfdbget2(adb->fdb, (void const   *)kbuf___33, ksiz___33,
                                    & vsiz___19);
              vbuf___19 = (char *)tmp___658;
              if (vbuf___19) {
                while (1) {
                  TC_mysize___18 = vsiz___19;
                  TC_index___18 = rv->start + rv->num;
                  if (TC_index___18 >= rv->anum) {
                    rv->anum += rv->num + 1;
                    while (1) {
                      tmp___660 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                      tmp___659 = (TCLISTDATUM *)tmp___660;
                      rv->array = tmp___659;
                      if (! tmp___659) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                  }
                  array___18 = rv->array;
                  while (1) {
                    tmp___662 = malloc((unsigned int )(TC_mysize___18 + 1));
                    tmp___661 = (char *)tmp___662;
                    (array___18 + TC_index___18)->ptr = tmp___661;
                    if (! tmp___661) {
                      tcmyfatal("out of memory");
                    }
                    break;
                  }
                  memcpy((void * __restrict  )(array___18 + TC_index___18)->ptr, (void const   * __restrict  )vbuf___19,
                         (unsigned int )TC_mysize___18);
                  *((array___18 + TC_index___18)->ptr + TC_mysize___18) = (char )'\000';
                  (array___18 + TC_index___18)->size = TC_mysize___18;
                  (rv->num) ++;
                  break;
                }
                while (1) {
                  free((void *)vbuf___19);
                  break;
                }
              } else {
                tclistdel(rv);
                rv = (TCLIST *)((void *)0);
              }
            } else {
              rv = (TCLIST *)((void *)0);
            }
          }
        } else {
          if (argc > 0) {
            rv = tclistnew2(1);
            while (1) {
              kbuf___32 = (char const   *)(args->array + (int )args->start)->ptr;
              ksiz___32 = (args->array + (int )args->start)->size;
              break;
            }
            tmp___657 = tcfdbout2(adb->fdb, (void const   *)kbuf___32, ksiz___32);
            if (! tmp___657) {
              tclistdel(rv);
              rv = (TCLIST *)((void *)0);
            }
          } else {
            rv = (TCLIST *)((void *)0);
          }
        }
      } else {
        _L___175: 
        if (argc > 1) {
          rv = tclistnew2(1);
          while (1) {
            kbuf___31 = (char const   *)(args->array + (int )args->start)->ptr;
            ksiz___31 = (args->array + (int )args->start)->size;
            break;
          }
          while (1) {
            vbuf___18 = (char const   *)(args->array + (1 + (int )args->start))->ptr;
            vsiz___18 = (args->array + (1 + (int )args->start))->size;
            break;
          }
          err___11 = (_Bool)0;
          if (0) {
            __s1_len___71 = strlen(name);
            __s2_len___71 = strlen("put");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___148;
            } else {
              if (__s1_len___71 >= 4U) {
                _L___148: 
                if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
                  tmp___656 = 1;
                } else {
                  if (__s2_len___71 >= 4U) {
                    tmp___656 = 1;
                  } else {
                    tmp___656 = 0;
                  }
                }
              } else {
                tmp___656 = 0;
              }
            }
            if (tmp___656) {
              tmp___651 = __builtin_strcmp(name, "put");
              tmp___655 = tmp___651;
            } else {
              tmp___654 = __builtin_strcmp(name, "put");
              tmp___655 = tmp___654;
            }
          } else {
            tmp___654 = __builtin_strcmp(name, "put");
            tmp___655 = tmp___654;
          }
          if (tmp___655) {
            if (0) {
              __s1_len___70 = strlen(name);
              __s2_len___70 = strlen("putkeep");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___146;
              } else {
                if (__s1_len___70 >= 4U) {
                  _L___146: 
                  if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
                    tmp___649 = 1;
                  } else {
                    if (__s2_len___70 >= 4U) {
                      tmp___649 = 1;
                    } else {
                      tmp___649 = 0;
                    }
                  }
                } else {
                  tmp___649 = 0;
                }
              }
              if (tmp___649) {
                tmp___644 = __builtin_strcmp(name, "putkeep");
                tmp___648 = tmp___644;
              } else {
                tmp___647 = __builtin_strcmp(name, "putkeep");
                tmp___648 = tmp___647;
              }
            } else {
              tmp___647 = __builtin_strcmp(name, "putkeep");
              tmp___648 = tmp___647;
            }
            if (tmp___648) {
              if (0) {
                __s1_len___69 = strlen(name);
                __s2_len___69 = strlen("putcat");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___144;
                } else {
                  if (__s1_len___69 >= 4U) {
                    _L___144: 
                    if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
                      tmp___642 = 1;
                    } else {
                      if (__s2_len___69 >= 4U) {
                        tmp___642 = 1;
                      } else {
                        tmp___642 = 0;
                      }
                    }
                  } else {
                    tmp___642 = 0;
                  }
                }
                if (tmp___642) {
                  tmp___637 = __builtin_strcmp(name, "putcat");
                  tmp___641 = tmp___637;
                } else {
                  tmp___640 = __builtin_strcmp(name, "putcat");
                  tmp___641 = tmp___640;
                }
              } else {
                tmp___640 = __builtin_strcmp(name, "putcat");
                tmp___641 = tmp___640;
              }
              if (! tmp___641) {
                tmp___635 = tcfdbputcat2(adb->fdb, (void const   *)kbuf___31, ksiz___31,
                                         (void const   *)vbuf___18, vsiz___18);
                if (! tmp___635) {
                  err___11 = (_Bool)1;
                }
              }
            } else {
              tmp___634 = tcfdbputkeep2(adb->fdb, (void const   *)kbuf___31, ksiz___31,
                                        (void const   *)vbuf___18, vsiz___18);
              if (! tmp___634) {
                err___11 = (_Bool)1;
              }
            }
          } else {
            tmp___633 = tcfdbput2(adb->fdb, (void const   *)kbuf___31, ksiz___31,
                                  (void const   *)vbuf___18, vsiz___18);
            if (! tmp___633) {
              err___11 = (_Bool)1;
            }
          }
          if (err___11) {
            tclistdel(rv);
            rv = (TCLIST *)((void *)0);
          }
        } else {
          rv = (TCLIST *)((void *)0);
        }
      }
    } else {
      goto _L___175;
    }
  } else {
    goto _L___175;
  }
  break;
  case 6: 
  if (0) {
    __s1_len___119 = strlen(name);
    __s2_len___119 = strlen("put");
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___254;
    } else {
      if (__s1_len___119 >= 4U) {
        _L___254: 
        if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
          tmp___1125 = 1;
        } else {
          if (__s2_len___119 >= 4U) {
            tmp___1125 = 1;
          } else {
            tmp___1125 = 0;
          }
        }
      } else {
        tmp___1125 = 0;
      }
    }
    if (tmp___1125) {
      tmp___1120 = __builtin_strcmp(name, "put");
      tmp___1124 = tmp___1120;
    } else {
      tmp___1123 = __builtin_strcmp(name, "put");
      tmp___1124 = tmp___1123;
    }
  } else {
    tmp___1123 = __builtin_strcmp(name, "put");
    tmp___1124 = tmp___1123;
  }
  if (tmp___1124) {
    if (0) {
      __s1_len___120 = strlen(name);
      __s2_len___120 = strlen("putkeep");
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___256;
      } else {
        if (__s1_len___120 >= 4U) {
          _L___256: 
          if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
            tmp___1132 = 1;
          } else {
            if (__s2_len___120 >= 4U) {
              tmp___1132 = 1;
            } else {
              tmp___1132 = 0;
            }
          }
        } else {
          tmp___1132 = 0;
        }
      }
      if (tmp___1132) {
        tmp___1127 = __builtin_strcmp(name, "putkeep");
        tmp___1131 = tmp___1127;
      } else {
        tmp___1130 = __builtin_strcmp(name, "putkeep");
        tmp___1131 = tmp___1130;
      }
    } else {
      tmp___1130 = __builtin_strcmp(name, "putkeep");
      tmp___1131 = tmp___1130;
    }
    if (tmp___1131) {
      if (0) {
        __s1_len___121 = strlen(name);
        __s2_len___121 = strlen("putcat");
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___258;
        } else {
          if (__s1_len___121 >= 4U) {
            _L___258: 
            if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
              tmp___1139 = 1;
            } else {
              if (__s2_len___121 >= 4U) {
                tmp___1139 = 1;
              } else {
                tmp___1139 = 0;
              }
            }
          } else {
            tmp___1139 = 0;
          }
        }
        if (tmp___1139) {
          tmp___1134 = __builtin_strcmp(name, "putcat");
          tmp___1138 = tmp___1134;
        } else {
          tmp___1137 = __builtin_strcmp(name, "putcat");
          tmp___1138 = tmp___1137;
        }
      } else {
        tmp___1137 = __builtin_strcmp(name, "putcat");
        tmp___1138 = tmp___1137;
      }
      if (tmp___1138) {
        if (0) {
          __s1_len___118 = strlen(name);
          __s2_len___118 = strlen("out");
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___252;
          } else {
            if (__s1_len___118 >= 4U) {
              _L___252: 
              if (! ((unsigned int )((void const   *)("out" + 1)) - (unsigned int )((void const   *)"out") == 1U)) {
                tmp___1118 = 1;
              } else {
                if (__s2_len___118 >= 4U) {
                  tmp___1118 = 1;
                } else {
                  tmp___1118 = 0;
                }
              }
            } else {
              tmp___1118 = 0;
            }
          }
          if (tmp___1118) {
            tmp___1113 = __builtin_strcmp(name, "out");
            tmp___1117 = tmp___1113;
          } else {
            tmp___1116 = __builtin_strcmp(name, "out");
            tmp___1117 = tmp___1116;
          }
        } else {
          tmp___1116 = __builtin_strcmp(name, "out");
          tmp___1117 = tmp___1116;
        }
        if (tmp___1117) {
          if (0) {
            __s1_len___117 = strlen(name);
            __s2_len___117 = strlen("get");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___250;
            } else {
              if (__s1_len___117 >= 4U) {
                _L___250: 
                if (! ((unsigned int )((void const   *)("get" + 1)) - (unsigned int )((void const   *)"get") == 1U)) {
                  tmp___1111 = 1;
                } else {
                  if (__s2_len___117 >= 4U) {
                    tmp___1111 = 1;
                  } else {
                    tmp___1111 = 0;
                  }
                }
              } else {
                tmp___1111 = 0;
              }
            }
            if (tmp___1111) {
              tmp___1106 = __builtin_strcmp(name, "get");
              tmp___1110 = tmp___1106;
            } else {
              tmp___1109 = __builtin_strcmp(name, "get");
              tmp___1110 = tmp___1109;
            }
          } else {
            tmp___1109 = __builtin_strcmp(name, "get");
            tmp___1110 = tmp___1109;
          }
          if (tmp___1110) {
            if (0) {
              __s1_len___116 = strlen(name);
              __s2_len___116 = strlen("putlist");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___248;
              } else {
                if (__s1_len___116 >= 4U) {
                  _L___248: 
                  if (! ((unsigned int )((void const   *)("putlist" + 1)) - (unsigned int )((void const   *)"putlist") == 1U)) {
                    tmp___1104 = 1;
                  } else {
                    if (__s2_len___116 >= 4U) {
                      tmp___1104 = 1;
                    } else {
                      tmp___1104 = 0;
                    }
                  }
                } else {
                  tmp___1104 = 0;
                }
              }
              if (tmp___1104) {
                tmp___1099 = __builtin_strcmp(name, "putlist");
                tmp___1103 = tmp___1099;
              } else {
                tmp___1102 = __builtin_strcmp(name, "putlist");
                tmp___1103 = tmp___1102;
              }
            } else {
              tmp___1102 = __builtin_strcmp(name, "putlist");
              tmp___1103 = tmp___1102;
            }
            if (tmp___1103) {
              if (0) {
                __s1_len___115 = strlen(name);
                __s2_len___115 = strlen("outlist");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___246;
                } else {
                  if (__s1_len___115 >= 4U) {
                    _L___246: 
                    if (! ((unsigned int )((void const   *)("outlist" + 1)) - (unsigned int )((void const   *)"outlist") == 1U)) {
                      tmp___1097 = 1;
                    } else {
                      if (__s2_len___115 >= 4U) {
                        tmp___1097 = 1;
                      } else {
                        tmp___1097 = 0;
                      }
                    }
                  } else {
                    tmp___1097 = 0;
                  }
                }
                if (tmp___1097) {
                  tmp___1092 = __builtin_strcmp(name, "outlist");
                  tmp___1096 = tmp___1092;
                } else {
                  tmp___1095 = __builtin_strcmp(name, "outlist");
                  tmp___1096 = tmp___1095;
                }
              } else {
                tmp___1095 = __builtin_strcmp(name, "outlist");
                tmp___1096 = tmp___1095;
              }
              if (tmp___1096) {
                if (0) {
                  __s1_len___114 = strlen(name);
                  __s2_len___114 = strlen("getlist");
                  if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                    goto _L___244;
                  } else {
                    if (__s1_len___114 >= 4U) {
                      _L___244: 
                      if (! ((unsigned int )((void const   *)("getlist" + 1)) - (unsigned int )((void const   *)"getlist") == 1U)) {
                        tmp___1090 = 1;
                      } else {
                        if (__s2_len___114 >= 4U) {
                          tmp___1090 = 1;
                        } else {
                          tmp___1090 = 0;
                        }
                      }
                    } else {
                      tmp___1090 = 0;
                    }
                  }
                  if (tmp___1090) {
                    tmp___1085 = __builtin_strcmp(name, "getlist");
                    tmp___1089 = tmp___1085;
                  } else {
                    tmp___1088 = __builtin_strcmp(name, "getlist");
                    tmp___1089 = tmp___1088;
                  }
                } else {
                  tmp___1088 = __builtin_strcmp(name, "getlist");
                  tmp___1089 = tmp___1088;
                }
                if (tmp___1089) {
                  if (0) {
                    __s1_len___113 = strlen(name);
                    __s2_len___113 = strlen("iterinit");
                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                      goto _L___242;
                    } else {
                      if (__s1_len___113 >= 4U) {
                        _L___242: 
                        if (! ((unsigned int )((void const   *)("iterinit" + 1)) - (unsigned int )((void const   *)"iterinit") == 1U)) {
                          tmp___1083 = 1;
                        } else {
                          if (__s2_len___113 >= 4U) {
                            tmp___1083 = 1;
                          } else {
                            tmp___1083 = 0;
                          }
                        }
                      } else {
                        tmp___1083 = 0;
                      }
                    }
                    if (tmp___1083) {
                      tmp___1078 = __builtin_strcmp(name, "iterinit");
                      tmp___1082 = tmp___1078;
                    } else {
                      tmp___1081 = __builtin_strcmp(name, "iterinit");
                      tmp___1082 = tmp___1081;
                    }
                  } else {
                    tmp___1081 = __builtin_strcmp(name, "iterinit");
                    tmp___1082 = tmp___1081;
                  }
                  if (tmp___1082) {
                    if (0) {
                      __s1_len___112 = strlen(name);
                      __s2_len___112 = strlen("iternext");
                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                        goto _L___240;
                      } else {
                        if (__s1_len___112 >= 4U) {
                          _L___240: 
                          if (! ((unsigned int )((void const   *)("iternext" + 1)) - (unsigned int )((void const   *)"iternext") == 1U)) {
                            tmp___1076 = 1;
                          } else {
                            if (__s2_len___112 >= 4U) {
                              tmp___1076 = 1;
                            } else {
                              tmp___1076 = 0;
                            }
                          }
                        } else {
                          tmp___1076 = 0;
                        }
                      }
                      if (tmp___1076) {
                        tmp___1071 = __builtin_strcmp(name, "iternext");
                        tmp___1075 = tmp___1071;
                      } else {
                        tmp___1074 = __builtin_strcmp(name, "iternext");
                        tmp___1075 = tmp___1074;
                      }
                    } else {
                      tmp___1074 = __builtin_strcmp(name, "iternext");
                      tmp___1075 = tmp___1074;
                    }
                    if (tmp___1075) {
                      if (0) {
                        __s1_len___111 = strlen(name);
                        __s2_len___111 = strlen("sync");
                        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                          goto _L___238;
                        } else {
                          if (__s1_len___111 >= 4U) {
                            _L___238: 
                            if (! ((unsigned int )((void const   *)("sync" + 1)) - (unsigned int )((void const   *)"sync") == 1U)) {
                              tmp___1069 = 1;
                            } else {
                              if (__s2_len___111 >= 4U) {
                                tmp___1069 = 1;
                              } else {
                                tmp___1069 = 0;
                              }
                            }
                          } else {
                            tmp___1069 = 0;
                          }
                        }
                        if (tmp___1069) {
                          tmp___1064 = __builtin_strcmp(name, "sync");
                          tmp___1068 = tmp___1064;
                        } else {
                          tmp___1067 = __builtin_strcmp(name, "sync");
                          tmp___1068 = tmp___1067;
                        }
                      } else {
                        tmp___1067 = __builtin_strcmp(name, "sync");
                        tmp___1068 = tmp___1067;
                      }
                      if (tmp___1068) {
                        if (0) {
                          __s1_len___110 = strlen(name);
                          __s2_len___110 = strlen("optimize");
                          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                            goto _L___236;
                          } else {
                            if (__s1_len___110 >= 4U) {
                              _L___236: 
                              if (! ((unsigned int )((void const   *)("optimize" + 1)) - (unsigned int )((void const   *)"optimize") == 1U)) {
                                tmp___1062 = 1;
                              } else {
                                if (__s2_len___110 >= 4U) {
                                  tmp___1062 = 1;
                                } else {
                                  tmp___1062 = 0;
                                }
                              }
                            } else {
                              tmp___1062 = 0;
                            }
                          }
                          if (tmp___1062) {
                            tmp___1057 = __builtin_strcmp(name, "optimize");
                            tmp___1061 = tmp___1057;
                          } else {
                            tmp___1060 = __builtin_strcmp(name, "optimize");
                            tmp___1061 = tmp___1060;
                          }
                        } else {
                          tmp___1060 = __builtin_strcmp(name, "optimize");
                          tmp___1061 = tmp___1060;
                        }
                        if (tmp___1061) {
                          if (0) {
                            __s1_len___109 = strlen(name);
                            __s2_len___109 = strlen("vanish");
                            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                              goto _L___234;
                            } else {
                              if (__s1_len___109 >= 4U) {
                                _L___234: 
                                if (! ((unsigned int )((void const   *)("vanish" + 1)) - (unsigned int )((void const   *)"vanish") == 1U)) {
                                  tmp___1055 = 1;
                                } else {
                                  if (__s2_len___109 >= 4U) {
                                    tmp___1055 = 1;
                                  } else {
                                    tmp___1055 = 0;
                                  }
                                }
                              } else {
                                tmp___1055 = 0;
                              }
                            }
                            if (tmp___1055) {
                              tmp___1050 = __builtin_strcmp(name, "vanish");
                              tmp___1054 = tmp___1050;
                            } else {
                              tmp___1053 = __builtin_strcmp(name, "vanish");
                              tmp___1054 = tmp___1053;
                            }
                          } else {
                            tmp___1053 = __builtin_strcmp(name, "vanish");
                            tmp___1054 = tmp___1053;
                          }
                          if (tmp___1054) {
                            if (0) {
                              __s1_len___108 = strlen(name);
                              __s2_len___108 = strlen("defrag");
                              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                                goto _L___232;
                              } else {
                                if (__s1_len___108 >= 4U) {
                                  _L___232: 
                                  if (! ((unsigned int )((void const   *)("defrag" + 1)) - (unsigned int )((void const   *)"defrag") == 1U)) {
                                    tmp___1048 = 1;
                                  } else {
                                    if (__s2_len___108 >= 4U) {
                                      tmp___1048 = 1;
                                    } else {
                                      tmp___1048 = 0;
                                    }
                                  }
                                } else {
                                  tmp___1048 = 0;
                                }
                              }
                              if (tmp___1048) {
                                tmp___1043 = __builtin_strcmp(name, "defrag");
                                tmp___1047 = tmp___1043;
                              } else {
                                tmp___1046 = __builtin_strcmp(name, "defrag");
                                tmp___1047 = tmp___1046;
                              }
                            } else {
                              tmp___1046 = __builtin_strcmp(name, "defrag");
                              tmp___1047 = tmp___1046;
                            }
                            if (tmp___1047) {
                              if (0) {
                                __s1_len___107 = strlen(name);
                                __s2_len___107 = strlen("setindex");
                                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                                  goto _L___230;
                                } else {
                                  if (__s1_len___107 >= 4U) {
                                    _L___230: 
                                    if (! ((unsigned int )((void const   *)("setindex" + 1)) - (unsigned int )((void const   *)"setindex") == 1U)) {
                                      tmp___1041 = 1;
                                    } else {
                                      if (__s2_len___107 >= 4U) {
                                        tmp___1041 = 1;
                                      } else {
                                        tmp___1041 = 0;
                                      }
                                    }
                                  } else {
                                    tmp___1041 = 0;
                                  }
                                }
                                if (tmp___1041) {
                                  tmp___1036 = __builtin_strcmp(name, "setindex");
                                  tmp___1040 = tmp___1036;
                                } else {
                                  tmp___1039 = __builtin_strcmp(name, "setindex");
                                  tmp___1040 = tmp___1039;
                                }
                              } else {
                                tmp___1039 = __builtin_strcmp(name, "setindex");
                                tmp___1040 = tmp___1039;
                              }
                              if (tmp___1040) {
                                if (0) {
                                  __s1_len___105 = strlen(name);
                                  __s2_len___105 = strlen("search");
                                  if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                                    goto _L___225;
                                  } else {
                                    if (__s1_len___105 >= 4U) {
                                      _L___225: 
                                      if (! ((unsigned int )((void const   *)("search" + 1)) - (unsigned int )((void const   *)"search") == 1U)) {
                                        tmp___1027 = 1;
                                      } else {
                                        if (__s2_len___105 >= 4U) {
                                          tmp___1027 = 1;
                                        } else {
                                          tmp___1027 = 0;
                                        }
                                      }
                                    } else {
                                      tmp___1027 = 0;
                                    }
                                  }
                                  if (tmp___1027) {
                                    tmp___1022 = __builtin_strcmp(name, "search");
                                    tmp___1026 = tmp___1022;
                                  } else {
                                    tmp___1025 = __builtin_strcmp(name, "search");
                                    tmp___1026 = tmp___1025;
                                  }
                                } else {
                                  tmp___1025 = __builtin_strcmp(name, "search");
                                  tmp___1026 = tmp___1025;
                                }
                                if (tmp___1026) {
                                  if (0) {
                                    __s1_len___106 = strlen(name);
                                    __s2_len___106 = strlen("metasearch");
                                    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                                      goto _L___227;
                                    } else {
                                      if (__s1_len___106 >= 4U) {
                                        _L___227: 
                                        if (! ((unsigned int )((void const   *)("metasearch" + 1)) - (unsigned int )((void const   *)"metasearch") == 1U)) {
                                          tmp___1034 = 1;
                                        } else {
                                          if (__s2_len___106 >= 4U) {
                                            tmp___1034 = 1;
                                          } else {
                                            tmp___1034 = 0;
                                          }
                                        }
                                      } else {
                                        tmp___1034 = 0;
                                      }
                                    }
                                    if (tmp___1034) {
                                      tmp___1029 = __builtin_strcmp(name, "metasearch");
                                      tmp___1033 = tmp___1029;
                                    } else {
                                      tmp___1032 = __builtin_strcmp(name, "metasearch");
                                      tmp___1033 = tmp___1032;
                                    }
                                  } else {
                                    tmp___1032 = __builtin_strcmp(name, "metasearch");
                                    tmp___1033 = tmp___1032;
                                  }
                                  if (tmp___1033) {
                                    if (0) {
                                      __s1_len___104 = strlen(name);
                                      __s2_len___104 = strlen("genuid");
                                      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                                        goto _L___223;
                                      } else {
                                        if (__s1_len___104 >= 4U) {
                                          _L___223: 
                                          if (! ((unsigned int )((void const   *)("genuid" + 1)) - (unsigned int )((void const   *)"genuid") == 1U)) {
                                            tmp___1020 = 1;
                                          } else {
                                            if (__s2_len___104 >= 4U) {
                                              tmp___1020 = 1;
                                            } else {
                                              tmp___1020 = 0;
                                            }
                                          }
                                        } else {
                                          tmp___1020 = 0;
                                        }
                                      }
                                      if (tmp___1020) {
                                        tmp___1015 = __builtin_strcmp(name, "genuid");
                                        tmp___1019 = tmp___1015;
                                      } else {
                                        tmp___1018 = __builtin_strcmp(name, "genuid");
                                        tmp___1019 = tmp___1018;
                                      }
                                    } else {
                                      tmp___1018 = __builtin_strcmp(name, "genuid");
                                      tmp___1019 = tmp___1018;
                                    }
                                    if (tmp___1019) {
                                      rv = (TCLIST *)((void *)0);
                                    } else {
                                      rv = tclistnew2(1);
                                      tmp___1008 = tctdbgenuid(adb->tdb);
                                      tmp___1009 = sprintf((char * __restrict  )(numbuf___0),
                                                           (char const   * __restrict  )"%lld",
                                                           tmp___1008);
                                      nsiz = tmp___1009;
                                      while (1) {
                                        TC_mysize___35 = nsiz;
                                        TC_index___31 = rv->start + rv->num;
                                        if (TC_index___31 >= rv->anum) {
                                          rv->anum += rv->num + 1;
                                          while (1) {
                                            tmp___1011 = realloc((void *)rv->array,
                                                                 (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                                            tmp___1010 = (TCLISTDATUM *)tmp___1011;
                                            rv->array = tmp___1010;
                                            if (! tmp___1010) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                        }
                                        array___31 = rv->array;
                                        while (1) {
                                          tmp___1013 = malloc((unsigned int )(TC_mysize___35 + 1));
                                          tmp___1012 = (char *)tmp___1013;
                                          (array___31 + TC_index___31)->ptr = tmp___1012;
                                          if (! tmp___1012) {
                                            tcmyfatal("out of memory");
                                          }
                                          break;
                                        }
                                        memcpy((void * __restrict  )(array___31 + TC_index___31)->ptr,
                                               (void const   * __restrict  )(numbuf___0),
                                               (unsigned int )TC_mysize___35);
                                        *((array___31 + TC_index___31)->ptr + TC_mysize___35) = (char )'\000';
                                        (array___31 + TC_index___31)->size = TC_mysize___35;
                                        (rv->num) ++;
                                        break;
                                      }
                                    }
                                  } else {
                                    _L___228: 
                                    toout = (_Bool)0;
                                    tocnt = (_Bool)0;
                                    tohint = (_Bool)0;
                                    tmp___858 = tctdbqrynew(adb->tdb);
                                    qry = tmp___858;
                                    qrys = (TDBQRY **)((void *)0);
                                    qnum = 0;
                                    mstype = 0;
                                    cnames = (TCLIST *)((void *)0);
                                    i___19 = 0;
                                    while (i___19 < argc) {
                                      while (1) {
                                        arg = (char const   *)(args->array + (i___19 + (int )args->start))->ptr;
                                        asiz = (args->array + (i___19 + (int )args->start))->size;
                                        break;
                                      }
                                      tmp___859 = tcstrsplit2((void const   *)arg,
                                                              asiz);
                                      tokens = tmp___859;
                                      tnum = tokens->num;
                                      if (tnum > 0) {
                                        cmd = (char const   *)((void *)(tokens->array + tokens->start)->ptr);
                                        if (0) {
                                          __s1_len___102 = strlen(cmd);
                                          __s2_len___102 = strlen("addcond");
                                          if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                            goto _L___217;
                                          } else {
                                            if (__s1_len___102 >= 4U) {
                                              _L___217: 
                                              if (! ((unsigned int )((void const   *)("addcond" + 1)) - (unsigned int )((void const   *)"addcond") == 1U)) {
                                                tmp___975 = 1;
                                              } else {
                                                if (__s2_len___102 >= 4U) {
                                                  tmp___975 = 1;
                                                } else {
                                                  tmp___975 = 0;
                                                }
                                              }
                                            } else {
                                              tmp___975 = 0;
                                            }
                                          }
                                          if (tmp___975) {
                                            tmp___970 = __builtin_strcmp(cmd, "addcond");
                                            tmp___974 = tmp___970;
                                          } else {
                                            tmp___973 = __builtin_strcmp(cmd, "addcond");
                                            tmp___974 = tmp___973;
                                          }
                                        } else {
                                          tmp___973 = __builtin_strcmp(cmd, "addcond");
                                          tmp___974 = tmp___973;
                                        }
                                        if (tmp___974) {
                                          if (0) {
                                            __s1_len___103 = strlen(cmd);
                                            __s2_len___103 = strlen("cond");
                                            if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                              goto _L___219;
                                            } else {
                                              if (__s1_len___103 >= 4U) {
                                                _L___219: 
                                                if (! ((unsigned int )((void const   *)("cond" + 1)) - (unsigned int )((void const   *)"cond") == 1U)) {
                                                  tmp___982 = 1;
                                                } else {
                                                  if (__s2_len___103 >= 4U) {
                                                    tmp___982 = 1;
                                                  } else {
                                                    tmp___982 = 0;
                                                  }
                                                }
                                              } else {
                                                tmp___982 = 0;
                                              }
                                            }
                                            if (tmp___982) {
                                              tmp___977 = __builtin_strcmp(cmd, "cond");
                                              tmp___981 = tmp___977;
                                            } else {
                                              tmp___980 = __builtin_strcmp(cmd, "cond");
                                              tmp___981 = tmp___980;
                                            }
                                          } else {
                                            tmp___980 = __builtin_strcmp(cmd, "cond");
                                            tmp___981 = tmp___980;
                                          }
                                          if (tmp___981) {
                                            _L___220: 
                                            if (0) {
                                              __s1_len___100 = strlen(cmd);
                                              __s2_len___100 = strlen("setorder");
                                              if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                goto _L___211;
                                              } else {
                                                if (__s1_len___100 >= 4U) {
                                                  _L___211: 
                                                  if (! ((unsigned int )((void const   *)("setorder" + 1)) - (unsigned int )((void const   *)"setorder") == 1U)) {
                                                    tmp___961 = 1;
                                                  } else {
                                                    if (__s2_len___100 >= 4U) {
                                                      tmp___961 = 1;
                                                    } else {
                                                      tmp___961 = 0;
                                                    }
                                                  }
                                                } else {
                                                  tmp___961 = 0;
                                                }
                                              }
                                              if (tmp___961) {
                                                tmp___956 = __builtin_strcmp(cmd,
                                                                             "setorder");
                                                tmp___960 = tmp___956;
                                              } else {
                                                tmp___959 = __builtin_strcmp(cmd,
                                                                             "setorder");
                                                tmp___960 = tmp___959;
                                              }
                                            } else {
                                              tmp___959 = __builtin_strcmp(cmd, "setorder");
                                              tmp___960 = tmp___959;
                                            }
                                            if (tmp___960) {
                                              if (0) {
                                                __s1_len___101 = strlen(cmd);
                                                __s2_len___101 = strlen("order");
                                                if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                  goto _L___213;
                                                } else {
                                                  if (__s1_len___101 >= 4U) {
                                                    _L___213: 
                                                    if (! ((unsigned int )((void const   *)("order" + 1)) - (unsigned int )((void const   *)"order") == 1U)) {
                                                      tmp___968 = 1;
                                                    } else {
                                                      if (__s2_len___101 >= 4U) {
                                                        tmp___968 = 1;
                                                      } else {
                                                        tmp___968 = 0;
                                                      }
                                                    }
                                                  } else {
                                                    tmp___968 = 0;
                                                  }
                                                }
                                                if (tmp___968) {
                                                  tmp___963 = __builtin_strcmp(cmd,
                                                                               "order");
                                                  tmp___967 = tmp___963;
                                                } else {
                                                  tmp___966 = __builtin_strcmp(cmd,
                                                                               "order");
                                                  tmp___967 = tmp___966;
                                                }
                                              } else {
                                                tmp___966 = __builtin_strcmp(cmd,
                                                                             "order");
                                                tmp___967 = tmp___966;
                                              }
                                              if (tmp___967) {
                                                _L___214: 
                                                if (0) {
                                                  __s1_len___96 = strlen(cmd);
                                                  __s2_len___96 = strlen("setlimit");
                                                  if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                    goto _L___201;
                                                  } else {
                                                    if (__s1_len___96 >= 4U) {
                                                      _L___201: 
                                                      if (! ((unsigned int )((void const   *)("setlimit" + 1)) - (unsigned int )((void const   *)"setlimit") == 1U)) {
                                                        tmp___933 = 1;
                                                      } else {
                                                        if (__s2_len___96 >= 4U) {
                                                          tmp___933 = 1;
                                                        } else {
                                                          tmp___933 = 0;
                                                        }
                                                      }
                                                    } else {
                                                      tmp___933 = 0;
                                                    }
                                                  }
                                                  if (tmp___933) {
                                                    tmp___928 = __builtin_strcmp(cmd,
                                                                                 "setlimit");
                                                    tmp___932 = tmp___928;
                                                  } else {
                                                    tmp___931 = __builtin_strcmp(cmd,
                                                                                 "setlimit");
                                                    tmp___932 = tmp___931;
                                                  }
                                                } else {
                                                  tmp___931 = __builtin_strcmp(cmd,
                                                                               "setlimit");
                                                  tmp___932 = tmp___931;
                                                }
                                                if (tmp___932) {
                                                  if (0) {
                                                    __s1_len___97 = strlen(cmd);
                                                    __s2_len___97 = strlen("limit");
                                                    if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                      goto _L___203;
                                                    } else {
                                                      if (__s1_len___97 >= 4U) {
                                                        _L___203: 
                                                        if (! ((unsigned int )((void const   *)("limit" + 1)) - (unsigned int )((void const   *)"limit") == 1U)) {
                                                          tmp___940 = 1;
                                                        } else {
                                                          if (__s2_len___97 >= 4U) {
                                                            tmp___940 = 1;
                                                          } else {
                                                            tmp___940 = 0;
                                                          }
                                                        }
                                                      } else {
                                                        tmp___940 = 0;
                                                      }
                                                    }
                                                    if (tmp___940) {
                                                      tmp___935 = __builtin_strcmp(cmd,
                                                                                   "limit");
                                                      tmp___939 = tmp___935;
                                                    } else {
                                                      tmp___938 = __builtin_strcmp(cmd,
                                                                                   "limit");
                                                      tmp___939 = tmp___938;
                                                    }
                                                  } else {
                                                    tmp___938 = __builtin_strcmp(cmd,
                                                                                 "limit");
                                                    tmp___939 = tmp___938;
                                                  }
                                                  if (tmp___939) {
                                                    if (0) {
                                                      __s1_len___98 = strlen(cmd);
                                                      __s2_len___98 = strlen("setmax");
                                                      if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                        goto _L___205;
                                                      } else {
                                                        if (__s1_len___98 >= 4U) {
                                                          _L___205: 
                                                          if (! ((unsigned int )((void const   *)("setmax" + 1)) - (unsigned int )((void const   *)"setmax") == 1U)) {
                                                            tmp___947 = 1;
                                                          } else {
                                                            if (__s2_len___98 >= 4U) {
                                                              tmp___947 = 1;
                                                            } else {
                                                              tmp___947 = 0;
                                                            }
                                                          }
                                                        } else {
                                                          tmp___947 = 0;
                                                        }
                                                      }
                                                      if (tmp___947) {
                                                        tmp___942 = __builtin_strcmp(cmd,
                                                                                     "setmax");
                                                        tmp___946 = tmp___942;
                                                      } else {
                                                        tmp___945 = __builtin_strcmp(cmd,
                                                                                     "setmax");
                                                        tmp___946 = tmp___945;
                                                      }
                                                    } else {
                                                      tmp___945 = __builtin_strcmp(cmd,
                                                                                   "setmax");
                                                      tmp___946 = tmp___945;
                                                    }
                                                    if (tmp___946) {
                                                      if (0) {
                                                        __s1_len___99 = strlen(cmd);
                                                        __s2_len___99 = strlen("max");
                                                        if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                          goto _L___207;
                                                        } else {
                                                          if (__s1_len___99 >= 4U) {
                                                            _L___207: 
                                                            if (! ((unsigned int )((void const   *)("max" + 1)) - (unsigned int )((void const   *)"max") == 1U)) {
                                                              tmp___954 = 1;
                                                            } else {
                                                              if (__s2_len___99 >= 4U) {
                                                                tmp___954 = 1;
                                                              } else {
                                                                tmp___954 = 0;
                                                              }
                                                            }
                                                          } else {
                                                            tmp___954 = 0;
                                                          }
                                                        }
                                                        if (tmp___954) {
                                                          tmp___949 = __builtin_strcmp(cmd,
                                                                                       "max");
                                                          tmp___953 = tmp___949;
                                                        } else {
                                                          tmp___952 = __builtin_strcmp(cmd,
                                                                                       "max");
                                                          tmp___953 = tmp___952;
                                                        }
                                                      } else {
                                                        tmp___952 = __builtin_strcmp(cmd,
                                                                                     "max");
                                                        tmp___953 = tmp___952;
                                                      }
                                                      if (tmp___953) {
                                                        _L___208: 
                                                        if (0) {
                                                          __s1_len___94 = strlen(cmd);
                                                          __s2_len___94 = strlen("get");
                                                          if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                            goto _L___196;
                                                          } else {
                                                            if (__s1_len___94 >= 4U) {
                                                              _L___196: 
                                                              if (! ((unsigned int )((void const   *)("get" + 1)) - (unsigned int )((void const   *)"get") == 1U)) {
                                                                tmp___919 = 1;
                                                              } else {
                                                                if (__s2_len___94 >= 4U) {
                                                                  tmp___919 = 1;
                                                                } else {
                                                                  tmp___919 = 0;
                                                                }
                                                              }
                                                            } else {
                                                              tmp___919 = 0;
                                                            }
                                                          }
                                                          if (tmp___919) {
                                                            tmp___914 = __builtin_strcmp(cmd,
                                                                                         "get");
                                                            tmp___918 = tmp___914;
                                                          } else {
                                                            tmp___917 = __builtin_strcmp(cmd,
                                                                                         "get");
                                                            tmp___918 = tmp___917;
                                                          }
                                                        } else {
                                                          tmp___917 = __builtin_strcmp(cmd,
                                                                                       "get");
                                                          tmp___918 = tmp___917;
                                                        }
                                                        if (tmp___918) {
                                                          if (0) {
                                                            __s1_len___95 = strlen(cmd);
                                                            __s2_len___95 = strlen("columns");
                                                            if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                              goto _L___198;
                                                            } else {
                                                              if (__s1_len___95 >= 4U) {
                                                                _L___198: 
                                                                if (! ((unsigned int )((void const   *)("columns" + 1)) - (unsigned int )((void const   *)"columns") == 1U)) {
                                                                  tmp___926 = 1;
                                                                } else {
                                                                  if (__s2_len___95 >= 4U) {
                                                                    tmp___926 = 1;
                                                                  } else {
                                                                    tmp___926 = 0;
                                                                  }
                                                                }
                                                              } else {
                                                                tmp___926 = 0;
                                                              }
                                                            }
                                                            if (tmp___926) {
                                                              tmp___921 = __builtin_strcmp(cmd,
                                                                                           "columns");
                                                              tmp___925 = tmp___921;
                                                            } else {
                                                              tmp___924 = __builtin_strcmp(cmd,
                                                                                           "columns");
                                                              tmp___925 = tmp___924;
                                                            }
                                                          } else {
                                                            tmp___924 = __builtin_strcmp(cmd,
                                                                                         "columns");
                                                            tmp___925 = tmp___924;
                                                          }
                                                          if (tmp___925) {
                                                            if (0) {
                                                              __s1_len___93 = strlen(cmd);
                                                              __s2_len___93 = strlen("next");
                                                              if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                                goto _L___194;
                                                              } else {
                                                                if (__s1_len___93 >= 4U) {
                                                                  _L___194: 
                                                                  if (! ((unsigned int )((void const   *)("next" + 1)) - (unsigned int )((void const   *)"next") == 1U)) {
                                                                    tmp___912 = 1;
                                                                  } else {
                                                                    if (__s2_len___93 >= 4U) {
                                                                      tmp___912 = 1;
                                                                    } else {
                                                                      tmp___912 = 0;
                                                                    }
                                                                  }
                                                                } else {
                                                                  tmp___912 = 0;
                                                                }
                                                              }
                                                              if (tmp___912) {
                                                                tmp___907 = __builtin_strcmp(cmd,
                                                                                             "next");
                                                                tmp___911 = tmp___907;
                                                              } else {
                                                                tmp___910 = __builtin_strcmp(cmd,
                                                                                             "next");
                                                                tmp___911 = tmp___910;
                                                              }
                                                            } else {
                                                              tmp___910 = __builtin_strcmp(cmd,
                                                                                           "next");
                                                              tmp___911 = tmp___910;
                                                            }
                                                            if (tmp___911) {
                                                              if (0) {
                                                                __s1_len___92 = strlen(cmd);
                                                                __s2_len___92 = strlen("mstype");
                                                                if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                                  goto _L___191;
                                                                } else {
                                                                  if (__s1_len___92 >= 4U) {
                                                                    _L___191: 
                                                                    if (! ((unsigned int )((void const   *)("mstype" + 1)) - (unsigned int )((void const   *)"mstype") == 1U)) {
                                                                      tmp___905 = 1;
                                                                    } else {
                                                                      if (__s2_len___92 >= 4U) {
                                                                        tmp___905 = 1;
                                                                      } else {
                                                                        tmp___905 = 0;
                                                                      }
                                                                    }
                                                                  } else {
                                                                    tmp___905 = 0;
                                                                  }
                                                                }
                                                                if (tmp___905) {
                                                                  tmp___900 = __builtin_strcmp(cmd,
                                                                                               "mstype");
                                                                  tmp___904 = tmp___900;
                                                                } else {
                                                                  tmp___903 = __builtin_strcmp(cmd,
                                                                                               "mstype");
                                                                  tmp___904 = tmp___903;
                                                                }
                                                              } else {
                                                                tmp___903 = __builtin_strcmp(cmd,
                                                                                             "mstype");
                                                                tmp___904 = tmp___903;
                                                              }
                                                              if (tmp___904) {
                                                                _L___192: 
                                                                if (0) {
                                                                  __s1_len___90 = strlen(cmd);
                                                                  __s2_len___90 = strlen("out");
                                                                  if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                                    goto _L___187;
                                                                  } else {
                                                                    if (__s1_len___90 >= 4U) {
                                                                      _L___187: 
                                                                      if (! ((unsigned int )((void const   *)("out" + 1)) - (unsigned int )((void const   *)"out") == 1U)) {
                                                                        tmp___891 = 1;
                                                                      } else {
                                                                        if (__s2_len___90 >= 4U) {
                                                                          tmp___891 = 1;
                                                                        } else {
                                                                          tmp___891 = 0;
                                                                        }
                                                                      }
                                                                    } else {
                                                                      tmp___891 = 0;
                                                                    }
                                                                  }
                                                                  if (tmp___891) {
                                                                    tmp___886 = __builtin_strcmp(cmd,
                                                                                                 "out");
                                                                    tmp___890 = tmp___886;
                                                                  } else {
                                                                    tmp___889 = __builtin_strcmp(cmd,
                                                                                                 "out");
                                                                    tmp___890 = tmp___889;
                                                                  }
                                                                } else {
                                                                  tmp___889 = __builtin_strcmp(cmd,
                                                                                               "out");
                                                                  tmp___890 = tmp___889;
                                                                }
                                                                if (tmp___890) {
                                                                  if (0) {
                                                                    __s1_len___91 = strlen(cmd);
                                                                    __s2_len___91 = strlen("remove");
                                                                    if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                                      goto _L___189;
                                                                    } else {
                                                                      if (__s1_len___91 >= 4U) {
                                                                        _L___189: 
                                                                        if (! ((unsigned int )((void const   *)("remove" + 1)) - (unsigned int )((void const   *)"remove") == 1U)) {
                                                                          tmp___898 = 1;
                                                                        } else {
                                                                          if (__s2_len___91 >= 4U) {
                                                                            tmp___898 = 1;
                                                                          } else {
                                                                            tmp___898 = 0;
                                                                          }
                                                                        }
                                                                      } else {
                                                                        tmp___898 = 0;
                                                                      }
                                                                    }
                                                                    if (tmp___898) {
                                                                      tmp___893 = __builtin_strcmp(cmd,
                                                                                                   "remove");
                                                                      tmp___897 = tmp___893;
                                                                    } else {
                                                                      tmp___896 = __builtin_strcmp(cmd,
                                                                                                   "remove");
                                                                      tmp___897 = tmp___896;
                                                                    }
                                                                  } else {
                                                                    tmp___896 = __builtin_strcmp(cmd,
                                                                                                 "remove");
                                                                    tmp___897 = tmp___896;
                                                                  }
                                                                  if (tmp___897) {
                                                                    if (0) {
                                                                      __s1_len___89 = strlen(cmd);
                                                                      __s2_len___89 = strlen("count");
                                                                      if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                                        goto _L___185;
                                                                      } else {
                                                                        if (__s1_len___89 >= 4U) {
                                                                          _L___185: 
                                                                          if (! ((unsigned int )((void const   *)("count" + 1)) - (unsigned int )((void const   *)"count") == 1U)) {
                                                                            tmp___884 = 1;
                                                                          } else {
                                                                            if (__s2_len___89 >= 4U) {
                                                                              tmp___884 = 1;
                                                                            } else {
                                                                              tmp___884 = 0;
                                                                            }
                                                                          }
                                                                        } else {
                                                                          tmp___884 = 0;
                                                                        }
                                                                      }
                                                                      if (tmp___884) {
                                                                        tmp___879 = __builtin_strcmp(cmd,
                                                                                                     "count");
                                                                        tmp___883 = tmp___879;
                                                                      } else {
                                                                        tmp___882 = __builtin_strcmp(cmd,
                                                                                                     "count");
                                                                        tmp___883 = tmp___882;
                                                                      }
                                                                    } else {
                                                                      tmp___882 = __builtin_strcmp(cmd,
                                                                                                   "count");
                                                                      tmp___883 = tmp___882;
                                                                    }
                                                                    if (tmp___883) {
                                                                      if (0) {
                                                                        __s1_len___88 = strlen(cmd);
                                                                        __s2_len___88 = strlen("hint");
                                                                        if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                                          goto _L___183;
                                                                        } else {
                                                                          if (__s1_len___88 >= 4U) {
                                                                            _L___183: 
                                                                            if (! ((unsigned int )((void const   *)("hint" + 1)) - (unsigned int )((void const   *)"hint") == 1U)) {
                                                                              tmp___877 = 1;
                                                                            } else {
                                                                              if (__s2_len___88 >= 4U) {
                                                                                tmp___877 = 1;
                                                                              } else {
                                                                                tmp___877 = 0;
                                                                              }
                                                                            }
                                                                          } else {
                                                                            tmp___877 = 0;
                                                                          }
                                                                        }
                                                                        if (tmp___877) {
                                                                          tmp___872 = __builtin_strcmp(cmd,
                                                                                                       "hint");
                                                                          tmp___876 = tmp___872;
                                                                        } else {
                                                                          tmp___875 = __builtin_strcmp(cmd,
                                                                                                       "hint");
                                                                          tmp___876 = tmp___875;
                                                                        }
                                                                      } else {
                                                                        tmp___875 = __builtin_strcmp(cmd,
                                                                                                     "hint");
                                                                        tmp___876 = tmp___875;
                                                                      }
                                                                      if (! tmp___876) {
                                                                        tohint = (_Bool)1;
                                                                      }
                                                                    } else {
                                                                      tocnt = (_Bool)1;
                                                                    }
                                                                  } else {
                                                                    toout = (_Bool)1;
                                                                  }
                                                                } else {
                                                                  toout = (_Bool)1;
                                                                }
                                                              } else {
                                                                if (tnum > 1) {
                                                                  typestr___0 = (char const   *)((void *)(tokens->array + (1 + tokens->start))->ptr);
                                                                  mstype = tctdbstrtometasearcytype(typestr___0);
                                                                  if (mstype < 0) {
                                                                    mstype = 0;
                                                                  }
                                                                } else {
                                                                  goto _L___192;
                                                                }
                                                              }
                                                            } else {
                                                              if (qrys) {
                                                                while (1) {
                                                                  tmp___868 = realloc((void *)qrys,
                                                                                      (unsigned int )((int )sizeof(*qrys) * (qnum + 1)));
                                                                  qrys = (TDBQRY **)tmp___868;
                                                                  if (! qrys) {
                                                                    tcmyfatal("out of memory");
                                                                  }
                                                                  break;
                                                                }
                                                              } else {
                                                                while (1) {
                                                                  tmp___869 = malloc((unsigned int )((int )sizeof(*qrys) * 2));
                                                                  qrys = (TDBQRY **)tmp___869;
                                                                  if (! qrys) {
                                                                    tcmyfatal("out of memory");
                                                                  }
                                                                  break;
                                                                }
                                                                *(qrys + 0) = qry;
                                                                qnum = 1;
                                                              }
                                                              qry = tctdbqrynew(adb->tdb);
                                                              tmp___870 = qnum;
                                                              qnum ++;
                                                              *(qrys + tmp___870) = qry;
                                                            }
                                                          } else {
                                                            _L___199: 
                                                            if (! cnames) {
                                                              cnames = tclistnew();
                                                            }
                                                            j___0 = 1;
                                                            while (j___0 < tnum) {
                                                              while (1) {
                                                                token = (char const   *)(tokens->array + (j___0 + tokens->start))->ptr;
                                                                tsiz = (tokens->array + (j___0 + tokens->start))->size;
                                                                break;
                                                              }
                                                              while (1) {
                                                                TC_mysize___29 = tsiz;
                                                                TC_index___29 = cnames->start + cnames->num;
                                                                if (TC_index___29 >= cnames->anum) {
                                                                  cnames->anum += cnames->num + 1;
                                                                  while (1) {
                                                                    tmp___865 = realloc((void *)cnames->array,
                                                                                        (unsigned int )(cnames->anum * (int )sizeof(*(cnames->array + 0))));
                                                                    tmp___864 = (TCLISTDATUM *)tmp___865;
                                                                    cnames->array = tmp___864;
                                                                    if (! tmp___864) {
                                                                      tcmyfatal("out of memory");
                                                                    }
                                                                    break;
                                                                  }
                                                                }
                                                                array___29 = cnames->array;
                                                                while (1) {
                                                                  tmp___867 = malloc((unsigned int )(TC_mysize___29 + 1));
                                                                  tmp___866 = (char *)tmp___867;
                                                                  (array___29 + TC_index___29)->ptr = tmp___866;
                                                                  if (! tmp___866) {
                                                                    tcmyfatal("out of memory");
                                                                  }
                                                                  break;
                                                                }
                                                                memcpy((void * __restrict  )(array___29 + TC_index___29)->ptr,
                                                                       (void const   * __restrict  )token,
                                                                       (unsigned int )TC_mysize___29);
                                                                *((array___29 + TC_index___29)->ptr + TC_mysize___29) = (char )'\000';
                                                                (array___29 + TC_index___29)->size = TC_mysize___29;
                                                                (cnames->num) ++;
                                                                break;
                                                              }
                                                              j___0 ++;
                                                            }
                                                          }
                                                        } else {
                                                          goto _L___199;
                                                        }
                                                      } else {
                                                        _L___209: 
                                                        if (tnum > 1) {
                                                          maxstr = (char const   *)((void *)(tokens->array + (1 + tokens->start))->ptr);
                                                          tmp___862 = tcatoi(maxstr);
                                                          max = (int )tmp___862;
                                                          skip = 0;
                                                          if (tnum > 2) {
                                                            maxstr = (char const   *)((void *)(tokens->array + (2 + tokens->start))->ptr);
                                                            tmp___863 = tcatoi(maxstr);
                                                            skip = (int )tmp___863;
                                                          }
                                                          tctdbqrysetlimit(qry, max,
                                                                           skip);
                                                        } else {
                                                          goto _L___208;
                                                        }
                                                      }
                                                    } else {
                                                      goto _L___209;
                                                    }
                                                  } else {
                                                    goto _L___209;
                                                  }
                                                } else {
                                                  goto _L___209;
                                                }
                                              } else {
                                                _L___215: 
                                                if (tnum > 2) {
                                                  name___1 = (char const   *)((void *)(tokens->array + (1 + tokens->start))->ptr);
                                                  typestr = (char const   *)((void *)(tokens->array + (2 + tokens->start))->ptr);
                                                  tmp___861 = tctdbqrystrtoordertype(typestr);
                                                  type___0 = tmp___861;
                                                  if (type___0 >= 0) {
                                                    tctdbqrysetorder(qry, name___1,
                                                                     type___0);
                                                  }
                                                } else {
                                                  goto _L___214;
                                                }
                                              }
                                            } else {
                                              goto _L___215;
                                            }
                                          } else {
                                            _L___221: 
                                            if (tnum > 3) {
                                              name___0 = (char const   *)((void *)(tokens->array + (1 + tokens->start))->ptr);
                                              opstr = (char const   *)((void *)(tokens->array + (2 + tokens->start))->ptr);
                                              expr = (char const   *)((void *)(tokens->array + (3 + tokens->start))->ptr);
                                              tmp___860 = tctdbqrystrtocondop(opstr);
                                              op = tmp___860;
                                              if (op >= 0) {
                                                tctdbqryaddcond(qry, name___0, op,
                                                                expr);
                                              }
                                            } else {
                                              goto _L___220;
                                            }
                                          }
                                        } else {
                                          goto _L___221;
                                        }
                                      }
                                      tclistdel(tokens);
                                      i___19 ++;
                                    }
                                    if (toout) {
                                      if (cnames) {
                                        rv = tclistnew2(1);
                                        opq[0] = (void *)rv;
                                        opq[1] = (void *)cnames;
                                        tmp___983 = tctdbqryproc2(qry, & tcadbtdbqrygetout,
                                                                  (void *)(opq));
                                        if (! tmp___983) {
                                          tclistdel(rv);
                                          rv = (TCLIST *)((void *)0);
                                        }
                                      } else {
                                        tmp___984 = tctdbqrysearchout2(qry);
                                        if (tmp___984) {
                                          rv = tclistnew2(1);
                                        } else {
                                          rv = (TCLIST *)((void *)0);
                                        }
                                      }
                                    } else {
                                      if (qrys) {
                                        rv = tctdbmetasearch(qrys, qnum, mstype);
                                      } else {
                                        rv = tctdbqrysearch(qry);
                                      }
                                      if (cnames) {
                                        cnnum = cnames->num;
                                        rnum = rv->num;
                                        tmp___985 = tclistnew2(rnum);
                                        nrv = tmp___985;
                                        i___20 = 0;
                                        while (i___20 < rnum) {
                                          while (1) {
                                            pkbuf___4 = (char const   *)(rv->array + (i___20 + rv->start))->ptr;
                                            pksiz___4 = (rv->array + (i___20 + rv->start))->size;
                                            break;
                                          }
                                          tmp___986 = tctdbget(adb->tdb, (void const   *)pkbuf___4,
                                                               pksiz___4);
                                          cols___1 = tmp___986;
                                          if (cols___1) {
                                            tcmapput(cols___1, (void const   *)"",
                                                     0, (void const   *)pkbuf___4,
                                                     pksiz___4);
                                            tcmapmove(cols___1, (void const   *)"",
                                                      0, (_Bool)1);
                                            if (cnnum > 0) {
                                              tmp___987 = tcmapnew2((unsigned int )(cnnum + 1));
                                              ncols = tmp___987;
                                              j___1 = 0;
                                              while (j___1 < cnnum) {
                                                while (1) {
                                                  cname = (char const   *)(cnames->array + (j___1 + cnames->start))->ptr;
                                                  cnsiz = (cnames->array + (j___1 + cnames->start))->size;
                                                  break;
                                                }
                                                tmp___988 = tcmapget((TCMAP const   *)cols___1,
                                                                     (void const   *)cname,
                                                                     cnsiz, & cvsiz);
                                                cvalue = (char const   *)tmp___988;
                                                if (cvalue) {
                                                  tcmapput(ncols, (void const   *)cname,
                                                           cnsiz, (void const   *)cvalue,
                                                           cvsiz);
                                                }
                                                j___1 ++;
                                              }
                                              tcmapdel(cols___1);
                                              cols___1 = ncols;
                                            }
                                            tmp___989 = tcstrjoin4((TCMAP const   *)cols___1,
                                                                   & csiz___0);
                                            cbuf___0 = (char *)tmp___989;
                                            tclistpushmalloc(nrv, (void *)cbuf___0,
                                                             csiz___0);
                                            tcmapdel(cols___1);
                                          }
                                          i___20 ++;
                                        }
                                        tclistdel(rv);
                                        rv = nrv;
                                      }
                                    }
                                    if (tocnt) {
                                      if (rv) {
                                        tclistclear(rv);
                                        tmp___990 = tctdbqrycount(qry);
                                        tmp___991 = sprintf((char * __restrict  )(numbuf),
                                                            (char const   * __restrict  )"%d",
                                                            tmp___990);
                                        len = tmp___991;
                                        tclistpush(rv, (void const   *)(numbuf), len);
                                      }
                                    }
                                    if (tohint) {
                                      if (rv) {
                                        tmp___992 = tcxstrnew();
                                        hbuf = tmp___992;
                                        while (1) {
                                          TC_mysize___30 = 1;
                                          TC_nsize = (hbuf->size + TC_mysize___30) + 1;
                                          if (hbuf->asize < TC_nsize) {
                                            while (hbuf->asize < TC_nsize) {
                                              hbuf->asize *= 2;
                                              if (hbuf->asize < TC_nsize) {
                                                hbuf->asize = TC_nsize;
                                              }
                                            }
                                            while (1) {
                                              tmp___994 = realloc((void *)hbuf->ptr,
                                                                  (unsigned int )hbuf->asize);
                                              tmp___993 = (char *)tmp___994;
                                              hbuf->ptr = tmp___993;
                                              if (! tmp___993) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          memcpy((void * __restrict  )(hbuf->ptr + hbuf->size),
                                                 (void const   * __restrict  )"",
                                                 (unsigned int )TC_mysize___30);
                                          hbuf->size += TC_mysize___30;
                                          *(hbuf->ptr + hbuf->size) = (char )'\000';
                                          break;
                                        }
                                        while (1) {
                                          TC_mysize___31 = 1;
                                          TC_nsize___0 = (hbuf->size + TC_mysize___31) + 1;
                                          if (hbuf->asize < TC_nsize___0) {
                                            while (hbuf->asize < TC_nsize___0) {
                                              hbuf->asize *= 2;
                                              if (hbuf->asize < TC_nsize___0) {
                                                hbuf->asize = TC_nsize___0;
                                              }
                                            }
                                            while (1) {
                                              tmp___996 = realloc((void *)hbuf->ptr,
                                                                  (unsigned int )hbuf->asize);
                                              tmp___995 = (char *)tmp___996;
                                              hbuf->ptr = tmp___995;
                                              if (! tmp___995) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          memcpy((void * __restrict  )(hbuf->ptr + hbuf->size),
                                                 (void const   * __restrict  )"",
                                                 (unsigned int )TC_mysize___31);
                                          hbuf->size += TC_mysize___31;
                                          *(hbuf->ptr + hbuf->size) = (char )'\000';
                                          break;
                                        }
                                        while (1) {
                                          TC_mysize___32 = 9;
                                          TC_nsize___1 = (hbuf->size + TC_mysize___32) + 1;
                                          if (hbuf->asize < TC_nsize___1) {
                                            while (hbuf->asize < TC_nsize___1) {
                                              hbuf->asize *= 2;
                                              if (hbuf->asize < TC_nsize___1) {
                                                hbuf->asize = TC_nsize___1;
                                              }
                                            }
                                            while (1) {
                                              tmp___998 = realloc((void *)hbuf->ptr,
                                                                  (unsigned int )hbuf->asize);
                                              tmp___997 = (char *)tmp___998;
                                              hbuf->ptr = tmp___997;
                                              if (! tmp___997) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          memcpy((void * __restrict  )(hbuf->ptr + hbuf->size),
                                                 (void const   * __restrict  )"[[HINT]]\n",
                                                 (unsigned int )TC_mysize___32);
                                          hbuf->size += TC_mysize___32;
                                          *(hbuf->ptr + hbuf->size) = (char )'\000';
                                          break;
                                        }
                                        if (qrys) {
                                          tmp___999 = *(qrys + 0);
                                        } else {
                                          tmp___999 = qry;
                                        }
                                        tmp___1000 = tctdbqryhint(tmp___999);
                                        hint = tmp___1000;
                                        while (1) {
                                          tmp___1001 = strlen(hint);
                                          TC_mysize___33 = (int )tmp___1001;
                                          TC_nsize___2 = (hbuf->size + TC_mysize___33) + 1;
                                          if (hbuf->asize < TC_nsize___2) {
                                            while (hbuf->asize < TC_nsize___2) {
                                              hbuf->asize *= 2;
                                              if (hbuf->asize < TC_nsize___2) {
                                                hbuf->asize = TC_nsize___2;
                                              }
                                            }
                                            while (1) {
                                              tmp___1003 = realloc((void *)hbuf->ptr,
                                                                   (unsigned int )hbuf->asize);
                                              tmp___1002 = (char *)tmp___1003;
                                              hbuf->ptr = tmp___1002;
                                              if (! tmp___1002) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          memcpy((void * __restrict  )(hbuf->ptr + hbuf->size),
                                                 (void const   * __restrict  )hint,
                                                 (unsigned int )TC_mysize___33);
                                          hbuf->size += TC_mysize___33;
                                          *(hbuf->ptr + hbuf->size) = (char )'\000';
                                          break;
                                        }
                                        while (1) {
                                          TC_mysize___34 = hbuf->size;
                                          TC_index___30 = rv->start + rv->num;
                                          if (TC_index___30 >= rv->anum) {
                                            rv->anum += rv->num + 1;
                                            while (1) {
                                              tmp___1005 = realloc((void *)rv->array,
                                                                   (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                                              tmp___1004 = (TCLISTDATUM *)tmp___1005;
                                              rv->array = tmp___1004;
                                              if (! tmp___1004) {
                                                tcmyfatal("out of memory");
                                              }
                                              break;
                                            }
                                          }
                                          array___30 = rv->array;
                                          while (1) {
                                            tmp___1007 = malloc((unsigned int )(TC_mysize___34 + 1));
                                            tmp___1006 = (char *)tmp___1007;
                                            (array___30 + TC_index___30)->ptr = tmp___1006;
                                            if (! tmp___1006) {
                                              tcmyfatal("out of memory");
                                            }
                                            break;
                                          }
                                          memcpy((void * __restrict  )(array___30 + TC_index___30)->ptr,
                                                 (void const   * __restrict  )hbuf->ptr,
                                                 (unsigned int )TC_mysize___34);
                                          *((array___30 + TC_index___30)->ptr + TC_mysize___34) = (char )'\000';
                                          (array___30 + TC_index___30)->size = TC_mysize___34;
                                          (rv->num) ++;
                                          break;
                                        }
                                        tcxstrdel(hbuf);
                                      }
                                    }
                                    if (cnames) {
                                      tclistdel(cnames);
                                    }
                                    if (qrys) {
                                      i___21 = 0;
                                      while (i___21 < qnum) {
                                        tctdbqrydel(*(qrys + i___21));
                                        i___21 ++;
                                      }
                                      while (1) {
                                        free((void *)qrys);
                                        break;
                                      }
                                    } else {
                                      tctdbqrydel(qry);
                                    }
                                  }
                                } else {
                                  goto _L___228;
                                }
                              } else {
                                rv = tclistnew2(1);
                                err___21 = (_Bool)0;
                                argc --;
                                i___18 = 0;
                                while (i___18 < argc) {
                                  while (1) {
                                    kbuf___44 = (char const   *)(args->array + (i___18 + (int )args->start))->ptr;
                                    ksiz___44 = (args->array + (i___18 + (int )args->start))->size;
                                    break;
                                  }
                                  tmp___855 = tclistval(args, i___18 + 1, & vsiz___27);
                                  vbuf___27 = (char const   *)tmp___855;
                                  tmp___856 = tctdbstrtoindextype(vbuf___27);
                                  type = tmp___856;
                                  if (type >= 0) {
                                    tmp___857 = tctdbsetindex(adb->tdb, kbuf___44,
                                                              type);
                                    if (! tmp___857) {
                                      err___21 = (_Bool)1;
                                    }
                                  } else {
                                    err___21 = (_Bool)1;
                                  }
                                  i___18 += 2;
                                }
                                if (err___21) {
                                  tclistdel(rv);
                                  rv = (TCLIST *)((void *)0);
                                }
                              }
                            } else {
                              rv = tclistnew2(1);
                              if (argc > 0) {
                                tmp___852 = tcatoi((char const   *)((void *)(args->array + (int )args->start)->ptr));
                                tmp___853 = tmp___852;
                              } else {
                                tmp___853 = -1LL;
                              }
                              step___1 = tmp___853;
                              tmp___854 = tctdbdefrag(adb->tdb, step___1);
                              if (! tmp___854) {
                                tclistdel(rv);
                                rv = (TCLIST *)((void *)0);
                              }
                            }
                          } else {
                            rv = tclistnew2(1);
                            tmp___851 = tcadbvanish(adb);
                            if (! tmp___851) {
                              tclistdel(rv);
                              rv = (TCLIST *)((void *)0);
                            }
                          }
                        } else {
                          rv = tclistnew2(1);
                          if (argc > 0) {
                            tmp___849 = (void *)(args->array + (int )args->start)->ptr;
                          } else {
                            tmp___849 = (void *)0;
                          }
                          params___4 = (char const   *)tmp___849;
                          tmp___850 = tcadboptimize(adb, params___4);
                          if (! tmp___850) {
                            tclistdel(rv);
                            rv = (TCLIST *)((void *)0);
                          }
                        }
                      } else {
                        rv = tclistnew2(1);
                        tmp___848 = tcadbsync(adb);
                        if (! tmp___848) {
                          tclistdel(rv);
                          rv = (TCLIST *)((void *)0);
                        }
                      }
                    } else {
                      rv = tclistnew2(1);
                      tmp___838 = tctdbiternext(adb->tdb, & pksiz___3);
                      pkbuf___3 = (char *)tmp___838;
                      if (pkbuf___3) {
                        while (1) {
                          TC_mysize___27 = pksiz___3;
                          TC_index___27 = rv->start + rv->num;
                          if (TC_index___27 >= rv->anum) {
                            rv->anum += rv->num + 1;
                            while (1) {
                              tmp___840 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                              tmp___839 = (TCLISTDATUM *)tmp___840;
                              rv->array = tmp___839;
                              if (! tmp___839) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                          }
                          array___27 = rv->array;
                          while (1) {
                            tmp___842 = malloc((unsigned int )(TC_mysize___27 + 1));
                            tmp___841 = (char *)tmp___842;
                            (array___27 + TC_index___27)->ptr = tmp___841;
                            if (! tmp___841) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                          memcpy((void * __restrict  )(array___27 + TC_index___27)->ptr,
                                 (void const   * __restrict  )pkbuf___3, (unsigned int )TC_mysize___27);
                          *((array___27 + TC_index___27)->ptr + TC_mysize___27) = (char )'\000';
                          (array___27 + TC_index___27)->size = TC_mysize___27;
                          (rv->num) ++;
                          break;
                        }
                        tmp___843 = tctdbget2(adb->tdb, (void const   *)pkbuf___3,
                                              pksiz___3, & csiz);
                        cbuf = tmp___843;
                        if (cbuf) {
                          while (1) {
                            TC_mysize___28 = csiz;
                            TC_index___28 = rv->start + rv->num;
                            if (TC_index___28 >= rv->anum) {
                              rv->anum += rv->num + 1;
                              while (1) {
                                tmp___845 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                                tmp___844 = (TCLISTDATUM *)tmp___845;
                                rv->array = tmp___844;
                                if (! tmp___844) {
                                  tcmyfatal("out of memory");
                                }
                                break;
                              }
                            }
                            array___28 = rv->array;
                            while (1) {
                              tmp___847 = malloc((unsigned int )(TC_mysize___28 + 1));
                              tmp___846 = (char *)tmp___847;
                              (array___28 + TC_index___28)->ptr = tmp___846;
                              if (! tmp___846) {
                                tcmyfatal("out of memory");
                              }
                              break;
                            }
                            memcpy((void * __restrict  )(array___28 + TC_index___28)->ptr,
                                   (void const   * __restrict  )cbuf, (unsigned int )TC_mysize___28);
                            *((array___28 + TC_index___28)->ptr + TC_mysize___28) = (char )'\000';
                            (array___28 + TC_index___28)->size = TC_mysize___28;
                            (rv->num) ++;
                            break;
                          }
                          while (1) {
                            free((void *)cbuf);
                            break;
                          }
                        }
                        while (1) {
                          free((void *)pkbuf___3);
                          break;
                        }
                      } else {
                        tclistdel(rv);
                        rv = (TCLIST *)((void *)0);
                      }
                    }
                  } else {
                    rv = tclistnew2(1);
                    err___20 = (_Bool)0;
                    if (argc > 0) {
                      while (1) {
                        pkbuf___2 = (char const   *)(args->array + (int )args->start)->ptr;
                        pksiz___2 = (args->array + (int )args->start)->size;
                        break;
                      }
                      tmp___836 = tctdbiterinit2(adb->tdb, (void const   *)pkbuf___2,
                                                 pksiz___2);
                      if (! tmp___836) {
                        err___20 = (_Bool)1;
                      }
                    } else {
                      tmp___837 = tctdbiterinit(adb->tdb);
                      if (! tmp___837) {
                        err___20 = (_Bool)1;
                      }
                    }
                    if (err___20) {
                      tclistdel(rv);
                      rv = (TCLIST *)((void *)0);
                    }
                  }
                } else {
                  rv = tclistnew2(argc * 2);
                  err___19 = (_Bool)0;
                  i___17 = 0;
                  while (i___17 < argc) {
                    while (1) {
                      kbuf___43 = (char const   *)(args->array + (i___17 + (int )args->start))->ptr;
                      ksiz___43 = (args->array + (i___17 + (int )args->start))->size;
                      break;
                    }
                    tmp___826 = tctdbget2(adb->tdb, (void const   *)kbuf___43, ksiz___43,
                                          & vsiz___26);
                    vbuf___26 = tmp___826;
                    if (vbuf___26) {
                      while (1) {
                        TC_mysize___25 = ksiz___43;
                        TC_index___25 = rv->start + rv->num;
                        if (TC_index___25 >= rv->anum) {
                          rv->anum += rv->num + 1;
                          while (1) {
                            tmp___828 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                            tmp___827 = (TCLISTDATUM *)tmp___828;
                            rv->array = tmp___827;
                            if (! tmp___827) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___25 = rv->array;
                        while (1) {
                          tmp___830 = malloc((unsigned int )(TC_mysize___25 + 1));
                          tmp___829 = (char *)tmp___830;
                          (array___25 + TC_index___25)->ptr = tmp___829;
                          if (! tmp___829) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___25 + TC_index___25)->ptr,
                               (void const   * __restrict  )kbuf___43, (unsigned int )TC_mysize___25);
                        *((array___25 + TC_index___25)->ptr + TC_mysize___25) = (char )'\000';
                        (array___25 + TC_index___25)->size = TC_mysize___25;
                        (rv->num) ++;
                        break;
                      }
                      while (1) {
                        TC_mysize___26 = vsiz___26;
                        TC_index___26 = rv->start + rv->num;
                        if (TC_index___26 >= rv->anum) {
                          rv->anum += rv->num + 1;
                          while (1) {
                            tmp___832 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                            tmp___831 = (TCLISTDATUM *)tmp___832;
                            rv->array = tmp___831;
                            if (! tmp___831) {
                              tcmyfatal("out of memory");
                            }
                            break;
                          }
                        }
                        array___26 = rv->array;
                        while (1) {
                          tmp___834 = malloc((unsigned int )(TC_mysize___26 + 1));
                          tmp___833 = (char *)tmp___834;
                          (array___26 + TC_index___26)->ptr = tmp___833;
                          if (! tmp___833) {
                            tcmyfatal("out of memory");
                          }
                          break;
                        }
                        memcpy((void * __restrict  )(array___26 + TC_index___26)->ptr,
                               (void const   * __restrict  )vbuf___26, (unsigned int )TC_mysize___26);
                        *((array___26 + TC_index___26)->ptr + TC_mysize___26) = (char )'\000';
                        (array___26 + TC_index___26)->size = TC_mysize___26;
                        (rv->num) ++;
                        break;
                      }
                      while (1) {
                        free((void *)vbuf___26);
                        break;
                      }
                    } else {
                      tmp___835 = tctdbecode(adb->tdb);
                      if (tmp___835 != 22) {
                        err___19 = (_Bool)1;
                      }
                    }
                    i___17 ++;
                  }
                  if (err___19) {
                    tclistdel(rv);
                    rv = (TCLIST *)((void *)0);
                  }
                }
              } else {
                rv = tclistnew2(1);
                err___18 = (_Bool)0;
                i___16 = 0;
                while (i___16 < argc) {
                  while (1) {
                    kbuf___42 = (char const   *)(args->array + (i___16 + (int )args->start))->ptr;
                    ksiz___42 = (args->array + (i___16 + (int )args->start))->size;
                    break;
                  }
                  tmp___824 = tctdbout(adb->tdb, (void const   *)kbuf___42, ksiz___42);
                  if (! tmp___824) {
                    tmp___825 = tctdbecode(adb->tdb);
                    if (tmp___825 != 22) {
                      err___18 = (_Bool)1;
                      break;
                    }
                  }
                  i___16 ++;
                }
                if (err___18) {
                  tclistdel(rv);
                  rv = (TCLIST *)((void *)0);
                }
              }
            } else {
              rv = tclistnew2(1);
              err___17 = (_Bool)0;
              argc --;
              i___15 = 0;
              while (i___15 < argc) {
                while (1) {
                  kbuf___41 = (char const   *)(args->array + (i___15 + (int )args->start))->ptr;
                  ksiz___41 = (args->array + (i___15 + (int )args->start))->size;
                  break;
                }
                tmp___822 = tclistval(args, i___15 + 1, & vsiz___25);
                vbuf___25 = (char const   *)tmp___822;
                tmp___823 = tctdbput2(adb->tdb, (void const   *)kbuf___41, ksiz___41,
                                      (void const   *)vbuf___25, vsiz___25);
                if (! tmp___823) {
                  err___17 = (_Bool)1;
                  break;
                }
                i___15 += 2;
              }
              if (err___17) {
                tclistdel(rv);
                rv = (TCLIST *)((void *)0);
              }
            }
          } else {
            if (argc > 0) {
              rv = tclistnew2(1);
              while (1) {
                pkbuf___1 = (args->array + (int )args->start)->ptr;
                pksiz___1 = (args->array + (int )args->start)->size;
                break;
              }
              tmp___811 = tctdbget(adb->tdb, (void const   *)pkbuf___1, pksiz___1);
              cols___0 = tmp___811;
              if (cols___0) {
                tcmapiterinit(cols___0);
                while (1) {
                  tmp___821 = tcmapiternext(cols___0, & ksiz___40);
                  kbuf___40 = (char const   *)tmp___821;
                  if (! ((unsigned int )kbuf___40 != (unsigned int )((void *)0))) {
                    break;
                  }
                  tmp___812 = tcmapiterval((void const   *)kbuf___40, & vsiz___24);
                  vbuf___24 = (char const   *)tmp___812;
                  while (1) {
                    TC_mysize___23 = ksiz___40;
                    TC_index___23 = rv->start + rv->num;
                    if (TC_index___23 >= rv->anum) {
                      rv->anum += rv->num + 1;
                      while (1) {
                        tmp___814 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                        tmp___813 = (TCLISTDATUM *)tmp___814;
                        rv->array = tmp___813;
                        if (! tmp___813) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    array___23 = rv->array;
                    while (1) {
                      tmp___816 = malloc((unsigned int )(TC_mysize___23 + 1));
                      tmp___815 = (char *)tmp___816;
                      (array___23 + TC_index___23)->ptr = tmp___815;
                      if (! tmp___815) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )(array___23 + TC_index___23)->ptr,
                           (void const   * __restrict  )kbuf___40, (unsigned int )TC_mysize___23);
                    *((array___23 + TC_index___23)->ptr + TC_mysize___23) = (char )'\000';
                    (array___23 + TC_index___23)->size = TC_mysize___23;
                    (rv->num) ++;
                    break;
                  }
                  while (1) {
                    TC_mysize___24 = vsiz___24;
                    TC_index___24 = rv->start + rv->num;
                    if (TC_index___24 >= rv->anum) {
                      rv->anum += rv->num + 1;
                      while (1) {
                        tmp___818 = realloc((void *)rv->array, (unsigned int )(rv->anum * (int )sizeof(*(rv->array + 0))));
                        tmp___817 = (TCLISTDATUM *)tmp___818;
                        rv->array = tmp___817;
                        if (! tmp___817) {
                          tcmyfatal("out of memory");
                        }
                        break;
                      }
                    }
                    array___24 = rv->array;
                    while (1) {
                      tmp___820 = malloc((unsigned int )(TC_mysize___24 + 1));
                      tmp___819 = (char *)tmp___820;
                      (array___24 + TC_index___24)->ptr = tmp___819;
                      if (! tmp___819) {
                        tcmyfatal("out of memory");
                      }
                      break;
                    }
                    memcpy((void * __restrict  )(array___24 + TC_index___24)->ptr,
                           (void const   * __restrict  )vbuf___24, (unsigned int )TC_mysize___24);
                    *((array___24 + TC_index___24)->ptr + TC_mysize___24) = (char )'\000';
                    (array___24 + TC_index___24)->size = TC_mysize___24;
                    (rv->num) ++;
                    break;
                  }
                }
                tcmapdel(cols___0);
              } else {
                tclistdel(rv);
                rv = (TCLIST *)((void *)0);
              }
            } else {
              rv = (TCLIST *)((void *)0);
            }
          }
        } else {
          if (argc > 0) {
            rv = tclistnew2(1);
            while (1) {
              pkbuf___0 = (args->array + (int )args->start)->ptr;
              pksiz___0 = (args->array + (int )args->start)->size;
              break;
            }
            tmp___810 = tctdbout(adb->tdb, (void const   *)pkbuf___0, pksiz___0);
            if (! tmp___810) {
              tclistdel(rv);
              rv = (TCLIST *)((void *)0);
            }
          } else {
            rv = (TCLIST *)((void *)0);
          }
        }
      } else {
        _L___259: 
        if (argc > 0) {
          rv = tclistnew2(1);
          while (1) {
            pkbuf = (args->array + (int )args->start)->ptr;
            pksiz = (args->array + (int )args->start)->size;
            break;
          }
          argc --;
          tmp___784 = tcmapnew2((unsigned int )argc);
          cols = tmp___784;
          i___14 = 1;
          while (i___14 < argc) {
            while (1) {
              kbuf___39 = (char const   *)(args->array + (i___14 + (int )args->start))->ptr;
              ksiz___39 = (args->array + (i___14 + (int )args->start))->size;
              break;
            }
            tmp___785 = tclistval(args, i___14 + 1, & vsiz___23);
            vbuf___23 = (char const   *)tmp___785;
            tcmapput(cols, (void const   *)kbuf___39, ksiz___39, (void const   *)vbuf___23,
                     vsiz___23);
            i___14 += 2;
          }
          err___16 = (_Bool)0;
          if (0) {
            __s1_len___87 = strlen(name);
            __s2_len___87 = strlen("put");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___181;
            } else {
              if (__s1_len___87 >= 4U) {
                _L___181: 
                if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
                  tmp___809 = 1;
                } else {
                  if (__s2_len___87 >= 4U) {
                    tmp___809 = 1;
                  } else {
                    tmp___809 = 0;
                  }
                }
              } else {
                tmp___809 = 0;
              }
            }
            if (tmp___809) {
              tmp___804 = __builtin_strcmp(name, "put");
              tmp___808 = tmp___804;
            } else {
              tmp___807 = __builtin_strcmp(name, "put");
              tmp___808 = tmp___807;
            }
          } else {
            tmp___807 = __builtin_strcmp(name, "put");
            tmp___808 = tmp___807;
          }
          if (tmp___808) {
            if (0) {
              __s1_len___86 = strlen(name);
              __s2_len___86 = strlen("putkeep");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___179;
              } else {
                if (__s1_len___86 >= 4U) {
                  _L___179: 
                  if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
                    tmp___802 = 1;
                  } else {
                    if (__s2_len___86 >= 4U) {
                      tmp___802 = 1;
                    } else {
                      tmp___802 = 0;
                    }
                  }
                } else {
                  tmp___802 = 0;
                }
              }
              if (tmp___802) {
                tmp___797 = __builtin_strcmp(name, "putkeep");
                tmp___801 = tmp___797;
              } else {
                tmp___800 = __builtin_strcmp(name, "putkeep");
                tmp___801 = tmp___800;
              }
            } else {
              tmp___800 = __builtin_strcmp(name, "putkeep");
              tmp___801 = tmp___800;
            }
            if (tmp___801) {
              if (0) {
                __s1_len___85 = strlen(name);
                __s2_len___85 = strlen("putcat");
                if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                  goto _L___177;
                } else {
                  if (__s1_len___85 >= 4U) {
                    _L___177: 
                    if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
                      tmp___795 = 1;
                    } else {
                      if (__s2_len___85 >= 4U) {
                        tmp___795 = 1;
                      } else {
                        tmp___795 = 0;
                      }
                    }
                  } else {
                    tmp___795 = 0;
                  }
                }
                if (tmp___795) {
                  tmp___790 = __builtin_strcmp(name, "putcat");
                  tmp___794 = tmp___790;
                } else {
                  tmp___793 = __builtin_strcmp(name, "putcat");
                  tmp___794 = tmp___793;
                }
              } else {
                tmp___793 = __builtin_strcmp(name, "putcat");
                tmp___794 = tmp___793;
              }
              if (! tmp___794) {
                tmp___788 = tctdbputcat(adb->tdb, (void const   *)pkbuf, pksiz, cols);
                if (! tmp___788) {
                  err___16 = (_Bool)1;
                }
              }
            } else {
              tmp___787 = tctdbputkeep(adb->tdb, (void const   *)pkbuf, pksiz, cols);
              if (! tmp___787) {
                err___16 = (_Bool)1;
              }
            }
          } else {
            tmp___786 = tctdbput(adb->tdb, (void const   *)pkbuf, pksiz, cols);
            if (! tmp___786) {
              err___16 = (_Bool)1;
            }
          }
          tcmapdel(cols);
          if (err___16) {
            tclistdel(rv);
            rv = (TCLIST *)((void *)0);
          }
        } else {
          rv = (TCLIST *)((void *)0);
        }
      }
    } else {
      goto _L___259;
    }
  } else {
    goto _L___259;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->misc) {
    rv = (*(skel->misc))(skel->opq, name, args);
  } else {
    rv = (TCLIST *)((void *)0);
  }
  break;
  default: 
  rv = (TCLIST *)((void *)0);
  break;
  }
  return (rv);
}
}
_Bool tcadbsetskel(TCADB *adb , ADBSKEL *skel ) 
{ 

  {
  if (adb->omode != 0) {
    return ((_Bool)0);
  }
  if (adb->skel) {
    while (1) {
      free(adb->skel);
      break;
    }
  }
  adb->skel = tcmemdup((void const   *)skel, (unsigned int )((int )sizeof(*skel)));
  return ((_Bool)1);
}
}
int tcadbomode(TCADB *adb ) 
{ 

  {
  return (adb->omode);
}
}
void *tcadbreveal(TCADB *adb ) 
{ void *rv ;

  {
  switch (adb->omode) {
  case 1: 
  rv = (void *)adb->mdb;
  break;
  case 2: 
  rv = (void *)adb->ndb;
  break;
  case 3: 
  rv = (void *)adb->hdb;
  break;
  case 4: 
  rv = (void *)adb->bdb;
  break;
  case 5: 
  rv = (void *)adb->fdb;
  break;
  case 6: 
  rv = (void *)adb->tdb;
  break;
  case 7: 
  rv = adb->skel;
  break;
  default: 
  rv = (void *)0;
  break;
  }
  return (rv);
}
}
_Bool tcadbputproc(TCADB *adb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz , void *(*proc___0)(void const   *vbuf , int vsiz , int *sp ,
                                                void *op ) , void *op ) 
{ _Bool err ;
  ADBSKEL *skel ;
  uint64_t tmp ;
  uint64_t tmp___0 ;
  _Bool tmp___1 ;
  uint64_t tmp___2 ;
  uint64_t tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  int64_t tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  tmp___1 = tcmdbputproc(adb->mdb, kbuf, ksiz, vbuf, vsiz, proc___0, op);
  if (tmp___1) {
    if (adb->capnum > 0LL) {
      goto _L;
    } else {
      if (adb->capsiz > 0LL) {
        _L: 
        (adb->capcnt) ++;
        if ((adb->capcnt & 255U) == 0U) {
          if (adb->capnum > 0LL) {
            tmp = tcmdbrnum(adb->mdb);
            if (tmp > (unsigned long long )(adb->capnum + 256LL)) {
              tcmdbcutfront(adb->mdb, 256);
            }
          }
          if (adb->capsiz > 0LL) {
            tmp___0 = tcmdbmsiz(adb->mdb);
            if (tmp___0 > (unsigned long long )adb->capsiz) {
              tcmdbcutfront(adb->mdb, 512);
            }
          }
        }
      }
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 2: 
  tmp___4 = tcndbputproc(adb->ndb, kbuf, ksiz, vbuf, vsiz, proc___0, op);
  if (tmp___4) {
    if (adb->capnum > 0LL) {
      goto _L___0;
    } else {
      if (adb->capsiz > 0LL) {
        _L___0: 
        (adb->capcnt) ++;
        if ((adb->capcnt & 255U) == 0U) {
          if (adb->capnum > 0LL) {
            tmp___2 = tcndbrnum(adb->ndb);
            if (tmp___2 > (unsigned long long )(adb->capnum + 256LL)) {
              tcndbcutfringe(adb->ndb, 256);
            }
          }
          if (adb->capsiz > 0LL) {
            tmp___3 = tcndbmsiz(adb->ndb);
            if (tmp___3 > (unsigned long long )adb->capsiz) {
              tcndbcutfringe(adb->ndb, 512);
            }
          }
        }
      }
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 3: 
  tmp___5 = tchdbputproc(adb->hdb, kbuf, ksiz, vbuf, vsiz, proc___0, op);
  if (! tmp___5) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___6 = tcbdbputproc(adb->bdb, kbuf, ksiz, vbuf, vsiz, proc___0, op);
  if (! tmp___6) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___7 = tcfdbkeytoid((char const   *)kbuf, ksiz);
  tmp___8 = tcfdbputproc(adb->fdb, tmp___7, vbuf, vsiz, proc___0, op);
  if (! tmp___8) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  tmp___9 = tctdbputproc(adb->tdb, kbuf, ksiz, vbuf, vsiz, proc___0, op);
  if (! tmp___9) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->putproc) {
    tmp___10 = (*(skel->putproc))(skel->opq, kbuf, ksiz, vbuf, vsiz, proc___0, op);
    if (! tmp___10) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadbforeach(TCADB *adb , _Bool (*iter)(void const   *kbuf , int ksiz , void const   *vbuf ,
                                              int vsiz , void *op ) , void *op ) 
{ _Bool err ;
  ADBSKEL *skel ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
  err = (_Bool)0;
  switch (adb->omode) {
  case 1: 
  tcmdbforeach(adb->mdb, iter, op);
  break;
  case 2: 
  tcndbforeach(adb->ndb, iter, op);
  break;
  case 3: 
  tmp = tchdbforeach(adb->hdb, iter, op);
  if (! tmp) {
    err = (_Bool)1;
  }
  break;
  case 4: 
  tmp___0 = tcbdbforeach(adb->bdb, iter, op);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  break;
  case 5: 
  tmp___1 = tcfdbforeach(adb->fdb, iter, op);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  break;
  case 6: 
  tmp___2 = tctdbforeach(adb->tdb, iter, op);
  if (! tmp___2) {
    err = (_Bool)1;
  }
  break;
  case 7: 
  skel = (ADBSKEL *)adb->skel;
  if (skel->foreach) {
    tmp___3 = (*(skel->foreach))(skel->opq, iter, op);
    if (! tmp___3) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
_Bool tcadbmapbdb(TCADB *adb , TCLIST *keys , TCBDB *bdb , _Bool (*proc___0)(void *map ,
                                                                             char const   *kbuf ,
                                                                             int ksiz ,
                                                                             char const   *vbuf ,
                                                                             int vsiz ,
                                                                             void *op ) ,
                  void *op , int64_t csiz ) 
{ TCLIST *recs ;
  long tmp ;
  TCLIST *tmp___0 ;
  ADBMAPBDB map ;
  _Bool err ;
  int knum ;
  int i ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  char *vbuf ;
  void *tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;

  {
  if (csiz < 0LL) {
    csiz = 256LL << 20;
  }
  tmp = tclmin((long )(csiz / 64LL + 256LL), 536870911L);
  tmp___0 = tclistnew2((int )tmp);
  recs = tmp___0;
  map.adb = adb;
  map.bdb = bdb;
  map.recs = recs;
  map.proc = proc___0;
  map.op = op;
  map.rsiz = 0LL;
  map.csiz = csiz;
  err = (_Bool)0;
  if (keys) {
    knum = keys->num;
    i = 0;
    while (1) {
      if (i < knum) {
        if (! (! err)) {
          break;
        }
      } else {
        break;
      }
      while (1) {
        kbuf = (char const   *)(keys->array + (i + keys->start))->ptr;
        ksiz = (keys->array + (i + keys->start))->size;
        break;
      }
      tmp___1 = tcadbget(adb, (void const   *)kbuf, ksiz, & vsiz);
      vbuf = (char *)tmp___1;
      if (vbuf) {
        tmp___2 = tcadbmapbdbiter((void const   *)kbuf, ksiz, (void const   *)vbuf,
                                  vsiz, (void *)(& map));
        if (! tmp___2) {
          err = (_Bool)1;
        }
        while (1) {
          free((void *)vbuf);
          break;
        }
        if (map.rsiz > map.csiz) {
          tmp___3 = tcadbmapbdbdump(& map);
          if (! tmp___3) {
            err = (_Bool)1;
          }
        }
      }
      if (map.rsiz > 0LL) {
        tmp___4 = tcadbmapbdbdump(& map);
        if (! tmp___4) {
          err = (_Bool)1;
        }
      }
      i ++;
    }
  } else {
    tmp___5 = tcadbforeach(adb, & tcadbmapbdbiter, (void *)(& map));
    if (! tmp___5) {
      err = (_Bool)1;
    }
  }
  if (map.rsiz > 0LL) {
    tmp___6 = tcadbmapbdbdump(& map);
    if (! tmp___6) {
      err = (_Bool)1;
    }
  }
  tclistdel(recs);
  return ((_Bool )(! err));
}
}
_Bool tcadbmapbdbemit(void *map , char const   *kbuf , int ksiz , char const   *vbuf ,
                      int vsiz ) 
{ ADBMAPBDB *mymap ;
  int rsiz ;
  char stack[256] ;
  char *rbuf ;
  void *tmp ;
  _Bool err ;
  char *wp ;
  _Bool tmp___0 ;

  {
  mymap = (ADBMAPBDB *)map;
  rsiz = ((int )sizeof(ksiz) + ksiz) + vsiz;
  if (rsiz <= (int )sizeof(stack)) {
    rbuf = stack;
  } else {
    while (1) {
      tmp = malloc((unsigned int )rsiz);
      rbuf = (char *)tmp;
      if (! rbuf) {
        tcmyfatal("out of memory");
      }
      break;
    }
  }
  err = (_Bool)0;
  wp = rbuf;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& ksiz), (unsigned int )((int )sizeof(ksiz)));
  wp += (int )sizeof(ksiz);
  memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  wp += ksiz;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
  tclistpush(mymap->recs, (void const   *)rbuf, rsiz);
  mymap->rsiz += (long long )(rsiz + (int )sizeof(TCLISTDATUM ));
  if ((unsigned int )rbuf != (unsigned int )(stack)) {
    while (1) {
      free((void *)rbuf);
      break;
    }
  }
  if (mymap->rsiz > mymap->csiz) {
    tmp___0 = tcadbmapbdbdump((ADBMAPBDB *)map);
    if (! tmp___0) {
      err = (_Bool)1;
    }
  }
  return ((_Bool )(! err));
}
}
static _Bool tcadbmapbdbiter(void const   *kbuf , int ksiz , void const   *vbuf ,
                             int vsiz , void *op ) 
{ ADBMAPBDB *map ;
  _Bool err ;
  _Bool tmp ;

  {
  map = (ADBMAPBDB *)op;
  err = (_Bool)0;
  tmp = (*(map->proc))((void *)map, (char const   *)kbuf, ksiz, (char const   *)vbuf,
                       vsiz, map->op);
  if (! tmp) {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcadbmapbdbdump(ADBMAPBDB *map ) 
{ TCBDB *bdb ;
  TCLIST *recs ;
  int rnum ;
  int (*cmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
  int (*tmp)(char const   *aptr , int asiz , char const   *bptr , int bsiz , void *op ) ;
  _Bool err ;
  int i ;
  char const   *rbuf ;
  int rsiz ;
  int ksiz ;
  char const   *kbuf ;
  _Bool tmp___0 ;

  {
  bdb = map->bdb;
  recs = map->recs;
  rnum = recs->num;
  tmp = tcbdbcmpfunc(bdb);
  cmp = tmp;
  if ((unsigned int )cmp == (unsigned int )(& tccmplexical)) {
    tclistsortex(recs, & tcadbmapreccmplexical);
  } else {
    if ((unsigned int )cmp == (unsigned int )(& tccmpdecimal)) {
      tclistsortex(recs, & tcadbmapreccmpdecimal);
    } else {
      if ((unsigned int )cmp == (unsigned int )(& tccmpint32)) {
        tclistsortex(recs, & tcadbmapreccmpint32);
      } else {
        if ((unsigned int )cmp == (unsigned int )(& tccmpint64)) {
          tclistsortex(recs, & tcadbmapreccmpint64);
        }
      }
    }
  }
  err = (_Bool)0;
  i = 0;
  while (i < rnum) {
    while (1) {
      rbuf = (char const   *)(recs->array + (i + recs->start))->ptr;
      rsiz = (recs->array + (i + recs->start))->size;
      break;
    }
    memcpy((void * __restrict  )(& ksiz), (void const   * __restrict  )rbuf, (unsigned int )((int )sizeof(ksiz)));
    kbuf = rbuf + (int )sizeof(ksiz);
    tmp___0 = tcbdbputdup(bdb, (void const   *)kbuf, ksiz, (void const   *)(kbuf + ksiz),
                          (rsiz - (int )sizeof(ksiz)) - ksiz);
    if (! tmp___0) {
      err = (_Bool)1;
      break;
    }
    i ++;
  }
  tclistclear(recs);
  map->rsiz = 0LL;
  return ((_Bool )(! err));
}
}
static int tcadbmapreccmplexical(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) 
{ unsigned char *ao ;
  unsigned char *bo ;
  int size ;
  int tmp ;
  int i ;

  {
  ao = (unsigned char *)((TCLISTDATUM *)a)->ptr;
  bo = (unsigned char *)((TCLISTDATUM *)b)->ptr;
  if (((TCLISTDATUM *)a)->size < ((TCLISTDATUM *)b)->size) {
    tmp = ((TCLISTDATUM *)a)->size;
  } else {
    tmp = ((TCLISTDATUM *)b)->size;
  }
  size = tmp;
  i = (int )sizeof(int );
  while (i < size) {
    if ((int )*(ao + i) > (int )*(bo + i)) {
      return (1);
    }
    if ((int )*(ao + i) < (int )*(bo + i)) {
      return (-1);
    }
    i ++;
  }
  return (((TCLISTDATUM *)a)->size - ((TCLISTDATUM *)b)->size);
}
}
static int tcadbmapreccmpdecimal(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) 
{ int tmp ;

  {
  tmp = tccmpdecimal((char const   *)(((TCLISTDATUM *)a)->ptr + (int )sizeof(int )),
                     (int )(a->size - (int const   )((int )sizeof(int ))), (char const   *)(((TCLISTDATUM *)b)->ptr + (int )sizeof(int )),
                     (int )(b->size - (int const   )((int )sizeof(int ))), (void *)0);
  return (tmp);
}
}
static int tcadbmapreccmpint32(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) 
{ int tmp ;

  {
  tmp = tccmpint32((char const   *)(((TCLISTDATUM *)a)->ptr + (int )sizeof(int )),
                   (int )(a->size - (int const   )((int )sizeof(int ))), (char const   *)(((TCLISTDATUM *)b)->ptr + (int )sizeof(int )),
                   (int )(b->size - (int const   )((int )sizeof(int ))), (void *)0);
  return (tmp);
}
}
static int tcadbmapreccmpint64(TCLISTDATUM const   *a , TCLISTDATUM const   *b ) 
{ int tmp ;

  {
  tmp = tccmpint64((char const   *)(((TCLISTDATUM *)a)->ptr + (int )sizeof(int )),
                   (int )(a->size - (int const   )((int )sizeof(int ))), (char const   *)(((TCLISTDATUM *)b)->ptr + (int )sizeof(int )),
                   (int )(b->size - (int const   )((int )sizeof(int ))), (void *)0);
  return (tmp);
}
}
static int tcadbtdbqrygetout(void const   *pkbuf , int pksiz , TCMAP *cols , void *op ) 
{ TCLIST *rv ;
  TCLIST *cnames ;
  int cnnum ;
  TCMAP *ncols ;
  TCMAP *tmp ;
  int j ;
  char const   *cname ;
  int cnsiz ;
  int cvsiz ;
  char const   *cvalue ;
  void const   *tmp___0 ;
  int csiz ;
  char *cbuf ;
  void *tmp___1 ;
  int csiz___0 ;
  char *cbuf___0 ;
  void *tmp___2 ;

  {
  rv = (TCLIST *)*((void **)op + 0);
  cnames = (TCLIST *)*((void **)op + 1);
  cnnum = cnames->num;
  tcmapput(cols, (void const   *)"", 0, pkbuf, pksiz);
  tcmapmove(cols, (void const   *)"", 0, (_Bool)1);
  if (cnnum > 0) {
    tmp = tcmapnew2((unsigned int )(cnnum + 1));
    ncols = tmp;
    j = 0;
    while (j < cnnum) {
      while (1) {
        cname = (char const   *)(cnames->array + (j + cnames->start))->ptr;
        cnsiz = (cnames->array + (j + cnames->start))->size;
        break;
      }
      tmp___0 = tcmapget((TCMAP const   *)cols, (void const   *)cname, cnsiz, & cvsiz);
      cvalue = (char const   *)tmp___0;
      if (cvalue) {
        tcmapput(ncols, (void const   *)cname, cnsiz, (void const   *)cvalue, cvsiz);
      }
      j ++;
    }
    tmp___1 = tcstrjoin4((TCMAP const   *)ncols, & csiz);
    cbuf = (char *)tmp___1;
    tclistpushmalloc(rv, (void *)cbuf, csiz);
    tcmapdel(ncols);
  } else {
    tmp___2 = tcstrjoin4((TCMAP const   *)cols, & csiz___0);
    cbuf___0 = (char *)tmp___2;
    tclistpushmalloc(rv, (void *)cbuf___0, csiz___0);
  }
  return (2);
}
}
#pragma merger(0,"/tmp/cil-xgqTLkpn.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
__inline extern  __attribute__((__nothrow__)) int __signbitf(float __x )  __attribute__((__const__)) ;
__inline extern int __signbitf(float __x ) 
{ union __anonunion___u_6 __u ;

  {
  __u.__f = __x;
  return (__u.__i < 0);
}
}
__inline extern  __attribute__((__nothrow__)) int __signbit(double __x )  __attribute__((__const__)) ;
__inline extern int __signbit(double __x ) 
{ union __anonunion___u_7 __u ;

  {
  __u.__d = __x;
  return (__u.__i[1] < 0);
}
}
__inline extern  __attribute__((__nothrow__)) int __signbitl(long double __x )  __attribute__((__const__)) ;
__inline extern int __signbitl(long double __x ) 
{ union __anonunion___u_8 __u ;

  {
  __u.__l = __x;
  return ((__u.__i[2] & 32768) != 0);
}
}
int _tc_dummy_cnt ;
int _tc_dummyfunc(void) ;
int _tc_dummyfuncv(int a  , ...) ;
void *_tc_recencode(void const   *ptr , int size , int *sp , void *op ) ;
void *_tc_recdecode(void const   *ptr , int size , int *sp , void *op ) ;
int _tc_dummy_cnt  =    0;
int _tc_dummyfunc(void) 
{ 

  {
  return (0);
}
}
int _tc_dummyfuncv(int a  , ...) 
{ 

  {
  return (0);
}
}
extern int deflate(z_streamp strm , int flush ) ;
extern int deflateEnd(z_streamp strm ) ;
extern int inflate(z_streamp strm , int flush ) ;
extern int inflateEnd(z_streamp strm ) ;
extern uLong crc32(uLong crc , Bytef const   *buf , uInt len ) ;
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
extern int inflateInit2_(z_streamp strm , int windowBits , char const   *version ,
                         int stream_size ) ;
static char *_tc_deflate_impl(char const   *ptr , int size , int *sp , int mode ) ;
static char *_tc_inflate_impl(char const   *ptr , int size , int *sp , int mode ) ;
static unsigned int _tc_getcrc_impl(char const   *ptr , int size ) ;
char *(*_tc_deflate)(char const   * , int  , int * , int  )  =    & _tc_deflate_impl;
char *(*_tc_inflate)(char const   * , int  , int * , int  )  =    & _tc_inflate_impl;
unsigned int (*_tc_getcrc)(char const   * , int  )  =    & _tc_getcrc_impl;
static char *_tc_deflate_impl(char const   *ptr , int size , int *sp , int mode ) 
{ z_stream zs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int asiz ;
  char *buf ;
  void *tmp___2 ;
  unsigned char obuf[8192] ;
  int bsiz ;
  int rv ;
  int osiz ;
  char *swap ;
  void *tmp___3 ;
  int osiz___0 ;
  char *swap___0 ;
  void *tmp___4 ;

  {
  zs.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
  zs.zfree = (void (*)(voidpf opaque , voidpf address ))0;
  zs.opaque = (void *)0;
  switch (mode) {
  case 1: 
  tmp = deflateInit2_(& zs, 5, 8, -15, 7, 0, "1.2.3.3", (int )sizeof(z_stream ));
  if (tmp != 0) {
    return ((char *)((void *)0));
  }
  break;
  case 2: 
  tmp___0 = deflateInit2_(& zs, 6, 8, 31, 9, 0, "1.2.3.3", (int )sizeof(z_stream ));
  if (tmp___0 != 0) {
    return ((char *)((void *)0));
  }
  break;
  default: 
  tmp___1 = deflateInit2_(& zs, 6, 8, 15, 8, 0, "1.2.3.3", (int )sizeof(z_stream ));
  if (tmp___1 != 0) {
    return ((char *)((void *)0));
  }
  break;
  }
  asiz = size + 16;
  if (asiz < 8192) {
    asiz = 8192;
  }
  tmp___2 = malloc((unsigned int )asiz);
  buf = (char *)tmp___2;
  if (! buf) {
    deflateEnd(& zs);
    return ((char *)((void *)0));
  }
  bsiz = 0;
  zs.next_in = (unsigned char *)ptr;
  zs.avail_in = (unsigned int )size;
  zs.next_out = obuf;
  zs.avail_out = 8192U;
  while (1) {
    rv = deflate(& zs, 4);
    if (! (rv == 0)) {
      break;
    }
    osiz = (int )(8192U - zs.avail_out);
    if (bsiz + osiz > asiz) {
      asiz = asiz * 2 + osiz;
      tmp___3 = realloc((void *)buf, (unsigned int )asiz);
      swap = (char *)tmp___3;
      if (! swap) {
        free((void *)buf);
        deflateEnd(& zs);
        return ((char *)((void *)0));
      }
      buf = swap;
    }
    memcpy((void * __restrict  )(buf + bsiz), (void const   * __restrict  )(obuf),
           (unsigned int )osiz);
    bsiz += osiz;
    zs.next_out = obuf;
    zs.avail_out = 8192U;
  }
  if (rv != 1) {
    free((void *)buf);
    deflateEnd(& zs);
    return ((char *)((void *)0));
  }
  osiz___0 = (int )(8192U - zs.avail_out);
  if ((bsiz + osiz___0) + 1 > asiz) {
    asiz = asiz * 2 + osiz___0;
    tmp___4 = realloc((void *)buf, (unsigned int )asiz);
    swap___0 = (char *)tmp___4;
    if (! swap___0) {
      free((void *)buf);
      deflateEnd(& zs);
      return ((char *)((void *)0));
    }
    buf = swap___0;
  }
  memcpy((void * __restrict  )(buf + bsiz), (void const   * __restrict  )(obuf), (unsigned int )osiz___0);
  bsiz += osiz___0;
  *(buf + bsiz) = (char )'\000';
  if (mode == 1) {
    bsiz ++;
  }
  *sp = bsiz;
  deflateEnd(& zs);
  return (buf);
}
}
static char *_tc_inflate_impl(char const   *ptr , int size , int *sp , int mode ) 
{ z_stream zs ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int asiz ;
  char *buf ;
  void *tmp___2 ;
  unsigned char obuf[8192] ;
  int bsiz ;
  int rv ;
  int osiz ;
  char *swap ;
  void *tmp___3 ;
  int osiz___0 ;
  char *swap___0 ;
  void *tmp___4 ;

  {
  zs.zalloc = (voidpf (*)(voidpf opaque , uInt items , uInt size ))0;
  zs.zfree = (void (*)(voidpf opaque , voidpf address ))0;
  zs.opaque = (void *)0;
  switch (mode) {
  case 1: 
  tmp = inflateInit2_(& zs, -15, "1.2.3.3", (int )sizeof(z_stream ));
  if (tmp != 0) {
    return ((char *)((void *)0));
  }
  break;
  case 2: 
  tmp___0 = inflateInit2_(& zs, 31, "1.2.3.3", (int )sizeof(z_stream ));
  if (tmp___0 != 0) {
    return ((char *)((void *)0));
  }
  break;
  default: 
  tmp___1 = inflateInit2_(& zs, 15, "1.2.3.3", (int )sizeof(z_stream ));
  if (tmp___1 != 0) {
    return ((char *)((void *)0));
  }
  break;
  }
  asiz = size * 2 + 16;
  if (asiz < 8192) {
    asiz = 8192;
  }
  tmp___2 = malloc((unsigned int )asiz);
  buf = (char *)tmp___2;
  if (! buf) {
    inflateEnd(& zs);
    return ((char *)((void *)0));
  }
  bsiz = 0;
  zs.next_in = (unsigned char *)ptr;
  zs.avail_in = (unsigned int )size;
  zs.next_out = obuf;
  zs.avail_out = 8192U;
  while (1) {
    rv = inflate(& zs, 0);
    if (! (rv == 0)) {
      break;
    }
    osiz = (int )(8192U - zs.avail_out);
    if (bsiz + osiz >= asiz) {
      asiz = asiz * 2 + osiz;
      tmp___3 = realloc((void *)buf, (unsigned int )asiz);
      swap = (char *)tmp___3;
      if (! swap) {
        free((void *)buf);
        inflateEnd(& zs);
        return ((char *)((void *)0));
      }
      buf = swap;
    }
    memcpy((void * __restrict  )(buf + bsiz), (void const   * __restrict  )(obuf),
           (unsigned int )osiz);
    bsiz += osiz;
    zs.next_out = obuf;
    zs.avail_out = 8192U;
  }
  if (rv != 1) {
    free((void *)buf);
    inflateEnd(& zs);
    return ((char *)((void *)0));
  }
  osiz___0 = (int )(8192U - zs.avail_out);
  if (bsiz + osiz___0 >= asiz) {
    asiz = asiz * 2 + osiz___0;
    tmp___4 = realloc((void *)buf, (unsigned int )asiz);
    swap___0 = (char *)tmp___4;
    if (! swap___0) {
      free((void *)buf);
      inflateEnd(& zs);
      return ((char *)((void *)0));
    }
    buf = swap___0;
  }
  memcpy((void * __restrict  )(buf + bsiz), (void const   * __restrict  )(obuf), (unsigned int )osiz___0);
  bsiz += osiz___0;
  *(buf + bsiz) = (char )'\000';
  *sp = bsiz;
  inflateEnd(& zs);
  return (buf);
}
}
static unsigned int _tc_getcrc_impl(char const   *ptr , int size ) 
{ int crc ;
  uLong tmp ;
  uLong tmp___0 ;

  {
  tmp = crc32(0UL, (Bytef const   *)0, 0U);
  crc = (int )tmp;
  tmp___0 = crc32((unsigned long )crc, (Bytef const   *)((unsigned char *)ptr), (unsigned int )size);
  return ((unsigned int )tmp___0);
}
}
extern int BZ2_bzCompressInit(bz_stream *strm , int blockSize100k , int verbosity ,
                              int workFactor ) ;
extern int BZ2_bzCompress(bz_stream *strm , int action ) ;
extern int BZ2_bzCompressEnd(bz_stream *strm ) ;
extern int BZ2_bzDecompressInit(bz_stream *strm , int verbosity , int small ) ;
extern int BZ2_bzDecompress(bz_stream *strm ) ;
extern int BZ2_bzDecompressEnd(bz_stream *strm ) ;
static char *_tc_bzcompress_impl(char const   *ptr , int size , int *sp ) ;
static char *_tc_bzdecompress_impl(char const   *ptr , int size , int *sp ) ;
char *(*_tc_bzcompress)(char const   * , int  , int * )  =    & _tc_bzcompress_impl;
char *(*_tc_bzdecompress)(char const   * , int  , int * )  =    & _tc_bzdecompress_impl;
static char *_tc_bzcompress_impl(char const   *ptr , int size , int *sp ) 
{ bz_stream zs ;
  int tmp ;
  int asiz ;
  char *buf ;
  void *tmp___0 ;
  char obuf[8192] ;
  int bsiz ;
  int rv ;
  int osiz ;
  char *swap ;
  void *tmp___1 ;
  int osiz___0 ;
  char *swap___0 ;
  void *tmp___2 ;

  {
  zs.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
  zs.bzfree = (void (*)(void * , void * ))((void *)0);
  zs.opaque = (void *)0;
  tmp = BZ2_bzCompressInit(& zs, 9, 0, 0);
  if (tmp != 0) {
    return ((char *)((void *)0));
  }
  asiz = size + 16;
  if (asiz < 8192) {
    asiz = 8192;
  }
  tmp___0 = malloc((unsigned int )asiz);
  buf = (char *)tmp___0;
  if (! buf) {
    BZ2_bzCompressEnd(& zs);
    return ((char *)((void *)0));
  }
  bsiz = 0;
  zs.next_in = (char *)ptr;
  zs.avail_in = (unsigned int )size;
  zs.next_out = obuf;
  zs.avail_out = 8192U;
  while (1) {
    rv = BZ2_bzCompress(& zs, 2);
    if (! (rv == 3)) {
      break;
    }
    osiz = (int )(8192U - zs.avail_out);
    if (bsiz + osiz > asiz) {
      asiz = asiz * 2 + osiz;
      tmp___1 = realloc((void *)buf, (unsigned int )asiz);
      swap = (char *)tmp___1;
      if (! swap) {
        free((void *)buf);
        BZ2_bzCompressEnd(& zs);
        return ((char *)((void *)0));
      }
      buf = swap;
    }
    memcpy((void * __restrict  )(buf + bsiz), (void const   * __restrict  )(obuf),
           (unsigned int )osiz);
    bsiz += osiz;
    zs.next_out = obuf;
    zs.avail_out = 8192U;
  }
  if (rv != 4) {
    free((void *)buf);
    BZ2_bzCompressEnd(& zs);
    return ((char *)((void *)0));
  }
  osiz___0 = (int )(8192U - zs.avail_out);
  if ((bsiz + osiz___0) + 1 > asiz) {
    asiz = asiz * 2 + osiz___0;
    tmp___2 = realloc((void *)buf, (unsigned int )asiz);
    swap___0 = (char *)tmp___2;
    if (! swap___0) {
      free((void *)buf);
      BZ2_bzCompressEnd(& zs);
      return ((char *)((void *)0));
    }
    buf = swap___0;
  }
  memcpy((void * __restrict  )(buf + bsiz), (void const   * __restrict  )(obuf), (unsigned int )osiz___0);
  bsiz += osiz___0;
  *(buf + bsiz) = (char )'\000';
  *sp = bsiz;
  BZ2_bzCompressEnd(& zs);
  return (buf);
}
}
static char *_tc_bzdecompress_impl(char const   *ptr , int size , int *sp ) 
{ bz_stream zs ;
  int tmp ;
  int asiz ;
  char *buf ;
  void *tmp___0 ;
  char obuf[8192] ;
  int bsiz ;
  int rv ;
  int osiz ;
  char *swap ;
  void *tmp___1 ;
  int osiz___0 ;
  char *swap___0 ;
  void *tmp___2 ;

  {
  zs.bzalloc = (void *(*)(void * , int  , int  ))((void *)0);
  zs.bzfree = (void (*)(void * , void * ))((void *)0);
  zs.opaque = (void *)0;
  tmp = BZ2_bzDecompressInit(& zs, 0, 0);
  if (tmp != 0) {
    return ((char *)((void *)0));
  }
  asiz = size * 2 + 16;
  if (asiz < 8192) {
    asiz = 8192;
  }
  tmp___0 = malloc((unsigned int )asiz);
  buf = (char *)tmp___0;
  if (! buf) {
    BZ2_bzDecompressEnd(& zs);
    return ((char *)((void *)0));
  }
  bsiz = 0;
  zs.next_in = (char *)ptr;
  zs.avail_in = (unsigned int )size;
  zs.next_out = obuf;
  zs.avail_out = 8192U;
  while (1) {
    rv = BZ2_bzDecompress(& zs);
    if (! (rv == 0)) {
      break;
    }
    osiz = (int )(8192U - zs.avail_out);
    if (bsiz + osiz >= asiz) {
      asiz = asiz * 2 + osiz;
      tmp___1 = realloc((void *)buf, (unsigned int )asiz);
      swap = (char *)tmp___1;
      if (! swap) {
        free((void *)buf);
        BZ2_bzDecompressEnd(& zs);
        return ((char *)((void *)0));
      }
      buf = swap;
    }
    memcpy((void * __restrict  )(buf + bsiz), (void const   * __restrict  )(obuf),
           (unsigned int )osiz);
    bsiz += osiz;
    zs.next_out = obuf;
    zs.avail_out = 8192U;
  }
  if (rv != 4) {
    free((void *)buf);
    BZ2_bzDecompressEnd(& zs);
    return ((char *)((void *)0));
  }
  osiz___0 = (int )(8192U - zs.avail_out);
  if (bsiz + osiz___0 >= asiz) {
    asiz = asiz * 2 + osiz___0;
    tmp___2 = realloc((void *)buf, (unsigned int )asiz);
    swap___0 = (char *)tmp___2;
    if (! swap___0) {
      free((void *)buf);
      BZ2_bzDecompressEnd(& zs);
      return ((char *)((void *)0));
    }
    buf = swap___0;
  }
  memcpy((void * __restrict  )(buf + bsiz), (void const   * __restrict  )(obuf), (unsigned int )osiz___0);
  bsiz += osiz___0;
  *(buf + bsiz) = (char )'\000';
  *sp = bsiz;
  BZ2_bzDecompressEnd(& zs);
  return (buf);
}
}
void *_tc_recencode(void const   *ptr , int size , int *sp , void *op ) 
{ char *res ;
  void *tmp ;

  {
  tmp = malloc((unsigned int )(size + 1));
  res = (char *)tmp;
  if (! res) {
    return ((void *)0);
  }
  memcpy((void * __restrict  )res, (void const   * __restrict  )ptr, (unsigned int )size);
  *sp = size;
  return ((void *)res);
}
}
void *_tc_recdecode(void const   *ptr , int size , int *sp , void *op ) 
{ char *res ;
  void *tmp ;

  {
  tmp = malloc((unsigned int )(size + 1));
  res = (char *)tmp;
  if (! res) {
    return ((void *)0);
  }
  memcpy((void * __restrict  )res, (void const   * __restrict  )ptr, (unsigned int )size);
  *sp = size;
  return ((void *)res);
}
}
#pragma merger(0,"/tmp/cil-opPHQTpe.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
static void md5_process(md5_state_t *pms , md5_byte_t const   *data ) ;
static int const   w  =    (int const   )1;
static void md5_process(md5_state_t *pms , md5_byte_t const   *data ) 
{ md5_word_t a ;
  md5_word_t b ;
  md5_word_t c ;
  md5_word_t d ;
  md5_word_t t ;
  md5_word_t xbuf[16] ;
  md5_word_t const   *X ;
  md5_byte_t const   *xp ;
  int i ;

  {
  a = pms->abcd[0];
  b = pms->abcd[1];
  c = pms->abcd[2];
  d = pms->abcd[3];
  if (*((md5_byte_t const   *)(& w))) {
    if (! ((data - (md5_byte_t const   *)0) & 3)) {
      X = (md5_word_t const   *)data;
    } else {
      memcpy((void * __restrict  )(xbuf), (void const   * __restrict  )data, 64U);
      X = (md5_word_t const   *)(xbuf);
    }
  } else {
    xp = data;
    X = (md5_word_t const   *)(xbuf);
    i = 0;
    while (i < 16) {
      xbuf[i] = (unsigned int )((((int const   )*(xp + 0) + ((int const   )*(xp + 1) << 8)) + ((int const   )*(xp + 2) << 16)) + ((int const   )*(xp + 3) << 24));
      i ++;
      xp += 4;
    }
  }
  t = ((a + ((b & c) | (~ b & d))) + (unsigned int )*(X + 0)) + 3614090360U;
  a = ((t << 7) | (t >> 25)) + b;
  t = ((d + ((a & b) | (~ a & c))) + (unsigned int )*(X + 1)) + 3905402710U;
  d = ((t << 12) | (t >> 20)) + a;
  t = ((c + ((d & a) | (~ d & b))) + (unsigned int )*(X + 2)) + 606105819U;
  c = ((t << 17) | (t >> 15)) + d;
  t = ((b + ((c & d) | (~ c & a))) + (unsigned int )*(X + 3)) + 3250441966U;
  b = ((t << 22) | (t >> 10)) + c;
  t = ((a + ((b & c) | (~ b & d))) + (unsigned int )*(X + 4)) + 4118548399U;
  a = ((t << 7) | (t >> 25)) + b;
  t = ((d + ((a & b) | (~ a & c))) + (unsigned int )*(X + 5)) + 1200080426U;
  d = ((t << 12) | (t >> 20)) + a;
  t = ((c + ((d & a) | (~ d & b))) + (unsigned int )*(X + 6)) + 2821735955U;
  c = ((t << 17) | (t >> 15)) + d;
  t = ((b + ((c & d) | (~ c & a))) + (unsigned int )*(X + 7)) + 4249261313U;
  b = ((t << 22) | (t >> 10)) + c;
  t = ((a + ((b & c) | (~ b & d))) + (unsigned int )*(X + 8)) + 1770035416U;
  a = ((t << 7) | (t >> 25)) + b;
  t = ((d + ((a & b) | (~ a & c))) + (unsigned int )*(X + 9)) + 2336552879U;
  d = ((t << 12) | (t >> 20)) + a;
  t = ((c + ((d & a) | (~ d & b))) + (unsigned int )*(X + 10)) + 4294925233U;
  c = ((t << 17) | (t >> 15)) + d;
  t = ((b + ((c & d) | (~ c & a))) + (unsigned int )*(X + 11)) + 2304563134U;
  b = ((t << 22) | (t >> 10)) + c;
  t = ((a + ((b & c) | (~ b & d))) + (unsigned int )*(X + 12)) + 1804603682U;
  a = ((t << 7) | (t >> 25)) + b;
  t = ((d + ((a & b) | (~ a & c))) + (unsigned int )*(X + 13)) + 4254626195U;
  d = ((t << 12) | (t >> 20)) + a;
  t = ((c + ((d & a) | (~ d & b))) + (unsigned int )*(X + 14)) + 2792965006U;
  c = ((t << 17) | (t >> 15)) + d;
  t = ((b + ((c & d) | (~ c & a))) + (unsigned int )*(X + 15)) + 1236535329U;
  b = ((t << 22) | (t >> 10)) + c;
  t = ((a + ((b & d) | (c & ~ d))) + (unsigned int )*(X + 1)) + 4129170786U;
  a = ((t << 5) | (t >> 27)) + b;
  t = ((d + ((a & c) | (b & ~ c))) + (unsigned int )*(X + 6)) + 3225465664U;
  d = ((t << 9) | (t >> 23)) + a;
  t = ((c + ((d & b) | (a & ~ b))) + (unsigned int )*(X + 11)) + 643717713U;
  c = ((t << 14) | (t >> 18)) + d;
  t = ((b + ((c & a) | (d & ~ a))) + (unsigned int )*(X + 0)) + 3921069994U;
  b = ((t << 20) | (t >> 12)) + c;
  t = ((a + ((b & d) | (c & ~ d))) + (unsigned int )*(X + 5)) + 3593408605U;
  a = ((t << 5) | (t >> 27)) + b;
  t = ((d + ((a & c) | (b & ~ c))) + (unsigned int )*(X + 10)) + 38016083U;
  d = ((t << 9) | (t >> 23)) + a;
  t = ((c + ((d & b) | (a & ~ b))) + (unsigned int )*(X + 15)) + 3634488961U;
  c = ((t << 14) | (t >> 18)) + d;
  t = ((b + ((c & a) | (d & ~ a))) + (unsigned int )*(X + 4)) + 3889429448U;
  b = ((t << 20) | (t >> 12)) + c;
  t = ((a + ((b & d) | (c & ~ d))) + (unsigned int )*(X + 9)) + 568446438U;
  a = ((t << 5) | (t >> 27)) + b;
  t = ((d + ((a & c) | (b & ~ c))) + (unsigned int )*(X + 14)) + 3275163606U;
  d = ((t << 9) | (t >> 23)) + a;
  t = ((c + ((d & b) | (a & ~ b))) + (unsigned int )*(X + 3)) + 4107603335U;
  c = ((t << 14) | (t >> 18)) + d;
  t = ((b + ((c & a) | (d & ~ a))) + (unsigned int )*(X + 8)) + 1163531501U;
  b = ((t << 20) | (t >> 12)) + c;
  t = ((a + ((b & d) | (c & ~ d))) + (unsigned int )*(X + 13)) + 2850285829U;
  a = ((t << 5) | (t >> 27)) + b;
  t = ((d + ((a & c) | (b & ~ c))) + (unsigned int )*(X + 2)) + 4243563512U;
  d = ((t << 9) | (t >> 23)) + a;
  t = ((c + ((d & b) | (a & ~ b))) + (unsigned int )*(X + 7)) + 1735328473U;
  c = ((t << 14) | (t >> 18)) + d;
  t = ((b + ((c & a) | (d & ~ a))) + (unsigned int )*(X + 12)) + 2368359562U;
  b = ((t << 20) | (t >> 12)) + c;
  t = ((a + ((b ^ c) ^ d)) + (unsigned int )*(X + 5)) + 4294588738U;
  a = ((t << 4) | (t >> 28)) + b;
  t = ((d + ((a ^ b) ^ c)) + (unsigned int )*(X + 8)) + 2272392833U;
  d = ((t << 11) | (t >> 21)) + a;
  t = ((c + ((d ^ a) ^ b)) + (unsigned int )*(X + 11)) + 1839030562U;
  c = ((t << 16) | (t >> 16)) + d;
  t = ((b + ((c ^ d) ^ a)) + (unsigned int )*(X + 14)) + 4259657740U;
  b = ((t << 23) | (t >> 9)) + c;
  t = ((a + ((b ^ c) ^ d)) + (unsigned int )*(X + 1)) + 2763975236U;
  a = ((t << 4) | (t >> 28)) + b;
  t = ((d + ((a ^ b) ^ c)) + (unsigned int )*(X + 4)) + 1272893353U;
  d = ((t << 11) | (t >> 21)) + a;
  t = ((c + ((d ^ a) ^ b)) + (unsigned int )*(X + 7)) + 4139469664U;
  c = ((t << 16) | (t >> 16)) + d;
  t = ((b + ((c ^ d) ^ a)) + (unsigned int )*(X + 10)) + 3200236656U;
  b = ((t << 23) | (t >> 9)) + c;
  t = ((a + ((b ^ c) ^ d)) + (unsigned int )*(X + 13)) + 681279174U;
  a = ((t << 4) | (t >> 28)) + b;
  t = ((d + ((a ^ b) ^ c)) + (unsigned int )*(X + 0)) + 3936430074U;
  d = ((t << 11) | (t >> 21)) + a;
  t = ((c + ((d ^ a) ^ b)) + (unsigned int )*(X + 3)) + 3572445317U;
  c = ((t << 16) | (t >> 16)) + d;
  t = ((b + ((c ^ d) ^ a)) + (unsigned int )*(X + 6)) + 76029189U;
  b = ((t << 23) | (t >> 9)) + c;
  t = ((a + ((b ^ c) ^ d)) + (unsigned int )*(X + 9)) + 3654602809U;
  a = ((t << 4) | (t >> 28)) + b;
  t = ((d + ((a ^ b) ^ c)) + (unsigned int )*(X + 12)) + 3873151461U;
  d = ((t << 11) | (t >> 21)) + a;
  t = ((c + ((d ^ a) ^ b)) + (unsigned int )*(X + 15)) + 530742520U;
  c = ((t << 16) | (t >> 16)) + d;
  t = ((b + ((c ^ d) ^ a)) + (unsigned int )*(X + 2)) + 3299628645U;
  b = ((t << 23) | (t >> 9)) + c;
  t = ((a + (c ^ (b | ~ d))) + (unsigned int )*(X + 0)) + 4096336452U;
  a = ((t << 6) | (t >> 26)) + b;
  t = ((d + (b ^ (a | ~ c))) + (unsigned int )*(X + 7)) + 1126891415U;
  d = ((t << 10) | (t >> 22)) + a;
  t = ((c + (a ^ (d | ~ b))) + (unsigned int )*(X + 14)) + 2878612391U;
  c = ((t << 15) | (t >> 17)) + d;
  t = ((b + (d ^ (c | ~ a))) + (unsigned int )*(X + 5)) + 4237533241U;
  b = ((t << 21) | (t >> 11)) + c;
  t = ((a + (c ^ (b | ~ d))) + (unsigned int )*(X + 12)) + 1700485571U;
  a = ((t << 6) | (t >> 26)) + b;
  t = ((d + (b ^ (a | ~ c))) + (unsigned int )*(X + 3)) + 2399980690U;
  d = ((t << 10) | (t >> 22)) + a;
  t = ((c + (a ^ (d | ~ b))) + (unsigned int )*(X + 10)) + 4293915773U;
  c = ((t << 15) | (t >> 17)) + d;
  t = ((b + (d ^ (c | ~ a))) + (unsigned int )*(X + 1)) + 2240044497U;
  b = ((t << 21) | (t >> 11)) + c;
  t = ((a + (c ^ (b | ~ d))) + (unsigned int )*(X + 8)) + 1873313359U;
  a = ((t << 6) | (t >> 26)) + b;
  t = ((d + (b ^ (a | ~ c))) + (unsigned int )*(X + 15)) + 4264355552U;
  d = ((t << 10) | (t >> 22)) + a;
  t = ((c + (a ^ (d | ~ b))) + (unsigned int )*(X + 6)) + 2734768916U;
  c = ((t << 15) | (t >> 17)) + d;
  t = ((b + (d ^ (c | ~ a))) + (unsigned int )*(X + 13)) + 1309151649U;
  b = ((t << 21) | (t >> 11)) + c;
  t = ((a + (c ^ (b | ~ d))) + (unsigned int )*(X + 4)) + 4149444226U;
  a = ((t << 6) | (t >> 26)) + b;
  t = ((d + (b ^ (a | ~ c))) + (unsigned int )*(X + 11)) + 3174756917U;
  d = ((t << 10) | (t >> 22)) + a;
  t = ((c + (a ^ (d | ~ b))) + (unsigned int )*(X + 2)) + 718787259U;
  c = ((t << 15) | (t >> 17)) + d;
  t = ((b + (d ^ (c | ~ a))) + (unsigned int )*(X + 9)) + 3951481745U;
  b = ((t << 21) | (t >> 11)) + c;
  pms->abcd[0] += a;
  pms->abcd[1] += b;
  pms->abcd[2] += c;
  pms->abcd[3] += d;
  return;
}
}
void _tc_md5_init(md5_state_t *pms ) 
{ md5_word_t tmp ;

  {
  tmp = 0U;
  pms->count[1] = tmp;
  pms->count[0] = tmp;
  pms->abcd[0] = 1732584193U;
  pms->abcd[1] = 4023233417U;
  pms->abcd[2] = 2562383102U;
  pms->abcd[3] = 271733878U;
  return;
}
}
void _tc_md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) 
{ md5_byte_t const   *p ;
  int left ;
  int offset ;
  md5_word_t nbits ;
  int copy ;
  int tmp ;

  {
  p = data;
  left = nbytes;
  offset = (int )((pms->count[0] >> 3) & 63U);
  nbits = (unsigned int )(nbytes << 3);
  if (nbytes <= 0) {
    return;
  }
  pms->count[1] += (unsigned int )(nbytes >> 29);
  pms->count[0] += nbits;
  if (pms->count[0] < nbits) {
    (pms->count[1]) ++;
  }
  if (offset) {
    if (offset + nbytes > 64) {
      tmp = 64 - offset;
    } else {
      tmp = nbytes;
    }
    copy = tmp;
    memcpy((void * __restrict  )(pms->buf + offset), (void const   * __restrict  )p,
           (unsigned int )copy);
    if (offset + copy < 64) {
      return;
    }
    p += copy;
    left -= copy;
    md5_process(pms, (md5_byte_t const   *)(pms->buf));
  }
  while (left >= 64) {
    md5_process(pms, p);
    p += 64;
    left -= 64;
  }
  if (left) {
    memcpy((void * __restrict  )(pms->buf), (void const   * __restrict  )p, (unsigned int )left);
  }
  return;
}
}
static md5_byte_t const   pad[64]  = 
  {      (unsigned char const   )128,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0, 
        (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0,      (unsigned char const   )0};
void _tc_md5_finish(md5_state_t *pms , md5_byte_t *digest ) 
{ md5_byte_t data[8] ;
  int i ;

  {
  i = 0;
  while (i < 8) {
    data[i] = (unsigned char )(pms->count[i >> 2] >> ((i & 3) << 3));
    i ++;
  }
  _tc_md5_append(pms, pad, (int )(((55U - (pms->count[0] >> 3)) & 63U) + 1U));
  _tc_md5_append(pms, (md5_byte_t const   *)(data), 8);
  i = 0;
  while (i < 16) {
    *(digest + i) = (unsigned char )(pms->abcd[i >> 2] >> ((i & 3) << 3));
    i ++;
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-t7gNdSli.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
extern int printf(char const   * __restrict  __format  , ...) ;
__inline extern int getc_unlocked(FILE *__fp ) ;
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
extern void ( __attribute__((__regparm__(1))) __pthread_register_cancel)(__pthread_unwind_buf_t *__buf ) ;
extern void ( __attribute__((__regparm__(1))) __pthread_unregister_cancel)(__pthread_unwind_buf_t *__buf ) ;
extern  __attribute__((__noreturn__)) void ( __attribute__((__regparm__(1))) __pthread_unwind_next)(__pthread_unwind_buf_t *__buf )  __attribute__((__weak__)) ;
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
char const   *ttversion ;
void ttsocksetlife(TTSOCK *sock , double lifetime ) ;
_Bool ttsocksend(TTSOCK *sock , void const   *buf , int size ) ;
_Bool ttsockprintf(TTSOCK *sock , char const   *format  , ...) ;
_Bool ttsockrecv(TTSOCK *sock , char *buf , int size ) ;
int ttsockgetc(TTSOCK *sock ) ;
void ttsockungetc(TTSOCK *sock , int c ) ;
_Bool ttsockgets(TTSOCK *sock , char *buf , int size ) ;
char *ttsockgets2(TTSOCK *sock ) ;
uint32_t ttsockgetint32(TTSOCK *sock ) ;
uint64_t ttsockgetint64(TTSOCK *sock ) ;
_Bool ttsockcheckend(TTSOCK *sock ) ;
void ttpackdouble(double num , char *buf ) ;
double ttunpackdouble(char const   *buf ) ;
TTSERV *ttservnew(void) ;
void ttservdel(TTSERV *serv ) ;
_Bool ttservconf(TTSERV *serv , char const   *host , int port ) ;
void ttservtune(TTSERV *serv , int thnum , double timeout ) ;
void ttservsetloghandler(TTSERV *serv , void (*do_log___0)(int  , char const   * ,
                                                           void * ) , void *opq ) ;
void ttservaddtimedhandler(TTSERV *serv , double freq , void (*do_timed)(void * ) ,
                           void *opq ) ;
void ttservsettaskhandler(TTSERV *serv , void (*do_task___0)(TTSOCK * , void * , TTREQ * ) ,
                          void *opq ) ;
void ttservsettermhandler(TTSERV *serv , void (*do_term___0)(void * ) , void *opq ) ;
_Bool ttservstart(TTSERV *serv ) ;
_Bool ttservkill(TTSERV *serv ) ;
void ttservlog(TTSERV *serv , int level , char const   *format  , ...) ;
_Bool ttserviskilled(TTSERV *serv ) ;
_Bool ttdaemonize(void) ;
double ttgetloadavg(void) ;
TCULOG *tculognew(void) ;
void tculogdel(TCULOG *ulog ) ;
_Bool tculogsetaio(TCULOG *ulog ) ;
_Bool tculogopen(TCULOG *ulog , char const   *base , uint64_t limsiz ) ;
_Bool tculogclose(TCULOG *ulog ) ;
TCULRD *tculrdnew(TCULOG *ulog , uint64_t ts ) ;
void tculrddel(TCULRD *ulrd ) ;
void tculrdwait(TCULRD *ulrd ) ;
void const   *tculrdread(TCULRD *ulrd , int *sp , uint64_t *tsp , uint32_t *sidp ,
                         uint32_t *midp ) ;
_Bool tculogadbput(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , void const   *kbuf ,
                   int ksiz , void const   *vbuf , int vsiz ) ;
_Bool tculogadbputkeep(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , void const   *kbuf ,
                       int ksiz , void const   *vbuf , int vsiz ) ;
_Bool tculogadbputcat(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , void const   *kbuf ,
                      int ksiz , void const   *vbuf , int vsiz ) ;
_Bool tculogadbout(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , void const   *kbuf ,
                   int ksiz ) ;
int tculogadbaddint(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , void const   *kbuf ,
                    int ksiz , int num ) ;
double tculogadbadddouble(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb ,
                          void const   *kbuf , int ksiz , double num ) ;
_Bool tculogadbsync(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb ) ;
_Bool tculogadboptimize(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb ,
                        char const   *params ) ;
_Bool tculogadbvanish(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb ) ;
TCLIST *tculogadbmisc(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , char const   *name ,
                      TCLIST const   *args ) ;
_Bool tculogadbrestore(TCADB *adb , char const   *path , uint64_t ts , _Bool con ,
                       TCULOG *ulog ) ;
_Bool tculogadbredo(TCADB *adb , char const   *ptr , int size , TCULOG *ulog , uint32_t sid ,
                    uint32_t mid , _Bool *cp ) ;
TCREPL *tcreplnew(void) ;
void tcrepldel(TCREPL *repl ) ;
_Bool tcreplopen(TCREPL *repl , char const   *host , int port , uint64_t ts , uint32_t sid ) ;
_Bool tcreplclose(TCREPL *repl ) ;
char const   *tcreplread(TCREPL *repl , int *sp , uint64_t *tsp , uint32_t *sidp ) ;
extern  __attribute__((__nothrow__)) __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern  __attribute__((__nothrow__)) int kill(__pid_t __pid , int __sig ) ;
extern  __attribute__((__nothrow__)) int chdir(char const   *__path )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int getrusage(__rusage_who_t __who , struct rusage *__usage ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg ) ;
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr ,
                                                                            struct cmsghdr *__cmsg ) ;
__inline extern struct cmsghdr *__cmsg_nxthdr(struct msghdr *__mhdr , struct cmsghdr *__cmsg ) 
{ 

  {
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
    return ((struct cmsghdr *)0);
  }
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U)));
  if ((unsigned int )((unsigned char *)(__cmsg + 1)) > (unsigned int )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
    return ((struct cmsghdr *)0);
  } else {
    if ((unsigned int )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1U) & ~ (sizeof(size_t ) - 1U))) > (unsigned int )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
      return ((struct cmsghdr *)0);
    }
  }
  return (__cmsg);
}
}
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
extern  __attribute__((__nothrow__)) int dlclose(void *__handle )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) void *dlsym(void * __restrict  __handle , char const   * __restrict  __name )  __attribute__((__nonnull__(2))) ;
extern  __attribute__((__nothrow__)) char *dlerror(void) ;
void *scrextnew(void **screxts , int thnum , int thid , char const   *path , TCADB *adb ,
                TCULOG *ulog , uint32_t sid , TCMDB *stash , TCMDB *lock , void (*logger)(int  ,
                                                                                          char const   * ,
                                                                                          void * ) ,
                void *logopq ) ;
_Bool scrextdel(void *scr ) ;
char *scrextcallmethod(void *scr , char const   *name , void const   *kbuf , int ksiz ,
                       void const   *vbuf , int vsiz , int *sp ) ;
_Bool scrextkill(void *scr ) ;
char const   *g_progname  =    (char const   *)((void *)0);
double g_starttime  =    0.0;
TTSERV *g_serv  =    (TTSERV *)((void *)0);
int g_loglevel  =    1;
_Bool g_restart  =    (_Bool)0;
int main(int argc , char **argv ) ;
static void usage(void) ;
static uint64_t getcmdmask(char const   *expr ) ;
static void sigtermhandler(int signum ) ;
static void sigchldhandler(int signum ) ;
static int proc(char const   *dbname , char const   *host , int port , int thnum ,
                int tout , _Bool dmn , char const   *pidpath , _Bool kl , char const   *logpath ,
                char const   *ulogpath , uint64_t ulim , _Bool uas , uint32_t sid ,
                char const   *mhost , int mport , char const   *rtspath , int ropts ,
                char const   *skelpath , char const   *extpath , TCLIST const   *extpcs ,
                uint64_t mask___0 ) ;
static void do_log(int level , char const   *msg , void *opq ) ;
static void do_slave(void *opq ) ;
static void do_extpc(void *opq ) ;
static void do_task(TTSOCK *sock , void *opq , TTREQ *req ) ;
static char **tokenize(char *str , int *np ) ;
static uint32_t recmtxidx(char const   *kbuf , int ksiz ) ;
static void do_put(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_putkeep(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_putcat(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_putshl(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_putnr(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_out(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_get(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_mget(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_vsiz(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_iterinit(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_iternext(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_fwmkeys(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_addint(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_adddouble(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_ext(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_sync(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_optimize(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_vanish(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_copy(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_restore(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_setmst(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_rnum(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_size(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_stat(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_misc(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_repl(TTSOCK *sock , TASKARG *arg , TTREQ *req ) ;
static void do_mc_set(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens , int tnum ) ;
static void do_mc_add(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens , int tnum ) ;
static void do_mc_replace(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                          int tnum ) ;
static void do_mc_get(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens , int tnum ) ;
static void do_mc_delete(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                         int tnum ) ;
static void do_mc_incr(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                       int tnum ) ;
static void do_mc_decr(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                       int tnum ) ;
static void do_mc_stats(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                        int tnum ) ;
static void do_mc_flushall(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                           int tnum ) ;
static void do_mc_version(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                          int tnum ) ;
static void do_mc_quit(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                       int tnum ) ;
static void do_http_get(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) ;
static void do_http_head(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) ;
static void do_http_put(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) ;
static void do_http_post(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) ;
static void do_http_delete(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) ;
static void do_http_options(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) ;
static void do_term(void *opq ) ;
int main(int argc , char **argv ) 
{ char *dbname ;
  char *host ;
  char *pidpath ;
  char *logpath ;
  char *ulogpath ;
  char *mhost ;
  char *rtspath ;
  char *skelpath ;
  char *extpath ;
  TCLIST *extpcs ;
  int port ;
  int thnum ;
  int tout ;
  _Bool dmn ;
  _Bool kl ;
  uint64_t ulim ;
  _Bool uas ;
  uint32_t sid ;
  int mport ;
  int ropts ;
  uint64_t mask___0 ;
  int i ;
  int64_t tmp ;
  int64_t tmp___0 ;
  int64_t tmp___1 ;
  int64_t tmp___2 ;
  int64_t tmp___3 ;
  int64_t tmp___4 ;
  uint64_t tmp___5 ;
  uint64_t tmp___6 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___36 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___43 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___50 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___57 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___71 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___78 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___85 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___92 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___99 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___106 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___113 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___120 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  size_t __s1_len___16 ;
  size_t __s2_len___16 ;
  int tmp___127 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  size_t __s1_len___17 ;
  size_t __s2_len___17 ;
  int tmp___134 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  size_t __s1_len___18 ;
  size_t __s2_len___18 ;
  int tmp___141 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  size_t __s1_len___19 ;
  size_t __s2_len___19 ;
  int tmp___148 ;
  int tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;
  size_t __s1_len___20 ;
  size_t __s2_len___20 ;
  int tmp___155 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  size_t __s1_len___21 ;
  size_t __s2_len___21 ;
  int tmp___162 ;
  int tmp___165 ;
  int tmp___166 ;
  int tmp___167 ;
  size_t __s1_len___22 ;
  size_t __s2_len___22 ;
  int tmp___169 ;
  int tmp___172 ;
  int tmp___173 ;
  int tmp___174 ;
  int rv ;
  int tmp___175 ;

  {
  g_progname = (char const   *)*(argv + 0);
  g_starttime = tctime();
  dbname = (char *)((void *)0);
  host = (char *)((void *)0);
  pidpath = (char *)((void *)0);
  logpath = (char *)((void *)0);
  ulogpath = (char *)((void *)0);
  mhost = (char *)((void *)0);
  rtspath = (char *)((void *)0);
  skelpath = (char *)((void *)0);
  extpath = (char *)((void *)0);
  extpcs = (TCLIST *)((void *)0);
  port = 1978;
  thnum = 8;
  tout = 0;
  dmn = (_Bool)0;
  kl = (_Bool)0;
  ulim = (uint64_t )(1LL << 30);
  uas = (_Bool)0;
  sid = (uint32_t )0;
  mport = 1978;
  ropts = 0;
  mask___0 = (uint64_t )0;
  i = 1;
  while (i < argc) {
    if (! dbname) {
      if ((int )*(*(argv + i) + 0) == 45) {
        if (0) {
          __s1_len___22 = strlen((char const   *)*(argv + i));
          __s2_len___22 = strlen("-host");
          if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
            goto _L___46;
          } else {
            if (__s1_len___22 >= 4U) {
              _L___46: /* CIL Label */ 
              if (! ((unsigned int )((void const   *)("-host" + 1)) - (unsigned int )((void const   *)"-host") == 1U)) {
                tmp___174 = 1;
              } else {
                if (__s2_len___22 >= 4U) {
                  tmp___174 = 1;
                } else {
                  tmp___174 = 0;
                }
              }
            } else {
              tmp___174 = 0;
            }
          }
          if (tmp___174) {
            tmp___169 = __builtin_strcmp((char const   *)*(argv + i), "-host");
            tmp___173 = tmp___169;
          } else {
            tmp___172 = __builtin_strcmp((char const   *)*(argv + i), "-host");
            tmp___173 = tmp___172;
          }
        } else {
          tmp___172 = __builtin_strcmp((char const   *)*(argv + i), "-host");
          tmp___173 = tmp___172;
        }
        if (tmp___173) {
          if (0) {
            __s1_len___21 = strlen((char const   *)*(argv + i));
            __s2_len___21 = strlen("-port");
            if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
              goto _L___44;
            } else {
              if (__s1_len___21 >= 4U) {
                _L___44: /* CIL Label */ 
                if (! ((unsigned int )((void const   *)("-port" + 1)) - (unsigned int )((void const   *)"-port") == 1U)) {
                  tmp___167 = 1;
                } else {
                  if (__s2_len___21 >= 4U) {
                    tmp___167 = 1;
                  } else {
                    tmp___167 = 0;
                  }
                }
              } else {
                tmp___167 = 0;
              }
            }
            if (tmp___167) {
              tmp___162 = __builtin_strcmp((char const   *)*(argv + i), "-port");
              tmp___166 = tmp___162;
            } else {
              tmp___165 = __builtin_strcmp((char const   *)*(argv + i), "-port");
              tmp___166 = tmp___165;
            }
          } else {
            tmp___165 = __builtin_strcmp((char const   *)*(argv + i), "-port");
            tmp___166 = tmp___165;
          }
          if (tmp___166) {
            if (0) {
              __s1_len___20 = strlen((char const   *)*(argv + i));
              __s2_len___20 = strlen("-thnum");
              if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                goto _L___42;
              } else {
                if (__s1_len___20 >= 4U) {
                  _L___42: /* CIL Label */ 
                  if (! ((unsigned int )((void const   *)("-thnum" + 1)) - (unsigned int )((void const   *)"-thnum") == 1U)) {
                    tmp___160 = 1;
                  } else {
                    if (__s2_len___20 >= 4U) {
                      tmp___160 = 1;
                    } else {
                      tmp___160 = 0;
                    }
                  }
                } else {
                  tmp___160 = 0;
                }
              }
              if (tmp___160) {
                tmp___155 = __builtin_strcmp((char const   *)*(argv + i), "-thnum");
                tmp___159 = tmp___155;
              } else {
                tmp___158 = __builtin_strcmp((char const   *)*(argv + i), "-thnum");
                tmp___159 = tmp___158;
              }
            } else {
              tmp___158 = __builtin_strcmp((char const   *)*(argv + i), "-thnum");
              tmp___159 = tmp___158;
            }
            if (tmp___159) {
              if (0) {
                __s1_len___19 = strlen((char const   *)*(argv + i));
                __s2_len___19 = strlen("-tout");
                if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                  goto _L___40;
                } else {
                  if (__s1_len___19 >= 4U) {
                    _L___40: /* CIL Label */ 
                    if (! ((unsigned int )((void const   *)("-tout" + 1)) - (unsigned int )((void const   *)"-tout") == 1U)) {
                      tmp___153 = 1;
                    } else {
                      if (__s2_len___19 >= 4U) {
                        tmp___153 = 1;
                      } else {
                        tmp___153 = 0;
                      }
                    }
                  } else {
                    tmp___153 = 0;
                  }
                }
                if (tmp___153) {
                  tmp___148 = __builtin_strcmp((char const   *)*(argv + i), "-tout");
                  tmp___152 = tmp___148;
                } else {
                  tmp___151 = __builtin_strcmp((char const   *)*(argv + i), "-tout");
                  tmp___152 = tmp___151;
                }
              } else {
                tmp___151 = __builtin_strcmp((char const   *)*(argv + i), "-tout");
                tmp___152 = tmp___151;
              }
              if (tmp___152) {
                if (0) {
                  __s1_len___18 = strlen((char const   *)*(argv + i));
                  __s2_len___18 = strlen("-dmn");
                  if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                    goto _L___38;
                  } else {
                    if (__s1_len___18 >= 4U) {
                      _L___38: /* CIL Label */ 
                      if (! ((unsigned int )((void const   *)("-dmn" + 1)) - (unsigned int )((void const   *)"-dmn") == 1U)) {
                        tmp___146 = 1;
                      } else {
                        if (__s2_len___18 >= 4U) {
                          tmp___146 = 1;
                        } else {
                          tmp___146 = 0;
                        }
                      }
                    } else {
                      tmp___146 = 0;
                    }
                  }
                  if (tmp___146) {
                    tmp___141 = __builtin_strcmp((char const   *)*(argv + i), "-dmn");
                    tmp___145 = tmp___141;
                  } else {
                    tmp___144 = __builtin_strcmp((char const   *)*(argv + i), "-dmn");
                    tmp___145 = tmp___144;
                  }
                } else {
                  tmp___144 = __builtin_strcmp((char const   *)*(argv + i), "-dmn");
                  tmp___145 = tmp___144;
                }
                if (tmp___145) {
                  if (0) {
                    __s1_len___17 = strlen((char const   *)*(argv + i));
                    __s2_len___17 = strlen("-pid");
                    if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                      goto _L___36;
                    } else {
                      if (__s1_len___17 >= 4U) {
                        _L___36: /* CIL Label */ 
                        if (! ((unsigned int )((void const   *)("-pid" + 1)) - (unsigned int )((void const   *)"-pid") == 1U)) {
                          tmp___139 = 1;
                        } else {
                          if (__s2_len___17 >= 4U) {
                            tmp___139 = 1;
                          } else {
                            tmp___139 = 0;
                          }
                        }
                      } else {
                        tmp___139 = 0;
                      }
                    }
                    if (tmp___139) {
                      tmp___134 = __builtin_strcmp((char const   *)*(argv + i), "-pid");
                      tmp___138 = tmp___134;
                    } else {
                      tmp___137 = __builtin_strcmp((char const   *)*(argv + i), "-pid");
                      tmp___138 = tmp___137;
                    }
                  } else {
                    tmp___137 = __builtin_strcmp((char const   *)*(argv + i), "-pid");
                    tmp___138 = tmp___137;
                  }
                  if (tmp___138) {
                    if (0) {
                      __s1_len___16 = strlen((char const   *)*(argv + i));
                      __s2_len___16 = strlen("-kl");
                      if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                        goto _L___34;
                      } else {
                        if (__s1_len___16 >= 4U) {
                          _L___34: /* CIL Label */ 
                          if (! ((unsigned int )((void const   *)("-kl" + 1)) - (unsigned int )((void const   *)"-kl") == 1U)) {
                            tmp___132 = 1;
                          } else {
                            if (__s2_len___16 >= 4U) {
                              tmp___132 = 1;
                            } else {
                              tmp___132 = 0;
                            }
                          }
                        } else {
                          tmp___132 = 0;
                        }
                      }
                      if (tmp___132) {
                        tmp___127 = __builtin_strcmp((char const   *)*(argv + i),
                                                     "-kl");
                        tmp___131 = tmp___127;
                      } else {
                        tmp___130 = __builtin_strcmp((char const   *)*(argv + i),
                                                     "-kl");
                        tmp___131 = tmp___130;
                      }
                    } else {
                      tmp___130 = __builtin_strcmp((char const   *)*(argv + i), "-kl");
                      tmp___131 = tmp___130;
                    }
                    if (tmp___131) {
                      if (0) {
                        __s1_len___15 = strlen((char const   *)*(argv + i));
                        __s2_len___15 = strlen("-log");
                        if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                          goto _L___32;
                        } else {
                          if (__s1_len___15 >= 4U) {
                            _L___32: /* CIL Label */ 
                            if (! ((unsigned int )((void const   *)("-log" + 1)) - (unsigned int )((void const   *)"-log") == 1U)) {
                              tmp___125 = 1;
                            } else {
                              if (__s2_len___15 >= 4U) {
                                tmp___125 = 1;
                              } else {
                                tmp___125 = 0;
                              }
                            }
                          } else {
                            tmp___125 = 0;
                          }
                        }
                        if (tmp___125) {
                          tmp___120 = __builtin_strcmp((char const   *)*(argv + i),
                                                       "-log");
                          tmp___124 = tmp___120;
                        } else {
                          tmp___123 = __builtin_strcmp((char const   *)*(argv + i),
                                                       "-log");
                          tmp___124 = tmp___123;
                        }
                      } else {
                        tmp___123 = __builtin_strcmp((char const   *)*(argv + i),
                                                     "-log");
                        tmp___124 = tmp___123;
                      }
                      if (tmp___124) {
                        if (0) {
                          __s1_len___14 = strlen((char const   *)*(argv + i));
                          __s2_len___14 = strlen("-ld");
                          if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                            goto _L___30;
                          } else {
                            if (__s1_len___14 >= 4U) {
                              _L___30: /* CIL Label */ 
                              if (! ((unsigned int )((void const   *)("-ld" + 1)) - (unsigned int )((void const   *)"-ld") == 1U)) {
                                tmp___118 = 1;
                              } else {
                                if (__s2_len___14 >= 4U) {
                                  tmp___118 = 1;
                                } else {
                                  tmp___118 = 0;
                                }
                              }
                            } else {
                              tmp___118 = 0;
                            }
                          }
                          if (tmp___118) {
                            tmp___113 = __builtin_strcmp((char const   *)*(argv + i),
                                                         "-ld");
                            tmp___117 = tmp___113;
                          } else {
                            tmp___116 = __builtin_strcmp((char const   *)*(argv + i),
                                                         "-ld");
                            tmp___117 = tmp___116;
                          }
                        } else {
                          tmp___116 = __builtin_strcmp((char const   *)*(argv + i),
                                                       "-ld");
                          tmp___117 = tmp___116;
                        }
                        if (tmp___117) {
                          if (0) {
                            __s1_len___13 = strlen((char const   *)*(argv + i));
                            __s2_len___13 = strlen("-le");
                            if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                              goto _L___28;
                            } else {
                              if (__s1_len___13 >= 4U) {
                                _L___28: /* CIL Label */ 
                                if (! ((unsigned int )((void const   *)("-le" + 1)) - (unsigned int )((void const   *)"-le") == 1U)) {
                                  tmp___111 = 1;
                                } else {
                                  if (__s2_len___13 >= 4U) {
                                    tmp___111 = 1;
                                  } else {
                                    tmp___111 = 0;
                                  }
                                }
                              } else {
                                tmp___111 = 0;
                              }
                            }
                            if (tmp___111) {
                              tmp___106 = __builtin_strcmp((char const   *)*(argv + i),
                                                           "-le");
                              tmp___110 = tmp___106;
                            } else {
                              tmp___109 = __builtin_strcmp((char const   *)*(argv + i),
                                                           "-le");
                              tmp___110 = tmp___109;
                            }
                          } else {
                            tmp___109 = __builtin_strcmp((char const   *)*(argv + i),
                                                         "-le");
                            tmp___110 = tmp___109;
                          }
                          if (tmp___110) {
                            if (0) {
                              __s1_len___12 = strlen((char const   *)*(argv + i));
                              __s2_len___12 = strlen("-ulog");
                              if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                goto _L___26;
                              } else {
                                if (__s1_len___12 >= 4U) {
                                  _L___26: /* CIL Label */ 
                                  if (! ((unsigned int )((void const   *)("-ulog" + 1)) - (unsigned int )((void const   *)"-ulog") == 1U)) {
                                    tmp___104 = 1;
                                  } else {
                                    if (__s2_len___12 >= 4U) {
                                      tmp___104 = 1;
                                    } else {
                                      tmp___104 = 0;
                                    }
                                  }
                                } else {
                                  tmp___104 = 0;
                                }
                              }
                              if (tmp___104) {
                                tmp___99 = __builtin_strcmp((char const   *)*(argv + i),
                                                            "-ulog");
                                tmp___103 = tmp___99;
                              } else {
                                tmp___102 = __builtin_strcmp((char const   *)*(argv + i),
                                                             "-ulog");
                                tmp___103 = tmp___102;
                              }
                            } else {
                              tmp___102 = __builtin_strcmp((char const   *)*(argv + i),
                                                           "-ulog");
                              tmp___103 = tmp___102;
                            }
                            if (tmp___103) {
                              if (0) {
                                __s1_len___11 = strlen((char const   *)*(argv + i));
                                __s2_len___11 = strlen("-ulim");
                                if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                  goto _L___24;
                                } else {
                                  if (__s1_len___11 >= 4U) {
                                    _L___24: /* CIL Label */ 
                                    if (! ((unsigned int )((void const   *)("-ulim" + 1)) - (unsigned int )((void const   *)"-ulim") == 1U)) {
                                      tmp___97 = 1;
                                    } else {
                                      if (__s2_len___11 >= 4U) {
                                        tmp___97 = 1;
                                      } else {
                                        tmp___97 = 0;
                                      }
                                    }
                                  } else {
                                    tmp___97 = 0;
                                  }
                                }
                                if (tmp___97) {
                                  tmp___92 = __builtin_strcmp((char const   *)*(argv + i),
                                                              "-ulim");
                                  tmp___96 = tmp___92;
                                } else {
                                  tmp___95 = __builtin_strcmp((char const   *)*(argv + i),
                                                              "-ulim");
                                  tmp___96 = tmp___95;
                                }
                              } else {
                                tmp___95 = __builtin_strcmp((char const   *)*(argv + i),
                                                            "-ulim");
                                tmp___96 = tmp___95;
                              }
                              if (tmp___96) {
                                if (0) {
                                  __s1_len___10 = strlen((char const   *)*(argv + i));
                                  __s2_len___10 = strlen("-uas");
                                  if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                    goto _L___22;
                                  } else {
                                    if (__s1_len___10 >= 4U) {
                                      _L___22: /* CIL Label */ 
                                      if (! ((unsigned int )((void const   *)("-uas" + 1)) - (unsigned int )((void const   *)"-uas") == 1U)) {
                                        tmp___90 = 1;
                                      } else {
                                        if (__s2_len___10 >= 4U) {
                                          tmp___90 = 1;
                                        } else {
                                          tmp___90 = 0;
                                        }
                                      }
                                    } else {
                                      tmp___90 = 0;
                                    }
                                  }
                                  if (tmp___90) {
                                    tmp___85 = __builtin_strcmp((char const   *)*(argv + i),
                                                                "-uas");
                                    tmp___89 = tmp___85;
                                  } else {
                                    tmp___88 = __builtin_strcmp((char const   *)*(argv + i),
                                                                "-uas");
                                    tmp___89 = tmp___88;
                                  }
                                } else {
                                  tmp___88 = __builtin_strcmp((char const   *)*(argv + i),
                                                              "-uas");
                                  tmp___89 = tmp___88;
                                }
                                if (tmp___89) {
                                  if (0) {
                                    __s1_len___9 = strlen((char const   *)*(argv + i));
                                    __s2_len___9 = strlen("-sid");
                                    if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                      goto _L___20;
                                    } else {
                                      if (__s1_len___9 >= 4U) {
                                        _L___20: /* CIL Label */ 
                                        if (! ((unsigned int )((void const   *)("-sid" + 1)) - (unsigned int )((void const   *)"-sid") == 1U)) {
                                          tmp___83 = 1;
                                        } else {
                                          if (__s2_len___9 >= 4U) {
                                            tmp___83 = 1;
                                          } else {
                                            tmp___83 = 0;
                                          }
                                        }
                                      } else {
                                        tmp___83 = 0;
                                      }
                                    }
                                    if (tmp___83) {
                                      tmp___78 = __builtin_strcmp((char const   *)*(argv + i),
                                                                  "-sid");
                                      tmp___82 = tmp___78;
                                    } else {
                                      tmp___81 = __builtin_strcmp((char const   *)*(argv + i),
                                                                  "-sid");
                                      tmp___82 = tmp___81;
                                    }
                                  } else {
                                    tmp___81 = __builtin_strcmp((char const   *)*(argv + i),
                                                                "-sid");
                                    tmp___82 = tmp___81;
                                  }
                                  if (tmp___82) {
                                    if (0) {
                                      __s1_len___8 = strlen((char const   *)*(argv + i));
                                      __s2_len___8 = strlen("-mhost");
                                      if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                        goto _L___18;
                                      } else {
                                        if (__s1_len___8 >= 4U) {
                                          _L___18: /* CIL Label */ 
                                          if (! ((unsigned int )((void const   *)("-mhost" + 1)) - (unsigned int )((void const   *)"-mhost") == 1U)) {
                                            tmp___76 = 1;
                                          } else {
                                            if (__s2_len___8 >= 4U) {
                                              tmp___76 = 1;
                                            } else {
                                              tmp___76 = 0;
                                            }
                                          }
                                        } else {
                                          tmp___76 = 0;
                                        }
                                      }
                                      if (tmp___76) {
                                        tmp___71 = __builtin_strcmp((char const   *)*(argv + i),
                                                                    "-mhost");
                                        tmp___75 = tmp___71;
                                      } else {
                                        tmp___74 = __builtin_strcmp((char const   *)*(argv + i),
                                                                    "-mhost");
                                        tmp___75 = tmp___74;
                                      }
                                    } else {
                                      tmp___74 = __builtin_strcmp((char const   *)*(argv + i),
                                                                  "-mhost");
                                      tmp___75 = tmp___74;
                                    }
                                    if (tmp___75) {
                                      if (0) {
                                        __s1_len___7 = strlen((char const   *)*(argv + i));
                                        __s2_len___7 = strlen("-mport");
                                        if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                          goto _L___16;
                                        } else {
                                          if (__s1_len___7 >= 4U) {
                                            _L___16: /* CIL Label */ 
                                            if (! ((unsigned int )((void const   *)("-mport" + 1)) - (unsigned int )((void const   *)"-mport") == 1U)) {
                                              tmp___69 = 1;
                                            } else {
                                              if (__s2_len___7 >= 4U) {
                                                tmp___69 = 1;
                                              } else {
                                                tmp___69 = 0;
                                              }
                                            }
                                          } else {
                                            tmp___69 = 0;
                                          }
                                        }
                                        if (tmp___69) {
                                          tmp___64 = __builtin_strcmp((char const   *)*(argv + i),
                                                                      "-mport");
                                          tmp___68 = tmp___64;
                                        } else {
                                          tmp___67 = __builtin_strcmp((char const   *)*(argv + i),
                                                                      "-mport");
                                          tmp___68 = tmp___67;
                                        }
                                      } else {
                                        tmp___67 = __builtin_strcmp((char const   *)*(argv + i),
                                                                    "-mport");
                                        tmp___68 = tmp___67;
                                      }
                                      if (tmp___68) {
                                        if (0) {
                                          __s1_len___6 = strlen((char const   *)*(argv + i));
                                          __s2_len___6 = strlen("-rts");
                                          if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                            goto _L___14;
                                          } else {
                                            if (__s1_len___6 >= 4U) {
                                              _L___14: /* CIL Label */ 
                                              if (! ((unsigned int )((void const   *)("-rts" + 1)) - (unsigned int )((void const   *)"-rts") == 1U)) {
                                                tmp___62 = 1;
                                              } else {
                                                if (__s2_len___6 >= 4U) {
                                                  tmp___62 = 1;
                                                } else {
                                                  tmp___62 = 0;
                                                }
                                              }
                                            } else {
                                              tmp___62 = 0;
                                            }
                                          }
                                          if (tmp___62) {
                                            tmp___57 = __builtin_strcmp((char const   *)*(argv + i),
                                                                        "-rts");
                                            tmp___61 = tmp___57;
                                          } else {
                                            tmp___60 = __builtin_strcmp((char const   *)*(argv + i),
                                                                        "-rts");
                                            tmp___61 = tmp___60;
                                          }
                                        } else {
                                          tmp___60 = __builtin_strcmp((char const   *)*(argv + i),
                                                                      "-rts");
                                          tmp___61 = tmp___60;
                                        }
                                        if (tmp___61) {
                                          if (0) {
                                            __s1_len___5 = strlen((char const   *)*(argv + i));
                                            __s2_len___5 = strlen("-rcc");
                                            if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                              goto _L___12;
                                            } else {
                                              if (__s1_len___5 >= 4U) {
                                                _L___12: /* CIL Label */ 
                                                if (! ((unsigned int )((void const   *)("-rcc" + 1)) - (unsigned int )((void const   *)"-rcc") == 1U)) {
                                                  tmp___55 = 1;
                                                } else {
                                                  if (__s2_len___5 >= 4U) {
                                                    tmp___55 = 1;
                                                  } else {
                                                    tmp___55 = 0;
                                                  }
                                                }
                                              } else {
                                                tmp___55 = 0;
                                              }
                                            }
                                            if (tmp___55) {
                                              tmp___50 = __builtin_strcmp((char const   *)*(argv + i),
                                                                          "-rcc");
                                              tmp___54 = tmp___50;
                                            } else {
                                              tmp___53 = __builtin_strcmp((char const   *)*(argv + i),
                                                                          "-rcc");
                                              tmp___54 = tmp___53;
                                            }
                                          } else {
                                            tmp___53 = __builtin_strcmp((char const   *)*(argv + i),
                                                                        "-rcc");
                                            tmp___54 = tmp___53;
                                          }
                                          if (tmp___54) {
                                            if (0) {
                                              __s1_len___4 = strlen((char const   *)*(argv + i));
                                              __s2_len___4 = strlen("-skel");
                                              if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                                goto _L___10;
                                              } else {
                                                if (__s1_len___4 >= 4U) {
                                                  _L___10: /* CIL Label */ 
                                                  if (! ((unsigned int )((void const   *)("-skel" + 1)) - (unsigned int )((void const   *)"-skel") == 1U)) {
                                                    tmp___48 = 1;
                                                  } else {
                                                    if (__s2_len___4 >= 4U) {
                                                      tmp___48 = 1;
                                                    } else {
                                                      tmp___48 = 0;
                                                    }
                                                  }
                                                } else {
                                                  tmp___48 = 0;
                                                }
                                              }
                                              if (tmp___48) {
                                                tmp___43 = __builtin_strcmp((char const   *)*(argv + i),
                                                                            "-skel");
                                                tmp___47 = tmp___43;
                                              } else {
                                                tmp___46 = __builtin_strcmp((char const   *)*(argv + i),
                                                                            "-skel");
                                                tmp___47 = tmp___46;
                                              }
                                            } else {
                                              tmp___46 = __builtin_strcmp((char const   *)*(argv + i),
                                                                          "-skel");
                                              tmp___47 = tmp___46;
                                            }
                                            if (tmp___47) {
                                              if (0) {
                                                __s1_len___3 = strlen((char const   *)*(argv + i));
                                                __s2_len___3 = strlen("-ext");
                                                if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                                  goto _L___8;
                                                } else {
                                                  if (__s1_len___3 >= 4U) {
                                                    _L___8: /* CIL Label */ 
                                                    if (! ((unsigned int )((void const   *)("-ext" + 1)) - (unsigned int )((void const   *)"-ext") == 1U)) {
                                                      tmp___41 = 1;
                                                    } else {
                                                      if (__s2_len___3 >= 4U) {
                                                        tmp___41 = 1;
                                                      } else {
                                                        tmp___41 = 0;
                                                      }
                                                    }
                                                  } else {
                                                    tmp___41 = 0;
                                                  }
                                                }
                                                if (tmp___41) {
                                                  tmp___36 = __builtin_strcmp((char const   *)*(argv + i),
                                                                              "-ext");
                                                  tmp___40 = tmp___36;
                                                } else {
                                                  tmp___39 = __builtin_strcmp((char const   *)*(argv + i),
                                                                              "-ext");
                                                  tmp___40 = tmp___39;
                                                }
                                              } else {
                                                tmp___39 = __builtin_strcmp((char const   *)*(argv + i),
                                                                            "-ext");
                                                tmp___40 = tmp___39;
                                              }
                                              if (tmp___40) {
                                                if (0) {
                                                  __s1_len___2 = strlen((char const   *)*(argv + i));
                                                  __s2_len___2 = strlen("-extpc");
                                                  if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                                    goto _L___6;
                                                  } else {
                                                    if (__s1_len___2 >= 4U) {
                                                      _L___6: /* CIL Label */ 
                                                      if (! ((unsigned int )((void const   *)("-extpc" + 1)) - (unsigned int )((void const   *)"-extpc") == 1U)) {
                                                        tmp___34 = 1;
                                                      } else {
                                                        if (__s2_len___2 >= 4U) {
                                                          tmp___34 = 1;
                                                        } else {
                                                          tmp___34 = 0;
                                                        }
                                                      }
                                                    } else {
                                                      tmp___34 = 0;
                                                    }
                                                  }
                                                  if (tmp___34) {
                                                    tmp___29 = __builtin_strcmp((char const   *)*(argv + i),
                                                                                "-extpc");
                                                    tmp___33 = tmp___29;
                                                  } else {
                                                    tmp___32 = __builtin_strcmp((char const   *)*(argv + i),
                                                                                "-extpc");
                                                    tmp___33 = tmp___32;
                                                  }
                                                } else {
                                                  tmp___32 = __builtin_strcmp((char const   *)*(argv + i),
                                                                              "-extpc");
                                                  tmp___33 = tmp___32;
                                                }
                                                if (tmp___33) {
                                                  if (0) {
                                                    __s1_len___1 = strlen((char const   *)*(argv + i));
                                                    __s2_len___1 = strlen("-mask");
                                                    if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                                      goto _L___4;
                                                    } else {
                                                      if (__s1_len___1 >= 4U) {
                                                        _L___4: /* CIL Label */ 
                                                        if (! ((unsigned int )((void const   *)("-mask" + 1)) - (unsigned int )((void const   *)"-mask") == 1U)) {
                                                          tmp___27 = 1;
                                                        } else {
                                                          if (__s2_len___1 >= 4U) {
                                                            tmp___27 = 1;
                                                          } else {
                                                            tmp___27 = 0;
                                                          }
                                                        }
                                                      } else {
                                                        tmp___27 = 0;
                                                      }
                                                    }
                                                    if (tmp___27) {
                                                      tmp___22 = __builtin_strcmp((char const   *)*(argv + i),
                                                                                  "-mask");
                                                      tmp___26 = tmp___22;
                                                    } else {
                                                      tmp___25 = __builtin_strcmp((char const   *)*(argv + i),
                                                                                  "-mask");
                                                      tmp___26 = tmp___25;
                                                    }
                                                  } else {
                                                    tmp___25 = __builtin_strcmp((char const   *)*(argv + i),
                                                                                "-mask");
                                                    tmp___26 = tmp___25;
                                                  }
                                                  if (tmp___26) {
                                                    if (0) {
                                                      __s1_len___0 = strlen((char const   *)*(argv + i));
                                                      __s2_len___0 = strlen("-unmask");
                                                      if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                                        goto _L___2;
                                                      } else {
                                                        if (__s1_len___0 >= 4U) {
                                                          _L___2: /* CIL Label */ 
                                                          if (! ((unsigned int )((void const   *)("-unmask" + 1)) - (unsigned int )((void const   *)"-unmask") == 1U)) {
                                                            tmp___20 = 1;
                                                          } else {
                                                            if (__s2_len___0 >= 4U) {
                                                              tmp___20 = 1;
                                                            } else {
                                                              tmp___20 = 0;
                                                            }
                                                          }
                                                        } else {
                                                          tmp___20 = 0;
                                                        }
                                                      }
                                                      if (tmp___20) {
                                                        tmp___15 = __builtin_strcmp((char const   *)*(argv + i),
                                                                                    "-unmask");
                                                        tmp___19 = tmp___15;
                                                      } else {
                                                        tmp___18 = __builtin_strcmp((char const   *)*(argv + i),
                                                                                    "-unmask");
                                                        tmp___19 = tmp___18;
                                                      }
                                                    } else {
                                                      tmp___18 = __builtin_strcmp((char const   *)*(argv + i),
                                                                                  "-unmask");
                                                      tmp___19 = tmp___18;
                                                    }
                                                    if (tmp___19) {
                                                      if (0) {
                                                        __s1_len = strlen((char const   *)*(argv + i));
                                                        __s2_len = strlen("--version");
                                                        if (! ((unsigned int )((void const   *)(*(argv + i) + 1)) - (unsigned int )((void const   *)*(argv + i)) == 1U)) {
                                                          goto _L___0;
                                                        } else {
                                                          if (__s1_len >= 4U) {
                                                            _L___0: /* CIL Label */ 
                                                            if (! ((unsigned int )((void const   *)("--version" + 1)) - (unsigned int )((void const   *)"--version") == 1U)) {
                                                              tmp___13 = 1;
                                                            } else {
                                                              if (__s2_len >= 4U) {
                                                                tmp___13 = 1;
                                                              } else {
                                                                tmp___13 = 0;
                                                              }
                                                            }
                                                          } else {
                                                            tmp___13 = 0;
                                                          }
                                                        }
                                                        if (tmp___13) {
                                                          tmp___8 = __builtin_strcmp((char const   *)*(argv + i),
                                                                                     "--version");
                                                          tmp___12 = tmp___8;
                                                        } else {
                                                          tmp___11 = __builtin_strcmp((char const   *)*(argv + i),
                                                                                      "--version");
                                                          tmp___12 = tmp___11;
                                                        }
                                                      } else {
                                                        tmp___11 = __builtin_strcmp((char const   *)*(argv + i),
                                                                                    "--version");
                                                        tmp___12 = tmp___11;
                                                      }
                                                      if (tmp___12) {
                                                        usage();
                                                      } else {
                                                        printf((char const   * __restrict  )"Tokyo Tyrant version %s (%d:%s) for %s\n",
                                                               ttversion, 317, "0.91",
                                                               "Linux");
                                                        printf((char const   * __restrict  )"Copyright (C) 2006-2009 Mikio Hirabayashi\n");
                                                        exit(0);
                                                      }
                                                    } else {
                                                      i ++;
                                                      if (i >= argc) {
                                                        usage();
                                                      }
                                                      tmp___6 = getcmdmask((char const   *)*(argv + i));
                                                      mask___0 &= ~ tmp___6;
                                                    }
                                                  } else {
                                                    i ++;
                                                    if (i >= argc) {
                                                      usage();
                                                    }
                                                    tmp___5 = getcmdmask((char const   *)*(argv + i));
                                                    mask___0 |= tmp___5;
                                                  }
                                                } else {
                                                  if (! extpcs) {
                                                    extpcs = tclistnew2(1);
                                                  }
                                                  i ++;
                                                  if (i >= argc) {
                                                    usage();
                                                  }
                                                  tclistpush2(extpcs, (char const   *)*(argv + i));
                                                  i ++;
                                                  if (i >= argc) {
                                                    usage();
                                                  }
                                                  tclistpush2(extpcs, (char const   *)*(argv + i));
                                                }
                                              } else {
                                                i ++;
                                                if (i >= argc) {
                                                  usage();
                                                }
                                                extpath = *(argv + i);
                                              }
                                            } else {
                                              i ++;
                                              if (i >= argc) {
                                                usage();
                                              }
                                              skelpath = *(argv + i);
                                            }
                                          } else {
                                            ropts |= 1;
                                          }
                                        } else {
                                          i ++;
                                          if (i >= argc) {
                                            usage();
                                          }
                                          rtspath = *(argv + i);
                                        }
                                      } else {
                                        i ++;
                                        if (i >= argc) {
                                          usage();
                                        }
                                        tmp___4 = tcatoi((char const   *)*(argv + i));
                                        mport = (int )tmp___4;
                                      }
                                    } else {
                                      i ++;
                                      if (i >= argc) {
                                        usage();
                                      }
                                      mhost = *(argv + i);
                                    }
                                  } else {
                                    i ++;
                                    if (i >= argc) {
                                      usage();
                                    }
                                    tmp___3 = tcatoi((char const   *)*(argv + i));
                                    sid = (unsigned int )tmp___3;
                                  }
                                } else {
                                  uas = (_Bool)1;
                                }
                              } else {
                                i ++;
                                if (i >= argc) {
                                  usage();
                                }
                                tmp___2 = tcatoix((char const   *)*(argv + i));
                                ulim = (unsigned long long )tmp___2;
                              }
                            } else {
                              i ++;
                              if (i >= argc) {
                                usage();
                              }
                              ulogpath = *(argv + i);
                            }
                          } else {
                            g_loglevel = 2;
                          }
                        } else {
                          g_loglevel = 0;
                        }
                      } else {
                        i ++;
                        if (i >= argc) {
                          usage();
                        }
                        logpath = *(argv + i);
                      }
                    } else {
                      kl = (_Bool)1;
                    }
                  } else {
                    i ++;
                    if (i >= argc) {
                      usage();
                    }
                    pidpath = *(argv + i);
                  }
                } else {
                  dmn = (_Bool)1;
                }
              } else {
                i ++;
                if (i >= argc) {
                  usage();
                }
                tmp___1 = tcatoi((char const   *)*(argv + i));
                tout = (int )tmp___1;
              }
            } else {
              i ++;
              if (i >= argc) {
                usage();
              }
              tmp___0 = tcatoi((char const   *)*(argv + i));
              thnum = (int )tmp___0;
            }
          } else {
            i ++;
            if (i >= argc) {
              usage();
            }
            tmp = tcatoi((char const   *)*(argv + i));
            port = (int )tmp;
          }
        } else {
          i ++;
          if (i >= argc) {
            usage();
          }
          host = *(argv + i);
        }
      } else {
        goto _L___47;
      }
    } else {
      _L___47: /* CIL Label */ 
      if (! dbname) {
        dbname = *(argv + i);
      } else {
        usage();
      }
    }
    i ++;
  }
  if (! dbname) {
    dbname = (char *)"*";
  }
  if (thnum < 1) {
    usage();
  } else {
    if (mport < 1) {
      usage();
    }
  }
  if (dmn) {
    if (! pidpath) {
      pidpath = (char *)"ttserver.pid";
    }
  }
  if (! rtspath) {
    rtspath = (char *)"ttserver.rts";
  }
  g_serv = ttservnew();
  tmp___175 = proc((char const   *)dbname, (char const   *)host, port, thnum, tout,
                   dmn, (char const   *)pidpath, kl, (char const   *)logpath, (char const   *)ulogpath,
                   ulim, uas, sid, (char const   *)mhost, mport, (char const   *)rtspath,
                   ropts, (char const   *)skelpath, (char const   *)extpath, (TCLIST const   *)extpcs,
                   mask___0);
  rv = tmp___175;
  ttservdel(g_serv);
  if (extpcs) {
    tclistdel(extpcs);
  }
  return (rv);
}
}
static void usage(void) 
{ 

  {
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: the server of Tokyo Tyrant\n",
          g_progname);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage:\n");
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"  %s [-host name] [-port num] [-thnum num] [-tout num] [-dmn] [-pid path] [-kl] [-log path] [-ld|-le] [-ulog path] [-ulim num] [-uas] [-sid num] [-mhost name] [-mport num] [-rts path] [-rcc] [-skel name] [-ext path] [-extpc name period] [-mask expr] [-unmask expr] [dbname]\n",
          g_progname);
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  exit(1);
}
}
static uint64_t getcmdmask(char const   *expr ) 
{ uint64_t mask___0 ;
  TCLIST *fields ;
  TCLIST *tmp ;
  int i ;
  char const   *name ;
  char const   *tmp___0 ;
  int64_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  _Bool tmp___36 ;
  int tmp___37 ;

  {
  mask___0 = (uint64_t )0;
  tmp = tcstrsplit(expr, " ,");
  fields = tmp;
  i = 0;
  while (1) {
    tmp___37 = tclistnum((TCLIST const   *)fields);
    if (! (i < tmp___37)) {
      break;
    }
    tmp___0 = tclistval2((TCLIST const   *)fields, i);
    name = tmp___0;
    tmp___36 = tcstrifwm(name, "0x");
    if (tmp___36) {
      tmp___1 = tcatoih(name);
      mask___0 |= (unsigned long long )tmp___1;
    } else {
      tmp___35 = tcstricmp(name, "put");
      if (tmp___35) {
        tmp___34 = tcstricmp(name, "putkeep");
        if (tmp___34) {
          tmp___33 = tcstricmp(name, "putcat");
          if (tmp___33) {
            tmp___32 = tcstricmp(name, "putshl");
            if (tmp___32) {
              tmp___31 = tcstricmp(name, "putnr");
              if (tmp___31) {
                tmp___30 = tcstricmp(name, "out");
                if (tmp___30) {
                  tmp___29 = tcstricmp(name, "get");
                  if (tmp___29) {
                    tmp___28 = tcstricmp(name, "mget");
                    if (tmp___28) {
                      tmp___27 = tcstricmp(name, "vsiz");
                      if (tmp___27) {
                        tmp___26 = tcstricmp(name, "iterinit");
                        if (tmp___26) {
                          tmp___25 = tcstricmp(name, "iternext");
                          if (tmp___25) {
                            tmp___24 = tcstricmp(name, "fwmkeys");
                            if (tmp___24) {
                              tmp___23 = tcstricmp(name, "addint");
                              if (tmp___23) {
                                tmp___22 = tcstricmp(name, "adddouble");
                                if (tmp___22) {
                                  tmp___21 = tcstricmp(name, "ext");
                                  if (tmp___21) {
                                    tmp___20 = tcstricmp(name, "sync");
                                    if (tmp___20) {
                                      tmp___19 = tcstricmp(name, "optimize");
                                      if (tmp___19) {
                                        tmp___18 = tcstricmp(name, "vanish");
                                        if (tmp___18) {
                                          tmp___17 = tcstricmp(name, "copy");
                                          if (tmp___17) {
                                            tmp___16 = tcstricmp(name, "restore");
                                            if (tmp___16) {
                                              tmp___15 = tcstricmp(name, "setmst");
                                              if (tmp___15) {
                                                tmp___14 = tcstricmp(name, "rnum");
                                                if (tmp___14) {
                                                  tmp___13 = tcstricmp(name, "size");
                                                  if (tmp___13) {
                                                    tmp___12 = tcstricmp(name, "stat");
                                                    if (tmp___12) {
                                                      tmp___11 = tcstricmp(name, "misc");
                                                      if (tmp___11) {
                                                        tmp___10 = tcstricmp(name,
                                                                             "repl");
                                                        if (tmp___10) {
                                                          tmp___9 = tcstricmp(name,
                                                                              "slave");
                                                          if (tmp___9) {
                                                            tmp___8 = tcstricmp(name,
                                                                                "all");
                                                            if (tmp___8) {
                                                              tmp___7 = tcstricmp(name,
                                                                                  "allorg");
                                                              if (tmp___7) {
                                                                tmp___6 = tcstricmp(name,
                                                                                    "allmc");
                                                                if (tmp___6) {
                                                                  tmp___5 = tcstricmp(name,
                                                                                      "allhttp");
                                                                  if (tmp___5) {
                                                                    tmp___4 = tcstricmp(name,
                                                                                        "allread");
                                                                    if (tmp___4) {
                                                                      tmp___3 = tcstricmp(name,
                                                                                          "allwrite");
                                                                      if (tmp___3) {
                                                                        tmp___2 = tcstricmp(name,
                                                                                            "allmanage");
                                                                        if (! tmp___2) {
                                                                          mask___0 |= 1ULL << 32;
                                                                        }
                                                                      } else {
                                                                        mask___0 |= 1ULL << 31;
                                                                      }
                                                                    } else {
                                                                      mask___0 |= 1ULL << 30;
                                                                    }
                                                                  } else {
                                                                    mask___0 |= 1ULL << 29;
                                                                  }
                                                                } else {
                                                                  mask___0 |= 1ULL << 28;
                                                                }
                                                              } else {
                                                                mask___0 |= 1ULL << 27;
                                                              }
                                                            } else {
                                                              mask___0 |= 0xffffffffffffffffULL;
                                                            }
                                                          } else {
                                                            mask___0 |= 1ULL << 26;
                                                          }
                                                        } else {
                                                          mask___0 |= 1ULL << 25;
                                                        }
                                                      } else {
                                                        mask___0 |= 1ULL << 24;
                                                      }
                                                    } else {
                                                      mask___0 |= 1ULL << 23;
                                                    }
                                                  } else {
                                                    mask___0 |= 1ULL << 22;
                                                  }
                                                } else {
                                                  mask___0 |= 1ULL << 21;
                                                }
                                              } else {
                                                mask___0 |= 1ULL << 20;
                                              }
                                            } else {
                                              mask___0 |= 1ULL << 19;
                                            }
                                          } else {
                                            mask___0 |= 1ULL << 19;
                                          }
                                        } else {
                                          mask___0 |= 1ULL << 17;
                                        }
                                      } else {
                                        mask___0 |= 1ULL << 16;
                                      }
                                    } else {
                                      mask___0 |= 1ULL << 15;
                                    }
                                  } else {
                                    mask___0 |= 1ULL << 14;
                                  }
                                } else {
                                  mask___0 |= 1ULL << 13;
                                }
                              } else {
                                mask___0 |= 1ULL << 12;
                              }
                            } else {
                              mask___0 |= 1ULL << 11;
                            }
                          } else {
                            mask___0 |= 1ULL << 10;
                          }
                        } else {
                          mask___0 |= 1ULL << 9;
                        }
                      } else {
                        mask___0 |= 1ULL << 8;
                      }
                    } else {
                      mask___0 |= 1ULL << 7;
                    }
                  } else {
                    mask___0 |= 1ULL << 6;
                  }
                } else {
                  mask___0 |= 1ULL << 5;
                }
              } else {
                mask___0 |= 1ULL << 4;
              }
            } else {
              mask___0 |= 1ULL << 3;
            }
          } else {
            mask___0 |= 1ULL << 2;
          }
        } else {
          mask___0 |= 1ULL << 1;
        }
      } else {
        mask___0 |= 1ULL;
      }
    }
    i ++;
  }
  tclistdel(fields);
  return (mask___0);
}
}
static void sigtermhandler(int signum ) 
{ 

  {
  if (signum == 1) {
    g_restart = (_Bool)1;
  }
  ttservkill(g_serv);
  return;
}
}
static void sigchldhandler(int signum ) 
{ 

  {
  return;
}
}
static int proc(char const   *dbname , char const   *host , int port , int thnum ,
                int tout , _Bool dmn , char const   *pidpath , _Bool kl , char const   *logpath ,
                char const   *ulogpath , uint64_t ulim , _Bool uas , uint32_t sid ,
                char const   *mhost , int mport , char const   *rtspath , int ropts ,
                char const   *skelpath , char const   *extpath , TCLIST const   *extpcs ,
                uint64_t mask___0 ) 
{ LOGARG larg ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  struct stat sbuf ;
  int tmp___3 ;
  char *numstr ;
  void *tmp___4 ;
  int64_t pid ;
  int64_t tmp___5 ;
  int tmp___6 ;
  int cnt___0 ;
  void *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  int64_t pid___0 ;
  int64_t tmp___10 ;
  _Bool tmp___11 ;
  int fd ;
  int tmp___12 ;
  int64_t pid___1 ;
  __pid_t tmp___13 ;
  char buf[32] ;
  size_t tmp___14 ;
  _Bool tmp___15 ;
  char const   *tmp___16 ;
  _Bool tmp___17 ;
  _Bool err ;
  TCADB *adb ;
  TCADB *tmp___18 ;
  ADBSKEL skel ;
  void *skellib ;
  void *initsym ;
  void *tmp___19 ;
  _Bool (*initfunc)(ADBSKEL * ) ;
  _Bool tmp___20 ;
  _Bool tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  _Bool tmp___24 ;
  TCULOG *ulog ;
  TCULOG *tmp___25 ;
  _Bool tmp___26 ;
  _Bool tmp___27 ;
  void **screxts ;
  unsigned int __lengthofscrexts ;
  void *tmp___28 ;
  TCMDB *scrstash ;
  TCMDB *scrlock ;
  pthread_mutex_t *scrlcks ;
  _Bool screrr ;
  int i ;
  int i___0 ;
  int i___1 ;
  REPLARG sarg ;
  char const   *tmp___29 ;
  EXTPCARG *pcargs ;
  int pcnum ;
  int tmp___30 ;
  void *tmp___31 ;
  int i___2 ;
  char const   *name ;
  char const   *tmp___32 ;
  double period ;
  char const   *tmp___33 ;
  double tmp___34 ;
  EXTPCARG *pcarg ;
  TASKARG targ ;
  int i___3 ;
  int tmp___35 ;
  TERMARG karg ;
  int fd___0 ;
  int tmp___36 ;
  __sighandler_t tmp___37 ;
  __sighandler_t tmp___38 ;
  __sighandler_t tmp___39 ;
  __sighandler_t tmp___40 ;
  __sighandler_t tmp___41 ;
  _Bool tmp___42 ;
  int i___4 ;
  EXTPCARG *pcarg___0 ;
  _Bool tmp___43 ;
  int i___5 ;
  int tmp___44 ;
  int i___6 ;
  _Bool tmp___45 ;
  int i___7 ;
  int tmp___46 ;
  _Bool tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;

  {
  larg.fd = 1;
  ttservsetloghandler(g_serv, & do_log, (void *)(& larg));
  if (dmn) {
    if (dbname) {
      if ((int const   )*dbname != 42) {
        if ((int const   )*dbname != 43) {
          if ((int const   )*dbname != 47) {
            ttservlog(g_serv, 1, "warning: dbname(%s) is not the absolute path", dbname);
          }
        }
      }
    }
    if (port == 0) {
      if (host) {
        if ((int const   )*host != 47) {
          ttservlog(g_serv, 1, "warning: host(%s) is not the absolute path", host);
        }
      }
    }
    if (pidpath) {
      if ((int const   )*pidpath != 47) {
        ttservlog(g_serv, 1, "warning: pid(%s) is not the absolute path", pidpath);
      }
    }
    if (logpath) {
      if ((int const   )*logpath != 47) {
        ttservlog(g_serv, 1, "warning: log(%s) is not the absolute path", logpath);
      }
    }
    if (ulogpath) {
      if ((int const   )*ulogpath != 47) {
        ttservlog(g_serv, 1, "warning: ulog(%s) is not the absolute path", ulogpath);
      }
    }
    if (mport == 0) {
      if (mhost) {
        if ((int const   )*mhost != 47) {
          ttservlog(g_serv, 1, "warning: mhost(%s) is not the absolute path", mhost);
        }
      }
    }
    if (mhost) {
      if (rtspath) {
        if ((int const   )*rtspath != 47) {
          ttservlog(g_serv, 1, "warning: rts(%s) is not the absolute path", rtspath);
        }
      }
    }
    if (skelpath) {
      tmp___0 = __builtin_strchr((char *)skelpath, '/');
      if (tmp___0) {
        if ((int const   )*skelpath != 47) {
          ttservlog(g_serv, 1, "warning: skel(%s) is not the absolute path", skelpath);
        }
      }
    }
    if (extpath) {
      if ((int const   )*extpath != 47) {
        ttservlog(g_serv, 1, "warning: ext(%s) is not the absolute path", extpath);
      }
    }
    tmp___1 = chdir("/");
    if (tmp___1 == -1) {
      ttservlog(g_serv, 2, "chdir failed");
      return (1);
    }
  }
  if (! skelpath) {
    if (dbname) {
      if ((int const   )*dbname != 42) {
        if ((int const   )*dbname != 43) {
          tmp___2 = strstr(dbname, ".tc");
          if (! tmp___2) {
            ttservlog(g_serv, 1, "warning: dbname(%s) has no suffix for database type",
                      dbname);
          }
        }
      }
    }
  }
  if (ulogpath) {
    tmp___3 = stat((char const   * __restrict  )ulogpath, (struct stat * __restrict  )(& sbuf));
    if (tmp___3 != 0) {
      ttservlog(g_serv, 1, "warning: ulog(%s) is not a directory", ulogpath);
    } else {
      if (! ((sbuf.st_mode & 61440U) == 16384U)) {
        ttservlog(g_serv, 1, "warning: ulog(%s) is not a directory", ulogpath);
      }
    }
  }
  if (pidpath) {
    tmp___4 = tcreadfile(pidpath, -1, (int *)((void *)0));
    numstr = (char *)tmp___4;
    if (numstr) {
      if (kl) {
        tmp___5 = tcatoi((char const   *)numstr);
        pid = tmp___5;
        tcfree((void *)numstr);
        ttservlog(g_serv, 1, "warning: killing the process %lld with SIGTERM", pid);
        tmp___6 = kill((int )pid, 15);
        if (tmp___6 != 0) {
          ttservlog(g_serv, 2, "kill failed");
        }
        cnt___0 = 0;
        while (1) {
          tcsleep(0.1);
          tmp___7 = tcreadfile(pidpath, -1, (int *)((void *)0));
          numstr = (char *)tmp___7;
          if ((unsigned int )numstr != (unsigned int )((void *)0)) {
            tcfree((void *)numstr);
          } else {
            break;
          }
          cnt___0 ++;
          if (cnt___0 >= 100) {
            ttservlog(g_serv, 1, "warning: killing the process %lld with SIGKILL",
                      pid);
            tmp___8 = kill((int )pid, 9);
            if (tmp___8 != 0) {
              ttservlog(g_serv, 2, "kill failed");
            }
            unlink(pidpath);
            break;
          }
        }
        tmp___9 = tcreadfile(pidpath, -1, (int *)((void *)0));
        numstr = (char *)tmp___9;
      }
    }
    if (numstr) {
      tmp___10 = tcatoi((char const   *)numstr);
      pid___0 = tmp___10;
      tcfree((void *)numstr);
      ttservlog(g_serv, 2, "the process %lld may be already running", pid___0);
      return (1);
    }
  }
  if (sid > 65535U) {
    ttservlog(g_serv, 1, "warning: the SID is ignored because it exceeds %d", 65535);
    sid = 0U;
  }
  if (sid < 1U) {
    if (ulogpath) {
      ttservlog(g_serv, 1, "warning: update logging is omitted because the SID is not specified");
      ulogpath = (char const   *)((void *)0);
    }
    if (mhost) {
      ttservlog(g_serv, 1, "warning: replication is omitted because the SID is not specified");
      mhost = (char const   *)((void *)0);
    }
  }
  if (dmn) {
    tmp___11 = ttdaemonize();
    if (! tmp___11) {
      ttservlog(g_serv, 2, "ttdaemonize failed");
      return (1);
    }
  }
  if (logpath) {
    tmp___12 = open(logpath, 1089, 420);
    fd = tmp___12;
    if (fd != -1) {
      larg.fd = fd;
    } else {
      ttservlog(g_serv, 2, "the log file %s could not be opened", logpath);
      return (1);
    }
  }
  tmp___13 = getpid();
  pid___1 = (int64_t )tmp___13;
  ttservlog(g_serv, 3, "--------- logging started [%lld] --------", pid___1);
  if (pidpath) {
    sprintf((char * __restrict  )(buf), (char const   * __restrict  )"%lld\n", pid___1);
    tmp___14 = strlen((char const   *)(buf));
    tmp___15 = tcwritefile(pidpath, (void const   *)(buf), (int )tmp___14);
    if (! tmp___15) {
      ttservlog(g_serv, 2, "tcwritefile failed");
      return (1);
    }
    ttservlog(g_serv, 3, "process ID configuration: path=%s pid=%lld", pidpath, pid___1);
  }
  if (host) {
    tmp___16 = host;
  } else {
    tmp___16 = "(any)";
  }
  ttservlog(g_serv, 3, "server configuration: host=%s port=%d", tmp___16, port);
  tmp___17 = ttservconf(g_serv, host, port);
  if (! tmp___17) {
    return (1);
  }
  err = (_Bool)0;
  tmp___18 = tcadbnew();
  adb = tmp___18;
  memset((void *)(& skel), 0, (unsigned int )((int )sizeof(skel)));
  skellib = (void *)0;
  if (skelpath) {
    ttservlog(g_serv, 3, "skeleton database library: %s", skelpath);
    skellib = dlopen(skelpath, 1);
    if (skellib) {
      tmp___19 = dlsym((void * __restrict  )skellib, (char const   * __restrict  )"initialize");
      initsym = tmp___19;
      if (initsym) {
        memcpy((void * __restrict  )(& initfunc), (void const   * __restrict  )(& initsym),
               (unsigned int )((int )sizeof(initsym)));
        tmp___21 = (*initfunc)(& skel);
        if (tmp___21) {
          tmp___20 = tcadbsetskel(adb, & skel);
          if (! tmp___20) {
            if (skel.opq) {
              if (skel.del) {
                (*(skel.del))(skel.opq);
              }
            }
            err = (_Bool)1;
            ttservlog(g_serv, 2, "tcadbsetskel failed");
          }
        } else {
          if (skel.opq) {
            if (skel.del) {
              (*(skel.del))(skel.opq);
            }
          }
          err = (_Bool)1;
          ttservlog(g_serv, 2, "initialize failed");
        }
      } else {
        err = (_Bool)1;
        tmp___22 = dlerror();
        ttservlog(g_serv, 2, "dlsym failed: %s", tmp___22);
      }
    } else {
      err = (_Bool)1;
      tmp___23 = dlerror();
      ttservlog(g_serv, 2, "dlopen failed: %s", tmp___23);
    }
  }
  ttservlog(g_serv, 3, "opening the database: %s", dbname);
  tmp___24 = tcadbopen(adb, dbname);
  if (! tmp___24) {
    err = (_Bool)1;
    ttservlog(g_serv, 2, "tcadbopen failed");
  }
  tmp___25 = tculognew();
  ulog = tmp___25;
  if (ulogpath) {
    ttservlog(g_serv, 3, "update log configuration: path=%s limit=%llu async=%d sid=%d",
              ulogpath, ulim, uas, sid);
    if (uas) {
      tmp___26 = tculogsetaio(ulog);
      if (! tmp___26) {
        err = (_Bool)1;
        ttservlog(g_serv, 2, "tculogsetaio failed");
      }
    }
    tmp___27 = tculogopen(ulog, ulogpath, ulim);
    if (! tmp___27) {
      err = (_Bool)1;
      ttservlog(g_serv, 2, "tculogopen failed");
    }
  }
  ttservtune(g_serv, thnum, (double )tout);
  if (mhost) {
    ttservlog(g_serv, 3, "replication configuration: host=%s port=%d ropts=%d", mhost,
              mport, ropts);
  }
  __lengthofscrexts = (unsigned int )thnum;
  tmp___28 = __builtin_alloca(sizeof(*screxts) * __lengthofscrexts);
  screxts = (void **)tmp___28;
  scrstash = (TCMDB *)((void *)0);
  scrlock = (TCMDB *)((void *)0);
  scrlcks = (pthread_mutex_t *)((void *)0);
  if (extpath) {
    ttservlog(g_serv, 3, "scripting extension: %s", extpath);
    scrstash = tcmdbnew2(1021U);
    scrlock = tcmdbnew2((unsigned int )(thnum * 2 + 1));
    screrr = (_Bool)0;
    i = 0;
    while (i < thnum) {
      *(screxts + i) = (void *)0;
      i ++;
    }
    i___0 = 0;
    while (i___0 < thnum) {
      *(screxts + i___0) = scrextnew(screxts, thnum, i___0, extpath, adb, ulog, sid,
                                     scrstash, scrlock, & do_log, (void *)(& larg));
      if (! *(screxts + i___0)) {
        screrr = (_Bool)1;
      }
      i___0 ++;
    }
    if (screrr) {
      err = (_Bool)1;
      ttservlog(g_serv, 2, "scrextnew failed");
    }
  } else {
    i___1 = 0;
    while (i___1 < thnum) {
      *(screxts + i___1) = (void *)0;
      i___1 ++;
    }
  }
  if (mask___0 != 0ULL) {
    ttservlog(g_serv, 3, "command bit mask: 0x%llx", mask___0);
  }
  if (mhost) {
    tmp___29 = mhost;
  } else {
    tmp___29 = "";
  }
  snprintf((char * __restrict  )(sarg.host), 1024U, (char const   * __restrict  )"%s",
           tmp___29);
  sarg.port = mport;
  sarg.rtspath = rtspath;
  sarg.rts = 0ULL;
  sarg.opts = ropts;
  sarg.adb = adb;
  sarg.ulog = ulog;
  sarg.sid = sid;
  sarg.fail = (_Bool)0;
  sarg.recon = (_Bool)0;
  sarg.fatal = (_Bool)0;
  sarg.mts = 0ULL;
  if (! (mask___0 & (1ULL << 26))) {
    ttservaddtimedhandler(g_serv, 1.0, & do_slave, (void *)(& sarg));
  }
  pcargs = (EXTPCARG *)((void *)0);
  pcnum = 0;
  if (extpath) {
    if (extpcs) {
      tmp___30 = tclistnum(extpcs);
      pcnum = tmp___30 / 2;
      tmp___31 = tcmalloc((unsigned int )((int )sizeof(*pcargs) * pcnum));
      pcargs = (EXTPCARG *)tmp___31;
      i___2 = 0;
      while (i___2 < pcnum) {
        tmp___32 = tclistval2(extpcs, i___2 * 2);
        name = tmp___32;
        tmp___33 = tclistval2(extpcs, i___2 * 2 + 1);
        tmp___34 = tcatof(tmp___33);
        period = tmp___34;
        pcarg = pcargs + i___2;
        pcarg->name = name;
        pcarg->adb = adb;
        pcarg->ulog = ulog;
        pcarg->sid = sid;
        pcarg->sarg = & sarg;
        pcarg->scrext = scrextnew(screxts, thnum, thnum + i___2, extpath, adb, ulog,
                                  sid, scrstash, scrlock, & do_log, (void *)(& larg));
        if (pcarg->scrext) {
          if (*name) {
            if (period > (double )0) {
              ttservaddtimedhandler(g_serv, period, & do_extpc, (void *)pcarg);
            }
          }
        } else {
          err = (_Bool)1;
          ttservlog(g_serv, 2, "scrextnew failed");
        }
        i___2 ++;
      }
    }
  }
  targ.mask = mask___0;
  targ.adb = adb;
  targ.ulog = ulog;
  targ.sid = sid;
  targ.sarg = & sarg;
  i___3 = 0;
  while (i___3 < 31) {
    tmp___35 = pthread_mutex_init(targ.rmtxs + i___3, (pthread_mutexattr_t const   *)((void *)0));
    if (tmp___35 != 0) {
      ttservlog(g_serv, 2, "pthread_mutex_init failed");
    }
    i___3 ++;
  }
  targ.screxts = screxts;
  ttservsettaskhandler(g_serv, & do_task, (void *)(& targ));
  karg.thnum = thnum;
  karg.adb = adb;
  karg.sarg = & sarg;
  karg.screxts = screxts;
  karg.pcargs = pcargs;
  karg.pcnum = pcnum;
  karg.err = (_Bool)0;
  ttservsettermhandler(g_serv, & do_term, (void *)(& karg));
  if (larg.fd != 1) {
    close(larg.fd);
    larg.fd = 1;
  }
  while (1) {
    g_restart = (_Bool)0;
    if (logpath) {
      tmp___36 = open(logpath, 1089, 420);
      fd___0 = tmp___36;
      if (fd___0 != -1) {
        larg.fd = fd___0;
      } else {
        err = (_Bool)1;
        ttservlog(g_serv, 2, "open failed");
      }
    }
    tmp___37 = signal(15, & sigtermhandler);
    if ((unsigned int )tmp___37 == (unsigned int )((void (*)(int  ))-1)) {
      err = (_Bool)1;
      ttservlog(g_serv, 2, "signal failed");
    } else {
      tmp___38 = signal(2, & sigtermhandler);
      if ((unsigned int )tmp___38 == (unsigned int )((void (*)(int  ))-1)) {
        err = (_Bool)1;
        ttservlog(g_serv, 2, "signal failed");
      } else {
        tmp___39 = signal(1, & sigtermhandler);
        if ((unsigned int )tmp___39 == (unsigned int )((void (*)(int  ))-1)) {
          err = (_Bool)1;
          ttservlog(g_serv, 2, "signal failed");
        } else {
          tmp___40 = signal(13, (void (*)(int  ))1);
          if ((unsigned int )tmp___40 == (unsigned int )((void (*)(int  ))-1)) {
            err = (_Bool)1;
            ttservlog(g_serv, 2, "signal failed");
          } else {
            tmp___41 = signal(17, & sigchldhandler);
            if ((unsigned int )tmp___41 == (unsigned int )((void (*)(int  ))-1)) {
              err = (_Bool)1;
              ttservlog(g_serv, 2, "signal failed");
            }
          }
        }
      }
    }
    tmp___42 = ttservstart(g_serv);
    if (! tmp___42) {
      err = (_Bool)1;
    }
    if (! g_restart) {
      break;
    }
  }
  if (karg.err) {
    err = (_Bool)1;
  }
  if (pcargs) {
    i___4 = 0;
    while (i___4 < pcnum) {
      pcarg___0 = pcargs + i___4;
      if (! pcarg___0->scrext) {
        goto __Cont;
      }
      tmp___43 = scrextdel(pcarg___0->scrext);
      if (! tmp___43) {
        err = (_Bool)1;
        ttservlog(g_serv, 2, "scrextdel failed");
      }
      __Cont: /* CIL Label */ 
      i___4 ++;
    }
    tcfree((void *)pcargs);
  }
  i___5 = 0;
  while (i___5 < 31) {
    tmp___44 = pthread_mutex_destroy(targ.rmtxs + i___5);
    if (tmp___44 != 0) {
      ttservlog(g_serv, 2, "pthread_mutex_destroy failed");
    }
    i___5 ++;
  }
  i___6 = 0;
  while (i___6 < thnum) {
    if (! *(screxts + i___6)) {
      goto __Cont___0;
    }
    tmp___45 = scrextdel(*(screxts + i___6));
    if (! tmp___45) {
      err = (_Bool)1;
      ttservlog(g_serv, 2, "scrextdel failed");
    }
    __Cont___0: /* CIL Label */ 
    i___6 ++;
  }
  if (scrlcks) {
    i___7 = 0;
    while (i___7 < 31) {
      tmp___46 = pthread_mutex_destroy(scrlcks + i___7);
      if (tmp___46 != 0) {
        ttservlog(g_serv, 2, "pthread_mutex_destroy failed");
      }
      i___7 ++;
    }
    tcfree((void *)scrlcks);
  }
  if (scrlock) {
    tcmdbdel(scrlock);
  }
  if (scrstash) {
    tcmdbdel(scrstash);
  }
  if (ulogpath) {
    tmp___47 = tculogclose(ulog);
    if (! tmp___47) {
      err = (_Bool)1;
      ttservlog(g_serv, 2, "tculogclose failed");
    }
  }
  tculogdel(ulog);
  if (skellib) {
    tmp___48 = dlclose(skellib);
    if (tmp___48 != 0) {
      err = (_Bool)1;
      ttservlog(g_serv, 2, "dlclose failed");
    }
  }
  tcadbdel(adb);
  if (pidpath) {
    tmp___49 = unlink(pidpath);
    if (tmp___49 != 0) {
      err = (_Bool)1;
      ttservlog(g_serv, 2, "unlink failed");
    }
  }
  ttservlog(g_serv, 3, "--------- logging finished [%d] --------", pid___1);
  if (logpath) {
    tmp___50 = close(larg.fd);
    if (tmp___50 == -1) {
      err = (_Bool)1;
    }
  }
  if (err) {
    tmp___51 = 1;
  } else {
    tmp___51 = 0;
  }
  return (tmp___51);
}
}
static void do_log(int level , char const   *msg , void *opq ) 
{ LOGARG *arg ;
  char date[48] ;
  char const   *lvstr ;
  char buf[8192] ;
  int len ;
  int tmp ;
  int tmp___0 ;

  {
  if (level < g_loglevel) {
    return;
  }
  arg = (LOGARG *)opq;
  tcdatestrwww(9223372036854775807LL, 2147483647, date);
  lvstr = "unknown";
  switch (level) {
  case 0: 
  lvstr = "DEBUG";
  break;
  case 1: 
  lvstr = "INFO";
  break;
  case 2: 
  lvstr = "ERROR";
  break;
  case 3: 
  lvstr = "SYSTEM";
  break;
  }
  tmp = snprintf((char * __restrict  )(buf), 8192U, (char const   * __restrict  )"%s\t%s\t%s\n",
                 date, lvstr, msg);
  len = tmp;
  if (len >= 8192) {
    buf[8191] = (char )'\n';
    len = 8192;
  }
  if (arg) {
    tmp___0 = arg->fd;
  } else {
    tmp___0 = 1;
  }
  tcwrite(tmp___0, (void const   *)(buf), (unsigned int )len);
  return;
}
}
static void do_slave(void *opq ) 
{ REPLARG *arg ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  char rtsbuf[32] ;
  int len ;
  int tmp ;
  _Bool tmp___0 ;
  int rtsfd ;
  int tmp___1 ;
  struct stat sbuf ;
  int tmp___2 ;
  char rtsbuf___0[32] ;
  int64_t tmp___3 ;
  long tmp___4 ;
  _Bool tmp___5 ;
  TCREPL *repl ;
  TCREPL *tmp___6 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___7 ;
  long tmp___8 ;
  _Bool err ;
  uint32_t rsid ;
  char const   *rbuf ;
  int rsiz ;
  uint64_t rts ;
  _Bool cc ;
  _Bool tmp___9 ;
  int len___0 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  __off_t tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  int tmp___15 ;

  {
  arg = (REPLARG *)opq;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  if (arg->fatal) {
    return;
  }
  if ((int )arg->host[0] == 0) {
    return;
  } else {
    if (arg->port < 1) {
      return;
    }
  }
  if (arg->mts > 0ULL) {
    tmp = sprintf((char * __restrict  )(rtsbuf), (char const   * __restrict  )"%llu\n",
                  arg->mts);
    len = tmp;
    tmp___0 = tcwritefile(arg->rtspath, (void const   *)(rtsbuf), len);
    if (! tmp___0) {
      ttservlog(g_serv, 2, "do_slave: tcwritefile failed");
    }
    arg->mts = 0ULL;
  }
  tmp___1 = open(arg->rtspath, 66, 420);
  rtsfd = tmp___1;
  if (rtsfd == -1) {
    ttservlog(g_serv, 2, "do_slave: open failed");
    return;
  }
  tmp___2 = fstat(rtsfd, & sbuf);
  if (tmp___2 == -1) {
    ttservlog(g_serv, 2, "do_slave: stat failed");
    close(rtsfd);
    return;
  }
  memset((void *)(rtsbuf___0), 0, 32U);
  arg->rts = 0ULL;
  if (sbuf.st_size > 0L) {
    tmp___4 = tclmin(31L, sbuf.st_size);
    tmp___5 = tcread(rtsfd, (void *)(rtsbuf___0), (unsigned int )tmp___4);
    if (tmp___5) {
      tmp___3 = tcatoi((char const   *)(rtsbuf___0));
      arg->rts = (unsigned long long )tmp___3;
    }
  }
  tmp___6 = tcreplnew();
  repl = tmp___6;
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrepldel);
    __cancel_arg = (void *)repl;
    tmp___7 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___7;
    tmp___8 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___8) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___14 = tcreplopen(repl, (char const   *)(arg->host), arg->port, arg->rts + 1ULL,
                            sid);
      if (tmp___14) {
        ttservlog(g_serv, 1, "replicating from sid=%u (%s:%d) after %llu", repl->mid,
                  arg->host, arg->port, arg->rts);
        arg->fail = (_Bool)0;
        arg->recon = (_Bool)0;
        err = (_Bool)0;
        while (1) {
          if (! err) {
            tmp___13 = ttserviskilled(g_serv);
            if (tmp___13) {
              break;
            } else {
              if (! arg->recon) {
                rbuf = tcreplread(repl, & rsiz, & rts, & rsid);
                if (! ((unsigned int )rbuf != (unsigned int )((void *)0))) {
                  break;
                }
              } else {
                break;
              }
            }
          } else {
            break;
          }
          if (rsiz < 1) {
            continue;
          }
          tmp___9 = tculogadbredo(adb, rbuf, rsiz, ulog, rsid, (unsigned int )repl->mid,
                                  & cc);
          if (tmp___9) {
            if (! cc) {
              if (arg->opts & 1) {
                err = (_Bool)1;
                arg->fatal = (_Bool)1;
                ttservlog(g_serv, 2, "do_slave: detected inconsistency");
              } else {
                ttservlog(g_serv, 1, "do_slave: detected inconsistency");
              }
            }
          } else {
            err = (_Bool)1;
            ttservlog(g_serv, 2, "do_slave: tculogadbredo failed");
          }
          tmp___12 = lseek(rtsfd, 0L, 0);
          if (tmp___12 != -1L) {
            tmp___10 = sprintf((char * __restrict  )(rtsbuf___0), (char const   * __restrict  )"%llu\n",
                               rts);
            len___0 = tmp___10;
            tmp___11 = tcwrite(rtsfd, (void const   *)(rtsbuf___0), (unsigned int )len___0);
            if (tmp___11) {
              arg->rts = rts;
            } else {
              err = (_Bool)1;
              ttservlog(g_serv, 2, "do_slave: tcwrite failed");
            }
          } else {
            err = (_Bool)1;
            ttservlog(g_serv, 2, "do_slave: lseek failed");
          }
        }
        tcreplclose(repl);
        ttservlog(g_serv, 1, "replication finished");
      } else {
        if (! arg->fail) {
          ttservlog(g_serv, 2, "do_slave: tcreplopen failed");
        }
        arg->fail = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  tmp___15 = close(rtsfd);
  if (tmp___15 == -1) {
    ttservlog(g_serv, 2, "do_slave: close failed");
  }
  return;
}
}
static void do_extpc(void *opq ) 
{ EXTPCARG *arg ;
  char const   *name ;
  void *scr ;
  int xsiz ;
  char *xbuf ;
  char *tmp ;

  {
  arg = (EXTPCARG *)opq;
  name = arg->name;
  scr = arg->scrext;
  tmp = scrextcallmethod(scr, name, (void const   *)"", 0, (void const   *)"", 0,
                         & xsiz);
  xbuf = tmp;
  tcfree((void *)xbuf);
  return;
}
}
static void do_task(TTSOCK *sock , void *opq , TTREQ *req ) 
{ TASKARG *arg ;
  int c ;
  int tmp ;
  int tmp___0 ;
  char *line ;
  char *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___2 ;
  long tmp___3 ;
  int tnum ;
  char **tokens ;
  char **tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_task)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___5 ;
  long tmp___6 ;
  char const   *cmd ;
  int ver ;
  int64_t tmp___7 ;
  char const   *uri ;
  char const   *pv ;
  char *tmp___9 ;
  _Bool tmp___10 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___19 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___26 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___33 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___40 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___47 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  _Bool tmp___53 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___55 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___62 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___69 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___76 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___83 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___90 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___97 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___104 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___111 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___118 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___125 ;
  int tmp___128 ;
  int tmp___129 ;
  int tmp___130 ;
  size_t __s1_len___16 ;
  size_t __s2_len___16 ;
  int tmp___132 ;
  int tmp___135 ;
  int tmp___136 ;
  int tmp___137 ;

  {
  arg = (TASKARG *)opq;
  tmp = ttsockgetc(sock);
  c = tmp;
  if (c == 200) {
    tmp___0 = ttsockgetc(sock);
    switch (tmp___0) {
    case 16: 
    do_put(sock, arg, req);
    break;
    case 17: 
    do_putkeep(sock, arg, req);
    break;
    case 18: 
    do_putcat(sock, arg, req);
    break;
    case 19: 
    do_putshl(sock, arg, req);
    break;
    case 24: 
    do_putnr(sock, arg, req);
    break;
    case 32: 
    do_out(sock, arg, req);
    break;
    case 48: 
    do_get(sock, arg, req);
    break;
    case 49: 
    do_mget(sock, arg, req);
    break;
    case 56: 
    do_vsiz(sock, arg, req);
    break;
    case 80: 
    do_iterinit(sock, arg, req);
    break;
    case 81: 
    do_iternext(sock, arg, req);
    break;
    case 88: 
    do_fwmkeys(sock, arg, req);
    break;
    case 96: 
    do_addint(sock, arg, req);
    break;
    case 97: 
    do_adddouble(sock, arg, req);
    break;
    case 104: 
    do_ext(sock, arg, req);
    break;
    case 112: 
    do_sync(sock, arg, req);
    break;
    case 113: 
    do_optimize(sock, arg, req);
    break;
    case 114: 
    do_vanish(sock, arg, req);
    break;
    case 115: 
    do_copy(sock, arg, req);
    break;
    case 116: 
    do_restore(sock, arg, req);
    break;
    case 120: 
    do_setmst(sock, arg, req);
    break;
    case 128: 
    do_rnum(sock, arg, req);
    break;
    case 129: 
    do_size(sock, arg, req);
    break;
    case 136: 
    do_stat(sock, arg, req);
    break;
    case 144: 
    do_misc(sock, arg, req);
    break;
    case 160: 
    do_repl(sock, arg, req);
    break;
    default: 
    ttservlog(g_serv, 1, "unknown command");
    break;
    }
  } else {
    ttsockungetc(sock, c);
    tmp___1 = ttsockgets2(sock);
    line = tmp___1;
    if (line) {
      while (1) {
        __cancel_routine = & tcfree;
        __cancel_arg = (void *)line;
        tmp___2 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                              0);
        not_first_call = tmp___2;
        tmp___3 = __builtin_expect((long )not_first_call, 0L);
        if (tmp___3) {
          (*__cancel_routine)(__cancel_arg);
          __pthread_unwind_next(& __cancel_buf);
        }
        __pthread_register_cancel(& __cancel_buf);
        while (1) {
          tmp___4 = tokenize(line, & tnum);
          tokens = tmp___4;
          while (1) {
            __cancel_routine___do_task = & tcfree;
            __cancel_arg___0 = (void *)tokens;
            tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                                  0);
            not_first_call___0 = tmp___5;
            tmp___6 = __builtin_expect((long )not_first_call___0, 0L);
            if (tmp___6) {
              (*__cancel_routine___do_task)(__cancel_arg___0);
              __pthread_unwind_next(& __cancel_buf___0);
            }
            __pthread_register_cancel(& __cancel_buf___0);
            while (1) {
              if (tnum > 0) {
                cmd = (char const   *)*(tokens + 0);
                if (0) {
                  __s1_len___16 = strlen(cmd);
                  __s2_len___16 = strlen("set");
                  if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                    goto _L___34;
                  } else {
                    if (__s1_len___16 >= 4U) {
                      _L___34: /* CIL Label */ 
                      if (! ((unsigned int )((void const   *)("set" + 1)) - (unsigned int )((void const   *)"set") == 1U)) {
                        tmp___137 = 1;
                      } else {
                        if (__s2_len___16 >= 4U) {
                          tmp___137 = 1;
                        } else {
                          tmp___137 = 0;
                        }
                      }
                    } else {
                      tmp___137 = 0;
                    }
                  }
                  if (tmp___137) {
                    tmp___132 = __builtin_strcmp(cmd, "set");
                    tmp___136 = tmp___132;
                  } else {
                    tmp___135 = __builtin_strcmp(cmd, "set");
                    tmp___136 = tmp___135;
                  }
                } else {
                  tmp___135 = __builtin_strcmp(cmd, "set");
                  tmp___136 = tmp___135;
                }
                if (tmp___136) {
                  if (0) {
                    __s1_len___15 = strlen(cmd);
                    __s2_len___15 = strlen("add");
                    if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                      goto _L___32;
                    } else {
                      if (__s1_len___15 >= 4U) {
                        _L___32: /* CIL Label */ 
                        if (! ((unsigned int )((void const   *)("add" + 1)) - (unsigned int )((void const   *)"add") == 1U)) {
                          tmp___130 = 1;
                        } else {
                          if (__s2_len___15 >= 4U) {
                            tmp___130 = 1;
                          } else {
                            tmp___130 = 0;
                          }
                        }
                      } else {
                        tmp___130 = 0;
                      }
                    }
                    if (tmp___130) {
                      tmp___125 = __builtin_strcmp(cmd, "add");
                      tmp___129 = tmp___125;
                    } else {
                      tmp___128 = __builtin_strcmp(cmd, "add");
                      tmp___129 = tmp___128;
                    }
                  } else {
                    tmp___128 = __builtin_strcmp(cmd, "add");
                    tmp___129 = tmp___128;
                  }
                  if (tmp___129) {
                    if (0) {
                      __s1_len___14 = strlen(cmd);
                      __s2_len___14 = strlen("replace");
                      if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                        goto _L___30;
                      } else {
                        if (__s1_len___14 >= 4U) {
                          _L___30: /* CIL Label */ 
                          if (! ((unsigned int )((void const   *)("replace" + 1)) - (unsigned int )((void const   *)"replace") == 1U)) {
                            tmp___123 = 1;
                          } else {
                            if (__s2_len___14 >= 4U) {
                              tmp___123 = 1;
                            } else {
                              tmp___123 = 0;
                            }
                          }
                        } else {
                          tmp___123 = 0;
                        }
                      }
                      if (tmp___123) {
                        tmp___118 = __builtin_strcmp(cmd, "replace");
                        tmp___122 = tmp___118;
                      } else {
                        tmp___121 = __builtin_strcmp(cmd, "replace");
                        tmp___122 = tmp___121;
                      }
                    } else {
                      tmp___121 = __builtin_strcmp(cmd, "replace");
                      tmp___122 = tmp___121;
                    }
                    if (tmp___122) {
                      if (0) {
                        __s1_len___12 = strlen(cmd);
                        __s2_len___12 = strlen("get");
                        if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                          goto _L___26;
                        } else {
                          if (__s1_len___12 >= 4U) {
                            _L___26: /* CIL Label */ 
                            if (! ((unsigned int )((void const   *)("get" + 1)) - (unsigned int )((void const   *)"get") == 1U)) {
                              tmp___109 = 1;
                            } else {
                              if (__s2_len___12 >= 4U) {
                                tmp___109 = 1;
                              } else {
                                tmp___109 = 0;
                              }
                            }
                          } else {
                            tmp___109 = 0;
                          }
                        }
                        if (tmp___109) {
                          tmp___104 = __builtin_strcmp(cmd, "get");
                          tmp___108 = tmp___104;
                        } else {
                          tmp___107 = __builtin_strcmp(cmd, "get");
                          tmp___108 = tmp___107;
                        }
                      } else {
                        tmp___107 = __builtin_strcmp(cmd, "get");
                        tmp___108 = tmp___107;
                      }
                      if (tmp___108) {
                        if (0) {
                          __s1_len___13 = strlen(cmd);
                          __s2_len___13 = strlen("gets");
                          if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                            goto _L___28;
                          } else {
                            if (__s1_len___13 >= 4U) {
                              _L___28: /* CIL Label */ 
                              if (! ((unsigned int )((void const   *)("gets" + 1)) - (unsigned int )((void const   *)"gets") == 1U)) {
                                tmp___116 = 1;
                              } else {
                                if (__s2_len___13 >= 4U) {
                                  tmp___116 = 1;
                                } else {
                                  tmp___116 = 0;
                                }
                              }
                            } else {
                              tmp___116 = 0;
                            }
                          }
                          if (tmp___116) {
                            tmp___111 = __builtin_strcmp(cmd, "gets");
                            tmp___115 = tmp___111;
                          } else {
                            tmp___114 = __builtin_strcmp(cmd, "gets");
                            tmp___115 = tmp___114;
                          }
                        } else {
                          tmp___114 = __builtin_strcmp(cmd, "gets");
                          tmp___115 = tmp___114;
                        }
                        if (tmp___115) {
                          if (0) {
                            __s1_len___11 = strlen(cmd);
                            __s2_len___11 = strlen("delete");
                            if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                              goto _L___24;
                            } else {
                              if (__s1_len___11 >= 4U) {
                                _L___24: /* CIL Label */ 
                                if (! ((unsigned int )((void const   *)("delete" + 1)) - (unsigned int )((void const   *)"delete") == 1U)) {
                                  tmp___102 = 1;
                                } else {
                                  if (__s2_len___11 >= 4U) {
                                    tmp___102 = 1;
                                  } else {
                                    tmp___102 = 0;
                                  }
                                }
                              } else {
                                tmp___102 = 0;
                              }
                            }
                            if (tmp___102) {
                              tmp___97 = __builtin_strcmp(cmd, "delete");
                              tmp___101 = tmp___97;
                            } else {
                              tmp___100 = __builtin_strcmp(cmd, "delete");
                              tmp___101 = tmp___100;
                            }
                          } else {
                            tmp___100 = __builtin_strcmp(cmd, "delete");
                            tmp___101 = tmp___100;
                          }
                          if (tmp___101) {
                            if (0) {
                              __s1_len___10 = strlen(cmd);
                              __s2_len___10 = strlen("incr");
                              if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                goto _L___22;
                              } else {
                                if (__s1_len___10 >= 4U) {
                                  _L___22: /* CIL Label */ 
                                  if (! ((unsigned int )((void const   *)("incr" + 1)) - (unsigned int )((void const   *)"incr") == 1U)) {
                                    tmp___95 = 1;
                                  } else {
                                    if (__s2_len___10 >= 4U) {
                                      tmp___95 = 1;
                                    } else {
                                      tmp___95 = 0;
                                    }
                                  }
                                } else {
                                  tmp___95 = 0;
                                }
                              }
                              if (tmp___95) {
                                tmp___90 = __builtin_strcmp(cmd, "incr");
                                tmp___94 = tmp___90;
                              } else {
                                tmp___93 = __builtin_strcmp(cmd, "incr");
                                tmp___94 = tmp___93;
                              }
                            } else {
                              tmp___93 = __builtin_strcmp(cmd, "incr");
                              tmp___94 = tmp___93;
                            }
                            if (tmp___94) {
                              if (0) {
                                __s1_len___9 = strlen(cmd);
                                __s2_len___9 = strlen("decr");
                                if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                  goto _L___20;
                                } else {
                                  if (__s1_len___9 >= 4U) {
                                    _L___20: /* CIL Label */ 
                                    if (! ((unsigned int )((void const   *)("decr" + 1)) - (unsigned int )((void const   *)"decr") == 1U)) {
                                      tmp___88 = 1;
                                    } else {
                                      if (__s2_len___9 >= 4U) {
                                        tmp___88 = 1;
                                      } else {
                                        tmp___88 = 0;
                                      }
                                    }
                                  } else {
                                    tmp___88 = 0;
                                  }
                                }
                                if (tmp___88) {
                                  tmp___83 = __builtin_strcmp(cmd, "decr");
                                  tmp___87 = tmp___83;
                                } else {
                                  tmp___86 = __builtin_strcmp(cmd, "decr");
                                  tmp___87 = tmp___86;
                                }
                              } else {
                                tmp___86 = __builtin_strcmp(cmd, "decr");
                                tmp___87 = tmp___86;
                              }
                              if (tmp___87) {
                                if (0) {
                                  __s1_len___8 = strlen(cmd);
                                  __s2_len___8 = strlen("stats");
                                  if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                    goto _L___18;
                                  } else {
                                    if (__s1_len___8 >= 4U) {
                                      _L___18: /* CIL Label */ 
                                      if (! ((unsigned int )((void const   *)("stats" + 1)) - (unsigned int )((void const   *)"stats") == 1U)) {
                                        tmp___81 = 1;
                                      } else {
                                        if (__s2_len___8 >= 4U) {
                                          tmp___81 = 1;
                                        } else {
                                          tmp___81 = 0;
                                        }
                                      }
                                    } else {
                                      tmp___81 = 0;
                                    }
                                  }
                                  if (tmp___81) {
                                    tmp___76 = __builtin_strcmp(cmd, "stats");
                                    tmp___80 = tmp___76;
                                  } else {
                                    tmp___79 = __builtin_strcmp(cmd, "stats");
                                    tmp___80 = tmp___79;
                                  }
                                } else {
                                  tmp___79 = __builtin_strcmp(cmd, "stats");
                                  tmp___80 = tmp___79;
                                }
                                if (tmp___80) {
                                  if (0) {
                                    __s1_len___7 = strlen(cmd);
                                    __s2_len___7 = strlen("flush_all");
                                    if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                      goto _L___16;
                                    } else {
                                      if (__s1_len___7 >= 4U) {
                                        _L___16: /* CIL Label */ 
                                        if (! ((unsigned int )((void const   *)("flush_all" + 1)) - (unsigned int )((void const   *)"flush_all") == 1U)) {
                                          tmp___74 = 1;
                                        } else {
                                          if (__s2_len___7 >= 4U) {
                                            tmp___74 = 1;
                                          } else {
                                            tmp___74 = 0;
                                          }
                                        }
                                      } else {
                                        tmp___74 = 0;
                                      }
                                    }
                                    if (tmp___74) {
                                      tmp___69 = __builtin_strcmp(cmd, "flush_all");
                                      tmp___73 = tmp___69;
                                    } else {
                                      tmp___72 = __builtin_strcmp(cmd, "flush_all");
                                      tmp___73 = tmp___72;
                                    }
                                  } else {
                                    tmp___72 = __builtin_strcmp(cmd, "flush_all");
                                    tmp___73 = tmp___72;
                                  }
                                  if (tmp___73) {
                                    if (0) {
                                      __s1_len___6 = strlen(cmd);
                                      __s2_len___6 = strlen("version");
                                      if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                        goto _L___14;
                                      } else {
                                        if (__s1_len___6 >= 4U) {
                                          _L___14: /* CIL Label */ 
                                          if (! ((unsigned int )((void const   *)("version" + 1)) - (unsigned int )((void const   *)"version") == 1U)) {
                                            tmp___67 = 1;
                                          } else {
                                            if (__s2_len___6 >= 4U) {
                                              tmp___67 = 1;
                                            } else {
                                              tmp___67 = 0;
                                            }
                                          }
                                        } else {
                                          tmp___67 = 0;
                                        }
                                      }
                                      if (tmp___67) {
                                        tmp___62 = __builtin_strcmp(cmd, "version");
                                        tmp___66 = tmp___62;
                                      } else {
                                        tmp___65 = __builtin_strcmp(cmd, "version");
                                        tmp___66 = tmp___65;
                                      }
                                    } else {
                                      tmp___65 = __builtin_strcmp(cmd, "version");
                                      tmp___66 = tmp___65;
                                    }
                                    if (tmp___66) {
                                      if (0) {
                                        __s1_len___5 = strlen(cmd);
                                        __s2_len___5 = strlen("quit");
                                        if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                          goto _L___12;
                                        } else {
                                          if (__s1_len___5 >= 4U) {
                                            _L___12: /* CIL Label */ 
                                            if (! ((unsigned int )((void const   *)("quit" + 1)) - (unsigned int )((void const   *)"quit") == 1U)) {
                                              tmp___60 = 1;
                                            } else {
                                              if (__s2_len___5 >= 4U) {
                                                tmp___60 = 1;
                                              } else {
                                                tmp___60 = 0;
                                              }
                                            }
                                          } else {
                                            tmp___60 = 0;
                                          }
                                        }
                                        if (tmp___60) {
                                          tmp___55 = __builtin_strcmp(cmd, "quit");
                                          tmp___59 = tmp___55;
                                        } else {
                                          tmp___58 = __builtin_strcmp(cmd, "quit");
                                          tmp___59 = tmp___58;
                                        }
                                      } else {
                                        tmp___58 = __builtin_strcmp(cmd, "quit");
                                        tmp___59 = tmp___58;
                                      }
                                      if (tmp___59) {
                                        if (tnum > 2) {
                                          tmp___53 = tcstrfwm((char const   *)*(tokens + 2),
                                                              "HTTP/1.");
                                          if (tmp___53) {
                                            tmp___7 = tcatoi((char const   *)(*(tokens + 2) + 7));
                                            ver = (int )tmp___7;
                                            uri = (char const   *)*(tokens + 1);
                                            tmp___10 = tcstrifwm(uri, "http://");
                                            if (tmp___10) {
                                              tmp___9 = __builtin_strchr((char *)(uri + 7),
                                                                         '/');
                                              pv = (char const   *)tmp___9;
                                              if (pv) {
                                                uri = pv;
                                              }
                                            }
                                            if (0) {
                                              __s1_len___4 = strlen(cmd);
                                              __s2_len___4 = strlen("GET");
                                              if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                goto _L___10;
                                              } else {
                                                if (__s1_len___4 >= 4U) {
                                                  _L___10: /* CIL Label */ 
                                                  if (! ((unsigned int )((void const   *)("GET" + 1)) - (unsigned int )((void const   *)"GET") == 1U)) {
                                                    tmp___52 = 1;
                                                  } else {
                                                    if (__s2_len___4 >= 4U) {
                                                      tmp___52 = 1;
                                                    } else {
                                                      tmp___52 = 0;
                                                    }
                                                  }
                                                } else {
                                                  tmp___52 = 0;
                                                }
                                              }
                                              if (tmp___52) {
                                                tmp___47 = __builtin_strcmp(cmd, "GET");
                                                tmp___51 = tmp___47;
                                              } else {
                                                tmp___50 = __builtin_strcmp(cmd, "GET");
                                                tmp___51 = tmp___50;
                                              }
                                            } else {
                                              tmp___50 = __builtin_strcmp(cmd, "GET");
                                              tmp___51 = tmp___50;
                                            }
                                            if (tmp___51) {
                                              if (0) {
                                                __s1_len___3 = strlen(cmd);
                                                __s2_len___3 = strlen("HEAD");
                                                if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                  goto _L___8;
                                                } else {
                                                  if (__s1_len___3 >= 4U) {
                                                    _L___8: /* CIL Label */ 
                                                    if (! ((unsigned int )((void const   *)("HEAD" + 1)) - (unsigned int )((void const   *)"HEAD") == 1U)) {
                                                      tmp___45 = 1;
                                                    } else {
                                                      if (__s2_len___3 >= 4U) {
                                                        tmp___45 = 1;
                                                      } else {
                                                        tmp___45 = 0;
                                                      }
                                                    }
                                                  } else {
                                                    tmp___45 = 0;
                                                  }
                                                }
                                                if (tmp___45) {
                                                  tmp___40 = __builtin_strcmp(cmd,
                                                                              "HEAD");
                                                  tmp___44 = tmp___40;
                                                } else {
                                                  tmp___43 = __builtin_strcmp(cmd,
                                                                              "HEAD");
                                                  tmp___44 = tmp___43;
                                                }
                                              } else {
                                                tmp___43 = __builtin_strcmp(cmd, "HEAD");
                                                tmp___44 = tmp___43;
                                              }
                                              if (tmp___44) {
                                                if (0) {
                                                  __s1_len___2 = strlen(cmd);
                                                  __s2_len___2 = strlen("PUT");
                                                  if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                    goto _L___6;
                                                  } else {
                                                    if (__s1_len___2 >= 4U) {
                                                      _L___6: /* CIL Label */ 
                                                      if (! ((unsigned int )((void const   *)("PUT" + 1)) - (unsigned int )((void const   *)"PUT") == 1U)) {
                                                        tmp___38 = 1;
                                                      } else {
                                                        if (__s2_len___2 >= 4U) {
                                                          tmp___38 = 1;
                                                        } else {
                                                          tmp___38 = 0;
                                                        }
                                                      }
                                                    } else {
                                                      tmp___38 = 0;
                                                    }
                                                  }
                                                  if (tmp___38) {
                                                    tmp___33 = __builtin_strcmp(cmd,
                                                                                "PUT");
                                                    tmp___37 = tmp___33;
                                                  } else {
                                                    tmp___36 = __builtin_strcmp(cmd,
                                                                                "PUT");
                                                    tmp___37 = tmp___36;
                                                  }
                                                } else {
                                                  tmp___36 = __builtin_strcmp(cmd,
                                                                              "PUT");
                                                  tmp___37 = tmp___36;
                                                }
                                                if (tmp___37) {
                                                  if (0) {
                                                    __s1_len___1 = strlen(cmd);
                                                    __s2_len___1 = strlen("POST");
                                                    if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                      goto _L___4;
                                                    } else {
                                                      if (__s1_len___1 >= 4U) {
                                                        _L___4: /* CIL Label */ 
                                                        if (! ((unsigned int )((void const   *)("POST" + 1)) - (unsigned int )((void const   *)"POST") == 1U)) {
                                                          tmp___31 = 1;
                                                        } else {
                                                          if (__s2_len___1 >= 4U) {
                                                            tmp___31 = 1;
                                                          } else {
                                                            tmp___31 = 0;
                                                          }
                                                        }
                                                      } else {
                                                        tmp___31 = 0;
                                                      }
                                                    }
                                                    if (tmp___31) {
                                                      tmp___26 = __builtin_strcmp(cmd,
                                                                                  "POST");
                                                      tmp___30 = tmp___26;
                                                    } else {
                                                      tmp___29 = __builtin_strcmp(cmd,
                                                                                  "POST");
                                                      tmp___30 = tmp___29;
                                                    }
                                                  } else {
                                                    tmp___29 = __builtin_strcmp(cmd,
                                                                                "POST");
                                                    tmp___30 = tmp___29;
                                                  }
                                                  if (tmp___30) {
                                                    if (0) {
                                                      __s1_len___0 = strlen(cmd);
                                                      __s2_len___0 = strlen("DELETE");
                                                      if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                        goto _L___2;
                                                      } else {
                                                        if (__s1_len___0 >= 4U) {
                                                          _L___2: /* CIL Label */ 
                                                          if (! ((unsigned int )((void const   *)("DELETE" + 1)) - (unsigned int )((void const   *)"DELETE") == 1U)) {
                                                            tmp___24 = 1;
                                                          } else {
                                                            if (__s2_len___0 >= 4U) {
                                                              tmp___24 = 1;
                                                            } else {
                                                              tmp___24 = 0;
                                                            }
                                                          }
                                                        } else {
                                                          tmp___24 = 0;
                                                        }
                                                      }
                                                      if (tmp___24) {
                                                        tmp___19 = __builtin_strcmp(cmd,
                                                                                    "DELETE");
                                                        tmp___23 = tmp___19;
                                                      } else {
                                                        tmp___22 = __builtin_strcmp(cmd,
                                                                                    "DELETE");
                                                        tmp___23 = tmp___22;
                                                      }
                                                    } else {
                                                      tmp___22 = __builtin_strcmp(cmd,
                                                                                  "DELETE");
                                                      tmp___23 = tmp___22;
                                                    }
                                                    if (tmp___23) {
                                                      if (0) {
                                                        __s1_len = strlen(cmd);
                                                        __s2_len = strlen("OPTIONS");
                                                        if (! ((unsigned int )((void const   *)(cmd + 1)) - (unsigned int )((void const   *)cmd) == 1U)) {
                                                          goto _L___0;
                                                        } else {
                                                          if (__s1_len >= 4U) {
                                                            _L___0: /* CIL Label */ 
                                                            if (! ((unsigned int )((void const   *)("OPTIONS" + 1)) - (unsigned int )((void const   *)"OPTIONS") == 1U)) {
                                                              tmp___17 = 1;
                                                            } else {
                                                              if (__s2_len >= 4U) {
                                                                tmp___17 = 1;
                                                              } else {
                                                                tmp___17 = 0;
                                                              }
                                                            }
                                                          } else {
                                                            tmp___17 = 0;
                                                          }
                                                        }
                                                        if (tmp___17) {
                                                          tmp___12 = __builtin_strcmp(cmd,
                                                                                      "OPTIONS");
                                                          tmp___16 = tmp___12;
                                                        } else {
                                                          tmp___15 = __builtin_strcmp(cmd,
                                                                                      "OPTIONS");
                                                          tmp___16 = tmp___15;
                                                        }
                                                      } else {
                                                        tmp___15 = __builtin_strcmp(cmd,
                                                                                    "OPTIONS");
                                                        tmp___16 = tmp___15;
                                                      }
                                                      if (! tmp___16) {
                                                        do_http_options(sock, arg,
                                                                        req, ver,
                                                                        uri);
                                                      }
                                                    } else {
                                                      do_http_delete(sock, arg, req,
                                                                     ver, uri);
                                                    }
                                                  } else {
                                                    do_http_post(sock, arg, req, ver,
                                                                 uri);
                                                  }
                                                } else {
                                                  do_http_put(sock, arg, req, ver,
                                                              uri);
                                                }
                                              } else {
                                                do_http_head(sock, arg, req, ver,
                                                             uri);
                                              }
                                            } else {
                                              do_http_get(sock, arg, req, ver, uri);
                                            }
                                          }
                                        }
                                      } else {
                                        do_mc_quit(sock, arg, req, tokens, tnum);
                                      }
                                    } else {
                                      do_mc_version(sock, arg, req, tokens, tnum);
                                    }
                                  } else {
                                    do_mc_flushall(sock, arg, req, tokens, tnum);
                                  }
                                } else {
                                  do_mc_stats(sock, arg, req, tokens, tnum);
                                }
                              } else {
                                do_mc_decr(sock, arg, req, tokens, tnum);
                              }
                            } else {
                              do_mc_incr(sock, arg, req, tokens, tnum);
                            }
                          } else {
                            do_mc_delete(sock, arg, req, tokens, tnum);
                          }
                        } else {
                          do_mc_get(sock, arg, req, tokens, tnum);
                        }
                      } else {
                        do_mc_get(sock, arg, req, tokens, tnum);
                      }
                    } else {
                      do_mc_replace(sock, arg, req, tokens, tnum);
                    }
                  } else {
                    do_mc_add(sock, arg, req, tokens, tnum);
                  }
                } else {
                  do_mc_set(sock, arg, req, tokens, tnum);
                }
              }
              break;
            }
            __pthread_unregister_cancel(& __cancel_buf___0);
            (*__cancel_routine___do_task)(__cancel_arg___0);
            break;
          }
          break;
        }
        __pthread_unregister_cancel(& __cancel_buf);
        (*__cancel_routine)(__cancel_arg);
        break;
      }
    }
  }
  return;
}
}
static char **tokenize(char *str , int *np ) 
{ int anum ;
  char **tokens ;
  void *tmp ;
  int tnum ;
  void *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
  anum = 256;
  tmp = tcmalloc((unsigned int )((int )sizeof(*tokens) * anum));
  tokens = (char **)tmp;
  tnum = 0;
  while (1) {
    if (! ((int )*str == 32)) {
      if (! ((int )*str == 9)) {
        break;
      }
    }
    str ++;
  }
  while ((int )*str != 0) {
    if (tnum >= anum) {
      anum *= 2;
      tmp___0 = tcrealloc((void *)tokens, (unsigned int )((int )sizeof(*tokens) * anum));
      tokens = (char **)tmp___0;
    }
    tmp___1 = tnum;
    tnum ++;
    *(tokens + tmp___1) = str;
    while (1) {
      if ((int )*str != 0) {
        if ((int )*str != 32) {
          if (! ((int )*str != 9)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      str ++;
    }
    while (1) {
      if (! ((int )*str == 32)) {
        if (! ((int )*str == 9)) {
          break;
        }
      }
      tmp___2 = str;
      str ++;
      *tmp___2 = (char )'\000';
    }
  }
  *np = tnum;
  return (tokens);
}
}
static uint32_t recmtxidx(char const   *kbuf , int ksiz ) 
{ uint32_t hash ;
  char const   *tmp ;
  int tmp___0 ;

  {
  hash = (uint32_t )725;
  while (1) {
    tmp___0 = ksiz;
    ksiz --;
    if (! tmp___0) {
      break;
    }
    tmp = kbuf;
    kbuf ++;
    hash = hash * 29U + (uint32_t )*((uint8_t *)tmp);
  }
  return (hash % 31U);
}
}
static void do_put(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  int ksiz ;
  uint32_t tmp ;
  int vsiz ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  int rsiz ;
  char stack[65536] ;
  char *buf ;
  void *tmp___2 ;
  char *tmp___3 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___4 ;
  int not_first_call ;
  int tmp___5 ;
  long tmp___6 ;
  uint8_t code ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
  ttservlog(g_serv, 0, "doing put command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  tmp = ttsockgetint32(sock);
  ksiz = (int )tmp;
  tmp___0 = ttsockgetint32(sock);
  vsiz = (int )tmp___0;
  tmp___1 = ttsockcheckend(sock);
  if (tmp___1) {
    ttservlog(g_serv, 1, "do_put: invalid parameters");
    return;
  } else {
    if (ksiz < 0) {
      ttservlog(g_serv, 1, "do_put: invalid parameters");
      return;
    } else {
      if (ksiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_put: invalid parameters");
        return;
      } else {
        if (vsiz < 0) {
          ttservlog(g_serv, 1, "do_put: invalid parameters");
          return;
        } else {
          if (vsiz > 32 << 20) {
            ttservlog(g_serv, 1, "do_put: invalid parameters");
            return;
          }
        }
      }
    }
  }
  rsiz = ksiz + vsiz;
  if (rsiz < 65536) {
    tmp___3 = stack;
  } else {
    tmp___2 = tcmalloc((unsigned int )(rsiz + 1));
    tmp___3 = (char *)tmp___2;
  }
  buf = tmp___3;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___4 = (char *)((void *)0);
    } else {
      tmp___4 = buf;
    }
    __cancel_arg = (void *)tmp___4;
    tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___5;
    tmp___6 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___6) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___9 = ttsockrecv(sock, buf, rsiz);
      if (tmp___9) {
        tmp___10 = ttsockcheckend(sock);
        if (tmp___10) {
          ttservlog(g_serv, 1, "do_put: invalid entity");
        } else {
          code = (uint8_t )0;
          if (mask___0 & ((1ULL | (1ULL << 27)) | (1ULL << 31))) {
            code = (unsigned char)1;
            ttservlog(g_serv, 1, "do_put: forbidden");
          } else {
            tmp___7 = tculogadbput(ulog, sid, 0U, adb, (void const   *)buf, ksiz,
                                   (void const   *)(buf + ksiz), vsiz);
            if (! tmp___7) {
              code = (unsigned char)1;
              ttservlog(g_serv, 2, "do_put: operation failed");
            }
          }
          tmp___8 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
          if (tmp___8) {
            req->keep = (_Bool)1;
          } else {
            ttservlog(g_serv, 1, "do_put: response failed");
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_put: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_putkeep(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  int ksiz ;
  uint32_t tmp ;
  int vsiz ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  int rsiz ;
  char stack[65536] ;
  char *buf ;
  void *tmp___2 ;
  char *tmp___3 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___4 ;
  int not_first_call ;
  int tmp___5 ;
  long tmp___6 ;
  uint8_t code ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
  ttservlog(g_serv, 0, "doing putkeep command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  tmp = ttsockgetint32(sock);
  ksiz = (int )tmp;
  tmp___0 = ttsockgetint32(sock);
  vsiz = (int )tmp___0;
  tmp___1 = ttsockcheckend(sock);
  if (tmp___1) {
    ttservlog(g_serv, 1, "do_putkeep: invalid parameters");
    return;
  } else {
    if (ksiz < 0) {
      ttservlog(g_serv, 1, "do_putkeep: invalid parameters");
      return;
    } else {
      if (ksiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_putkeep: invalid parameters");
        return;
      } else {
        if (vsiz < 0) {
          ttservlog(g_serv, 1, "do_putkeep: invalid parameters");
          return;
        } else {
          if (vsiz > 32 << 20) {
            ttservlog(g_serv, 1, "do_putkeep: invalid parameters");
            return;
          }
        }
      }
    }
  }
  rsiz = ksiz + vsiz;
  if (rsiz < 65536) {
    tmp___3 = stack;
  } else {
    tmp___2 = tcmalloc((unsigned int )(rsiz + 1));
    tmp___3 = (char *)tmp___2;
  }
  buf = tmp___3;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___4 = (char *)((void *)0);
    } else {
      tmp___4 = buf;
    }
    __cancel_arg = (void *)tmp___4;
    tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___5;
    tmp___6 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___6) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___9 = ttsockrecv(sock, buf, rsiz);
      if (tmp___9) {
        tmp___10 = ttsockcheckend(sock);
        if (tmp___10) {
          ttservlog(g_serv, 1, "do_putkeep: invalid entity");
        } else {
          code = (uint8_t )0;
          if (mask___0 & (((1ULL << 1) | (1ULL << 27)) | (1ULL << 31))) {
            code = (unsigned char)1;
            ttservlog(g_serv, 1, "do_putkeep: forbidden");
          } else {
            tmp___7 = tculogadbputkeep(ulog, sid, 0U, adb, (void const   *)buf, ksiz,
                                       (void const   *)(buf + ksiz), vsiz);
            if (! tmp___7) {
              code = (unsigned char)1;
            }
          }
          tmp___8 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
          if (tmp___8) {
            req->keep = (_Bool)1;
          } else {
            ttservlog(g_serv, 1, "do_putkeep: response failed");
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_putkeep: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_putcat(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  int ksiz ;
  uint32_t tmp ;
  int vsiz ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  int rsiz ;
  char stack[65536] ;
  char *buf ;
  void *tmp___2 ;
  char *tmp___3 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___4 ;
  int not_first_call ;
  int tmp___5 ;
  long tmp___6 ;
  uint8_t code ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
  ttservlog(g_serv, 0, "doing putcat command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  tmp = ttsockgetint32(sock);
  ksiz = (int )tmp;
  tmp___0 = ttsockgetint32(sock);
  vsiz = (int )tmp___0;
  tmp___1 = ttsockcheckend(sock);
  if (tmp___1) {
    ttservlog(g_serv, 1, "do_putcat: invalid parameters");
    return;
  } else {
    if (ksiz < 0) {
      ttservlog(g_serv, 1, "do_putcat: invalid parameters");
      return;
    } else {
      if (ksiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_putcat: invalid parameters");
        return;
      } else {
        if (vsiz < 0) {
          ttservlog(g_serv, 1, "do_putcat: invalid parameters");
          return;
        } else {
          if (vsiz > 32 << 20) {
            ttservlog(g_serv, 1, "do_putcat: invalid parameters");
            return;
          }
        }
      }
    }
  }
  rsiz = ksiz + vsiz;
  if (rsiz < 65536) {
    tmp___3 = stack;
  } else {
    tmp___2 = tcmalloc((unsigned int )(rsiz + 1));
    tmp___3 = (char *)tmp___2;
  }
  buf = tmp___3;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___4 = (char *)((void *)0);
    } else {
      tmp___4 = buf;
    }
    __cancel_arg = (void *)tmp___4;
    tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___5;
    tmp___6 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___6) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___9 = ttsockrecv(sock, buf, rsiz);
      if (tmp___9) {
        tmp___10 = ttsockcheckend(sock);
        if (tmp___10) {
          ttservlog(g_serv, 1, "do_putcat: invalid entity");
        } else {
          code = (uint8_t )0;
          if (mask___0 & (((1ULL << 2) | (1ULL << 27)) | (1ULL << 31))) {
            code = (unsigned char)1;
            ttservlog(g_serv, 1, "do_putcat: forbidden");
          } else {
            tmp___7 = tculogadbputcat(ulog, sid, 0U, adb, (void const   *)buf, ksiz,
                                      (void const   *)(buf + ksiz), vsiz);
            if (! tmp___7) {
              code = (unsigned char)1;
              ttservlog(g_serv, 2, "do_putcat: operation failed");
            }
          }
          tmp___8 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
          if (tmp___8) {
            req->keep = (_Bool)1;
          } else {
            ttservlog(g_serv, 1, "do_putcat: response failed");
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_putcat: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_putshl(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  pthread_mutex_t *rmtxs ;
  int ksiz ;
  uint32_t tmp ;
  int vsiz ;
  uint32_t tmp___0 ;
  int width ;
  uint32_t tmp___1 ;
  _Bool tmp___2 ;
  int rsiz ;
  char stack[65536] ;
  char *buf ;
  void *tmp___3 ;
  char *tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___5 ;
  int not_first_call ;
  int tmp___6 ;
  long tmp___7 ;
  uint8_t code ;
  int mtxidx ;
  uint32_t tmp___8 ;
  int osiz ;
  char *obuf ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  char const   *nbuf ;
  int nsiz ;
  _Bool tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;

  {
  ttservlog(g_serv, 0, "doing putshl command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  rmtxs = arg->rmtxs;
  tmp = ttsockgetint32(sock);
  ksiz = (int )tmp;
  tmp___0 = ttsockgetint32(sock);
  vsiz = (int )tmp___0;
  tmp___1 = ttsockgetint32(sock);
  width = (int )tmp___1;
  tmp___2 = ttsockcheckend(sock);
  if (tmp___2) {
    ttservlog(g_serv, 1, "do_putshl: invalid parameters");
    return;
  } else {
    if (ksiz < 0) {
      ttservlog(g_serv, 1, "do_putshl: invalid parameters");
      return;
    } else {
      if (ksiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_putshl: invalid parameters");
        return;
      } else {
        if (vsiz < 0) {
          ttservlog(g_serv, 1, "do_putshl: invalid parameters");
          return;
        } else {
          if (vsiz > 32 << 20) {
            ttservlog(g_serv, 1, "do_putshl: invalid parameters");
            return;
          } else {
            if (width < 0) {
              ttservlog(g_serv, 1, "do_putshl: invalid parameters");
              return;
            }
          }
        }
      }
    }
  }
  rsiz = ksiz + vsiz;
  if (rsiz < 65536) {
    tmp___4 = stack;
  } else {
    tmp___3 = tcmalloc((unsigned int )(rsiz + 1));
    tmp___4 = (char *)tmp___3;
  }
  buf = tmp___4;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___5 = (char *)((void *)0);
    } else {
      tmp___5 = buf;
    }
    __cancel_arg = (void *)tmp___5;
    tmp___6 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___6;
    tmp___7 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___7) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___16 = ttsockrecv(sock, buf, rsiz);
      if (tmp___16) {
        tmp___17 = ttsockcheckend(sock);
        if (tmp___17) {
          ttservlog(g_serv, 1, "do_putshl: invalid entity");
        } else {
          code = (uint8_t )0;
          tmp___8 = recmtxidx((char const   *)buf, ksiz);
          mtxidx = (int )tmp___8;
          if (mask___0 & (((1ULL << 3) | (1ULL << 27)) | (1ULL << 31))) {
            code = (unsigned char)1;
            ttservlog(g_serv, 1, "do_putshl: forbidden");
          } else {
            tmp___14 = pthread_mutex_lock(rmtxs + mtxidx);
            if (tmp___14 == 0) {
              tmp___9 = tcadbget(adb, (void const   *)buf, ksiz, & osiz);
              obuf = (char *)tmp___9;
              if (obuf) {
                tmp___10 = tcrealloc((void *)obuf, (unsigned int )(osiz + vsiz));
                obuf = (char *)tmp___10;
                memcpy((void * __restrict  )(obuf + osiz), (void const   * __restrict  )(buf + ksiz),
                       (unsigned int )vsiz);
                osiz += vsiz;
              } else {
                tmp___11 = tcmalloc((unsigned int )(vsiz + 1));
                obuf = (char *)tmp___11;
                memcpy((void * __restrict  )obuf, (void const   * __restrict  )(buf + ksiz),
                       (unsigned int )vsiz);
                osiz = vsiz;
              }
              if (osiz <= width) {
                nbuf = (char const   *)obuf;
                nsiz = osiz;
              } else {
                nbuf = (char const   *)((obuf + osiz) - width);
                nsiz = width;
              }
              tmp___12 = tculogadbput(ulog, sid, 0U, adb, (void const   *)buf, ksiz,
                                      (void const   *)nbuf, nsiz);
              if (! tmp___12) {
                code = (unsigned char)1;
                ttservlog(g_serv, 2, "do_putshl: operation failed");
              }
              tcfree((void *)obuf);
              tmp___13 = pthread_mutex_unlock(rmtxs + mtxidx);
              if (tmp___13 != 0) {
                ttservlog(g_serv, 2, "do_putshl: pthread_mutex_unlock failed");
              }
            } else {
              code = (unsigned char)1;
              ttservlog(g_serv, 2, "do_putshl: pthread_mutex_lock failed");
            }
          }
          tmp___15 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
          if (tmp___15) {
            req->keep = (_Bool)1;
          } else {
            ttservlog(g_serv, 1, "do_putshl: response failed");
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_putshl: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_putnr(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  int ksiz ;
  uint32_t tmp ;
  int vsiz ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  int rsiz ;
  char stack[65536] ;
  char *buf ;
  void *tmp___2 ;
  char *tmp___3 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___4 ;
  int not_first_call ;
  int tmp___5 ;
  long tmp___6 ;
  uint8_t code ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;

  {
  ttservlog(g_serv, 0, "doing putnr command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  tmp = ttsockgetint32(sock);
  ksiz = (int )tmp;
  tmp___0 = ttsockgetint32(sock);
  vsiz = (int )tmp___0;
  tmp___1 = ttsockcheckend(sock);
  if (tmp___1) {
    ttservlog(g_serv, 1, "do_putnr: invalid parameters");
    return;
  } else {
    if (ksiz < 0) {
      ttservlog(g_serv, 1, "do_putnr: invalid parameters");
      return;
    } else {
      if (ksiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_putnr: invalid parameters");
        return;
      } else {
        if (vsiz < 0) {
          ttservlog(g_serv, 1, "do_putnr: invalid parameters");
          return;
        } else {
          if (vsiz > 32 << 20) {
            ttservlog(g_serv, 1, "do_putnr: invalid parameters");
            return;
          }
        }
      }
    }
  }
  rsiz = ksiz + vsiz;
  if (rsiz < 65536) {
    tmp___3 = stack;
  } else {
    tmp___2 = tcmalloc((unsigned int )(rsiz + 1));
    tmp___3 = (char *)tmp___2;
  }
  buf = tmp___3;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___4 = (char *)((void *)0);
    } else {
      tmp___4 = buf;
    }
    __cancel_arg = (void *)tmp___4;
    tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___5;
    tmp___6 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___6) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___8 = ttsockrecv(sock, buf, rsiz);
      if (tmp___8) {
        tmp___9 = ttsockcheckend(sock);
        if (tmp___9) {
          ttservlog(g_serv, 1, "do_putnr: invalid entity");
        } else {
          code = (uint8_t )0;
          if (mask___0 & (((1ULL << 4) | (1ULL << 27)) | (1ULL << 31))) {
            code = (unsigned char)1;
            ttservlog(g_serv, 1, "do_putnr: forbidden");
          } else {
            tmp___7 = tculogadbput(ulog, sid, 0U, adb, (void const   *)buf, ksiz,
                                   (void const   *)(buf + ksiz), vsiz);
            if (! tmp___7) {
              code = (unsigned char)1;
              ttservlog(g_serv, 2, "do_putnr: operation failed");
            }
          }
          req->keep = (_Bool)1;
        }
      } else {
        ttservlog(g_serv, 1, "do_putnr: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_out(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  int ksiz ;
  uint32_t tmp ;
  _Bool tmp___0 ;
  char stack[65536] ;
  char *buf ;
  void *tmp___1 ;
  char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___3 ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  uint8_t code ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;

  {
  ttservlog(g_serv, 0, "doing out command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  tmp = ttsockgetint32(sock);
  ksiz = (int )tmp;
  tmp___0 = ttsockcheckend(sock);
  if (tmp___0) {
    ttservlog(g_serv, 1, "do_out: invalid parameters");
    return;
  } else {
    if (ksiz < 0) {
      ttservlog(g_serv, 1, "do_out: invalid parameters");
      return;
    } else {
      if (ksiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_out: invalid parameters");
        return;
      }
    }
  }
  if (ksiz < 65536) {
    tmp___2 = stack;
  } else {
    tmp___1 = tcmalloc((unsigned int )(ksiz + 1));
    tmp___2 = (char *)tmp___1;
  }
  buf = tmp___2;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___3 = (char *)((void *)0);
    } else {
      tmp___3 = buf;
    }
    __cancel_arg = (void *)tmp___3;
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___4;
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___5) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___8 = ttsockrecv(sock, buf, ksiz);
      if (tmp___8) {
        tmp___9 = ttsockcheckend(sock);
        if (tmp___9) {
          ttservlog(g_serv, 1, "do_out: invalid entity");
        } else {
          code = (uint8_t )0;
          if (mask___0 & (((1ULL << 5) | (1ULL << 27)) | (1ULL << 31))) {
            code = (unsigned char)1;
            ttservlog(g_serv, 1, "do_out: forbidden");
          } else {
            tmp___6 = tculogadbout(ulog, sid, 0U, adb, (void const   *)buf, ksiz);
            if (! tmp___6) {
              code = (unsigned char)1;
            }
          }
          tmp___7 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
          if (tmp___7) {
            req->keep = (_Bool)1;
          } else {
            ttservlog(g_serv, 1, "do_out: response failed");
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_out: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_get(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  int ksiz ;
  uint32_t tmp ;
  _Bool tmp___0 ;
  char stack[65536] ;
  char *buf ;
  void *tmp___1 ;
  char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___3 ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  char *vbuf ;
  int vsiz ;
  void *tmp___6 ;
  int rsiz ;
  char *rbuf ;
  void *tmp___7 ;
  char *tmp___8 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_get)(void * ) ;
  void *__cancel_arg___0 ;
  char *tmp___9 ;
  int not_first_call___0 ;
  int tmp___10 ;
  long tmp___11 ;
  uint32_t num ;
  _Bool tmp___12 ;
  uint8_t code ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;

  {
  ttservlog(g_serv, 0, "doing get command");
  mask___0 = arg->mask;
  adb = arg->adb;
  tmp = ttsockgetint32(sock);
  ksiz = (int )tmp;
  tmp___0 = ttsockcheckend(sock);
  if (tmp___0) {
    ttservlog(g_serv, 1, "do_get: invalid parameters");
    return;
  } else {
    if (ksiz < 0) {
      ttservlog(g_serv, 1, "do_get: invalid parameters");
      return;
    } else {
      if (ksiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_get: invalid parameters");
        return;
      }
    }
  }
  if (ksiz < 65536) {
    tmp___2 = stack;
  } else {
    tmp___1 = tcmalloc((unsigned int )(ksiz + 1));
    tmp___2 = (char *)tmp___1;
  }
  buf = tmp___2;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___3 = (char *)((void *)0);
    } else {
      tmp___3 = buf;
    }
    __cancel_arg = (void *)tmp___3;
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___4;
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___5) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___14 = ttsockrecv(sock, buf, ksiz);
      if (tmp___14) {
        tmp___15 = ttsockcheckend(sock);
        if (tmp___15) {
          ttservlog(g_serv, 1, "do_get: invalid entity");
        } else {
          if (mask___0 & (((1ULL << 6) | (1ULL << 27)) | (1ULL << 30))) {
            vbuf = (char *)((void *)0);
            vsiz = 0;
            ttservlog(g_serv, 1, "do_get: forbidden");
          } else {
            tmp___6 = tcadbget(adb, (void const   *)buf, ksiz, & vsiz);
            vbuf = (char *)tmp___6;
          }
          if (vbuf) {
            rsiz = (vsiz + (int )sizeof(uint8_t )) + (int )sizeof(uint32_t );
            if (rsiz < 65536) {
              tmp___8 = stack;
            } else {
              tmp___7 = tcmalloc((unsigned int )rsiz);
              tmp___8 = (char *)tmp___7;
            }
            rbuf = tmp___8;
            while (1) {
              __cancel_routine___do_get = & free;
              if ((unsigned int )rbuf == (unsigned int )(stack)) {
                tmp___9 = (char *)((void *)0);
              } else {
                tmp___9 = rbuf;
              }
              __cancel_arg___0 = (void *)tmp___9;
              tmp___10 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                                     0);
              not_first_call___0 = tmp___10;
              tmp___11 = __builtin_expect((long )not_first_call___0, 0L);
              if (tmp___11) {
                (*__cancel_routine___do_get)(__cancel_arg___0);
                __pthread_unwind_next(& __cancel_buf___0);
              }
              __pthread_register_cancel(& __cancel_buf___0);
              while (1) {
                *rbuf = (char)0;
                num = (unsigned int )((((((unsigned long )((unsigned int )vsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )vsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )vsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )vsiz) & 4278190080UL) >> 24));
                memcpy((void * __restrict  )(rbuf + (int )sizeof(uint8_t )), (void const   * __restrict  )(& num),
                       (unsigned int )((int )sizeof(uint32_t )));
                memcpy((void * __restrict  )((rbuf + (int )sizeof(uint8_t )) + (int )sizeof(uint32_t )),
                       (void const   * __restrict  )vbuf, (unsigned int )vsiz);
                tcfree((void *)vbuf);
                tmp___12 = ttsocksend(sock, (void const   *)rbuf, rsiz);
                if (tmp___12) {
                  req->keep = (_Bool)1;
                } else {
                  ttservlog(g_serv, 1, "do_get: response failed");
                }
                break;
              }
              __pthread_unregister_cancel(& __cancel_buf___0);
              (*__cancel_routine___do_get)(__cancel_arg___0);
              break;
            }
          } else {
            code = (uint8_t )1;
            tmp___13 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
            if (tmp___13) {
              req->keep = (_Bool)1;
            } else {
              ttservlog(g_serv, 1, "do_get: response failed");
            }
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_get: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_mget(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  int rnum ;
  uint32_t tmp ;
  _Bool tmp___0 ;
  TCLIST *keys ;
  TCLIST *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___2 ;
  long tmp___3 ;
  char stack[65536] ;
  int i ;
  int ksiz ;
  uint32_t tmp___4 ;
  _Bool tmp___5 ;
  char *buf ;
  void *tmp___6 ;
  char *tmp___7 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_mget)(void * ) ;
  void *__cancel_arg___0 ;
  char *tmp___8 ;
  int not_first_call___0 ;
  int tmp___9 ;
  long tmp___10 ;
  _Bool tmp___11 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___12 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___13 ;
  long tmp___14 ;
  uint8_t code ;
  uint32_t num ;
  int i___0 ;
  int ksiz___0 ;
  char const   *kbuf ;
  void const   *tmp___15 ;
  int vsiz ;
  char *vbuf ;
  void *tmp___16 ;
  int tmp___17 ;
  void const   *tmp___18 ;
  int tmp___19 ;
  void const   *tmp___20 ;
  _Bool tmp___21 ;
  _Bool tmp___22 ;

  {
  ttservlog(g_serv, 0, "doing mget command");
  mask___0 = arg->mask;
  adb = arg->adb;
  tmp = ttsockgetint32(sock);
  rnum = (int )tmp;
  tmp___0 = ttsockcheckend(sock);
  if (tmp___0) {
    ttservlog(g_serv, 1, "do_mget: invalid parameters");
    return;
  } else {
    if (rnum < 0) {
      ttservlog(g_serv, 1, "do_mget: invalid parameters");
      return;
    } else {
      if (rnum > 1 << 20) {
        ttservlog(g_serv, 1, "do_mget: invalid parameters");
        return;
      }
    }
  }
  tmp___1 = tclistnew2(rnum);
  keys = tmp___1;
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tclistdel);
    __cancel_arg = (void *)keys;
    tmp___2 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___2;
    tmp___3 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___3) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      i = 0;
      while (i < rnum) {
        tmp___4 = ttsockgetint32(sock);
        ksiz = (int )tmp___4;
        tmp___5 = ttsockcheckend(sock);
        if (tmp___5) {
          break;
        } else {
          if (ksiz < 0) {
            break;
          } else {
            if (ksiz > 32 << 20) {
              break;
            }
          }
        }
        if (ksiz < 65536) {
          tmp___7 = stack;
        } else {
          tmp___6 = tcmalloc((unsigned int )(ksiz + 1));
          tmp___7 = (char *)tmp___6;
        }
        buf = tmp___7;
        while (1) {
          __cancel_routine___do_mget = & free;
          if ((unsigned int )buf == (unsigned int )(stack)) {
            tmp___8 = (char *)((void *)0);
          } else {
            tmp___8 = buf;
          }
          __cancel_arg___0 = (void *)tmp___8;
          tmp___9 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                                0);
          not_first_call___0 = tmp___9;
          tmp___10 = __builtin_expect((long )not_first_call___0, 0L);
          if (tmp___10) {
            (*__cancel_routine___do_mget)(__cancel_arg___0);
            __pthread_unwind_next(& __cancel_buf___0);
          }
          __pthread_register_cancel(& __cancel_buf___0);
          while (1) {
            tmp___11 = ttsockrecv(sock, buf, ksiz);
            if (tmp___11) {
              tclistpush(keys, (void const   *)buf, ksiz);
            }
            break;
          }
          __pthread_unregister_cancel(& __cancel_buf___0);
          (*__cancel_routine___do_mget)(__cancel_arg___0);
          break;
        }
        i ++;
      }
      tmp___22 = ttsockcheckend(sock);
      if (tmp___22) {
        ttservlog(g_serv, 1, "do_mget: invalid entity");
      } else {
        tmp___12 = tcxstrnew();
        xstr = tmp___12;
        while (1) {
          __cancel_routine___1 = (void (*)(void * ))(& tcxstrdel);
          __cancel_arg___1 = (void *)xstr;
          tmp___13 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf)),
                                 0);
          not_first_call___1 = tmp___13;
          tmp___14 = __builtin_expect((long )not_first_call___1, 0L);
          if (tmp___14) {
            (*__cancel_routine___1)(__cancel_arg___1);
            __pthread_unwind_next(& __cancel_buf___1);
          }
          __pthread_register_cancel(& __cancel_buf___1);
          while (1) {
            code = (uint8_t )0;
            tcxstrcat(xstr, (void const   *)(& code), (int )sizeof(code));
            num = (uint32_t )0;
            tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
            rnum = 0;
            if (mask___0 & (((1ULL << 7) | (1ULL << 27)) | (1ULL << 30))) {
              ttservlog(g_serv, 1, "do_mget: forbidden");
            } else {
              i___0 = 0;
              while (1) {
                tmp___17 = tclistnum((TCLIST const   *)keys);
                if (! (i___0 < tmp___17)) {
                  break;
                }
                tmp___15 = tclistval((TCLIST const   *)keys, i___0, & ksiz___0);
                kbuf = (char const   *)tmp___15;
                tmp___16 = tcadbget(adb, (void const   *)kbuf, ksiz___0, & vsiz);
                vbuf = (char *)tmp___16;
                if (vbuf) {
                  num = (unsigned int )((((((unsigned long )((unsigned int )ksiz___0) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz___0) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz___0) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz___0) & 4278190080UL) >> 24));
                  tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
                  num = (unsigned int )((((((unsigned long )((unsigned int )vsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )vsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )vsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )vsiz) & 4278190080UL) >> 24));
                  tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
                  tcxstrcat(xstr, (void const   *)kbuf, ksiz___0);
                  tcxstrcat(xstr, (void const   *)vbuf, vsiz);
                  tcfree((void *)vbuf);
                  rnum ++;
                }
                i___0 ++;
              }
            }
            num = (unsigned int )((((((unsigned long )((unsigned int )rnum) & 255UL) << 24) | (((unsigned long )((unsigned int )rnum) & 65280UL) << 8)) | (((unsigned long )((unsigned int )rnum) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )rnum) & 4278190080UL) >> 24));
            tmp___18 = tcxstrptr((TCXSTR const   *)xstr);
            memcpy((void * __restrict  )((char *)tmp___18 + (int )sizeof(code)), (void const   * __restrict  )(& num),
                   (unsigned int )((int )sizeof(num)));
            tmp___19 = tcxstrsize((TCXSTR const   *)xstr);
            tmp___20 = tcxstrptr((TCXSTR const   *)xstr);
            tmp___21 = ttsocksend(sock, tmp___20, tmp___19);
            if (tmp___21) {
              req->keep = (_Bool)1;
            } else {
              ttservlog(g_serv, 1, "do_mget: response failed");
            }
            break;
          }
          __pthread_unregister_cancel(& __cancel_buf___1);
          (*__cancel_routine___1)(__cancel_arg___1);
          break;
        }
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_vsiz(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  int ksiz ;
  uint32_t tmp ;
  _Bool tmp___0 ;
  char stack[65536] ;
  char *buf ;
  void *tmp___1 ;
  char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___3 ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  int vsiz ;
  uint32_t num ;
  _Bool tmp___6 ;
  uint8_t code ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;

  {
  ttservlog(g_serv, 0, "doing vsiz command");
  mask___0 = arg->mask;
  adb = arg->adb;
  tmp = ttsockgetint32(sock);
  ksiz = (int )tmp;
  tmp___0 = ttsockcheckend(sock);
  if (tmp___0) {
    ttservlog(g_serv, 1, "do_vsiz: invalid parameters");
    return;
  } else {
    if (ksiz < 0) {
      ttservlog(g_serv, 1, "do_vsiz: invalid parameters");
      return;
    } else {
      if (ksiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_vsiz: invalid parameters");
        return;
      }
    }
  }
  if (ksiz < 65536) {
    tmp___2 = stack;
  } else {
    tmp___1 = tcmalloc((unsigned int )(ksiz + 1));
    tmp___2 = (char *)tmp___1;
  }
  buf = tmp___2;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___3 = (char *)((void *)0);
    } else {
      tmp___3 = buf;
    }
    __cancel_arg = (void *)tmp___3;
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___4;
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___5) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___8 = ttsockrecv(sock, buf, ksiz);
      if (tmp___8) {
        tmp___9 = ttsockcheckend(sock);
        if (tmp___9) {
          ttservlog(g_serv, 1, "do_vsiz: invalid entity");
        } else {
          if (mask___0 & (((1ULL << 8) | (1ULL << 27)) | (1ULL << 30))) {
            vsiz = -1;
            ttservlog(g_serv, 1, "do_vsiz: forbidden");
          } else {
            vsiz = tcadbvsiz(adb, (void const   *)buf, ksiz);
          }
          if (vsiz >= 0) {
            stack[0] = (char)0;
            num = (unsigned int )((((((unsigned long )((unsigned int )vsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )vsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )vsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )vsiz) & 4278190080UL) >> 24));
            memcpy((void * __restrict  )(stack + (int )sizeof(uint8_t )), (void const   * __restrict  )(& num),
                   (unsigned int )((int )sizeof(uint32_t )));
            tmp___6 = ttsocksend(sock, (void const   *)(stack), (int )sizeof(uint8_t ) + (int )sizeof(uint32_t ));
            if (tmp___6) {
              req->keep = (_Bool)1;
            } else {
              ttservlog(g_serv, 1, "do_vsiz: response failed");
            }
          } else {
            code = (uint8_t )1;
            tmp___7 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
            if (tmp___7) {
              req->keep = (_Bool)1;
            } else {
              ttservlog(g_serv, 1, "do_vsiz: response failed");
            }
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_vsiz: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_iterinit(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  uint8_t code ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  ttservlog(g_serv, 0, "doing iterinit command");
  mask___0 = arg->mask;
  adb = arg->adb;
  code = (uint8_t )0;
  if (mask___0 & (((1ULL << 9) | (1ULL << 27)) | (1ULL << 30))) {
    code = (unsigned char)1;
    ttservlog(g_serv, 1, "do_iterinit: forbidden");
  } else {
    tmp = tcadbiterinit(adb);
    if (! tmp) {
      code = (unsigned char)1;
      ttservlog(g_serv, 2, "do_iterinit: operation failed");
    }
  }
  tmp___0 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
  if (tmp___0) {
    req->keep = (_Bool)1;
  } else {
    ttservlog(g_serv, 1, "do_iterinit: response failed");
  }
  return;
}
}
static void do_iternext(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  int vsiz ;
  char *vbuf ;
  void *tmp ;
  int rsiz ;
  char stack[65536] ;
  char *rbuf ;
  void *tmp___0 ;
  char *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___2 ;
  int not_first_call ;
  int tmp___3 ;
  long tmp___4 ;
  uint32_t num ;
  _Bool tmp___5 ;
  uint8_t code ;
  _Bool tmp___6 ;

  {
  ttservlog(g_serv, 0, "doing iternext command");
  mask___0 = arg->mask;
  adb = arg->adb;
  if (mask___0 & (((1ULL << 10) | (1ULL << 27)) | (1ULL << 30))) {
    vbuf = (char *)((void *)0);
    vsiz = 0;
    ttservlog(g_serv, 1, "do_iternext: forbidden");
  } else {
    tmp = tcadbiternext(adb, & vsiz);
    vbuf = (char *)tmp;
  }
  if (vbuf) {
    rsiz = (vsiz + (int )sizeof(uint8_t )) + (int )sizeof(uint32_t );
    if (rsiz < 65536) {
      tmp___1 = stack;
    } else {
      tmp___0 = tcmalloc((unsigned int )rsiz);
      tmp___1 = (char *)tmp___0;
    }
    rbuf = tmp___1;
    while (1) {
      __cancel_routine = & free;
      if ((unsigned int )rbuf == (unsigned int )(stack)) {
        tmp___2 = (char *)((void *)0);
      } else {
        tmp___2 = rbuf;
      }
      __cancel_arg = (void *)tmp___2;
      tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                            0);
      not_first_call = tmp___3;
      tmp___4 = __builtin_expect((long )not_first_call, 0L);
      if (tmp___4) {
        (*__cancel_routine)(__cancel_arg);
        __pthread_unwind_next(& __cancel_buf);
      }
      __pthread_register_cancel(& __cancel_buf);
      while (1) {
        *rbuf = (char)0;
        num = (unsigned int )((((((unsigned long )((unsigned int )vsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )vsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )vsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )vsiz) & 4278190080UL) >> 24));
        memcpy((void * __restrict  )(rbuf + (int )sizeof(uint8_t )), (void const   * __restrict  )(& num),
               (unsigned int )((int )sizeof(uint32_t )));
        memcpy((void * __restrict  )((rbuf + (int )sizeof(uint8_t )) + (int )sizeof(uint32_t )),
               (void const   * __restrict  )vbuf, (unsigned int )vsiz);
        tcfree((void *)vbuf);
        tmp___5 = ttsocksend(sock, (void const   *)rbuf, rsiz);
        if (tmp___5) {
          req->keep = (_Bool)1;
        } else {
          ttservlog(g_serv, 1, "do_iternext: response failed");
        }
        break;
      }
      __pthread_unregister_cancel(& __cancel_buf);
      (*__cancel_routine)(__cancel_arg);
      break;
    }
  } else {
    code = (uint8_t )1;
    tmp___6 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
    if (tmp___6) {
      req->keep = (_Bool)1;
    } else {
      ttservlog(g_serv, 1, "do_iternext: response failed");
    }
  }
  return;
}
}
static void do_fwmkeys(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  int psiz ;
  uint32_t tmp ;
  int max ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  char stack[65536] ;
  char *buf ;
  void *tmp___2 ;
  char *tmp___3 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___4 ;
  int not_first_call ;
  int tmp___5 ;
  long tmp___6 ;
  TCLIST *keys ;
  TCLIST *tmp___7 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_fwmkeys)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___8 ;
  long tmp___9 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___10 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___11 ;
  long tmp___12 ;
  uint8_t code ;
  uint32_t num ;
  int knum ;
  int i ;
  int ksiz ;
  char const   *kbuf ;
  void const   *tmp___13 ;
  int tmp___14 ;
  void const   *tmp___15 ;
  int tmp___16 ;
  void const   *tmp___17 ;
  _Bool tmp___18 ;
  _Bool tmp___19 ;
  _Bool tmp___20 ;

  {
  ttservlog(g_serv, 0, "doing fwmkeys command");
  mask___0 = arg->mask;
  adb = arg->adb;
  tmp = ttsockgetint32(sock);
  psiz = (int )tmp;
  tmp___0 = ttsockgetint32(sock);
  max = (int )tmp___0;
  tmp___1 = ttsockcheckend(sock);
  if (tmp___1) {
    ttservlog(g_serv, 1, "do_fwmkeys: invalid parameters");
    return;
  } else {
    if (psiz < 0) {
      ttservlog(g_serv, 1, "do_fwmkeys: invalid parameters");
      return;
    } else {
      if (psiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_fwmkeys: invalid parameters");
        return;
      }
    }
  }
  if (psiz < 65536) {
    tmp___3 = stack;
  } else {
    tmp___2 = tcmalloc((unsigned int )(psiz + 1));
    tmp___3 = (char *)tmp___2;
  }
  buf = tmp___3;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___4 = (char *)((void *)0);
    } else {
      tmp___4 = buf;
    }
    __cancel_arg = (void *)tmp___4;
    tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___5;
    tmp___6 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___6) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___19 = ttsockrecv(sock, buf, psiz);
      if (tmp___19) {
        tmp___20 = ttsockcheckend(sock);
        if (tmp___20) {
          ttservlog(g_serv, 1, "do_fwmkeys: invalid entity");
        } else {
          tmp___7 = tcadbfwmkeys(adb, (void const   *)buf, psiz, max);
          keys = tmp___7;
          while (1) {
            __cancel_routine___do_fwmkeys = (void (*)(void * ))(& tclistdel);
            __cancel_arg___0 = (void *)keys;
            tmp___8 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                                  0);
            not_first_call___0 = tmp___8;
            tmp___9 = __builtin_expect((long )not_first_call___0, 0L);
            if (tmp___9) {
              (*__cancel_routine___do_fwmkeys)(__cancel_arg___0);
              __pthread_unwind_next(& __cancel_buf___0);
            }
            __pthread_register_cancel(& __cancel_buf___0);
            while (1) {
              tmp___10 = tcxstrnew();
              xstr = tmp___10;
              while (1) {
                __cancel_routine___1 = (void (*)(void * ))(& tcxstrdel);
                __cancel_arg___1 = (void *)xstr;
                tmp___11 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf)),
                                       0);
                not_first_call___1 = tmp___11;
                tmp___12 = __builtin_expect((long )not_first_call___1, 0L);
                if (tmp___12) {
                  (*__cancel_routine___1)(__cancel_arg___1);
                  __pthread_unwind_next(& __cancel_buf___1);
                }
                __pthread_register_cancel(& __cancel_buf___1);
                while (1) {
                  code = (uint8_t )0;
                  tcxstrcat(xstr, (void const   *)(& code), (int )sizeof(code));
                  num = (uint32_t )0;
                  tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
                  knum = 0;
                  if (mask___0 & (((1ULL << 11) | (1ULL << 27)) | (1ULL << 30))) {
                    ttservlog(g_serv, 1, "do_fwmkeys: forbidden");
                  } else {
                    i = 0;
                    while (1) {
                      tmp___14 = tclistnum((TCLIST const   *)keys);
                      if (! (i < tmp___14)) {
                        break;
                      }
                      tmp___13 = tclistval((TCLIST const   *)keys, i, & ksiz);
                      kbuf = (char const   *)tmp___13;
                      num = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
                      tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
                      tcxstrcat(xstr, (void const   *)kbuf, ksiz);
                      knum ++;
                      i ++;
                    }
                  }
                  num = (unsigned int )((((((unsigned long )((unsigned int )knum) & 255UL) << 24) | (((unsigned long )((unsigned int )knum) & 65280UL) << 8)) | (((unsigned long )((unsigned int )knum) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )knum) & 4278190080UL) >> 24));
                  tmp___15 = tcxstrptr((TCXSTR const   *)xstr);
                  memcpy((void * __restrict  )((char *)tmp___15 + (int )sizeof(code)),
                         (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(num)));
                  tmp___16 = tcxstrsize((TCXSTR const   *)xstr);
                  tmp___17 = tcxstrptr((TCXSTR const   *)xstr);
                  tmp___18 = ttsocksend(sock, tmp___17, tmp___16);
                  if (tmp___18) {
                    req->keep = (_Bool)1;
                  } else {
                    ttservlog(g_serv, 1, "do_fwmkeys: response failed");
                  }
                  break;
                }
                __pthread_unregister_cancel(& __cancel_buf___1);
                (*__cancel_routine___1)(__cancel_arg___1);
                break;
              }
              break;
            }
            __pthread_unregister_cancel(& __cancel_buf___0);
            (*__cancel_routine___do_fwmkeys)(__cancel_arg___0);
            break;
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_fwmkeys: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_addint(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  int ksiz ;
  uint32_t tmp ;
  int anum ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  char stack[65536] ;
  char *buf ;
  void *tmp___2 ;
  char *tmp___3 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___4 ;
  int not_first_call ;
  int tmp___5 ;
  long tmp___6 ;
  int snum ;
  uint32_t num ;
  _Bool tmp___7 ;
  uint8_t code ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;

  {
  ttservlog(g_serv, 0, "doing addint command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  tmp = ttsockgetint32(sock);
  ksiz = (int )tmp;
  tmp___0 = ttsockgetint32(sock);
  anum = (int )tmp___0;
  tmp___1 = ttsockcheckend(sock);
  if (tmp___1) {
    ttservlog(g_serv, 1, "do_addint: invalid parameters");
    return;
  } else {
    if (ksiz < 0) {
      ttservlog(g_serv, 1, "do_addint: invalid parameters");
      return;
    } else {
      if (ksiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_addint: invalid parameters");
        return;
      }
    }
  }
  if (ksiz < 65536) {
    tmp___3 = stack;
  } else {
    tmp___2 = tcmalloc((unsigned int )(ksiz + 1));
    tmp___3 = (char *)tmp___2;
  }
  buf = tmp___3;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___4 = (char *)((void *)0);
    } else {
      tmp___4 = buf;
    }
    __cancel_arg = (void *)tmp___4;
    tmp___5 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___5;
    tmp___6 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___6) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___9 = ttsockrecv(sock, buf, ksiz);
      if (tmp___9) {
        tmp___10 = ttsockcheckend(sock);
        if (tmp___10) {
          ttservlog(g_serv, 1, "do_addint: invalid entity");
        } else {
          if (mask___0 & (((1ULL << 12) | (1ULL << 27)) | (1ULL << 31))) {
            snum = (-0x7FFFFFFF-1);
            ttservlog(g_serv, 1, "do_addint: forbidden");
          } else {
            snum = tculogadbaddint(ulog, sid, 0U, adb, (void const   *)buf, ksiz,
                                   anum);
          }
          if (snum != (-0x7FFFFFFF-1)) {
            stack[0] = (char)0;
            num = (unsigned int )((((((unsigned long )((unsigned int )snum) & 255UL) << 24) | (((unsigned long )((unsigned int )snum) & 65280UL) << 8)) | (((unsigned long )((unsigned int )snum) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )snum) & 4278190080UL) >> 24));
            memcpy((void * __restrict  )(stack + (int )sizeof(uint8_t )), (void const   * __restrict  )(& num),
                   (unsigned int )((int )sizeof(uint32_t )));
            tmp___7 = ttsocksend(sock, (void const   *)(stack), (int )sizeof(uint8_t ) + (int )sizeof(uint32_t ));
            if (tmp___7) {
              req->keep = (_Bool)1;
            } else {
              ttservlog(g_serv, 1, "do_addint: response failed");
            }
          } else {
            code = (uint8_t )1;
            tmp___8 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
            if (tmp___8) {
              req->keep = (_Bool)1;
            } else {
              ttservlog(g_serv, 1, "do_addint: response failed");
            }
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_addint: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_adddouble(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  int ksiz ;
  uint32_t tmp ;
  char abuf[(int )sizeof(uint64_t ) * 2] ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  double anum ;
  double tmp___2 ;
  char stack[65536] ;
  char *buf ;
  void *tmp___3 ;
  char *tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___5 ;
  int not_first_call ;
  int tmp___6 ;
  long tmp___7 ;
  double snum ;
  _Bool tmp___8 ;
  uint8_t code ;
  _Bool tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;

  {
  ttservlog(g_serv, 0, "doing adddouble command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  tmp = ttsockgetint32(sock);
  ksiz = (int )tmp;
  tmp___0 = ttsockrecv(sock, abuf, (int )sizeof(abuf));
  if (tmp___0) {
    tmp___1 = ttsockcheckend(sock);
    if (tmp___1) {
      ttservlog(g_serv, 1, "do_adddouble: invalid parameters");
      return;
    } else {
      if (ksiz < 0) {
        ttservlog(g_serv, 1, "do_adddouble: invalid parameters");
        return;
      } else {
        if (ksiz > 32 << 20) {
          ttservlog(g_serv, 1, "do_adddouble: invalid parameters");
          return;
        }
      }
    }
  } else {
    ttservlog(g_serv, 1, "do_adddouble: invalid parameters");
    return;
  }
  tmp___2 = ttunpackdouble((char const   *)(abuf));
  anum = tmp___2;
  if (ksiz < 65536) {
    tmp___4 = stack;
  } else {
    tmp___3 = tcmalloc((unsigned int )(ksiz + 1));
    tmp___4 = (char *)tmp___3;
  }
  buf = tmp___4;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___5 = (char *)((void *)0);
    } else {
      tmp___5 = buf;
    }
    __cancel_arg = (void *)tmp___5;
    tmp___6 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___6;
    tmp___7 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___7) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___15 = ttsockrecv(sock, buf, ksiz);
      if (tmp___15) {
        tmp___16 = ttsockcheckend(sock);
        if (tmp___16) {
          ttservlog(g_serv, 1, "do_adddouble: invalid entity");
        } else {
          if (mask___0 & (((1ULL << 13) | (1ULL << 27)) | (1ULL << 31))) {
            snum = nan("");
            ttservlog(g_serv, 1, "do_adddouble: forbidden");
          } else {
            snum = tculogadbadddouble(ulog, sid, 0U, adb, (void const   *)buf, ksiz,
                                      anum);
          }
          if ((int )sizeof(snum) == (int )sizeof(float )) {
            tmp___10 = __isnanf((float )snum);
            tmp___14 = tmp___10;
          } else {
            if ((int )sizeof(snum) == (int )sizeof(double )) {
              tmp___11 = __isnan(snum);
              tmp___13 = tmp___11;
            } else {
              tmp___12 = __isnanl((long double )snum);
              tmp___13 = tmp___12;
            }
            tmp___14 = tmp___13;
          }
          if (tmp___14) {
            code = (uint8_t )1;
            tmp___9 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
            if (tmp___9) {
              req->keep = (_Bool)1;
            } else {
              ttservlog(g_serv, 1, "do_adddouble: response failed");
            }
          } else {
            stack[0] = (char)0;
            ttpackdouble(snum, abuf);
            memcpy((void * __restrict  )(stack + (int )sizeof(uint8_t )), (void const   * __restrict  )(abuf),
                   (unsigned int )((int )sizeof(abuf)));
            tmp___8 = ttsocksend(sock, (void const   *)(stack), (int )sizeof(uint8_t ) + (int )sizeof(abuf));
            if (tmp___8) {
              req->keep = (_Bool)1;
            } else {
              ttservlog(g_serv, 1, "do_adddouble: response failed");
            }
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_adddouble: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_ext(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  pthread_mutex_t *rmtxs ;
  void *scr ;
  int nsiz ;
  uint32_t tmp ;
  int opts ;
  uint32_t tmp___0 ;
  int ksiz ;
  uint32_t tmp___1 ;
  int vsiz ;
  uint32_t tmp___2 ;
  _Bool tmp___3 ;
  int rsiz ;
  char stack[65536] ;
  char *buf ;
  void *tmp___4 ;
  char *tmp___5 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___6 ;
  int not_first_call ;
  int tmp___7 ;
  long tmp___8 ;
  char name[1024] ;
  char const   *kbuf ;
  char const   *vbuf ;
  int xsiz ;
  char *xbuf ;
  _Bool err ;
  int i ;
  int tmp___9 ;
  int i___0 ;
  int tmp___10 ;
  int mtxidx ;
  uint32_t tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int rsiz___0 ;
  char *rbuf ;
  void *tmp___14 ;
  char *tmp___15 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_ext)(void * ) ;
  void *__cancel_arg___0 ;
  char *tmp___16 ;
  int not_first_call___0 ;
  int tmp___17 ;
  long tmp___18 ;
  uint32_t num ;
  _Bool tmp___19 ;
  uint8_t code ;
  _Bool tmp___20 ;
  _Bool tmp___21 ;
  _Bool tmp___22 ;

  {
  ttservlog(g_serv, 0, "doing ext command");
  mask___0 = arg->mask;
  rmtxs = arg->rmtxs;
  scr = *(arg->screxts + req->idx);
  tmp = ttsockgetint32(sock);
  nsiz = (int )tmp;
  tmp___0 = ttsockgetint32(sock);
  opts = (int )tmp___0;
  tmp___1 = ttsockgetint32(sock);
  ksiz = (int )tmp___1;
  tmp___2 = ttsockgetint32(sock);
  vsiz = (int )tmp___2;
  tmp___3 = ttsockcheckend(sock);
  if (tmp___3) {
    ttservlog(g_serv, 1, "do_ext: invalid parameters");
    return;
  } else {
    if (nsiz < 0) {
      ttservlog(g_serv, 1, "do_ext: invalid parameters");
      return;
    } else {
      if (nsiz >= 1024) {
        ttservlog(g_serv, 1, "do_ext: invalid parameters");
        return;
      } else {
        if (ksiz < 0) {
          ttservlog(g_serv, 1, "do_ext: invalid parameters");
          return;
        } else {
          if (ksiz > 32 << 20) {
            ttservlog(g_serv, 1, "do_ext: invalid parameters");
            return;
          } else {
            if (vsiz < 0) {
              ttservlog(g_serv, 1, "do_ext: invalid parameters");
              return;
            } else {
              if (vsiz > 32 << 20) {
                ttservlog(g_serv, 1, "do_ext: invalid parameters");
                return;
              }
            }
          }
        }
      }
    }
  }
  rsiz = (nsiz + ksiz) + vsiz;
  if (rsiz < 65536) {
    tmp___5 = stack;
  } else {
    tmp___4 = tcmalloc((unsigned int )(rsiz + 1));
    tmp___5 = (char *)tmp___4;
  }
  buf = tmp___5;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___6 = (char *)((void *)0);
    } else {
      tmp___6 = buf;
    }
    __cancel_arg = (void *)tmp___6;
    tmp___7 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___7;
    tmp___8 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___8) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___21 = ttsockrecv(sock, buf, rsiz);
      if (tmp___21) {
        tmp___22 = ttsockcheckend(sock);
        if (tmp___22) {
          ttservlog(g_serv, 1, "do_ext: invalid entity");
        } else {
          memcpy((void * __restrict  )(name), (void const   * __restrict  )buf, (unsigned int )nsiz);
          name[nsiz] = (char )'\000';
          kbuf = (char const   *)(buf + nsiz);
          vbuf = kbuf + ksiz;
          xsiz = 0;
          xbuf = (char *)((void *)0);
          if (mask___0 & ((1ULL << 14) | (1ULL << 27))) {
            ttservlog(g_serv, 1, "do_ext: forbidden");
          } else {
            if (scr) {
              if (opts & 2) {
                err = (_Bool)0;
                i = 0;
                while (i < 31) {
                  tmp___9 = pthread_mutex_lock(rmtxs + i);
                  if (tmp___9 != 0) {
                    ttservlog(g_serv, 2, "do_ext: pthread_mutex_lock failed");
                    while (1) {
                      i --;
                      if (! (i >= 0)) {
                        break;
                      }
                      pthread_mutex_unlock(rmtxs + i);
                    }
                    err = (_Bool)1;
                    break;
                  }
                  i ++;
                }
                if (! err) {
                  xbuf = scrextcallmethod(scr, (char const   *)(name), (void const   *)kbuf,
                                          ksiz, (void const   *)vbuf, vsiz, & xsiz);
                  i___0 = 30;
                  while (i___0 >= 0) {
                    tmp___10 = pthread_mutex_unlock(rmtxs + i___0);
                    if (tmp___10 != 0) {
                      ttservlog(g_serv, 2, "do_ext: pthread_mutex_unlock failed");
                    }
                    i___0 --;
                  }
                }
              } else {
                if (opts & 1) {
                  tmp___11 = recmtxidx(kbuf, ksiz);
                  mtxidx = (int )tmp___11;
                  tmp___13 = pthread_mutex_lock(rmtxs + mtxidx);
                  if (tmp___13 == 0) {
                    xbuf = scrextcallmethod(scr, (char const   *)(name), (void const   *)kbuf,
                                            ksiz, (void const   *)vbuf, vsiz, & xsiz);
                    tmp___12 = pthread_mutex_unlock(rmtxs + mtxidx);
                    if (tmp___12 != 0) {
                      ttservlog(g_serv, 2, "do_ext: pthread_mutex_unlock failed");
                    }
                  } else {
                    ttservlog(g_serv, 2, "do_ext: pthread_mutex_lock failed");
                  }
                } else {
                  xbuf = scrextcallmethod(scr, (char const   *)(name), (void const   *)kbuf,
                                          ksiz, (void const   *)vbuf, vsiz, & xsiz);
                }
              }
            }
          }
          if (xbuf) {
            rsiz___0 = (xsiz + (int )sizeof(uint8_t )) + (int )sizeof(uint32_t );
            if (rsiz___0 < 65536) {
              tmp___15 = stack;
            } else {
              tmp___14 = tcmalloc((unsigned int )rsiz___0);
              tmp___15 = (char *)tmp___14;
            }
            rbuf = tmp___15;
            while (1) {
              __cancel_routine___do_ext = & free;
              if ((unsigned int )rbuf == (unsigned int )(stack)) {
                tmp___16 = (char *)((void *)0);
              } else {
                tmp___16 = rbuf;
              }
              __cancel_arg___0 = (void *)tmp___16;
              tmp___17 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                                     0);
              not_first_call___0 = tmp___17;
              tmp___18 = __builtin_expect((long )not_first_call___0, 0L);
              if (tmp___18) {
                (*__cancel_routine___do_ext)(__cancel_arg___0);
                __pthread_unwind_next(& __cancel_buf___0);
              }
              __pthread_register_cancel(& __cancel_buf___0);
              while (1) {
                *rbuf = (char)0;
                num = (unsigned int )((((((unsigned long )((unsigned int )xsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )xsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )xsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )xsiz) & 4278190080UL) >> 24));
                memcpy((void * __restrict  )(rbuf + (int )sizeof(uint8_t )), (void const   * __restrict  )(& num),
                       (unsigned int )((int )sizeof(uint32_t )));
                memcpy((void * __restrict  )((rbuf + (int )sizeof(uint8_t )) + (int )sizeof(uint32_t )),
                       (void const   * __restrict  )xbuf, (unsigned int )xsiz);
                tcfree((void *)xbuf);
                tmp___19 = ttsocksend(sock, (void const   *)rbuf, rsiz___0);
                if (tmp___19) {
                  req->keep = (_Bool)1;
                } else {
                  ttservlog(g_serv, 1, "do_ext: response failed");
                }
                break;
              }
              __pthread_unregister_cancel(& __cancel_buf___0);
              (*__cancel_routine___do_ext)(__cancel_arg___0);
              break;
            }
          } else {
            code = (uint8_t )1;
            tmp___20 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
            if (tmp___20) {
              req->keep = (_Bool)1;
            } else {
              ttservlog(g_serv, 1, "do_ext: response failed");
            }
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_ext: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_sync(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  uint8_t code ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  ttservlog(g_serv, 1, "doing sync command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  code = (uint8_t )0;
  if (mask___0 & (((1ULL << 15) | (1ULL << 27)) | (1ULL << 32))) {
    code = (unsigned char)1;
    ttservlog(g_serv, 1, "do_sync: forbidden");
  } else {
    tmp = tculogadbsync(ulog, sid, 0U, adb);
    if (! tmp) {
      code = (unsigned char)1;
      ttservlog(g_serv, 2, "do_sync: operation failed");
    }
  }
  tmp___0 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
  if (tmp___0) {
    req->keep = (_Bool)1;
  } else {
    ttservlog(g_serv, 1, "do_sync: response failed");
  }
  return;
}
}
static void do_optimize(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  int psiz ;
  uint32_t tmp ;
  _Bool tmp___0 ;
  char stack[65536] ;
  char *buf ;
  void *tmp___1 ;
  char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___3 ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  uint8_t code ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;

  {
  ttservlog(g_serv, 1, "doing optimize command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  tmp = ttsockgetint32(sock);
  psiz = (int )tmp;
  tmp___0 = ttsockcheckend(sock);
  if (tmp___0) {
    ttservlog(g_serv, 1, "do_optimize: invalid parameters");
    return;
  } else {
    if (psiz < 0) {
      ttservlog(g_serv, 1, "do_optimize: invalid parameters");
      return;
    } else {
      if (psiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_optimize: invalid parameters");
        return;
      }
    }
  }
  if (psiz < 65536) {
    tmp___2 = stack;
  } else {
    tmp___1 = tcmalloc((unsigned int )(psiz + 1));
    tmp___2 = (char *)tmp___1;
  }
  buf = tmp___2;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___3 = (char *)((void *)0);
    } else {
      tmp___3 = buf;
    }
    __cancel_arg = (void *)tmp___3;
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___4;
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___5) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___8 = ttsockrecv(sock, buf, psiz);
      if (tmp___8) {
        tmp___9 = ttsockcheckend(sock);
        if (tmp___9) {
          ttservlog(g_serv, 1, "do_optimize: invalid entity");
        } else {
          *(buf + psiz) = (char )'\000';
          code = (uint8_t )0;
          if (mask___0 & (((1ULL << 16) | (1ULL << 27)) | (1ULL << 32))) {
            code = (unsigned char)1;
            ttservlog(g_serv, 1, "do_optimize: forbidden");
          } else {
            tmp___6 = tculogadboptimize(ulog, sid, 0U, adb, (char const   *)buf);
            if (! tmp___6) {
              code = (unsigned char)1;
            }
          }
          tmp___7 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
          if (tmp___7) {
            req->keep = (_Bool)1;
          } else {
            ttservlog(g_serv, 1, "do_optimize: response failed");
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_optimize: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_vanish(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  uint8_t code ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  ttservlog(g_serv, 1, "doing vanish command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  code = (uint8_t )0;
  if (mask___0 & (((1ULL << 17) | (1ULL << 27)) | (1ULL << 31))) {
    code = (unsigned char)1;
    ttservlog(g_serv, 1, "do_vanish: forbidden");
  } else {
    tmp = tculogadbvanish(ulog, sid, 0U, adb);
    if (! tmp) {
      code = (unsigned char)1;
      ttservlog(g_serv, 2, "do_vanish: operation failed");
    }
  }
  tmp___0 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
  if (tmp___0) {
    req->keep = (_Bool)1;
  } else {
    ttservlog(g_serv, 1, "do_vanish: response failed");
  }
  return;
}
}
static void do_copy(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  int psiz ;
  uint32_t tmp ;
  _Bool tmp___0 ;
  char stack[65536] ;
  char *buf ;
  void *tmp___1 ;
  char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___3 ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  uint8_t code ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;

  {
  ttservlog(g_serv, 1, "doing copy command");
  mask___0 = arg->mask;
  adb = arg->adb;
  tmp = ttsockgetint32(sock);
  psiz = (int )tmp;
  tmp___0 = ttsockcheckend(sock);
  if (tmp___0) {
    ttservlog(g_serv, 1, "do_copy: invalid parameters");
    return;
  } else {
    if (psiz < 0) {
      ttservlog(g_serv, 1, "do_copy: invalid parameters");
      return;
    } else {
      if (psiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_copy: invalid parameters");
        return;
      }
    }
  }
  if (psiz < 65536) {
    tmp___2 = stack;
  } else {
    tmp___1 = tcmalloc((unsigned int )(psiz + 1));
    tmp___2 = (char *)tmp___1;
  }
  buf = tmp___2;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___3 = (char *)((void *)0);
    } else {
      tmp___3 = buf;
    }
    __cancel_arg = (void *)tmp___3;
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___4;
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___5) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___8 = ttsockrecv(sock, buf, psiz);
      if (tmp___8) {
        tmp___9 = ttsockcheckend(sock);
        if (tmp___9) {
          ttservlog(g_serv, 1, "do_copy: invalid entity");
        } else {
          *(buf + psiz) = (char )'\000';
          code = (uint8_t )0;
          if (mask___0 & (((1ULL << 19) | (1ULL << 27)) | (1ULL << 32))) {
            code = (unsigned char)1;
            ttservlog(g_serv, 1, "do_copy: forbidden");
          } else {
            tmp___6 = tcadbcopy(adb, (char const   *)buf);
            if (! tmp___6) {
              code = (unsigned char)1;
              ttservlog(g_serv, 2, "do_copy: operation failed");
            }
          }
          tmp___7 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
          if (tmp___7) {
            req->keep = (_Bool)1;
          } else {
            ttservlog(g_serv, 1, "do_copy: response failed");
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_copy: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_restore(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  int psiz ;
  uint32_t tmp ;
  uint64_t ts ;
  uint64_t tmp___0 ;
  int opts ;
  uint32_t tmp___1 ;
  _Bool tmp___2 ;
  char stack[65536] ;
  char *buf ;
  void *tmp___3 ;
  char *tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___5 ;
  int not_first_call ;
  int tmp___6 ;
  long tmp___7 ;
  _Bool con ;
  uint8_t code ;
  _Bool tmp___8 ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;

  {
  ttservlog(g_serv, 1, "doing restore command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  tmp = ttsockgetint32(sock);
  psiz = (int )tmp;
  tmp___0 = ttsockgetint64(sock);
  ts = tmp___0;
  tmp___1 = ttsockgetint32(sock);
  opts = (int )tmp___1;
  tmp___2 = ttsockcheckend(sock);
  if (tmp___2) {
    ttservlog(g_serv, 1, "do_restore: invalid parameters");
    return;
  } else {
    if (psiz < 0) {
      ttservlog(g_serv, 1, "do_restore: invalid parameters");
      return;
    } else {
      if (psiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_restore: invalid parameters");
        return;
      }
    }
  }
  if (psiz < 65536) {
    tmp___4 = stack;
  } else {
    tmp___3 = tcmalloc((unsigned int )(psiz + 1));
    tmp___4 = (char *)tmp___3;
  }
  buf = tmp___4;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___5 = (char *)((void *)0);
    } else {
      tmp___5 = buf;
    }
    __cancel_arg = (void *)tmp___5;
    tmp___6 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___6;
    tmp___7 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___7) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___10 = ttsockrecv(sock, buf, psiz);
      if (tmp___10) {
        tmp___11 = ttsockcheckend(sock);
        if (tmp___11) {
          ttservlog(g_serv, 1, "do_restore: invalid entity");
        } else {
          *(buf + psiz) = (char )'\000';
          con = (_Bool )((opts & 1) != 0);
          code = (uint8_t )0;
          if (mask___0 & (((1ULL << 19) | (1ULL << 27)) | (1ULL << 32))) {
            code = (unsigned char)1;
            ttservlog(g_serv, 1, "do_restore: forbidden");
          } else {
            tmp___8 = tculogadbrestore(adb, (char const   *)buf, ts, con, ulog);
            if (! tmp___8) {
              code = (unsigned char)1;
              ttservlog(g_serv, 2, "do_restore: operation failed");
            }
          }
          tmp___9 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
          if (tmp___9) {
            req->keep = (_Bool)1;
          } else {
            ttservlog(g_serv, 1, "do_restore: response failed");
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_restore: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_setmst(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  REPLARG *sarg ;
  int hsiz ;
  uint32_t tmp ;
  int port ;
  uint32_t tmp___0 ;
  uint64_t ts ;
  uint64_t tmp___1 ;
  int opts ;
  uint32_t tmp___2 ;
  _Bool tmp___3 ;
  char stack[65536] ;
  char *buf ;
  void *tmp___4 ;
  char *tmp___5 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___6 ;
  int not_first_call ;
  int tmp___7 ;
  long tmp___8 ;
  uint8_t code ;
  _Bool tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;

  {
  ttservlog(g_serv, 1, "doing setmst command");
  mask___0 = arg->mask;
  sarg = arg->sarg;
  tmp = ttsockgetint32(sock);
  hsiz = (int )tmp;
  tmp___0 = ttsockgetint32(sock);
  port = (int )tmp___0;
  tmp___1 = ttsockgetint64(sock);
  ts = tmp___1;
  tmp___2 = ttsockgetint32(sock);
  opts = (int )tmp___2;
  tmp___3 = ttsockcheckend(sock);
  if (tmp___3) {
    ttservlog(g_serv, 1, "do_setmst: invalid parameters");
    return;
  } else {
    if (hsiz < 0) {
      ttservlog(g_serv, 1, "do_setmst: invalid parameters");
      return;
    } else {
      if (hsiz > 32 << 20) {
        ttservlog(g_serv, 1, "do_setmst: invalid parameters");
        return;
      } else {
        if (port < 0) {
          ttservlog(g_serv, 1, "do_setmst: invalid parameters");
          return;
        }
      }
    }
  }
  if (hsiz < 65536) {
    tmp___5 = stack;
  } else {
    tmp___4 = tcmalloc((unsigned int )(hsiz + 1));
    tmp___5 = (char *)tmp___4;
  }
  buf = tmp___5;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___6 = (char *)((void *)0);
    } else {
      tmp___6 = buf;
    }
    __cancel_arg = (void *)tmp___6;
    tmp___7 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___7;
    tmp___8 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___8) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___10 = ttsockrecv(sock, buf, hsiz);
      if (tmp___10) {
        tmp___11 = ttsockcheckend(sock);
        if (tmp___11) {
          ttservlog(g_serv, 1, "do_setmst: invalid entity");
        } else {
          *(buf + hsiz) = (char )'\000';
          code = (uint8_t )0;
          if (mask___0 & (((1ULL << 20) | (1ULL << 27)) | (1ULL << 32))) {
            code = (unsigned char)1;
            ttservlog(g_serv, 1, "do_setmst: forbidden");
          } else {
            snprintf((char * __restrict  )(sarg->host), 1024U, (char const   * __restrict  )"%s",
                     buf);
            sarg->port = port;
            sarg->opts = opts;
            sarg->recon = (_Bool)1;
            sarg->fatal = (_Bool)0;
            sarg->mts = ts;
          }
          tmp___9 = ttsocksend(sock, (void const   *)(& code), (int )sizeof(code));
          if (tmp___9) {
            req->keep = (_Bool)1;
          } else {
            ttservlog(g_serv, 1, "do_setmst: response failed");
          }
        }
      } else {
        ttservlog(g_serv, 1, "do_setmst: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_rnum(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  char buf[8192] ;
  uint64_t rnum ;
  _Bool tmp ;

  {
  ttservlog(g_serv, 0, "doing rnum command");
  mask___0 = arg->mask;
  adb = arg->adb;
  buf[0] = (char)0;
  if (mask___0 & (((1ULL << 21) | (1ULL << 27)) | (1ULL << 30))) {
    rnum = 0ULL;
    ttservlog(g_serv, 1, "do_rnum: forbidden");
  } else {
    rnum = tcadbrnum(adb);
  }
  rnum = ((((((((rnum & 255ULL) << 56) | ((rnum & 65280ULL) << 40)) | ((rnum & 16711680ULL) << 24)) | ((rnum & 4278190080ULL) << 8)) | ((rnum & 1095216660480ULL) >> 8)) | ((rnum & 280375465082880ULL) >> 24)) | ((rnum & 71776119061217280ULL) >> 40)) | ((rnum & 0xff00000000000000ULL) >> 56);
  memcpy((void * __restrict  )(buf + (int )sizeof(uint8_t )), (void const   * __restrict  )(& rnum),
         (unsigned int )((int )sizeof(uint64_t )));
  tmp = ttsocksend(sock, (void const   *)(buf), (int )sizeof(uint8_t ) + (int )sizeof(uint64_t ));
  if (tmp) {
    req->keep = (_Bool)1;
  } else {
    ttservlog(g_serv, 1, "do_rnum: response failed");
  }
  return;
}
}
static void do_size(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  char buf[8192] ;
  uint64_t size ;
  _Bool tmp ;

  {
  ttservlog(g_serv, 0, "doing size command");
  mask___0 = arg->mask;
  adb = arg->adb;
  buf[0] = (char)0;
  if (mask___0 & (((1ULL << 22) | (1ULL << 27)) | (1ULL << 30))) {
    size = 0ULL;
    ttservlog(g_serv, 1, "do_size: forbidden");
  } else {
    size = tcadbsize(adb);
  }
  size = ((((((((size & 255ULL) << 56) | ((size & 65280ULL) << 40)) | ((size & 16711680ULL) << 24)) | ((size & 4278190080ULL) << 8)) | ((size & 1095216660480ULL) >> 8)) | ((size & 280375465082880ULL) >> 24)) | ((size & 71776119061217280ULL) >> 40)) | ((size & 0xff00000000000000ULL) >> 56);
  memcpy((void * __restrict  )(buf + (int )sizeof(uint8_t )), (void const   * __restrict  )(& size),
         (unsigned int )((int )sizeof(uint64_t )));
  tmp = ttsocksend(sock, (void const   *)(buf), (int )sizeof(uint8_t ) + (int )sizeof(uint64_t ));
  if (tmp) {
    req->keep = (_Bool)1;
  } else {
    ttservlog(g_serv, 1, "do_size: response failed");
  }
  return;
}
}
static void do_stat(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  REPLARG *sarg ;
  char buf[65536] ;
  char *wp ;
  double now ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __pid_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char const   *path ;
  char const   *tmp___17 ;
  int tmp___18 ;
  uint64_t tmp___19 ;
  int tmp___20 ;
  uint64_t tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  double delay ;
  double tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  double tmp___30 ;
  int tmp___31 ;
  TCMAP *info ;
  TCMAP *tmp___32 ;
  char const   *vbuf ;
  char const   *tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  struct rusage ubuf ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  uint32_t size ;
  _Bool tmp___40 ;

  {
  ttservlog(g_serv, 0, "doing stat command");
  mask___0 = arg->mask;
  adb = arg->adb;
  sarg = arg->sarg;
  wp = (buf + (int )sizeof(uint8_t )) + (int )sizeof(uint32_t );
  if (mask___0 & (((1ULL << 23) | (1ULL << 27)) | (1ULL << 30))) {
    ttservlog(g_serv, 1, "do_stat: forbidden");
  } else {
    tmp = tctime();
    now = tmp;
    tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"version\t%s\n",
                      ttversion);
    wp += tmp___0;
    tmp___1 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"libver\t%d\n",
                      317);
    wp += tmp___1;
    tmp___2 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"protver\t%s\n",
                      "0.91");
    wp += tmp___2;
    tmp___3 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"os\t%s\n",
                      "Linux");
    wp += tmp___3;
    tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"time\t%.6f\n",
                      now);
    wp += tmp___4;
    tmp___5 = getpid();
    tmp___6 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"pid\t%lld\n",
                      (long long )tmp___5);
    wp += tmp___6;
    tmp___7 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"sid\t%d\n",
                      arg->sid);
    wp += tmp___7;
    tmp___8 = tcadbomode(adb);
    switch (tmp___8) {
    case 0: 
    tmp___9 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"type\tvoid\n");
    wp += tmp___9;
    break;
    case 1: 
    tmp___10 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"type\ton-memory hash\n");
    wp += tmp___10;
    break;
    case 2: 
    tmp___11 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"type\ton-memory tree\n");
    wp += tmp___11;
    break;
    case 3: 
    tmp___12 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"type\thash\n");
    wp += tmp___12;
    break;
    case 4: 
    tmp___13 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"type\tB+ tree\n");
    wp += tmp___13;
    break;
    case 5: 
    tmp___14 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"type\tfixed-length\n");
    wp += tmp___14;
    break;
    case 6: 
    tmp___15 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"type\ttable\n");
    wp += tmp___15;
    break;
    case 7: 
    tmp___16 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"type\tskeleton\n");
    wp += tmp___16;
    break;
    }
    tmp___17 = tcadbpath(adb);
    path = tmp___17;
    if (path) {
      tmp___18 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"path\t%s\n",
                         path);
      wp += tmp___18;
    }
    tmp___19 = tcadbrnum(adb);
    tmp___20 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"rnum\t%llu\n",
                       tmp___19);
    wp += tmp___20;
    tmp___21 = tcadbsize(adb);
    tmp___22 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"size\t%llu\n",
                       tmp___21);
    wp += tmp___22;
    tmp___23 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"bigend\t%d\n",
                       0);
    wp += tmp___23;
    if ((int )sarg->host[0] != 0) {
      tmp___24 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"mhost\t%s\n",
                         sarg->host);
      wp += tmp___24;
      tmp___25 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"mport\t%d\n",
                         sarg->port);
      wp += tmp___25;
      tmp___26 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"rts\t%llu\n",
                         sarg->rts);
      wp += tmp___26;
      delay = now - (double )sarg->rts / 1000000.0;
      if (delay >= (double )0) {
        tmp___27 = delay;
      } else {
        tmp___27 = 0.0;
      }
      tmp___28 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"delay\t%.6f\n",
                         tmp___27);
      wp += tmp___28;
    }
    tmp___29 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"fd\t%d\n",
                       sock->fd);
    wp += tmp___29;
    tmp___30 = ttgetloadavg();
    tmp___31 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"loadavg\t%.6f\n",
                       tmp___30);
    wp += tmp___31;
    tmp___32 = tcsysinfo();
    info = tmp___32;
    if (info) {
      tmp___33 = tcmapget2((TCMAP const   *)info, "size");
      vbuf = tmp___33;
      if (vbuf) {
        tmp___34 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"memsize\t%s\n",
                           vbuf);
        wp += tmp___34;
      }
      vbuf = tcmapget2((TCMAP const   *)info, "rss");
      if (vbuf) {
        tmp___35 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"memrss\t%s\n",
                           vbuf);
        wp += tmp___35;
      }
      tcmapdel(info);
    }
    tmp___36 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"ru_real\t%.6f\n",
                       now - g_starttime);
    wp += tmp___36;
    memset((void *)(& ubuf), 0, (unsigned int )((int )sizeof(ubuf)));
    tmp___39 = getrusage((enum __rusage_who )0, & ubuf);
    if (tmp___39 == 0) {
      tmp___37 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"ru_user\t%d.%06d\n",
                         (int )ubuf.ru_utime.tv_sec, (int )ubuf.ru_utime.tv_usec);
      wp += tmp___37;
      tmp___38 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"ru_sys\t%d.%06d\n",
                         (int )ubuf.ru_stime.tv_sec, (int )ubuf.ru_stime.tv_usec);
      wp += tmp___38;
    }
  }
  buf[0] = (char)0;
  size = (uint32_t )((wp - buf) - ((int )sizeof(uint8_t ) + (int )sizeof(uint32_t )));
  size = (unsigned int )((((((unsigned long )size & 255UL) << 24) | (((unsigned long )size & 65280UL) << 8)) | (((unsigned long )size & 16711680UL) >> 8)) | (((unsigned long )size & 4278190080UL) >> 24));
  memcpy((void * __restrict  )(buf + (int )sizeof(uint8_t )), (void const   * __restrict  )(& size),
         (unsigned int )((int )sizeof(uint32_t )));
  tmp___40 = ttsocksend(sock, (void const   *)(buf), wp - buf);
  if (tmp___40) {
    req->keep = (_Bool)1;
  } else {
    ttservlog(g_serv, 1, "do_stat: response failed");
  }
  return;
}
}
static void do_misc(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  int nsiz ;
  uint32_t tmp ;
  int opts ;
  uint32_t tmp___0 ;
  int rnum ;
  uint32_t tmp___1 ;
  _Bool tmp___2 ;
  char name[1024] ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  TCLIST *args ;
  TCLIST *tmp___5 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___6 ;
  long tmp___7 ;
  char stack[65536] ;
  int i ;
  int rsiz ;
  uint32_t tmp___8 ;
  _Bool tmp___9 ;
  char *buf ;
  void *tmp___10 ;
  char *tmp___11 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_misc)(void * ) ;
  void *__cancel_arg___0 ;
  char *tmp___12 ;
  int not_first_call___0 ;
  int tmp___13 ;
  long tmp___14 ;
  _Bool tmp___15 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___16 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___17 ;
  long tmp___18 ;
  uint8_t code ;
  uint32_t num ;
  TCLIST *res ;
  TCLIST *tmp___19 ;
  TCLIST *tmp___20 ;
  TCLIST *tmp___21 ;
  int i___0 ;
  int esiz ;
  char const   *ebuf ;
  void const   *tmp___22 ;
  int tmp___23 ;
  void const   *tmp___24 ;
  void const   *tmp___25 ;
  int tmp___26 ;
  void const   *tmp___27 ;
  _Bool tmp___28 ;
  _Bool tmp___29 ;

  {
  ttservlog(g_serv, 0, "doing misc command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  tmp = ttsockgetint32(sock);
  nsiz = (int )tmp;
  tmp___0 = ttsockgetint32(sock);
  opts = (int )tmp___0;
  tmp___1 = ttsockgetint32(sock);
  rnum = (int )tmp___1;
  tmp___2 = ttsockcheckend(sock);
  if (tmp___2) {
    ttservlog(g_serv, 1, "do_misc: invalid parameters");
    return;
  } else {
    if (nsiz < 0) {
      ttservlog(g_serv, 1, "do_misc: invalid parameters");
      return;
    } else {
      if (nsiz >= 1024) {
        ttservlog(g_serv, 1, "do_misc: invalid parameters");
        return;
      } else {
        if (rnum < 0) {
          ttservlog(g_serv, 1, "do_misc: invalid parameters");
          return;
        } else {
          if (rnum > 1 << 20) {
            ttservlog(g_serv, 1, "do_misc: invalid parameters");
            return;
          }
        }
      }
    }
  }
  tmp___3 = ttsockrecv(sock, name, nsiz);
  if (! tmp___3) {
    tmp___4 = ttsockcheckend(sock);
    if (! tmp___4) {
      ttservlog(g_serv, 1, "do_misc: invalid parameters");
      return;
    }
  }
  name[nsiz] = (char )'\000';
  tmp___5 = tclistnew2(rnum);
  args = tmp___5;
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tclistdel);
    __cancel_arg = (void *)args;
    tmp___6 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___6;
    tmp___7 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___7) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      i = 0;
      while (i < rnum) {
        tmp___8 = ttsockgetint32(sock);
        rsiz = (int )tmp___8;
        tmp___9 = ttsockcheckend(sock);
        if (tmp___9) {
          break;
        } else {
          if (rsiz < 0) {
            break;
          } else {
            if (rsiz > 32 << 20) {
              break;
            }
          }
        }
        if (rsiz < 65536) {
          tmp___11 = stack;
        } else {
          tmp___10 = tcmalloc((unsigned int )(rsiz + 1));
          tmp___11 = (char *)tmp___10;
        }
        buf = tmp___11;
        while (1) {
          __cancel_routine___do_misc = & free;
          if ((unsigned int )buf == (unsigned int )(stack)) {
            tmp___12 = (char *)((void *)0);
          } else {
            tmp___12 = buf;
          }
          __cancel_arg___0 = (void *)tmp___12;
          tmp___13 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                                 0);
          not_first_call___0 = tmp___13;
          tmp___14 = __builtin_expect((long )not_first_call___0, 0L);
          if (tmp___14) {
            (*__cancel_routine___do_misc)(__cancel_arg___0);
            __pthread_unwind_next(& __cancel_buf___0);
          }
          __pthread_register_cancel(& __cancel_buf___0);
          while (1) {
            tmp___15 = ttsockrecv(sock, buf, rsiz);
            if (tmp___15) {
              tclistpush(args, (void const   *)buf, rsiz);
            }
            break;
          }
          __pthread_unregister_cancel(& __cancel_buf___0);
          (*__cancel_routine___do_misc)(__cancel_arg___0);
          break;
        }
        i ++;
      }
      tmp___29 = ttsockcheckend(sock);
      if (tmp___29) {
        ttservlog(g_serv, 1, "do_misc: invalid entity");
      } else {
        tmp___16 = tcxstrnew();
        xstr = tmp___16;
        while (1) {
          __cancel_routine___1 = (void (*)(void * ))(& tcxstrdel);
          __cancel_arg___1 = (void *)xstr;
          tmp___17 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf)),
                                 0);
          not_first_call___1 = tmp___17;
          tmp___18 = __builtin_expect((long )not_first_call___1, 0L);
          if (tmp___18) {
            (*__cancel_routine___1)(__cancel_arg___1);
            __pthread_unwind_next(& __cancel_buf___1);
          }
          __pthread_register_cancel(& __cancel_buf___1);
          while (1) {
            code = (uint8_t )0;
            tcxstrcat(xstr, (void const   *)(& code), (int )sizeof(code));
            num = (uint32_t )0;
            tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
            rnum = 0;
            if (mask___0 & (((1ULL << 24) | (1ULL << 27)) | (1ULL << 31))) {
              ttservlog(g_serv, 1, "do_misc: forbidden");
            } else {
              if (opts & 1) {
                tmp___19 = tcadbmisc(adb, (char const   *)(name), (TCLIST const   *)args);
                tmp___21 = tmp___19;
              } else {
                tmp___20 = tculogadbmisc(ulog, sid, 0U, adb, (char const   *)(name),
                                         (TCLIST const   *)args);
                tmp___21 = tmp___20;
              }
              res = tmp___21;
              if (res) {
                i___0 = 0;
                while (1) {
                  tmp___23 = tclistnum((TCLIST const   *)res);
                  if (! (i___0 < tmp___23)) {
                    break;
                  }
                  tmp___22 = tclistval((TCLIST const   *)res, i___0, & esiz);
                  ebuf = (char const   *)tmp___22;
                  num = (unsigned int )((((((unsigned long )((unsigned int )esiz) & 255UL) << 24) | (((unsigned long )((unsigned int )esiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )esiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )esiz) & 4278190080UL) >> 24));
                  tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
                  tcxstrcat(xstr, (void const   *)ebuf, esiz);
                  rnum ++;
                  i___0 ++;
                }
                tclistdel(res);
              } else {
                tmp___24 = tcxstrptr((TCXSTR const   *)xstr);
                *((uint8_t *)tmp___24) = (unsigned char)1;
              }
            }
            num = (unsigned int )((((((unsigned long )((unsigned int )rnum) & 255UL) << 24) | (((unsigned long )((unsigned int )rnum) & 65280UL) << 8)) | (((unsigned long )((unsigned int )rnum) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )rnum) & 4278190080UL) >> 24));
            tmp___25 = tcxstrptr((TCXSTR const   *)xstr);
            memcpy((void * __restrict  )((char *)tmp___25 + (int )sizeof(code)), (void const   * __restrict  )(& num),
                   (unsigned int )((int )sizeof(num)));
            tmp___26 = tcxstrsize((TCXSTR const   *)xstr);
            tmp___27 = tcxstrptr((TCXSTR const   *)xstr);
            tmp___28 = ttsocksend(sock, tmp___27, tmp___26);
            if (tmp___28) {
              req->keep = (_Bool)1;
            } else {
              ttservlog(g_serv, 1, "do_misc: response failed");
            }
            break;
          }
          __pthread_unregister_cancel(& __cancel_buf___1);
          (*__cancel_routine___1)(__cancel_arg___1);
          break;
        }
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_repl(TTSOCK *sock , TASKARG *arg , TTREQ *req ) 
{ uint64_t mask___0 ;
  TCULOG *ulog ;
  uint64_t ts ;
  uint64_t tmp ;
  uint32_t sid ;
  uint32_t tmp___0 ;
  _Bool tmp___1 ;
  uint32_t lnum ;
  _Bool tmp___2 ;
  TCULRD *ulrd ;
  TCULRD *tmp___3 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  _Bool err ;
  double noptime ;
  char stack[65536] ;
  double now ;
  double tmp___6 ;
  _Bool tmp___7 ;
  uint32_t nopcnt ;
  char const   *rbuf ;
  int rsiz ;
  uint64_t rts ;
  uint32_t rsid ;
  uint32_t rmid ;
  _Bool tmp___8 ;
  uint32_t tmp___9 ;
  int msiz ;
  char *mbuf ;
  void *tmp___10 ;
  char *tmp___11 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_repl)(void * ) ;
  void *__cancel_arg___0 ;
  char *tmp___12 ;
  int not_first_call___0 ;
  int tmp___13 ;
  long tmp___14 ;
  unsigned char *wp ;
  unsigned char *tmp___15 ;
  uint64_t llnum ;
  _Bool tmp___16 ;
  void const   *tmp___17 ;
  _Bool tmp___18 ;

  {
  ttservlog(g_serv, 1, "doing repl command");
  mask___0 = arg->mask;
  ulog = arg->ulog;
  tmp = ttsockgetint64(sock);
  ts = tmp;
  tmp___0 = ttsockgetint32(sock);
  sid = tmp___0;
  tmp___1 = ttsockcheckend(sock);
  if (tmp___1) {
    ttservlog(g_serv, 1, "do_repl: invalid parameters");
    return;
  } else {
    if (ts < 1ULL) {
      ttservlog(g_serv, 1, "do_repl: invalid parameters");
      return;
    } else {
      if (sid < 1U) {
        ttservlog(g_serv, 1, "do_repl: invalid parameters");
        return;
      }
    }
  }
  if (mask___0 & (1ULL << 25)) {
    ttservlog(g_serv, 1, "do_repl: forbidden");
    return;
  }
  if (sid == arg->sid) {
    ttservlog(g_serv, 1, "do_repl: rejected circular replication");
    return;
  }
  lnum = (uint32_t )((((((unsigned long )arg->sid & 255UL) << 24) | (((unsigned long )arg->sid & 65280UL) << 8)) | (((unsigned long )arg->sid & 16711680UL) >> 8)) | (((unsigned long )arg->sid & 4278190080UL) >> 24));
  tmp___2 = ttsocksend(sock, (void const   *)(& lnum), (int )sizeof(lnum));
  if (! tmp___2) {
    ttservlog(g_serv, 1, "do_repl: response failed");
    return;
  }
  tmp___3 = tculrdnew(ulog, ts);
  ulrd = tmp___3;
  if (ulrd) {
    ttservlog(g_serv, 1, "replicating to sid=%u after %llu", sid, ts - 1ULL);
    while (1) {
      __cancel_routine = (void (*)(void * ))(& tculrddel);
      __cancel_arg = (void *)ulrd;
      tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                            0);
      not_first_call = tmp___4;
      tmp___5 = __builtin_expect((long )not_first_call, 0L);
      if (tmp___5) {
        (*__cancel_routine)(__cancel_arg);
        __pthread_unwind_next(& __cancel_buf);
      }
      __pthread_register_cancel(& __cancel_buf);
      while (1) {
        err = (_Bool)0;
        noptime = (double )0;
        while (1) {
          if (! err) {
            tmp___18 = ttserviskilled(g_serv);
            if (tmp___18) {
              break;
            }
          } else {
            break;
          }
          ttsocksetlife(sock, (double )4294967295U);
          tmp___6 = tctime();
          now = tmp___6;
          req->mtime = now + (double )4294967295U;
          if (now - noptime >= 1.0) {
            *((unsigned char *)(stack)) = (unsigned char)202;
            tmp___7 = ttsocksend(sock, (void const   *)(stack), (int )sizeof(uint8_t ));
            if (! tmp___7) {
              err = (_Bool)1;
              ttservlog(g_serv, 1, "do_repl: connection closed");
            }
            noptime = now;
          }
          tculrdwait(ulrd);
          nopcnt = (uint32_t )0;
          while (1) {
            if (! err) {
              tmp___17 = tculrdread(ulrd, & rsiz, & rts, & rsid, & rmid);
              rbuf = (char const   *)tmp___17;
              if (! ((unsigned int )rbuf != (unsigned int )((void *)0))) {
                break;
              }
            } else {
              break;
            }
            if (rsid == sid) {
              goto _L;
            } else {
              if (rmid == sid) {
                _L: /* CIL Label */ 
                tmp___9 = nopcnt;
                nopcnt ++;
                if ((tmp___9 & 255U) == 0U) {
                  now = tctime();
                  if (now - noptime >= 1.0) {
                    *((unsigned char *)(stack)) = (unsigned char)202;
                    tmp___8 = ttsocksend(sock, (void const   *)(stack), (int )sizeof(uint8_t ));
                    if (! tmp___8) {
                      err = (_Bool)1;
                      ttservlog(g_serv, 1, "do_repl: connection closed");
                    }
                    noptime = now;
                  }
                }
                continue;
              }
            }
            msiz = (((int )sizeof(uint8_t ) + (int )sizeof(uint64_t )) + (int )sizeof(uint32_t ) * 2) + rsiz;
            if (msiz < 65536) {
              tmp___11 = stack;
            } else {
              tmp___10 = tcmalloc((unsigned int )msiz);
              tmp___11 = (char *)tmp___10;
            }
            mbuf = tmp___11;
            while (1) {
              __cancel_routine___do_repl = & free;
              if ((unsigned int )mbuf == (unsigned int )(stack)) {
                tmp___12 = (char *)((void *)0);
              } else {
                tmp___12 = mbuf;
              }
              __cancel_arg___0 = (void *)tmp___12;
              tmp___13 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                                     0);
              not_first_call___0 = tmp___13;
              tmp___14 = __builtin_expect((long )not_first_call___0, 0L);
              if (tmp___14) {
                (*__cancel_routine___do_repl)(__cancel_arg___0);
                __pthread_unwind_next(& __cancel_buf___0);
              }
              __pthread_register_cancel(& __cancel_buf___0);
              while (1) {
                wp = (unsigned char *)mbuf;
                tmp___15 = wp;
                wp ++;
                *tmp___15 = (unsigned char)201;
                llnum = ((((((((rts & 255ULL) << 56) | ((rts & 65280ULL) << 40)) | ((rts & 16711680ULL) << 24)) | ((rts & 4278190080ULL) << 8)) | ((rts & 1095216660480ULL) >> 8)) | ((rts & 280375465082880ULL) >> 24)) | ((rts & 71776119061217280ULL) >> 40)) | ((rts & 0xff00000000000000ULL) >> 56);
                memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum),
                       (unsigned int )((int )sizeof(llnum)));
                wp += (int )sizeof(llnum);
                lnum = (unsigned int )((((((unsigned long )rsid & 255UL) << 24) | (((unsigned long )rsid & 65280UL) << 8)) | (((unsigned long )rsid & 16711680UL) >> 8)) | (((unsigned long )rsid & 4278190080UL) >> 24));
                memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum),
                       (unsigned int )((int )sizeof(lnum)));
                wp += (int )sizeof(lnum);
                lnum = (unsigned int )((((((unsigned long )rsiz & 255UL) << 24) | (((unsigned long )rsiz & 65280UL) << 8)) | (((unsigned long )rsiz & 16711680UL) >> 8)) | (((unsigned long )rsiz & 4278190080UL) >> 24));
                memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum),
                       (unsigned int )((int )sizeof(lnum)));
                wp += (int )sizeof(lnum);
                memcpy((void * __restrict  )wp, (void const   * __restrict  )rbuf,
                       (unsigned int )rsiz);
                tmp___16 = ttsocksend(sock, (void const   *)mbuf, msiz);
                if (! tmp___16) {
                  err = (_Bool)1;
                  ttservlog(g_serv, 1, "do_repl: response failed");
                }
                break;
              }
              __pthread_unregister_cancel(& __cancel_buf___0);
              (*__cancel_routine___do_repl)(__cancel_arg___0);
              break;
            }
          }
        }
        break;
      }
      __pthread_unregister_cancel(& __cancel_buf);
      (*__cancel_routine)(__cancel_arg);
      break;
    }
  } else {
    ttservlog(g_serv, 2, "do_repl: tculrdnew failed");
  }
  return;
}
}
static void do_mc_set(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens , int tnum ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  _Bool nr ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *kbuf ;
  int ksiz ;
  size_t tmp___7 ;
  int vsiz ;
  int64_t tmp___8 ;
  long tmp___9 ;
  char stack[65536] ;
  char *vbuf ;
  void *tmp___10 ;
  char *tmp___11 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___12 ;
  int not_first_call ;
  int tmp___13 ;
  long tmp___14 ;
  int len ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  _Bool tmp___20 ;

  {
  ttservlog(g_serv, 0, "doing mc_set command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  if (tnum < 5) {
    ttsockprintf(sock, "CLIENT_ERROR error\r\n");
    return;
  }
  if (tnum > 5) {
    if (0) {
      __s1_len = strlen((char const   *)*(tokens + 5));
      __s2_len = strlen("noreply");
      if (! ((unsigned int )((void const   *)(*(tokens + 5) + 1)) - (unsigned int )((void const   *)*(tokens + 5)) == 1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
          if (! ((unsigned int )((void const   *)("noreply" + 1)) - (unsigned int )((void const   *)"noreply") == 1U)) {
            tmp___5 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___5 = 1;
            } else {
              tmp___5 = 0;
            }
          }
        } else {
          tmp___5 = 0;
        }
      }
      if (tmp___5) {
        tmp___0 = __builtin_strcmp((char const   *)*(tokens + 5), "noreply");
        tmp___4 = tmp___0;
      } else {
        tmp___3 = __builtin_strcmp((char const   *)*(tokens + 5), "noreply");
        tmp___4 = tmp___3;
      }
    } else {
      tmp___3 = __builtin_strcmp((char const   *)*(tokens + 5), "noreply");
      tmp___4 = tmp___3;
    }
    if (tmp___4) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
  } else {
    tmp___6 = 0;
  }
  nr = (_Bool )tmp___6;
  kbuf = (char const   *)*(tokens + 1);
  tmp___7 = strlen(kbuf);
  ksiz = (int )tmp___7;
  tmp___8 = tcatoi((char const   *)*(tokens + 4));
  tmp___9 = tclmax((long )tmp___8, 0L);
  vsiz = (int )tmp___9;
  if (vsiz < 65536) {
    tmp___11 = stack;
  } else {
    tmp___10 = tcmalloc((unsigned int )(vsiz + 1));
    tmp___11 = (char *)tmp___10;
  }
  vbuf = tmp___11;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )vbuf == (unsigned int )(stack)) {
      tmp___12 = (char *)((void *)0);
    } else {
      tmp___12 = vbuf;
    }
    __cancel_arg = (void *)tmp___12;
    tmp___13 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                           0);
    not_first_call = tmp___13;
    tmp___14 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___14) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___17 = ttsockrecv(sock, vbuf, vsiz);
      if (tmp___17) {
        tmp___18 = ttsockgetc(sock);
        if (tmp___18 == 13) {
          tmp___19 = ttsockgetc(sock);
          if (tmp___19 == 10) {
            tmp___20 = ttsockcheckend(sock);
            if (tmp___20) {
              ttservlog(g_serv, 1, "do_mc_set: invalid entity");
            } else {
              if (mask___0 & ((1ULL | (1ULL << 28)) | (1ULL << 31))) {
                len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"CLIENT_ERROR forbidden\r\n");
                ttservlog(g_serv, 1, "do_mc_set: forbidden");
              } else {
                tmp___15 = tculogadbput(ulog, sid, 0U, adb, (void const   *)kbuf,
                                        ksiz, (void const   *)vbuf, vsiz);
                if (tmp___15) {
                  len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"STORED\r\n");
                } else {
                  len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"SERVER_ERROR unexpected\r\n");
                  ttservlog(g_serv, 2, "do_mc_set: operation failed");
                }
              }
              if (nr) {
                req->keep = (_Bool)1;
              } else {
                tmp___16 = ttsocksend(sock, (void const   *)(stack), len);
                if (tmp___16) {
                  req->keep = (_Bool)1;
                } else {
                  ttservlog(g_serv, 1, "do_mc_set: response failed");
                }
              }
            }
          } else {
            ttservlog(g_serv, 1, "do_mc_set: invalid entity");
          }
        } else {
          ttservlog(g_serv, 1, "do_mc_set: invalid entity");
        }
      } else {
        ttservlog(g_serv, 1, "do_mc_set: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_mc_add(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens , int tnum ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  _Bool nr ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *kbuf ;
  int ksiz ;
  size_t tmp___7 ;
  int vsiz ;
  int64_t tmp___8 ;
  long tmp___9 ;
  char stack[65536] ;
  char *vbuf ;
  void *tmp___10 ;
  char *tmp___11 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___12 ;
  int not_first_call ;
  int tmp___13 ;
  long tmp___14 ;
  int len ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  _Bool tmp___20 ;

  {
  ttservlog(g_serv, 0, "doing mc_add command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  if (tnum < 5) {
    ttsockprintf(sock, "CLIENT_ERROR error\r\n");
    return;
  }
  if (tnum > 5) {
    if (0) {
      __s1_len = strlen((char const   *)*(tokens + 5));
      __s2_len = strlen("noreply");
      if (! ((unsigned int )((void const   *)(*(tokens + 5) + 1)) - (unsigned int )((void const   *)*(tokens + 5)) == 1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
          if (! ((unsigned int )((void const   *)("noreply" + 1)) - (unsigned int )((void const   *)"noreply") == 1U)) {
            tmp___5 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___5 = 1;
            } else {
              tmp___5 = 0;
            }
          }
        } else {
          tmp___5 = 0;
        }
      }
      if (tmp___5) {
        tmp___0 = __builtin_strcmp((char const   *)*(tokens + 5), "noreply");
        tmp___4 = tmp___0;
      } else {
        tmp___3 = __builtin_strcmp((char const   *)*(tokens + 5), "noreply");
        tmp___4 = tmp___3;
      }
    } else {
      tmp___3 = __builtin_strcmp((char const   *)*(tokens + 5), "noreply");
      tmp___4 = tmp___3;
    }
    if (tmp___4) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
  } else {
    tmp___6 = 0;
  }
  nr = (_Bool )tmp___6;
  kbuf = (char const   *)*(tokens + 1);
  tmp___7 = strlen(kbuf);
  ksiz = (int )tmp___7;
  tmp___8 = tcatoi((char const   *)*(tokens + 4));
  tmp___9 = tclmax((long )tmp___8, 0L);
  vsiz = (int )tmp___9;
  if (vsiz < 65536) {
    tmp___11 = stack;
  } else {
    tmp___10 = tcmalloc((unsigned int )(vsiz + 1));
    tmp___11 = (char *)tmp___10;
  }
  vbuf = tmp___11;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )vbuf == (unsigned int )(stack)) {
      tmp___12 = (char *)((void *)0);
    } else {
      tmp___12 = vbuf;
    }
    __cancel_arg = (void *)tmp___12;
    tmp___13 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                           0);
    not_first_call = tmp___13;
    tmp___14 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___14) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___17 = ttsockrecv(sock, vbuf, vsiz);
      if (tmp___17) {
        tmp___18 = ttsockgetc(sock);
        if (tmp___18 == 13) {
          tmp___19 = ttsockgetc(sock);
          if (tmp___19 == 10) {
            tmp___20 = ttsockcheckend(sock);
            if (tmp___20) {
              ttservlog(g_serv, 1, "do_mc_add: invalid entity");
            } else {
              if (mask___0 & (((1ULL << 1) | (1ULL << 28)) | (1ULL << 31))) {
                len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"CLIENT_ERROR forbidden\r\n");
                ttservlog(g_serv, 1, "do_mc_add: forbidden");
              } else {
                tmp___15 = tculogadbputkeep(ulog, sid, 0U, adb, (void const   *)kbuf,
                                            ksiz, (void const   *)vbuf, vsiz);
                if (tmp___15) {
                  len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"STORED\r\n");
                } else {
                  len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"NOT_STORED\r\n");
                }
              }
              if (nr) {
                req->keep = (_Bool)1;
              } else {
                tmp___16 = ttsocksend(sock, (void const   *)(stack), len);
                if (tmp___16) {
                  req->keep = (_Bool)1;
                } else {
                  ttservlog(g_serv, 1, "do_mc_add: response failed");
                }
              }
            }
          } else {
            ttservlog(g_serv, 1, "do_mc_add: invalid entity");
          }
        } else {
          ttservlog(g_serv, 1, "do_mc_add: invalid entity");
        }
      } else {
        ttservlog(g_serv, 1, "do_mc_add: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_mc_replace(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                          int tnum ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  _Bool nr ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *kbuf ;
  int ksiz ;
  size_t tmp___7 ;
  int vsiz ;
  int64_t tmp___8 ;
  long tmp___9 ;
  char stack[65536] ;
  char *vbuf ;
  void *tmp___10 ;
  char *tmp___11 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  char *tmp___12 ;
  int not_first_call ;
  int tmp___13 ;
  long tmp___14 ;
  int len ;
  int tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  _Bool tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  _Bool tmp___21 ;

  {
  ttservlog(g_serv, 0, "doing mc_replace command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  if (tnum < 5) {
    ttsockprintf(sock, "CLIENT_ERROR error\r\n");
    return;
  }
  if (tnum > 5) {
    if (0) {
      __s1_len = strlen((char const   *)*(tokens + 5));
      __s2_len = strlen("noreply");
      if (! ((unsigned int )((void const   *)(*(tokens + 5) + 1)) - (unsigned int )((void const   *)*(tokens + 5)) == 1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
          if (! ((unsigned int )((void const   *)("noreply" + 1)) - (unsigned int )((void const   *)"noreply") == 1U)) {
            tmp___5 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___5 = 1;
            } else {
              tmp___5 = 0;
            }
          }
        } else {
          tmp___5 = 0;
        }
      }
      if (tmp___5) {
        tmp___0 = __builtin_strcmp((char const   *)*(tokens + 5), "noreply");
        tmp___4 = tmp___0;
      } else {
        tmp___3 = __builtin_strcmp((char const   *)*(tokens + 5), "noreply");
        tmp___4 = tmp___3;
      }
    } else {
      tmp___3 = __builtin_strcmp((char const   *)*(tokens + 5), "noreply");
      tmp___4 = tmp___3;
    }
    if (tmp___4) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
  } else {
    tmp___6 = 0;
  }
  nr = (_Bool )tmp___6;
  kbuf = (char const   *)*(tokens + 1);
  tmp___7 = strlen(kbuf);
  ksiz = (int )tmp___7;
  tmp___8 = tcatoi((char const   *)*(tokens + 4));
  tmp___9 = tclmax((long )tmp___8, 0L);
  vsiz = (int )tmp___9;
  if (vsiz < 65536) {
    tmp___11 = stack;
  } else {
    tmp___10 = tcmalloc((unsigned int )(vsiz + 1));
    tmp___11 = (char *)tmp___10;
  }
  vbuf = tmp___11;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )vbuf == (unsigned int )(stack)) {
      tmp___12 = (char *)((void *)0);
    } else {
      tmp___12 = vbuf;
    }
    __cancel_arg = (void *)tmp___12;
    tmp___13 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                           0);
    not_first_call = tmp___13;
    tmp___14 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___14) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___18 = ttsockrecv(sock, vbuf, vsiz);
      if (tmp___18) {
        tmp___19 = ttsockgetc(sock);
        if (tmp___19 == 13) {
          tmp___20 = ttsockgetc(sock);
          if (tmp___20 == 10) {
            tmp___21 = ttsockcheckend(sock);
            if (tmp___21) {
              ttservlog(g_serv, 1, "do_mc_replace: invalid entity");
            } else {
              if (mask___0 & ((1ULL | (1ULL << 28)) | (1ULL << 31))) {
                len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"CLIENT_ERROR forbidden\r\n");
                ttservlog(g_serv, 1, "do_mc_replace: forbidden");
              } else {
                tmp___15 = tcadbvsiz(adb, (void const   *)kbuf, ksiz);
                if (tmp___15 >= 0) {
                  tmp___16 = tculogadbput(ulog, sid, 0U, adb, (void const   *)kbuf,
                                          ksiz, (void const   *)vbuf, vsiz);
                  if (tmp___16) {
                    len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"STORED\r\n");
                  } else {
                    len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"NOT_STORED\r\n");
                  }
                } else {
                  len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"NOT_STORED\r\n");
                }
              }
              if (nr) {
                req->keep = (_Bool)1;
              } else {
                tmp___17 = ttsocksend(sock, (void const   *)(stack), len);
                if (tmp___17) {
                  req->keep = (_Bool)1;
                } else {
                  ttservlog(g_serv, 1, "do_mc_replace: response failed");
                }
              }
            }
          } else {
            ttservlog(g_serv, 1, "do_mc_replace: invalid entity");
          }
        } else {
          ttservlog(g_serv, 1, "do_mc_replace: invalid entity");
        }
      } else {
        ttservlog(g_serv, 1, "do_mc_replace: invalid entity");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_mc_get(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens , int tnum ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCXSTR *xstr ;
  TCXSTR *tmp ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;
  int i ;
  char const   *kbuf ;
  int ksiz ;
  size_t tmp___2 ;
  int vsiz ;
  char *vbuf ;
  void *tmp___3 ;
  int tmp___4 ;
  void const   *tmp___5 ;
  _Bool tmp___6 ;

  {
  ttservlog(g_serv, 0, "doing mc_get command");
  mask___0 = arg->mask;
  adb = arg->adb;
  if (tnum < 2) {
    ttsockprintf(sock, "CLIENT_ERROR error\r\n");
    return;
  }
  tmp = tcxstrnew();
  xstr = tmp;
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcxstrdel);
    __cancel_arg = (void *)xstr;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      i = 1;
      while (i < tnum) {
        kbuf = (char const   *)*(tokens + i);
        tmp___2 = strlen(kbuf);
        ksiz = (int )tmp___2;
        if (mask___0 & (((1ULL << 6) | (1ULL << 28)) | (1ULL << 30))) {
          vbuf = (char *)((void *)0);
          vsiz = 0;
          ttservlog(g_serv, 1, "do_mc_get: forbidden");
        } else {
          tmp___3 = tcadbget(adb, (void const   *)kbuf, ksiz, & vsiz);
          vbuf = (char *)tmp___3;
        }
        if (vbuf) {
          tcxstrprintf(xstr, "VALUE %s 0 %d\r\n", kbuf, vsiz);
          tcxstrcat(xstr, (void const   *)vbuf, vsiz);
          tcxstrcat(xstr, (void const   *)"\r\n", 2);
          tcfree((void *)vbuf);
        }
        i ++;
      }
      tcxstrprintf(xstr, "END\r\n");
      tmp___4 = tcxstrsize((TCXSTR const   *)xstr);
      tmp___5 = tcxstrptr((TCXSTR const   *)xstr);
      tmp___6 = ttsocksend(sock, tmp___5, tmp___4);
      if (tmp___6) {
        req->keep = (_Bool)1;
      } else {
        ttservlog(g_serv, 1, "do_mc_get: response failed");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_mc_delete(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                         int tnum ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  _Bool nr ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char const   *kbuf ;
  int ksiz ;
  size_t tmp___14 ;
  char stack[65536] ;
  int len ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;

  {
  ttservlog(g_serv, 0, "doing mc_delete command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  if (tnum < 2) {
    ttsockprintf(sock, "CLIENT_ERROR error\r\n");
    return;
  }
  if (tnum > 2) {
    if (0) {
      __s1_len = strlen((char const   *)*(tokens + 2));
      __s2_len = strlen("noreply");
      if (! ((unsigned int )((void const   *)(*(tokens + 2) + 1)) - (unsigned int )((void const   *)*(tokens + 2)) == 1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
          if (! ((unsigned int )((void const   *)("noreply" + 1)) - (unsigned int )((void const   *)"noreply") == 1U)) {
            tmp___5 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___5 = 1;
            } else {
              tmp___5 = 0;
            }
          }
        } else {
          tmp___5 = 0;
        }
      }
      if (tmp___5) {
        tmp___0 = __builtin_strcmp((char const   *)*(tokens + 2), "noreply");
        tmp___4 = tmp___0;
      } else {
        tmp___3 = __builtin_strcmp((char const   *)*(tokens + 2), "noreply");
        tmp___4 = tmp___3;
      }
    } else {
      tmp___3 = __builtin_strcmp((char const   *)*(tokens + 2), "noreply");
      tmp___4 = tmp___3;
    }
    if (tmp___4) {
      goto _L___3;
    } else {
      tmp___13 = 1;
    }
  } else {
    _L___3: /* CIL Label */ 
    if (tnum > 3) {
      if (0) {
        __s1_len___0 = strlen((char const   *)*(tokens + 3));
        __s2_len___0 = strlen("noreply");
        if (! ((unsigned int )((void const   *)(*(tokens + 3) + 1)) - (unsigned int )((void const   *)*(tokens + 3)) == 1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
            if (! ((unsigned int )((void const   *)("noreply" + 1)) - (unsigned int )((void const   *)"noreply") == 1U)) {
              tmp___12 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___12 = 1;
              } else {
                tmp___12 = 0;
              }
            }
          } else {
            tmp___12 = 0;
          }
        }
        if (tmp___12) {
          tmp___7 = __builtin_strcmp((char const   *)*(tokens + 3), "noreply");
          tmp___11 = tmp___7;
        } else {
          tmp___10 = __builtin_strcmp((char const   *)*(tokens + 3), "noreply");
          tmp___11 = tmp___10;
        }
      } else {
        tmp___10 = __builtin_strcmp((char const   *)*(tokens + 3), "noreply");
        tmp___11 = tmp___10;
      }
      if (tmp___11) {
        tmp___13 = 0;
      } else {
        tmp___13 = 1;
      }
    } else {
      tmp___13 = 0;
    }
  }
  nr = (_Bool )tmp___13;
  kbuf = (char const   *)*(tokens + 1);
  tmp___14 = strlen(kbuf);
  ksiz = (int )tmp___14;
  if (mask___0 & (((1ULL << 5) | (1ULL << 28)) | (1ULL << 31))) {
    len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"CLIENT_ERROR forbidden\r\n");
    ttservlog(g_serv, 1, "do_mc_delete: forbidden");
  } else {
    tmp___15 = tculogadbout(ulog, sid, 0U, adb, (void const   *)kbuf, ksiz);
    if (tmp___15) {
      len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"DELETED\r\n");
    } else {
      len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"NOT_FOUND\r\n");
    }
  }
  if (nr) {
    req->keep = (_Bool)1;
  } else {
    tmp___16 = ttsocksend(sock, (void const   *)(stack), len);
    if (tmp___16) {
      req->keep = (_Bool)1;
    } else {
      ttservlog(g_serv, 1, "do_mc_delete: response failed");
    }
  }
  return;
}
}
static void do_mc_incr(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                       int tnum ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  pthread_mutex_t *rmtxs ;
  _Bool nr ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *kbuf ;
  int ksiz ;
  size_t tmp___7 ;
  int64_t num ;
  int64_t tmp___8 ;
  int mtxidx ;
  uint32_t tmp___9 ;
  char stack[65536] ;
  int len ;
  int tmp___10 ;
  int vsiz ;
  char *vbuf ;
  void *tmp___11 ;
  int64_t tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;

  {
  ttservlog(g_serv, 0, "doing mc_incr command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  rmtxs = arg->rmtxs;
  if (tnum < 3) {
    ttsockprintf(sock, "CLIENT_ERROR error\r\n");
    return;
  }
  if (tnum > 3) {
    if (0) {
      __s1_len = strlen((char const   *)*(tokens + 3));
      __s2_len = strlen("noreply");
      if (! ((unsigned int )((void const   *)(*(tokens + 3) + 1)) - (unsigned int )((void const   *)*(tokens + 3)) == 1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
          if (! ((unsigned int )((void const   *)("noreply" + 1)) - (unsigned int )((void const   *)"noreply") == 1U)) {
            tmp___5 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___5 = 1;
            } else {
              tmp___5 = 0;
            }
          }
        } else {
          tmp___5 = 0;
        }
      }
      if (tmp___5) {
        tmp___0 = __builtin_strcmp((char const   *)*(tokens + 3), "noreply");
        tmp___4 = tmp___0;
      } else {
        tmp___3 = __builtin_strcmp((char const   *)*(tokens + 3), "noreply");
        tmp___4 = tmp___3;
      }
    } else {
      tmp___3 = __builtin_strcmp((char const   *)*(tokens + 3), "noreply");
      tmp___4 = tmp___3;
    }
    if (tmp___4) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
  } else {
    tmp___6 = 0;
  }
  nr = (_Bool )tmp___6;
  kbuf = (char const   *)*(tokens + 1);
  tmp___7 = strlen(kbuf);
  ksiz = (int )tmp___7;
  tmp___8 = tcatoi((char const   *)*(tokens + 2));
  num = tmp___8;
  tmp___9 = recmtxidx(kbuf, ksiz);
  mtxidx = (int )tmp___9;
  if (mask___0 & (((1ULL << 12) | (1ULL << 28)) | (1ULL << 31))) {
    len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"CLIENT_ERROR forbidden\r\n");
    ttservlog(g_serv, 1, "do_mc_incr: forbidden");
  } else {
    tmp___10 = pthread_mutex_lock(rmtxs + mtxidx);
    if (tmp___10 != 0) {
      ttsockprintf(sock, "SERVER_ERROR unexpected\r\n");
      ttservlog(g_serv, 2, "do_mc_incr: pthread_mutex_lock failed");
      return;
    }
    tmp___11 = tcadbget(adb, (void const   *)kbuf, ksiz, & vsiz);
    vbuf = (char *)tmp___11;
    if (vbuf) {
      tmp___12 = tcatoi((char const   *)vbuf);
      num += tmp___12;
      if (num < 0LL) {
        num = 0LL;
      }
      len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"%lld",
                    num);
      tmp___13 = tculogadbput(ulog, sid, 0U, adb, (void const   *)kbuf, ksiz, (void const   *)(stack),
                              len);
      if (tmp___13) {
        len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"%lld\r\n",
                      num);
      } else {
        len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"SERVER_ERROR unexpected\r\n");
        ttservlog(g_serv, 2, "do_mc_incr: operation failed");
      }
      tcfree((void *)vbuf);
    } else {
      len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"NOT_FOUND\r\n");
    }
    tmp___14 = pthread_mutex_unlock(rmtxs + mtxidx);
    if (tmp___14 != 0) {
      ttservlog(g_serv, 2, "do_mc_incr: pthread_mutex_unlock failed");
    }
  }
  if (nr) {
    req->keep = (_Bool)1;
  } else {
    tmp___15 = ttsocksend(sock, (void const   *)(stack), len);
    if (tmp___15) {
      req->keep = (_Bool)1;
    } else {
      ttservlog(g_serv, 1, "do_mc_incr: response failed");
    }
  }
  return;
}
}
static void do_mc_decr(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                       int tnum ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  pthread_mutex_t *rmtxs ;
  _Bool nr ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *kbuf ;
  int ksiz ;
  size_t tmp___7 ;
  int64_t num ;
  int64_t tmp___8 ;
  int mtxidx ;
  uint32_t tmp___9 ;
  char stack[65536] ;
  int len ;
  int tmp___10 ;
  int vsiz ;
  char *vbuf ;
  void *tmp___11 ;
  int64_t tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  _Bool tmp___15 ;

  {
  ttservlog(g_serv, 0, "doing mc_decr command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  rmtxs = arg->rmtxs;
  if (tnum < 3) {
    ttsockprintf(sock, "CLIENT_ERROR error\r\n");
    return;
  }
  if (tnum > 3) {
    if (0) {
      __s1_len = strlen((char const   *)*(tokens + 3));
      __s2_len = strlen("noreply");
      if (! ((unsigned int )((void const   *)(*(tokens + 3) + 1)) - (unsigned int )((void const   *)*(tokens + 3)) == 1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
          if (! ((unsigned int )((void const   *)("noreply" + 1)) - (unsigned int )((void const   *)"noreply") == 1U)) {
            tmp___5 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___5 = 1;
            } else {
              tmp___5 = 0;
            }
          }
        } else {
          tmp___5 = 0;
        }
      }
      if (tmp___5) {
        tmp___0 = __builtin_strcmp((char const   *)*(tokens + 3), "noreply");
        tmp___4 = tmp___0;
      } else {
        tmp___3 = __builtin_strcmp((char const   *)*(tokens + 3), "noreply");
        tmp___4 = tmp___3;
      }
    } else {
      tmp___3 = __builtin_strcmp((char const   *)*(tokens + 3), "noreply");
      tmp___4 = tmp___3;
    }
    if (tmp___4) {
      tmp___6 = 0;
    } else {
      tmp___6 = 1;
    }
  } else {
    tmp___6 = 0;
  }
  nr = (_Bool )tmp___6;
  kbuf = (char const   *)*(tokens + 1);
  tmp___7 = strlen(kbuf);
  ksiz = (int )tmp___7;
  tmp___8 = tcatoi((char const   *)*(tokens + 2));
  num = tmp___8 * -1LL;
  tmp___9 = recmtxidx(kbuf, ksiz);
  mtxidx = (int )tmp___9;
  if (mask___0 & (((1ULL << 12) | (1ULL << 28)) | (1ULL << 31))) {
    len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"CLIENT_ERROR forbidden\r\n");
    ttservlog(g_serv, 1, "do_mc_decr: forbidden");
  } else {
    tmp___10 = pthread_mutex_lock(rmtxs + mtxidx);
    if (tmp___10 != 0) {
      ttsockprintf(sock, "SERVER_ERROR unexpected\r\n");
      ttservlog(g_serv, 2, "do_mc_decr: pthread_mutex_lock failed");
      return;
    }
    tmp___11 = tcadbget(adb, (void const   *)kbuf, ksiz, & vsiz);
    vbuf = (char *)tmp___11;
    if (vbuf) {
      tmp___12 = tcatoi((char const   *)vbuf);
      num += tmp___12;
      if (num < 0LL) {
        num = 0LL;
      }
      len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"%lld",
                    num);
      tmp___13 = tculogadbput(ulog, sid, 0U, adb, (void const   *)kbuf, ksiz, (void const   *)(stack),
                              len);
      if (tmp___13) {
        len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"%lld\r\n",
                      num);
      } else {
        len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"SERVER_ERROR unexpected\r\n");
        ttservlog(g_serv, 2, "do_mc_decr: operation failed");
      }
      tcfree((void *)vbuf);
    } else {
      len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"NOT_FOUND\r\n");
    }
    tmp___14 = pthread_mutex_unlock(rmtxs + mtxidx);
    if (tmp___14 != 0) {
      ttservlog(g_serv, 2, "do_mc_decr: pthread_mutex_unlock failed");
    }
  }
  if (nr) {
    req->keep = (_Bool)1;
  } else {
    tmp___15 = ttsocksend(sock, (void const   *)(stack), len);
    if (tmp___15) {
      req->keep = (_Bool)1;
    } else {
      ttservlog(g_serv, 1, "do_mc_decr: response failed");
    }
  }
  return;
}
}
static void do_mc_stats(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                        int tnum ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  char stack[65536] ;
  char *wp ;
  __pid_t tmp ;
  int tmp___0 ;
  time_t now ;
  time_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct rusage ubuf ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  uint64_t tmp___8 ;
  int tmp___9 ;
  uint64_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;

  {
  ttservlog(g_serv, 0, "doing mc_stats command");
  mask___0 = arg->mask;
  adb = arg->adb;
  wp = stack;
  if (mask___0 & (((1ULL << 23) | (1ULL << 28)) | (1ULL << 30))) {
    ttservlog(g_serv, 1, "do_mc_stats: forbidden");
  } else {
    tmp = getpid();
    tmp___0 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"STAT pid %lld\r\n",
                      (long long )tmp);
    wp += tmp___0;
    tmp___1 = time((time_t *)((void *)0));
    now = tmp___1;
    tmp___2 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"STAT uptime %lld\r\n",
                      (long long )(now - (time_t )((int )g_starttime)));
    wp += tmp___2;
    tmp___3 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"STAT time %lld\r\n",
                      (long long )now);
    wp += tmp___3;
    tmp___4 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"STAT version %s\r\n",
                      ttversion);
    wp += tmp___4;
    memset((void *)(& ubuf), 0, (unsigned int )((int )sizeof(ubuf)));
    tmp___7 = getrusage((enum __rusage_who )0, & ubuf);
    if (tmp___7 == 0) {
      tmp___5 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"STAT rusage_user %d.%06d\r\n",
                        (int )ubuf.ru_utime.tv_sec, (int )ubuf.ru_utime.tv_usec);
      wp += tmp___5;
      tmp___6 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"STAT rusage_system %d.%06d\r\n",
                        (int )ubuf.ru_stime.tv_sec, (int )ubuf.ru_stime.tv_usec);
      wp += tmp___6;
    }
    tmp___8 = tcadbrnum(adb);
    tmp___9 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"STAT curr_items %lld\r\n",
                      (long long )tmp___8);
    wp += tmp___9;
    tmp___10 = tcadbsize(adb);
    tmp___11 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"STAT bytes %lld\r\n",
                       (long long )tmp___10);
    wp += tmp___11;
    tmp___12 = sprintf((char * __restrict  )wp, (char const   * __restrict  )"END\r\n");
    wp += tmp___12;
  }
  tmp___13 = ttsocksend(sock, (void const   *)(stack), wp - stack);
  if (tmp___13) {
    req->keep = (_Bool)1;
  } else {
    ttservlog(g_serv, 1, "do_mc_stats: response failed");
  }
  return;
}
}
static void do_mc_flushall(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                           int tnum ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  _Bool nr ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char stack[65536] ;
  int len ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;

  {
  ttservlog(g_serv, 1, "doing mc_flushall command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  if (tnum > 1) {
    if (0) {
      __s1_len = strlen((char const   *)*(tokens + 1));
      __s2_len = strlen("noreply");
      if (! ((unsigned int )((void const   *)(*(tokens + 1) + 1)) - (unsigned int )((void const   *)*(tokens + 1)) == 1U)) {
        goto _L___0;
      } else {
        if (__s1_len >= 4U) {
          _L___0: /* CIL Label */ 
          if (! ((unsigned int )((void const   *)("noreply" + 1)) - (unsigned int )((void const   *)"noreply") == 1U)) {
            tmp___5 = 1;
          } else {
            if (__s2_len >= 4U) {
              tmp___5 = 1;
            } else {
              tmp___5 = 0;
            }
          }
        } else {
          tmp___5 = 0;
        }
      }
      if (tmp___5) {
        tmp___0 = __builtin_strcmp((char const   *)*(tokens + 1), "noreply");
        tmp___4 = tmp___0;
      } else {
        tmp___3 = __builtin_strcmp((char const   *)*(tokens + 1), "noreply");
        tmp___4 = tmp___3;
      }
    } else {
      tmp___3 = __builtin_strcmp((char const   *)*(tokens + 1), "noreply");
      tmp___4 = tmp___3;
    }
    if (tmp___4) {
      goto _L___3;
    } else {
      tmp___13 = 1;
    }
  } else {
    _L___3: /* CIL Label */ 
    if (tnum > 2) {
      if (0) {
        __s1_len___0 = strlen((char const   *)*(tokens + 2));
        __s2_len___0 = strlen("noreply");
        if (! ((unsigned int )((void const   *)(*(tokens + 2) + 1)) - (unsigned int )((void const   *)*(tokens + 2)) == 1U)) {
          goto _L___2;
        } else {
          if (__s1_len___0 >= 4U) {
            _L___2: /* CIL Label */ 
            if (! ((unsigned int )((void const   *)("noreply" + 1)) - (unsigned int )((void const   *)"noreply") == 1U)) {
              tmp___12 = 1;
            } else {
              if (__s2_len___0 >= 4U) {
                tmp___12 = 1;
              } else {
                tmp___12 = 0;
              }
            }
          } else {
            tmp___12 = 0;
          }
        }
        if (tmp___12) {
          tmp___7 = __builtin_strcmp((char const   *)*(tokens + 2), "noreply");
          tmp___11 = tmp___7;
        } else {
          tmp___10 = __builtin_strcmp((char const   *)*(tokens + 2), "noreply");
          tmp___11 = tmp___10;
        }
      } else {
        tmp___10 = __builtin_strcmp((char const   *)*(tokens + 2), "noreply");
        tmp___11 = tmp___10;
      }
      if (tmp___11) {
        tmp___13 = 0;
      } else {
        tmp___13 = 1;
      }
    } else {
      tmp___13 = 0;
    }
  }
  nr = (_Bool )tmp___13;
  if (mask___0 & (((1ULL << 17) | (1ULL << 28)) | (1ULL << 31))) {
    len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"CLIENT_ERROR forbidden\r\n");
    ttservlog(g_serv, 1, "do_mc_flushall: forbidden");
  } else {
    tmp___14 = tculogadbvanish(ulog, sid, 0U, adb);
    if (tmp___14) {
      len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"OK\r\n");
    } else {
      len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"SERVER_ERROR unexpected\r\n");
      ttservlog(g_serv, 2, "do_mc_flushall: operation failed");
    }
  }
  if (nr) {
    req->keep = (_Bool)1;
  } else {
    tmp___15 = ttsocksend(sock, (void const   *)(stack), len);
    if (tmp___15) {
      req->keep = (_Bool)1;
    } else {
      ttservlog(g_serv, 1, "do_mc_flushall: response failed");
    }
  }
  return;
}
}
static void do_mc_version(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                          int tnum ) 
{ uint64_t mask___0 ;
  char stack[65536] ;
  int len ;
  _Bool tmp ;

  {
  ttservlog(g_serv, 0, "doing mc_version command");
  mask___0 = arg->mask;
  if (mask___0 & (((1ULL << 23) | (1ULL << 28)) | (1ULL << 30))) {
    len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"CLIENT_ERROR forbidden\r\n");
    ttservlog(g_serv, 1, "do_mc_version: forbidden");
  } else {
    len = sprintf((char * __restrict  )(stack), (char const   * __restrict  )"VERSION %s\r\n",
                  ttversion);
  }
  tmp = ttsocksend(sock, (void const   *)(stack), len);
  if (tmp) {
    req->keep = (_Bool)1;
  } else {
    ttservlog(g_serv, 1, "do_mc_version: response failed");
  }
  return;
}
}
static void do_mc_quit(TTSOCK *sock , TASKARG *arg , TTREQ *req , char **tokens ,
                       int tnum ) 
{ 

  {
  ttservlog(g_serv, 0, "doing mc_quit command");
  return;
}
}
static void do_http_get(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  _Bool keep ;
  char line[8192] ;
  char *pv ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int ksiz ;
  char *kbuf ;
  char *tmp___6 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___7 ;
  long tmp___8 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___9 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_http_get)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___10 ;
  long tmp___11 ;
  int len ;
  int tmp___12 ;
  int vsiz ;
  char *vbuf ;
  void *tmp___13 ;
  int len___0 ;
  int tmp___14 ;
  int tmp___15 ;
  void const   *tmp___16 ;
  _Bool tmp___17 ;

  {
  ttservlog(g_serv, 0, "doing http_get command");
  mask___0 = arg->mask;
  adb = arg->adb;
  keep = (_Bool )(ver >= 1);
  while (1) {
    tmp___5 = ttsockgets(sock, line, 8192);
    if (tmp___5) {
      if (! ((int )line[0] != 0)) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = __builtin_strchr(line, ':');
    pv = tmp___0;
    if (! pv) {
      continue;
    }
    tmp___1 = pv;
    pv ++;
    *tmp___1 = (char )'\000';
    while (1) {
      if (! ((int )*pv == 32)) {
        if (! ((int )*pv == 9)) {
          break;
        }
      }
      pv ++;
    }
    tmp___4 = tcstricmp((char const   *)(line), "connection");
    if (! tmp___4) {
      tmp___3 = tcstricmp((char const   *)pv, "close");
      if (tmp___3) {
        tmp___2 = tcstricmp((char const   *)pv, "keep-alive");
        if (! tmp___2) {
          keep = (_Bool)1;
        }
      } else {
        keep = (_Bool)0;
      }
    }
  }
  if ((int const   )*uri == 47) {
    uri ++;
  }
  tmp___6 = tcurldecode(uri, & ksiz);
  kbuf = tmp___6;
  while (1) {
    __cancel_routine = & free;
    __cancel_arg = (void *)kbuf;
    tmp___7 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___7;
    tmp___8 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___8) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___9 = tcxstrnew();
      xstr = tmp___9;
      while (1) {
        __cancel_routine___do_http_get = (void (*)(void * ))(& tcxstrdel);
        __cancel_arg___0 = (void *)xstr;
        tmp___10 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                               0);
        not_first_call___0 = tmp___10;
        tmp___11 = __builtin_expect((long )not_first_call___0, 0L);
        if (tmp___11) {
          (*__cancel_routine___do_http_get)(__cancel_arg___0);
          __pthread_unwind_next(& __cancel_buf___0);
        }
        __pthread_register_cancel(& __cancel_buf___0);
        while (1) {
          if (mask___0 & (((1ULL << 6) | (1ULL << 29)) | (1ULL << 30))) {
            tmp___12 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Forbidden\n");
            len = tmp___12;
            tcxstrprintf(xstr, "HTTP/1.1 403 Forbidden\r\n");
            tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
            tcxstrprintf(xstr, "Content-Length: %d\r\n", len);
            tcxstrprintf(xstr, "\r\n");
            tcxstrcat(xstr, (void const   *)(line), len);
            ttservlog(g_serv, 1, "do_http_get: forbidden");
          } else {
            tmp___13 = tcadbget(adb, (void const   *)kbuf, ksiz, & vsiz);
            vbuf = (char *)tmp___13;
            if (vbuf) {
              tcxstrprintf(xstr, "HTTP/1.1 200 OK\r\n");
              tcxstrprintf(xstr, "Content-Type: application/octet-stream\r\n");
              tcxstrprintf(xstr, "Content-Length: %d\r\n", vsiz);
              tcxstrprintf(xstr, "\r\n");
              tcxstrcat(xstr, (void const   *)vbuf, vsiz);
              tcfree((void *)vbuf);
            } else {
              tmp___14 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Not Found\n");
              len___0 = tmp___14;
              tcxstrprintf(xstr, "HTTP/1.1 404 Not Found\r\n");
              tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
              tcxstrprintf(xstr, "Content-Length: %d\r\n", len___0);
              tcxstrprintf(xstr, "\r\n");
              tcxstrcat(xstr, (void const   *)(line), len___0);
            }
          }
          tmp___15 = tcxstrsize((TCXSTR const   *)xstr);
          tmp___16 = tcxstrptr((TCXSTR const   *)xstr);
          tmp___17 = ttsocksend(sock, tmp___16, tmp___15);
          if (tmp___17) {
            req->keep = keep;
          } else {
            ttservlog(g_serv, 1, "do_http_get: response failed");
          }
          break;
        }
        __pthread_unregister_cancel(& __cancel_buf___0);
        (*__cancel_routine___do_http_get)(__cancel_arg___0);
        break;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_http_head(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  _Bool keep ;
  char line[8192] ;
  char *pv ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int ksiz ;
  char *kbuf ;
  char *tmp___6 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___7 ;
  long tmp___8 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___9 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_http_head)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___10 ;
  long tmp___11 ;
  int vsiz ;
  int tmp___12 ;
  int tmp___13 ;
  void const   *tmp___14 ;
  _Bool tmp___15 ;

  {
  ttservlog(g_serv, 0, "doing http_head command");
  mask___0 = arg->mask;
  adb = arg->adb;
  keep = (_Bool )(ver >= 1);
  while (1) {
    tmp___5 = ttsockgets(sock, line, 8192);
    if (tmp___5) {
      if (! ((int )line[0] != 0)) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = __builtin_strchr(line, ':');
    pv = tmp___0;
    if (! pv) {
      continue;
    }
    tmp___1 = pv;
    pv ++;
    *tmp___1 = (char )'\000';
    while (1) {
      if (! ((int )*pv == 32)) {
        if (! ((int )*pv == 9)) {
          break;
        }
      }
      pv ++;
    }
    tmp___4 = tcstricmp((char const   *)(line), "connection");
    if (! tmp___4) {
      tmp___3 = tcstricmp((char const   *)pv, "close");
      if (tmp___3) {
        tmp___2 = tcstricmp((char const   *)pv, "keep-alive");
        if (! tmp___2) {
          keep = (_Bool)1;
        }
      } else {
        keep = (_Bool)0;
      }
    }
  }
  if ((int const   )*uri == 47) {
    uri ++;
  }
  tmp___6 = tcurldecode(uri, & ksiz);
  kbuf = tmp___6;
  while (1) {
    __cancel_routine = & free;
    __cancel_arg = (void *)kbuf;
    tmp___7 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___7;
    tmp___8 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___8) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___9 = tcxstrnew();
      xstr = tmp___9;
      while (1) {
        __cancel_routine___do_http_head = (void (*)(void * ))(& tcxstrdel);
        __cancel_arg___0 = (void *)xstr;
        tmp___10 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                               0);
        not_first_call___0 = tmp___10;
        tmp___11 = __builtin_expect((long )not_first_call___0, 0L);
        if (tmp___11) {
          (*__cancel_routine___do_http_head)(__cancel_arg___0);
          __pthread_unwind_next(& __cancel_buf___0);
        }
        __pthread_register_cancel(& __cancel_buf___0);
        while (1) {
          if (mask___0 & (((1ULL << 8) | (1ULL << 29)) | (1ULL << 30))) {
            tcxstrprintf(xstr, "HTTP/1.1 403 Forbidden\r\n");
            tcxstrprintf(xstr, "\r\n");
            ttservlog(g_serv, 1, "do_http_head: forbidden");
          } else {
            tmp___12 = tcadbvsiz(adb, (void const   *)kbuf, ksiz);
            vsiz = tmp___12;
            if (vsiz >= 0) {
              tcxstrprintf(xstr, "HTTP/1.1 200 OK\r\n");
              tcxstrprintf(xstr, "Content-Type: application/octet-stream\r\n");
              tcxstrprintf(xstr, "Content-Length: %d\r\n", vsiz);
              tcxstrprintf(xstr, "\r\n");
            } else {
              tcxstrprintf(xstr, "HTTP/1.1 404 Not Found\r\n");
              tcxstrprintf(xstr, "\r\n");
            }
          }
          tmp___13 = tcxstrsize((TCXSTR const   *)xstr);
          tmp___14 = tcxstrptr((TCXSTR const   *)xstr);
          tmp___15 = ttsocksend(sock, tmp___14, tmp___13);
          if (tmp___15) {
            req->keep = keep;
          } else {
            ttservlog(g_serv, 1, "do_http_head: response failed");
          }
          break;
        }
        __pthread_unregister_cancel(& __cancel_buf___0);
        (*__cancel_routine___do_http_head)(__cancel_arg___0);
        break;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_http_put(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  _Bool keep ;
  int vsiz ;
  int pdmode ;
  char line[8192] ;
  char *pv ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int64_t tmp___4 ;
  int64_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;
  int ksiz ;
  char *kbuf ;
  char *tmp___10 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___11 ;
  long tmp___12 ;
  char stack[65536] ;
  char *vbuf ;
  void *tmp___13 ;
  char *tmp___14 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_http_put)(void * ) ;
  void *__cancel_arg___0 ;
  char *tmp___15 ;
  int not_first_call___0 ;
  int tmp___16 ;
  long tmp___17 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___18 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___19 ;
  long tmp___20 ;
  int len ;
  int tmp___21 ;
  int len___0 ;
  int tmp___22 ;
  int len___1 ;
  int tmp___23 ;
  _Bool tmp___24 ;
  int len___2 ;
  int tmp___25 ;
  int len___3 ;
  int tmp___26 ;
  _Bool tmp___27 ;
  int len___4 ;
  int tmp___28 ;
  int len___5 ;
  int tmp___29 ;
  _Bool tmp___30 ;
  int tmp___31 ;
  void const   *tmp___32 ;
  _Bool tmp___33 ;
  _Bool tmp___34 ;
  _Bool tmp___35 ;

  {
  ttservlog(g_serv, 0, "doing http_put command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  keep = (_Bool )(ver >= 1);
  vsiz = 0;
  pdmode = 0;
  while (1) {
    tmp___9 = ttsockgets(sock, line, 8192);
    if (tmp___9) {
      if (! ((int )line[0] != 0)) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = __builtin_strchr(line, ':');
    pv = tmp___0;
    if (! pv) {
      continue;
    }
    tmp___1 = pv;
    pv ++;
    *tmp___1 = (char )'\000';
    while (1) {
      if (! ((int )*pv == 32)) {
        if (! ((int )*pv == 9)) {
          break;
        }
      }
      pv ++;
    }
    tmp___8 = tcstricmp((char const   *)(line), "connection");
    if (tmp___8) {
      tmp___7 = tcstricmp((char const   *)(line), "content-length");
      if (tmp___7) {
        tmp___6 = tcstricmp((char const   *)(line), "x-tt-pdmode");
        if (! tmp___6) {
          tmp___5 = tcatoi((char const   *)pv);
          pdmode = (int )tmp___5;
        }
      } else {
        tmp___4 = tcatoi((char const   *)pv);
        vsiz = (int )tmp___4;
      }
    } else {
      tmp___3 = tcstricmp((char const   *)pv, "close");
      if (tmp___3) {
        tmp___2 = tcstricmp((char const   *)pv, "keep-alive");
        if (! tmp___2) {
          keep = (_Bool)1;
        }
      } else {
        keep = (_Bool)0;
      }
    }
  }
  if ((int const   )*uri == 47) {
    uri ++;
  }
  tmp___10 = tcurldecode(uri, & ksiz);
  kbuf = tmp___10;
  while (1) {
    __cancel_routine = & free;
    __cancel_arg = (void *)kbuf;
    tmp___11 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                           0);
    not_first_call = tmp___11;
    tmp___12 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___12) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      if (vsiz < 65536) {
        tmp___14 = stack;
      } else {
        tmp___13 = tcmalloc((unsigned int )(vsiz + 1));
        tmp___14 = (char *)tmp___13;
      }
      vbuf = tmp___14;
      while (1) {
        __cancel_routine___do_http_put = & free;
        if ((unsigned int )vbuf == (unsigned int )(stack)) {
          tmp___15 = (char *)((void *)0);
        } else {
          tmp___15 = vbuf;
        }
        __cancel_arg___0 = (void *)tmp___15;
        tmp___16 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                               0);
        not_first_call___0 = tmp___16;
        tmp___17 = __builtin_expect((long )not_first_call___0, 0L);
        if (tmp___17) {
          (*__cancel_routine___do_http_put)(__cancel_arg___0);
          __pthread_unwind_next(& __cancel_buf___0);
        }
        __pthread_register_cancel(& __cancel_buf___0);
        while (1) {
          if (vsiz >= 0) {
            tmp___34 = ttsockrecv(sock, vbuf, vsiz);
            if (tmp___34) {
              tmp___35 = ttsockcheckend(sock);
              if (tmp___35) {
                ttservlog(g_serv, 1, "do_http_put: invalid entity");
              } else {
                tmp___18 = tcxstrnew();
                xstr = tmp___18;
                while (1) {
                  __cancel_routine___1 = (void (*)(void * ))(& tcxstrdel);
                  __cancel_arg___1 = (void *)xstr;
                  tmp___19 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf)),
                                         0);
                  not_first_call___1 = tmp___19;
                  tmp___20 = __builtin_expect((long )not_first_call___1, 0L);
                  if (tmp___20) {
                    (*__cancel_routine___1)(__cancel_arg___1);
                    __pthread_unwind_next(& __cancel_buf___1);
                  }
                  __pthread_register_cancel(& __cancel_buf___1);
                  while (1) {
                    if (mask___0 & ((1ULL | (1ULL << 29)) | (1ULL << 31))) {
                      tmp___21 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Forbidden\n");
                      len = tmp___21;
                      tcxstrprintf(xstr, "HTTP/1.1 403 Forbidden\r\n");
                      tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
                      tcxstrprintf(xstr, "Content-Length: %d\r\n", len);
                      tcxstrprintf(xstr, "\r\n");
                      tcxstrcat(xstr, (void const   *)(line), len);
                      ttservlog(g_serv, 1, "do_http_put: forbidden");
                    } else {
                      switch (pdmode) {
                      case 1: 
                      tmp___24 = tculogadbputkeep(ulog, sid, 0U, adb, (void const   *)kbuf,
                                                  ksiz, (void const   *)vbuf, vsiz);
                      if (tmp___24) {
                        tmp___22 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Created\n");
                        len___0 = tmp___22;
                        tcxstrprintf(xstr, "HTTP/1.1 201 Created\r\n");
                        tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
                        tcxstrprintf(xstr, "Content-Length: %d\r\n", len___0);
                        tcxstrprintf(xstr, "\r\n");
                        tcxstrcat(xstr, (void const   *)(line), len___0);
                      } else {
                        tmp___23 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Conflict\n");
                        len___1 = tmp___23;
                        tcxstrprintf(xstr, "HTTP/1.1 409 Conflict\r\n");
                        tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
                        tcxstrprintf(xstr, "Content-Length: %d\r\n", len___1);
                        tcxstrprintf(xstr, "\r\n");
                        tcxstrcat(xstr, (void const   *)(line), len___1);
                      }
                      break;
                      case 2: 
                      tmp___27 = tculogadbputcat(ulog, sid, 0U, adb, (void const   *)kbuf,
                                                 ksiz, (void const   *)vbuf, vsiz);
                      if (tmp___27) {
                        tmp___25 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Created\n");
                        len___2 = tmp___25;
                        tcxstrprintf(xstr, "HTTP/1.1 201 Created\r\n");
                        tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
                        tcxstrprintf(xstr, "Content-Length: %d\r\n", len___2);
                        tcxstrprintf(xstr, "\r\n");
                        tcxstrcat(xstr, (void const   *)(line), len___2);
                      } else {
                        tmp___26 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Internal Server Error\n");
                        len___3 = tmp___26;
                        tcxstrprintf(xstr, "HTTP/1.1 500 Internal Server Error\r\n");
                        tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
                        tcxstrprintf(xstr, "Content-Length: %d\r\n", len___3);
                        tcxstrprintf(xstr, "\r\n");
                        tcxstrcat(xstr, (void const   *)(line), len___3);
                        ttservlog(g_serv, 2, "do_http_put: operation failed");
                      }
                      break;
                      default: 
                      tmp___30 = tculogadbput(ulog, sid, 0U, adb, (void const   *)kbuf,
                                              ksiz, (void const   *)vbuf, vsiz);
                      if (tmp___30) {
                        tmp___28 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Created\n");
                        len___4 = tmp___28;
                        tcxstrprintf(xstr, "HTTP/1.1 201 Created\r\n");
                        tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
                        tcxstrprintf(xstr, "Content-Length: %d\r\n", len___4);
                        tcxstrprintf(xstr, "\r\n");
                        tcxstrcat(xstr, (void const   *)(line), len___4);
                      } else {
                        tmp___29 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Internal Server Error\n");
                        len___5 = tmp___29;
                        tcxstrprintf(xstr, "HTTP/1.1 500 Internal Server Error\r\n");
                        tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
                        tcxstrprintf(xstr, "Content-Length: %d\r\n", len___5);
                        tcxstrprintf(xstr, "\r\n");
                        tcxstrcat(xstr, (void const   *)(line), len___5);
                        ttservlog(g_serv, 2, "do_http_put: operation failed");
                      }
                      }
                    }
                    tmp___31 = tcxstrsize((TCXSTR const   *)xstr);
                    tmp___32 = tcxstrptr((TCXSTR const   *)xstr);
                    tmp___33 = ttsocksend(sock, tmp___32, tmp___31);
                    if (tmp___33) {
                      req->keep = keep;
                    } else {
                      ttservlog(g_serv, 1, "do_http_put: response failed");
                    }
                    break;
                  }
                  __pthread_unregister_cancel(& __cancel_buf___1);
                  (*__cancel_routine___1)(__cancel_arg___1);
                  break;
                }
              }
            } else {
              ttservlog(g_serv, 1, "do_http_put: invalid entity");
            }
          } else {
            ttservlog(g_serv, 1, "do_http_put: invalid entity");
          }
          break;
        }
        __pthread_unregister_cancel(& __cancel_buf___0);
        (*__cancel_routine___do_http_put)(__cancel_arg___0);
        break;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_http_post(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) 
{ uint64_t mask___0 ;
  pthread_mutex_t *rmtxs ;
  void *scr ;
  _Bool keep ;
  int vsiz ;
  char name[2049] ;
  int opts ;
  char line[8192] ;
  char *pv ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int64_t tmp___4 ;
  int64_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  _Bool tmp___10 ;
  int ksiz ;
  char *kbuf ;
  char *tmp___11 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___12 ;
  long tmp___13 ;
  char stack[65536] ;
  char *vbuf ;
  void *tmp___14 ;
  char *tmp___15 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_http_post)(void * ) ;
  void *__cancel_arg___0 ;
  char *tmp___16 ;
  int not_first_call___0 ;
  int tmp___17 ;
  long tmp___18 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___19 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___20 ;
  long tmp___21 ;
  int len ;
  int tmp___22 ;
  int xsiz ;
  char *xbuf ;
  _Bool err ;
  int i ;
  int tmp___23 ;
  int i___0 ;
  int tmp___24 ;
  int mtxidx ;
  uint32_t tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int len___0 ;
  int tmp___28 ;
  int tmp___29 ;
  void const   *tmp___30 ;
  _Bool tmp___31 ;
  _Bool tmp___32 ;
  _Bool tmp___33 ;

  {
  ttservlog(g_serv, 0, "doing http_post command");
  mask___0 = arg->mask;
  rmtxs = arg->rmtxs;
  scr = *(arg->screxts + req->idx);
  keep = (_Bool )(ver >= 1);
  vsiz = 0;
  name[0] = (char )'\000';
  opts = 0;
  while (1) {
    tmp___10 = ttsockgets(sock, line, 8192);
    if (tmp___10) {
      if (! ((int )line[0] != 0)) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = __builtin_strchr(line, ':');
    pv = tmp___0;
    if (! pv) {
      continue;
    }
    tmp___1 = pv;
    pv ++;
    *tmp___1 = (char )'\000';
    while (1) {
      if (! ((int )*pv == 32)) {
        if (! ((int )*pv == 9)) {
          break;
        }
      }
      pv ++;
    }
    tmp___9 = tcstricmp((char const   *)(line), "connection");
    if (tmp___9) {
      tmp___8 = tcstricmp((char const   *)(line), "content-length");
      if (tmp___8) {
        tmp___7 = tcstricmp((char const   *)(line), "x-tt-xname");
        if (tmp___7) {
          tmp___6 = tcstricmp((char const   *)(line), "x-tt-xopts");
          if (! tmp___6) {
            tmp___5 = tcatoi((char const   *)pv);
            opts = (int )tmp___5;
          }
        } else {
          snprintf((char * __restrict  )(name), (unsigned int )((int )sizeof(name)),
                   (char const   * __restrict  )"%s", pv);
          name[(int )sizeof(name) - 1] = (char )'\000';
        }
      } else {
        tmp___4 = tcatoi((char const   *)pv);
        vsiz = (int )tmp___4;
      }
    } else {
      tmp___3 = tcstricmp((char const   *)pv, "close");
      if (tmp___3) {
        tmp___2 = tcstricmp((char const   *)pv, "keep-alive");
        if (! tmp___2) {
          keep = (_Bool)1;
        }
      } else {
        keep = (_Bool)0;
      }
    }
  }
  if ((int const   )*uri == 47) {
    uri ++;
  }
  tmp___11 = tcurldecode(uri, & ksiz);
  kbuf = tmp___11;
  while (1) {
    __cancel_routine = & free;
    __cancel_arg = (void *)kbuf;
    tmp___12 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                           0);
    not_first_call = tmp___12;
    tmp___13 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___13) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      if (vsiz < 65536) {
        tmp___15 = stack;
      } else {
        tmp___14 = tcmalloc((unsigned int )(vsiz + 1));
        tmp___15 = (char *)tmp___14;
      }
      vbuf = tmp___15;
      while (1) {
        __cancel_routine___do_http_post = & free;
        if ((unsigned int )vbuf == (unsigned int )(stack)) {
          tmp___16 = (char *)((void *)0);
        } else {
          tmp___16 = vbuf;
        }
        __cancel_arg___0 = (void *)tmp___16;
        tmp___17 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                               0);
        not_first_call___0 = tmp___17;
        tmp___18 = __builtin_expect((long )not_first_call___0, 0L);
        if (tmp___18) {
          (*__cancel_routine___do_http_post)(__cancel_arg___0);
          __pthread_unwind_next(& __cancel_buf___0);
        }
        __pthread_register_cancel(& __cancel_buf___0);
        while (1) {
          if (vsiz >= 0) {
            tmp___32 = ttsockrecv(sock, vbuf, vsiz);
            if (tmp___32) {
              tmp___33 = ttsockcheckend(sock);
              if (tmp___33) {
                ttservlog(g_serv, 1, "do_http_post: invalid entity");
              } else {
                tmp___19 = tcxstrnew();
                xstr = tmp___19;
                while (1) {
                  __cancel_routine___1 = (void (*)(void * ))(& tcxstrdel);
                  __cancel_arg___1 = (void *)xstr;
                  tmp___20 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf)),
                                         0);
                  not_first_call___1 = tmp___20;
                  tmp___21 = __builtin_expect((long )not_first_call___1, 0L);
                  if (tmp___21) {
                    (*__cancel_routine___1)(__cancel_arg___1);
                    __pthread_unwind_next(& __cancel_buf___1);
                  }
                  __pthread_register_cancel(& __cancel_buf___1);
                  while (1) {
                    if (mask___0 & ((1ULL << 14) | (1ULL << 29))) {
                      tmp___22 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Forbidden\n");
                      len = tmp___22;
                      tcxstrprintf(xstr, "HTTP/1.1 403 Forbidden\r\n");
                      tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
                      tcxstrprintf(xstr, "Content-Length: %d\r\n", len);
                      tcxstrprintf(xstr, "\r\n");
                      tcxstrcat(xstr, (void const   *)(line), len);
                      ttservlog(g_serv, 1, "do_http_post: forbidden");
                    } else {
                      xsiz = 0;
                      xbuf = (char *)((void *)0);
                      if (scr) {
                        if (opts & 2) {
                          err = (_Bool)0;
                          i = 0;
                          while (i < 31) {
                            tmp___23 = pthread_mutex_lock(rmtxs + i);
                            if (tmp___23 != 0) {
                              ttservlog(g_serv, 2, "do_http_post: pthread_mutex_lock failed");
                              while (1) {
                                i --;
                                if (! (i >= 0)) {
                                  break;
                                }
                                pthread_mutex_unlock(rmtxs + i);
                              }
                              err = (_Bool)1;
                              break;
                            }
                            i ++;
                          }
                          if (! err) {
                            xbuf = scrextcallmethod(scr, (char const   *)(name), (void const   *)kbuf,
                                                    ksiz, (void const   *)vbuf, vsiz,
                                                    & xsiz);
                            i___0 = 30;
                            while (i___0 >= 0) {
                              tmp___24 = pthread_mutex_unlock(rmtxs + i___0);
                              if (tmp___24 != 0) {
                                ttservlog(g_serv, 2, "do_http_post: pthread_mutex_unlock failed");
                              }
                              i___0 --;
                            }
                          }
                        } else {
                          if (opts & 1) {
                            tmp___25 = recmtxidx((char const   *)kbuf, ksiz);
                            mtxidx = (int )tmp___25;
                            tmp___27 = pthread_mutex_lock(rmtxs + mtxidx);
                            if (tmp___27 == 0) {
                              xbuf = scrextcallmethod(scr, (char const   *)(name),
                                                      (void const   *)kbuf, ksiz,
                                                      (void const   *)vbuf, vsiz,
                                                      & xsiz);
                              tmp___26 = pthread_mutex_unlock(rmtxs + mtxidx);
                              if (tmp___26 != 0) {
                                ttservlog(g_serv, 2, "do_http_post: pthread_mutex_unlock failed");
                              }
                            } else {
                              ttservlog(g_serv, 2, "do_http_post: pthread_mutex_lock failed");
                            }
                          } else {
                            xbuf = scrextcallmethod(scr, (char const   *)(name), (void const   *)kbuf,
                                                    ksiz, (void const   *)vbuf, vsiz,
                                                    & xsiz);
                          }
                        }
                      }
                      if (xbuf) {
                        tcxstrprintf(xstr, "HTTP/1.1 200 OK\r\n");
                        tcxstrprintf(xstr, "Content-Type: application/octet-stream\r\n");
                        tcxstrprintf(xstr, "Content-Length: %d\r\n", xsiz);
                        tcxstrprintf(xstr, "\r\n");
                        tcxstrcat(xstr, (void const   *)xbuf, xsiz);
                        tcfree((void *)xbuf);
                      } else {
                        tmp___28 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Internal Server Error");
                        len___0 = tmp___28;
                        tcxstrprintf(xstr, "HTTP/1.1 500 Internal Server Error\r\n");
                        tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
                        tcxstrprintf(xstr, "Content-Length: %d\r\n", len___0);
                        tcxstrprintf(xstr, "\r\n");
                        tcxstrcat(xstr, (void const   *)(line), len___0);
                      }
                    }
                    tmp___29 = tcxstrsize((TCXSTR const   *)xstr);
                    tmp___30 = tcxstrptr((TCXSTR const   *)xstr);
                    tmp___31 = ttsocksend(sock, tmp___30, tmp___29);
                    if (tmp___31) {
                      req->keep = keep;
                    } else {
                      ttservlog(g_serv, 1, "do_http_post: response failed");
                    }
                    break;
                  }
                  __pthread_unregister_cancel(& __cancel_buf___1);
                  (*__cancel_routine___1)(__cancel_arg___1);
                  break;
                }
              }
            } else {
              ttservlog(g_serv, 1, "do_http_post: invalid entity");
            }
          } else {
            ttservlog(g_serv, 1, "do_http_post: invalid entity");
          }
          break;
        }
        __pthread_unregister_cancel(& __cancel_buf___0);
        (*__cancel_routine___do_http_post)(__cancel_arg___0);
        break;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_http_delete(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  TCULOG *ulog ;
  uint32_t sid ;
  _Bool keep ;
  char line[8192] ;
  char *pv ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int ksiz ;
  char *kbuf ;
  char *tmp___6 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___7 ;
  long tmp___8 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___9 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___do_http_delete)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___10 ;
  long tmp___11 ;
  int len ;
  int tmp___12 ;
  int len___0 ;
  int tmp___13 ;
  int len___1 ;
  int tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  void const   *tmp___17 ;
  _Bool tmp___18 ;

  {
  ttservlog(g_serv, 0, "doing http_delete command");
  mask___0 = arg->mask;
  adb = arg->adb;
  ulog = arg->ulog;
  sid = arg->sid;
  keep = (_Bool )(ver >= 1);
  while (1) {
    tmp___5 = ttsockgets(sock, line, 8192);
    if (tmp___5) {
      if (! ((int )line[0] != 0)) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = __builtin_strchr(line, ':');
    pv = tmp___0;
    if (! pv) {
      continue;
    }
    tmp___1 = pv;
    pv ++;
    *tmp___1 = (char )'\000';
    while (1) {
      if (! ((int )*pv == 32)) {
        if (! ((int )*pv == 9)) {
          break;
        }
      }
      pv ++;
    }
    tmp___4 = tcstricmp((char const   *)(line), "connection");
    if (! tmp___4) {
      tmp___3 = tcstricmp((char const   *)pv, "close");
      if (tmp___3) {
        tmp___2 = tcstricmp((char const   *)pv, "keep-alive");
        if (! tmp___2) {
          keep = (_Bool)1;
        }
      } else {
        keep = (_Bool)0;
      }
    }
  }
  if ((int const   )*uri == 47) {
    uri ++;
  }
  tmp___6 = tcurldecode(uri, & ksiz);
  kbuf = tmp___6;
  while (1) {
    __cancel_routine = & free;
    __cancel_arg = (void *)kbuf;
    tmp___7 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___7;
    tmp___8 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___8) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___9 = tcxstrnew();
      xstr = tmp___9;
      while (1) {
        __cancel_routine___do_http_delete = (void (*)(void * ))(& tcxstrdel);
        __cancel_arg___0 = (void *)xstr;
        tmp___10 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf)),
                               0);
        not_first_call___0 = tmp___10;
        tmp___11 = __builtin_expect((long )not_first_call___0, 0L);
        if (tmp___11) {
          (*__cancel_routine___do_http_delete)(__cancel_arg___0);
          __pthread_unwind_next(& __cancel_buf___0);
        }
        __pthread_register_cancel(& __cancel_buf___0);
        while (1) {
          if (mask___0 & (((1ULL << 5) | (1ULL << 29)) | (1ULL << 31))) {
            tmp___12 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Forbidden\n");
            len = tmp___12;
            tcxstrprintf(xstr, "HTTP/1.1 403 Forbidden\r\n");
            tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
            tcxstrprintf(xstr, "Content-Length: %d\r\n", len);
            tcxstrprintf(xstr, "\r\n");
            tcxstrcat(xstr, (void const   *)(line), len);
            ttservlog(g_serv, 1, "do_http_delete: forbidden");
          } else {
            tmp___15 = tculogadbout(ulog, sid, 0U, adb, (void const   *)kbuf, ksiz);
            if (tmp___15) {
              tmp___13 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"OK\n");
              len___0 = tmp___13;
              tcxstrprintf(xstr, "HTTP/1.1 200 OK\r\n");
              tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
              tcxstrprintf(xstr, "Content-Length: %d\r\n", len___0);
              tcxstrprintf(xstr, "\r\n");
              tcxstrcat(xstr, (void const   *)(line), len___0);
            } else {
              tmp___14 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Not Found\n");
              len___1 = tmp___14;
              tcxstrprintf(xstr, "HTTP/1.1 404 Not Found\r\n");
              tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
              tcxstrprintf(xstr, "Content-Length: %d\r\n", len___1);
              tcxstrprintf(xstr, "\r\n");
              tcxstrcat(xstr, (void const   *)(line), len___1);
            }
          }
          tmp___16 = tcxstrsize((TCXSTR const   *)xstr);
          tmp___17 = tcxstrptr((TCXSTR const   *)xstr);
          tmp___18 = ttsocksend(sock, tmp___17, tmp___16);
          if (tmp___18) {
            req->keep = keep;
          } else {
            ttservlog(g_serv, 1, "do_http_delete: response failed");
          }
          break;
        }
        __pthread_unregister_cancel(& __cancel_buf___0);
        (*__cancel_routine___do_http_delete)(__cancel_arg___0);
        break;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_http_options(TTSOCK *sock , TASKARG *arg , TTREQ *req , int ver , char const   *uri ) 
{ uint64_t mask___0 ;
  TCADB *adb ;
  REPLARG *sarg ;
  _Bool keep ;
  char line[8192] ;
  char *pv ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  TCXSTR *xstr ;
  TCXSTR *tmp___6 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___7 ;
  long tmp___8 ;
  int len ;
  int tmp___9 ;
  double now ;
  double tmp___10 ;
  __pid_t tmp___11 ;
  int tmp___12 ;
  char const   *path ;
  char const   *tmp___13 ;
  uint64_t tmp___14 ;
  uint64_t tmp___15 ;
  double delay ;
  double tmp___16 ;
  double tmp___17 ;
  TCMAP *info ;
  TCMAP *tmp___18 ;
  char const   *vbuf ;
  char const   *tmp___19 ;
  struct rusage ubuf ;
  int tmp___20 ;
  int tmp___21 ;
  void const   *tmp___22 ;
  _Bool tmp___23 ;

  {
  ttservlog(g_serv, 0, "doing http_options command");
  mask___0 = arg->mask;
  adb = arg->adb;
  sarg = arg->sarg;
  keep = (_Bool )(ver >= 1);
  while (1) {
    tmp___5 = ttsockgets(sock, line, 8192);
    if (tmp___5) {
      if (! ((int )line[0] != 0)) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = __builtin_strchr(line, ':');
    pv = tmp___0;
    if (! pv) {
      continue;
    }
    tmp___1 = pv;
    pv ++;
    *tmp___1 = (char )'\000';
    while (1) {
      if (! ((int )*pv == 32)) {
        if (! ((int )*pv == 9)) {
          break;
        }
      }
      pv ++;
    }
    tmp___4 = tcstricmp((char const   *)(line), "connection");
    if (! tmp___4) {
      tmp___3 = tcstricmp((char const   *)pv, "close");
      if (tmp___3) {
        tmp___2 = tcstricmp((char const   *)pv, "keep-alive");
        if (! tmp___2) {
          keep = (_Bool)1;
        }
      } else {
        keep = (_Bool)0;
      }
    }
  }
  tmp___6 = tcxstrnew();
  xstr = tmp___6;
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcxstrdel);
    __cancel_arg = (void *)xstr;
    tmp___7 = __sigsetjmp((struct __jmp_buf_tag *)((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf)),
                          0);
    not_first_call = tmp___7;
    tmp___8 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___8) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      if (mask___0 & (((1ULL << 23) | (1ULL << 27)) | (1ULL << 30))) {
        tmp___9 = sprintf((char * __restrict  )(line), (char const   * __restrict  )"Forbidden\n");
        len = tmp___9;
        tcxstrprintf(xstr, "HTTP/1.1 403 Forbidden\r\n");
        tcxstrprintf(xstr, "Content-Type: text/plain\r\n");
        tcxstrprintf(xstr, "Content-Length: %d\r\n", len);
        tcxstrprintf(xstr, "\r\n");
        tcxstrcat(xstr, (void const   *)(line), len);
        ttservlog(g_serv, 1, "do_http_options: forbidden");
      } else {
        tmp___10 = tctime();
        now = tmp___10;
        tcxstrprintf(xstr, "HTTP/1.1 200 OK\r\n");
        tcxstrprintf(xstr, "Content-Length: 0\r\n");
        tcxstrprintf(xstr, "Allow: OPTIONS");
        if (! (mask___0 & ((1ULL << 6) | (1ULL << 30)))) {
          tcxstrprintf(xstr, ", GET");
        }
        if (! (mask___0 & ((1ULL << 8) | (1ULL << 30)))) {
          tcxstrprintf(xstr, ", HEAD");
        }
        if (! (mask___0 & (1ULL | (1ULL << 31)))) {
          tcxstrprintf(xstr, ", PUT");
        }
        if (! (mask___0 & ((1ULL << 14) | (1ULL << 31)))) {
          tcxstrprintf(xstr, ", POST");
        }
        if (! (mask___0 & ((1ULL << 5) | (1ULL << 31)))) {
          tcxstrprintf(xstr, ", DELETE");
        }
        tcxstrprintf(xstr, "\r\n");
        tcxstrprintf(xstr, "X-TT-VERSION: %s\r\n", ttversion);
        tcxstrprintf(xstr, "X-TT-LIBVER: %d\r\n", 317);
        tcxstrprintf(xstr, "X-TT-PROTVER: %s\r\n", "0.91");
        tcxstrprintf(xstr, "X-TT-OS: %s\r\n", "Linux");
        tcxstrprintf(xstr, "X-TT-TIME: %.6f\r\n", now);
        tmp___11 = getpid();
        tcxstrprintf(xstr, "X-TT-PID: %lld\r\n", (long long )tmp___11);
        tcxstrprintf(xstr, "X-TT-SID: %d\r\n", arg->sid);
        tmp___12 = tcadbomode(adb);
        switch (tmp___12) {
        case 0: 
        tcxstrprintf(xstr, "X-TT-TYPE: void\r\n");
        break;
        case 1: 
        tcxstrprintf(xstr, "X-TT-TYPE: on-memory hash\r\n");
        break;
        case 2: 
        tcxstrprintf(xstr, "X-TT-TYPE: on-memory tree\r\n");
        break;
        case 3: 
        tcxstrprintf(xstr, "X-TT-TYPE: hash\r\n");
        break;
        case 4: 
        tcxstrprintf(xstr, "X-TT-TYPE: B+ tree\r\n");
        break;
        case 5: 
        tcxstrprintf(xstr, "X-TT-TYPE: fixed-length\r\n");
        break;
        case 6: 
        tcxstrprintf(xstr, "X-TT-TYPE: table\r\n");
        break;
        case 7: 
        tcxstrprintf(xstr, "X-TT-TYPE: skeleton\r\n");
        break;
        }
        tmp___13 = tcadbpath(adb);
        path = tmp___13;
        if (path) {
          tcxstrprintf(xstr, "X-TT-PATH: %s\r\n", path);
        }
        tmp___14 = tcadbrnum(adb);
        tcxstrprintf(xstr, "X-TT-RNUM: %llu\r\n", tmp___14);
        tmp___15 = tcadbsize(adb);
        tcxstrprintf(xstr, "X-TT-SIZE: %llu\r\n", tmp___15);
        tcxstrprintf(xstr, "X-TT-BIGEND: %d\r\n", 0);
        if ((int )sarg->host[0] != 0) {
          tcxstrprintf(xstr, "X-TT-MHOST: %s\r\n", sarg->host);
          tcxstrprintf(xstr, "X-TT-MPORT: %d\r\n", sarg->port);
          tcxstrprintf(xstr, "X-TT-RTS: %llu\r\n", sarg->rts);
          delay = now - (double )sarg->rts / 1000000.0;
          if (delay >= (double )0) {
            tmp___16 = delay;
          } else {
            tmp___16 = 0.0;
          }
          tcxstrprintf(xstr, "X-TT-DELAY: %.6f\r\n", tmp___16);
        }
        tcxstrprintf(xstr, "X-TT-FD: %d\r\n", sock->fd);
        tmp___17 = ttgetloadavg();
        tcxstrprintf(xstr, "X-TT-LOADAVG: %.6f\r\n", tmp___17);
        tmp___18 = tcsysinfo();
        info = tmp___18;
        if (info) {
          tmp___19 = tcmapget2((TCMAP const   *)info, "size");
          vbuf = tmp___19;
          if (vbuf) {
            tcxstrprintf(xstr, "X-TT-MEMSIZE: %s\r\n", vbuf);
          }
          vbuf = tcmapget2((TCMAP const   *)info, "rss");
          if (vbuf) {
            tcxstrprintf(xstr, "X-TT-MEMRSS: %s\r\n", vbuf);
          }
          tcmapdel(info);
        }
        tcxstrprintf(xstr, "X-TT-RU_REAL: %.6f\r\n", now - g_starttime);
        memset((void *)(& ubuf), 0, (unsigned int )((int )sizeof(ubuf)));
        tmp___20 = getrusage((enum __rusage_who )0, & ubuf);
        if (tmp___20 == 0) {
          tcxstrprintf(xstr, "X-TT-RU_USER: %d.%06d\r\n", (int )ubuf.ru_utime.tv_sec,
                       (int )ubuf.ru_utime.tv_usec);
          tcxstrprintf(xstr, "X-TT-RU_SYS: %d.%06d\r\n", (int )ubuf.ru_stime.tv_sec,
                       (int )ubuf.ru_stime.tv_usec);
        }
        tcxstrprintf(xstr, "\r\n");
      }
      tmp___21 = tcxstrsize((TCXSTR const   *)xstr);
      tmp___22 = tcxstrptr((TCXSTR const   *)xstr);
      tmp___23 = ttsocksend(sock, tmp___22, tmp___21);
      if (tmp___23) {
        req->keep = keep;
      } else {
        ttservlog(g_serv, 1, "do_http_options: response failed");
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
static void do_term(void *opq ) 
{ TERMARG *arg ;
  int thnum ;
  TCADB *adb ;
  REPLARG *sarg ;
  void **screxts ;
  EXTPCARG *pcargs ;
  int pcnum ;
  int i ;
  EXTPCARG *pcarg ;
  _Bool tmp ;
  int i___0 ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;

  {
  arg = (TERMARG *)opq;
  thnum = arg->thnum;
  adb = arg->adb;
  sarg = arg->sarg;
  screxts = arg->screxts;
  pcargs = arg->pcargs;
  pcnum = arg->pcnum;
  if ((int )sarg->host[0] != 0) {
    tcsleep(1.0 * 1.2);
  }
  if (g_restart) {
    return;
  }
  if (pcargs) {
    i = 0;
    while (i < pcnum) {
      pcarg = pcargs + i;
      if (! pcarg->scrext) {
        goto __Cont;
      }
      tmp = scrextkill(pcarg->scrext);
      if (! tmp) {
        arg->err = (_Bool)1;
        ttservlog(g_serv, 2, "scrextkill failed");
      }
      __Cont: /* CIL Label */ 
      i ++;
    }
  }
  i___0 = 0;
  while (i___0 < thnum) {
    if (! *(screxts + i___0)) {
      goto __Cont___0;
    }
    tmp___0 = scrextkill(*(screxts + i___0));
    if (! tmp___0) {
      arg->err = (_Bool)1;
      ttservlog(g_serv, 2, "scrextkill failed");
    }
    __Cont___0: /* CIL Label */ 
    i___0 ++;
  }
  ttservlog(g_serv, 3, "closing the database");
  tmp___1 = tcadbclose(adb);
  if (! tmp___1) {
    arg->err = (_Bool)1;
    ttservlog(g_serv, 2, "tcadbclose failed");
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-je7owCXA.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
void *scrextnew(void **screxts , int thnum , int thid , char const   *path , TCADB *adb ,
                TCULOG *ulog , uint32_t sid , TCMDB *stash , TCMDB *lock , void (*logger)(int  ,
                                                                                          char const   * ,
                                                                                          void * ) ,
                void *logopq ) 
{ SCREXT *scr ;
  void *tmp ;

  {
  tmp = tcmalloc((unsigned int )((int )sizeof(*scr)));
  scr = (SCREXT *)tmp;
  scr->screxts = (SCREXT **)screxts;
  scr->thnum = thnum;
  scr->thid = thid;
  scr->path = tcstrdup((void const   *)path);
  scr->adb = adb;
  scr->ulog = ulog;
  scr->sid = sid;
  scr->stash = stash;
  scr->lock = lock;
  scr->logger = logger;
  scr->logopq = logopq;
  scr->term = (_Bool)0;
  return ((void *)scr);
}
}
_Bool scrextdel(void *scr ) 
{ SCREXT *myscr ;

  {
  myscr = (SCREXT *)scr;
  tcfree((void *)myscr->path);
  tcfree((void *)myscr);
  return ((_Bool)1);
}
}
char *scrextcallmethod(void *scr , char const   *name , void const   *kbuf , int ksiz ,
                       void const   *vbuf , int vsiz , int *sp ) 
{ SCREXT *myscr ;
  _Bool tmp ;
  char *msg ;
  char *tmp___0 ;
  size_t tmp___1 ;
  _Bool tmp___2 ;
  char *msg___0 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  _Bool tmp___5 ;
  char *msg___1 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  _Bool tmp___8 ;
  char *msg___2 ;
  char *tmp___9 ;
  size_t tmp___10 ;
  void *tmp___11 ;
  char *msg___3 ;
  void *tmp___12 ;
  size_t tmp___13 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___36 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___43 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___50 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int psiz ;
  size_t tmp___56 ;
  int nsiz ;
  size_t tmp___57 ;
  char *msg___4 ;
  void *tmp___58 ;
  char *wp ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;

  {
  myscr = (SCREXT *)scr;
  if (0) {
    __s1_len___4 = strlen(name);
    __s2_len___4 = strlen("put");
    if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
      goto _L___10;
    } else {
      if (__s1_len___4 >= 4U) {
        _L___10: /* CIL Label */ 
        if (! ((unsigned int )((void const   *)("put" + 1)) - (unsigned int )((void const   *)"put") == 1U)) {
          tmp___55 = 1;
        } else {
          if (__s2_len___4 >= 4U) {
            tmp___55 = 1;
          } else {
            tmp___55 = 0;
          }
        }
      } else {
        tmp___55 = 0;
      }
    }
    if (tmp___55) {
      tmp___50 = __builtin_strcmp(name, "put");
      tmp___54 = tmp___50;
    } else {
      tmp___53 = __builtin_strcmp(name, "put");
      tmp___54 = tmp___53;
    }
  } else {
    tmp___53 = __builtin_strcmp(name, "put");
    tmp___54 = tmp___53;
  }
  if (tmp___54) {
    if (0) {
      __s1_len___3 = strlen(name);
      __s2_len___3 = strlen("putkeep");
      if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
        goto _L___8;
      } else {
        if (__s1_len___3 >= 4U) {
          _L___8: /* CIL Label */ 
          if (! ((unsigned int )((void const   *)("putkeep" + 1)) - (unsigned int )((void const   *)"putkeep") == 1U)) {
            tmp___48 = 1;
          } else {
            if (__s2_len___3 >= 4U) {
              tmp___48 = 1;
            } else {
              tmp___48 = 0;
            }
          }
        } else {
          tmp___48 = 0;
        }
      }
      if (tmp___48) {
        tmp___43 = __builtin_strcmp(name, "putkeep");
        tmp___47 = tmp___43;
      } else {
        tmp___46 = __builtin_strcmp(name, "putkeep");
        tmp___47 = tmp___46;
      }
    } else {
      tmp___46 = __builtin_strcmp(name, "putkeep");
      tmp___47 = tmp___46;
    }
    if (tmp___47) {
      if (0) {
        __s1_len___2 = strlen(name);
        __s2_len___2 = strlen("putcat");
        if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
          goto _L___6;
        } else {
          if (__s1_len___2 >= 4U) {
            _L___6: /* CIL Label */ 
            if (! ((unsigned int )((void const   *)("putcat" + 1)) - (unsigned int )((void const   *)"putcat") == 1U)) {
              tmp___41 = 1;
            } else {
              if (__s2_len___2 >= 4U) {
                tmp___41 = 1;
              } else {
                tmp___41 = 0;
              }
            }
          } else {
            tmp___41 = 0;
          }
        }
        if (tmp___41) {
          tmp___36 = __builtin_strcmp(name, "putcat");
          tmp___40 = tmp___36;
        } else {
          tmp___39 = __builtin_strcmp(name, "putcat");
          tmp___40 = tmp___39;
        }
      } else {
        tmp___39 = __builtin_strcmp(name, "putcat");
        tmp___40 = tmp___39;
      }
      if (tmp___40) {
        if (0) {
          __s1_len___1 = strlen(name);
          __s2_len___1 = strlen("out");
          if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
            goto _L___4;
          } else {
            if (__s1_len___1 >= 4U) {
              _L___4: /* CIL Label */ 
              if (! ((unsigned int )((void const   *)("out" + 1)) - (unsigned int )((void const   *)"out") == 1U)) {
                tmp___34 = 1;
              } else {
                if (__s2_len___1 >= 4U) {
                  tmp___34 = 1;
                } else {
                  tmp___34 = 0;
                }
              }
            } else {
              tmp___34 = 0;
            }
          }
          if (tmp___34) {
            tmp___29 = __builtin_strcmp(name, "out");
            tmp___33 = tmp___29;
          } else {
            tmp___32 = __builtin_strcmp(name, "out");
            tmp___33 = tmp___32;
          }
        } else {
          tmp___32 = __builtin_strcmp(name, "out");
          tmp___33 = tmp___32;
        }
        if (tmp___33) {
          if (0) {
            __s1_len___0 = strlen(name);
            __s2_len___0 = strlen("get");
            if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
              goto _L___2;
            } else {
              if (__s1_len___0 >= 4U) {
                _L___2: /* CIL Label */ 
                if (! ((unsigned int )((void const   *)("get" + 1)) - (unsigned int )((void const   *)"get") == 1U)) {
                  tmp___27 = 1;
                } else {
                  if (__s2_len___0 >= 4U) {
                    tmp___27 = 1;
                  } else {
                    tmp___27 = 0;
                  }
                }
              } else {
                tmp___27 = 0;
              }
            }
            if (tmp___27) {
              tmp___22 = __builtin_strcmp(name, "get");
              tmp___26 = tmp___22;
            } else {
              tmp___25 = __builtin_strcmp(name, "get");
              tmp___26 = tmp___25;
            }
          } else {
            tmp___25 = __builtin_strcmp(name, "get");
            tmp___26 = tmp___25;
          }
          if (tmp___26) {
            if (0) {
              __s1_len = strlen(name);
              __s2_len = strlen("log");
              if (! ((unsigned int )((void const   *)(name + 1)) - (unsigned int )((void const   *)name) == 1U)) {
                goto _L___0;
              } else {
                if (__s1_len >= 4U) {
                  _L___0: /* CIL Label */ 
                  if (! ((unsigned int )((void const   *)("log" + 1)) - (unsigned int )((void const   *)"log") == 1U)) {
                    tmp___20 = 1;
                  } else {
                    if (__s2_len >= 4U) {
                      tmp___20 = 1;
                    } else {
                      tmp___20 = 0;
                    }
                  }
                } else {
                  tmp___20 = 0;
                }
              }
              if (tmp___20) {
                tmp___15 = __builtin_strcmp(name, "log");
                tmp___19 = tmp___15;
              } else {
                tmp___18 = __builtin_strcmp(name, "log");
                tmp___19 = tmp___18;
              }
            } else {
              tmp___18 = __builtin_strcmp(name, "log");
              tmp___19 = tmp___18;
            }
            if (! tmp___19) {
              tmp___12 = tcmemdup(kbuf, (unsigned int )ksiz);
              msg___3 = (char *)tmp___12;
              (*(myscr->logger))(1, (char const   *)msg___3, myscr->logopq);
              tcfree((void *)msg___3);
              msg___3 = tcstrdup((void const   *)"ok");
              tmp___13 = strlen((char const   *)msg___3);
              *sp = (int )tmp___13;
              return (msg___3);
            }
          } else {
            tmp___11 = tcadbget(myscr->adb, kbuf, ksiz, sp);
            return ((char *)tmp___11);
          }
        } else {
          tmp___8 = tculogadbout(myscr->ulog, myscr->sid, 0U, myscr->adb, kbuf, ksiz);
          if (! tmp___8) {
            return ((char *)((void *)0));
          }
          tmp___9 = tcstrdup((void const   *)"ok");
          msg___2 = tmp___9;
          tmp___10 = strlen((char const   *)msg___2);
          *sp = (int )tmp___10;
          return (msg___2);
        }
      } else {
        tmp___5 = tculogadbputcat(myscr->ulog, myscr->sid, 0U, myscr->adb, kbuf, ksiz,
                                  vbuf, vsiz);
        if (! tmp___5) {
          return ((char *)((void *)0));
        }
        tmp___6 = tcstrdup((void const   *)"ok");
        msg___1 = tmp___6;
        tmp___7 = strlen((char const   *)msg___1);
        *sp = (int )tmp___7;
        return (msg___1);
      }
    } else {
      tmp___2 = tculogadbputkeep(myscr->ulog, myscr->sid, 0U, myscr->adb, kbuf, ksiz,
                                 vbuf, vsiz);
      if (! tmp___2) {
        return ((char *)((void *)0));
      }
      tmp___3 = tcstrdup((void const   *)"ok");
      msg___0 = tmp___3;
      tmp___4 = strlen((char const   *)msg___0);
      *sp = (int )tmp___4;
      return (msg___0);
    }
  } else {
    tmp = tculogadbput(myscr->ulog, myscr->sid, 0U, myscr->adb, kbuf, ksiz, vbuf,
                       vsiz);
    if (! tmp) {
      return ((char *)((void *)0));
    }
    tmp___0 = tcstrdup((void const   *)"ok");
    msg = tmp___0;
    tmp___1 = strlen((char const   *)msg);
    *sp = (int )tmp___1;
    return (msg);
  }
  tmp___56 = strlen((char const   *)myscr->path);
  psiz = (int )tmp___56;
  tmp___57 = strlen(name);
  nsiz = (int )tmp___57;
  tmp___58 = tcmalloc((unsigned int )((((psiz + nsiz) + ksiz) + vsiz) + 4));
  msg___4 = (char *)tmp___58;
  wp = msg___4;
  memcpy((void * __restrict  )wp, (void const   * __restrict  )myscr->path, (unsigned int )psiz);
  wp += psiz;
  tmp___59 = wp;
  wp ++;
  *tmp___59 = (char )':';
  memcpy((void * __restrict  )wp, (void const   * __restrict  )name, (unsigned int )nsiz);
  wp += nsiz;
  tmp___60 = wp;
  wp ++;
  *tmp___60 = (char )':';
  memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
  wp += ksiz;
  tmp___61 = wp;
  wp ++;
  *tmp___61 = (char )':';
  memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
  wp += vsiz;
  *sp = wp - msg___4;
  return (msg___4);
}
}
_Bool scrextkill(void *scr ) 
{ SCREXT *myscr ;

  {
  myscr = (SCREXT *)scr;
  myscr->term = (_Bool)1;
  return ((_Bool)1);
}
}
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
#pragma merger(0,"/tmp/cil-S6MQS5eS.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
extern  __attribute__((__nothrow__)) int getloadavg(double *__loadavg , int __nelem )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int __isinf(double __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __isinff(float __value )  __attribute__((__const__)) ;
extern  __attribute__((__nothrow__)) int __isinfl(long double __value )  __attribute__((__const__)) ;
extern int fflush(FILE *__stream ) ;
extern  __attribute__((__nothrow__)) int vsnprintf(char * __restrict  __s , size_t __maxlen ,
                                                   char const   * __restrict  __format ,
                                                   __gnuc_va_list __arg ) ;
extern  __attribute__((__nothrow__)) int pthread_create(pthread_t * __restrict  __newthread ,
                                                        pthread_attr_t const   * __restrict  __attr ,
                                                        void *(*__start_routine)(void * ) ,
                                                        void * __restrict  __arg )  __attribute__((__nonnull__(1,3))) ;
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
extern int pthread_setcancelstate(int __state , int *__oldstate ) ;
extern int pthread_cancel(pthread_t __th ) ;
extern void pthread_testcancel(void) ;
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t * __restrict  __cond ,
                                                           pthread_condattr_t const   * __restrict  __cond_attr )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_cond_destroy(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_cond_broadcast(pthread_cond_t *__cond )  __attribute__((__nonnull__(1))) ;
extern int pthread_cond_timedwait(pthread_cond_t * __restrict  __cond , pthread_mutex_t * __restrict  __mutex ,
                                  struct timespec  const  * __restrict  __abstime )  __attribute__((__nonnull__(1,2,3))) ;
_Bool ttgetlocalhostname(char *name ) ;
_Bool ttgethostaddr(char const   *name , char *addr ) ;
int ttopensock(char const   *addr , int port ) ;
int ttopensockunix(char const   *path ) ;
int ttopenservsock(char const   *addr , int port ) ;
int ttopenservsockunix(char const   *path ) ;
int ttacceptsock(int fd , char *addr , int *pp ) ;
int ttacceptsockunix(int fd ) ;
_Bool ttclosesock(int fd ) ;
TTSOCK *ttsocknew(int fd ) ;
void ttsockdel(TTSOCK *sock ) ;
int ttsockcheckpfsiz(TTSOCK *sock ) ;
int tthttpfetch(char const   *url , TCMAP *reqheads , TCMAP *resheads , TCXSTR *resbody ) ;
char *ttbreakservexpr(char const   *expr , int *pp ) ;
uint64_t ttstrtots(char const   *str ) ;
char const   *ttcmdidtostr(int id ) ;
extern  __attribute__((__nothrow__)) int sigemptyset(sigset_t *__set )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int sigaddset(sigset_t *__set , int __signo )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int pthread_sigmask(int __how , __sigset_t const   * __restrict  __newmask ,
                                                         __sigset_t * __restrict  __oldmask ) ;
extern  __attribute__((__nothrow__)) int dup2(int __fd , int __fd2 ) ;
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
extern  __attribute__((__nothrow__)) __pid_t setsid(void) ;
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
extern  __attribute__((__nothrow__)) int gethostname(char *__name , size_t __len )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) __mode_t umask(__mode_t __mask ) ;
extern  __attribute__((__nothrow__)) int socket(int __domain , int __type , int __protocol ) ;
extern  __attribute__((__nothrow__)) int bind(int __fd , struct sockaddr  const  * __restrict  __addr ,
                                              socklen_t __len ) ;
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
extern  __attribute__((__nothrow__)) int setsockopt(int __fd , int __level , int __optname ,
                                                    void const   *__optval , socklen_t __optlen ) ;
extern  __attribute__((__nothrow__)) int listen(int __fd , int __n ) ;
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
extern  __attribute__((__nothrow__)) int shutdown(int __fd , int __how ) ;
extern  __attribute__((__nothrow__)) int inet_aton(char const   *__cp , struct in_addr *__inp ) ;
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
extern  __attribute__((__nothrow__)) void freeaddrinfo(struct addrinfo *__ai ) ;
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , unsigned int __flags ) ;
extern  __attribute__((__nothrow__)) int epoll_create(int __size ) ;
extern  __attribute__((__nothrow__)) int epoll_ctl(int __epfd , int __op , int __fd ,
                                                   struct epoll_event *__event ) ;
extern int epoll_wait(int __epfd , struct epoll_event *__events , int __maxevents ,
                      int __timeout ) ;
char const   *ttversion  =    "1.1.34";
_Bool ttgetlocalhostname(char *name ) 
{ int tmp ;

  {
  tmp = gethostname(name, 1023U);
  if (tmp != 0) {
    sprintf((char * __restrict  )name, (char const   * __restrict  )"localhost");
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
_Bool ttgethostaddr(char const   *name , char *addr ) 
{ struct addrinfo hints ;
  struct addrinfo *result ;
  int tmp ;
  int tmp___0 ;

  {
  memset((void *)(& hints), 0, (unsigned int )((int )sizeof(hints)));
  hints.ai_family = 2;
  hints.ai_socktype = 1;
  hints.ai_flags = 0;
  hints.ai_protocol = 6;
  hints.ai_canonname = (char *)((void *)0);
  hints.ai_addr = (struct sockaddr *)((void *)0);
  hints.ai_next = (struct addrinfo *)((void *)0);
  tmp = getaddrinfo((char const   * __restrict  )name, (char const   * __restrict  )((void *)0),
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& result));
  if (tmp != 0) {
    *addr = (char )'\000';
    return ((_Bool)0);
  }
  if (! result) {
    freeaddrinfo(result);
    return ((_Bool)0);
  }
  if ((int )(result->ai_addr)->sa_family != 2) {
    freeaddrinfo(result);
    return ((_Bool)0);
  }
  tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )result->ai_addr, result->ai_addrlen,
                        (char * __restrict  )addr, 1024U, (char * __restrict  )((void *)0),
                        0U, 1U);
  if (tmp___0 != 0) {
    freeaddrinfo(result);
    return ((_Bool)0);
  }
  freeaddrinfo(result);
  return ((_Bool)1);
}
}
int ttopensock(char const   *addr , int port ) 
{ struct sockaddr_in sain ;
  int tmp ;
  uint16_t snum ;
  register unsigned short __v ;
  register unsigned short __x ;
  int fd ;
  int tmp___0 ;
  int optint ;
  struct timeval opttv ;
  double dl ;
  double tmp___1 ;
  int ocs ;
  int rv ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  double tmp___8 ;

  {
  memset((void *)(& sain), 0, (unsigned int )((int )sizeof(sain)));
  sain.sin_family = (unsigned short)2;
  tmp = inet_aton(addr, & sain.sin_addr);
  if (tmp == 0) {
    return (-1);
  }
  snum = (unsigned short )port;
  __x = snum;
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
  sain.sin_port = __v;
  tmp___0 = socket(2, 1, 0);
  fd = tmp___0;
  if (fd == -1) {
    return (-1);
  }
  optint = 1;
  setsockopt(fd, 1, 9, (void const   *)((char *)(& optint)), (unsigned int )((int )sizeof(optint)));
  opttv.tv_sec = (long )((int )0.25);
  opttv.tv_usec = (long )((0.25 - (double )((int )0.25)) * (double )1000000);
  setsockopt(fd, 1, 20, (void const   *)((char *)(& opttv)), (unsigned int )((int )sizeof(opttv)));
  opttv.tv_sec = (long )((int )0.25);
  opttv.tv_usec = (long )((0.25 - (double )((int )0.25)) * (double )1000000);
  setsockopt(fd, 1, 21, (void const   *)((char *)(& opttv)), (unsigned int )((int )sizeof(opttv)));
  optint = 1;
  setsockopt(fd, 6, 1, (void const   *)((char *)(& optint)), (unsigned int )((int )sizeof(optint)));
  tmp___1 = tctime();
  dl = tmp___1 + 5.0;
  while (1) {
    ocs = 1;
    pthread_setcancelstate(0, & ocs);
    tmp___2 = connect(fd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sain)),
                      (unsigned int )((int )sizeof(sain)));
    rv = tmp___2;
    pthread_setcancelstate(ocs, (int *)((void *)0));
    if (rv == 0) {
      return (fd);
    }
    tmp___3 = __errno_location();
    if (*tmp___3 != 4) {
      tmp___4 = __errno_location();
      if (*tmp___4 != 11) {
        tmp___5 = __errno_location();
        if (*tmp___5 != 115) {
          tmp___6 = __errno_location();
          if (*tmp___6 != 114) {
            tmp___7 = __errno_location();
            if (*tmp___7 != 110) {
              break;
            }
          }
        }
      }
    }
    tmp___8 = tctime();
    if (! (tmp___8 <= dl)) {
      break;
    }
  }
  close(fd);
  return (-1);
}
}
int ttopensockunix(char const   *path ) 
{ struct sockaddr_un saun ;
  int fd ;
  int tmp ;
  int optint ;
  struct timeval opttv ;
  double dl ;
  double tmp___0 ;
  int ocs ;
  int rv ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  double tmp___7 ;

  {
  memset((void *)(& saun), 0, (unsigned int )((int )sizeof(saun)));
  saun.sun_family = (unsigned short)1;
  snprintf((char * __restrict  )(saun.sun_path), 108U, (char const   * __restrict  )"%s",
           path);
  tmp = socket(1, 1, 0);
  fd = tmp;
  if (fd == -1) {
    return (-1);
  }
  optint = 1;
  setsockopt(fd, 1, 9, (void const   *)((char *)(& optint)), (unsigned int )((int )sizeof(optint)));
  opttv.tv_sec = (long )((int )0.25);
  opttv.tv_usec = (long )((0.25 - (double )((int )0.25)) * (double )1000000);
  setsockopt(fd, 1, 20, (void const   *)((char *)(& opttv)), (unsigned int )((int )sizeof(opttv)));
  opttv.tv_sec = (long )((int )0.25);
  opttv.tv_usec = (long )((0.25 - (double )((int )0.25)) * (double )1000000);
  setsockopt(fd, 1, 21, (void const   *)((char *)(& opttv)), (unsigned int )((int )sizeof(opttv)));
  tmp___0 = tctime();
  dl = tmp___0 + 5.0;
  while (1) {
    ocs = 1;
    pthread_setcancelstate(0, & ocs);
    tmp___1 = connect(fd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& saun)),
                      (unsigned int )((int )sizeof(saun)));
    rv = tmp___1;
    pthread_setcancelstate(ocs, (int *)((void *)0));
    if (rv == 0) {
      return (fd);
    }
    tmp___2 = __errno_location();
    if (*tmp___2 != 4) {
      tmp___3 = __errno_location();
      if (*tmp___3 != 11) {
        tmp___4 = __errno_location();
        if (*tmp___4 != 115) {
          tmp___5 = __errno_location();
          if (*tmp___5 != 114) {
            tmp___6 = __errno_location();
            if (*tmp___6 != 110) {
              break;
            }
          }
        }
      }
    }
    tmp___7 = tctime();
    if (! (tmp___7 <= dl)) {
      break;
    }
  }
  close(fd);
  return (-1);
}
}
int ttopenservsock(char const   *addr , int port ) 
{ struct sockaddr_in sain ;
  char const   *tmp ;
  int tmp___0 ;
  uint16_t snum ;
  register unsigned short __v ;
  register unsigned short __x ;
  int fd ;
  int tmp___1 ;
  int optint ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  memset((void *)(& sain), 0, (unsigned int )((int )sizeof(sain)));
  sain.sin_family = (unsigned short)2;
  if (addr) {
    tmp = addr;
  } else {
    tmp = "0.0.0.0";
  }
  tmp___0 = inet_aton(tmp, & sain.sin_addr);
  if (tmp___0 == 0) {
    return (-1);
  }
  snum = (unsigned short )port;
  __x = snum;
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
  sain.sin_port = __v;
  tmp___1 = socket(2, 1, 0);
  fd = tmp___1;
  if (fd == -1) {
    return (-1);
  }
  optint = 1;
  tmp___2 = setsockopt(fd, 1, 2, (void const   *)((char *)(& optint)), (unsigned int )((int )sizeof(optint)));
  if (tmp___2 != 0) {
    close(fd);
    return (-1);
  }
  tmp___3 = bind(fd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sain)),
                 (unsigned int )((int )sizeof(sain)));
  if (tmp___3 != 0) {
    close(fd);
    return (-1);
  } else {
    tmp___4 = listen(fd, 128);
    if (tmp___4 != 0) {
      close(fd);
      return (-1);
    }
  }
  return (fd);
}
}
int ttopenservsockunix(char const   *path ) 
{ struct sockaddr_un saun ;
  int fd ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  if ((int const   )*path == 0) {
    return (-1);
  }
  memset((void *)(& saun), 0, (unsigned int )((int )sizeof(saun)));
  saun.sun_family = (unsigned short)1;
  snprintf((char * __restrict  )(saun.sun_path), 108U, (char const   * __restrict  )"%s",
           path);
  tmp = socket(1, 1, 0);
  fd = tmp;
  if (fd == -1) {
    return (-1);
  }
  tmp___0 = bind(fd, (struct sockaddr  const  * __restrict  )((struct sockaddr *)(& saun)),
                 (unsigned int )((int )sizeof(saun)));
  if (tmp___0 != 0) {
    close(fd);
    return (-1);
  } else {
    tmp___1 = listen(fd, 128);
    if (tmp___1 != 0) {
      close(fd);
      return (-1);
    }
  }
  return (fd);
}
}
int ttacceptsock(int fd , char *addr , int *pp ) 
{ struct sockaddr_in sain ;
  socklen_t slen ;
  int cfd ;
  int tmp ;
  int optint ;
  struct timeval opttv ;
  int tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
  while (1) {
    memset((void *)(& sain), 0, (unsigned int )((int )sizeof(sain)));
    sain.sin_family = (unsigned short)2;
    slen = (unsigned int )((int )sizeof(sain));
    tmp = accept(fd, (struct sockaddr * __restrict  )((struct sockaddr *)(& sain)),
                 (socklen_t * __restrict  )(& slen));
    cfd = tmp;
    if (cfd >= 0) {
      optint = 1;
      setsockopt(fd, 1, 9, (void const   *)((char *)(& optint)), (unsigned int )((int )sizeof(optint)));
      opttv.tv_sec = (long )((int )0.25);
      opttv.tv_usec = (long )((0.25 - (double )((int )0.25)) * (double )1000000);
      setsockopt(cfd, 1, 20, (void const   *)((char *)(& opttv)), (unsigned int )((int )sizeof(opttv)));
      opttv.tv_sec = (long )((int )0.25);
      opttv.tv_usec = (long )((0.25 - (double )((int )0.25)) * (double )1000000);
      setsockopt(cfd, 1, 21, (void const   *)((char *)(& opttv)), (unsigned int )((int )sizeof(opttv)));
      optint = 1;
      setsockopt(cfd, 6, 1, (void const   *)((char *)(& optint)), (unsigned int )((int )sizeof(optint)));
      if (addr) {
        tmp___0 = getnameinfo((struct sockaddr  const  * __restrict  )((struct sockaddr *)(& sain)),
                              (unsigned int )((int )sizeof(sain)), (char * __restrict  )addr,
                              1024U, (char * __restrict  )((void *)0), 0U, 1U);
        if (tmp___0 != 0) {
          sprintf((char * __restrict  )addr, (char const   * __restrict  )"0.0.0.0");
        }
      }
      if (pp) {
        __x = sain.sin_port;
        __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
        *pp = (int )__v;
      }
      return (cfd);
    }
    tmp___1 = __errno_location();
    if (! (*tmp___1 == 4)) {
      tmp___2 = __errno_location();
      if (! (*tmp___2 == 11)) {
        break;
      }
    }
  }
  return (-1);
}
}
int ttacceptsockunix(int fd ) 
{ int cfd ;
  int tmp ;
  int optint ;
  struct timeval opttv ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  while (1) {
    tmp = accept(fd, (struct sockaddr * __restrict  )((void *)0), (socklen_t * __restrict  )((void *)0));
    cfd = tmp;
    if (cfd >= 0) {
      optint = 1;
      setsockopt(fd, 1, 9, (void const   *)((char *)(& optint)), (unsigned int )((int )sizeof(optint)));
      opttv.tv_sec = (long )((int )0.25);
      opttv.tv_usec = (long )((0.25 - (double )((int )0.25)) * (double )1000000);
      setsockopt(cfd, 1, 20, (void const   *)((char *)(& opttv)), (unsigned int )((int )sizeof(opttv)));
      opttv.tv_sec = (long )((int )0.25);
      opttv.tv_usec = (long )((0.25 - (double )((int )0.25)) * (double )1000000);
      setsockopt(cfd, 1, 21, (void const   *)((char *)(& opttv)), (unsigned int )((int )sizeof(opttv)));
      return (cfd);
    }
    tmp___0 = __errno_location();
    if (! (*tmp___0 == 4)) {
      tmp___1 = __errno_location();
      if (! (*tmp___1 == 11)) {
        break;
      }
    }
  }
  return (-1);
}
}
_Bool ttclosesock(int fd ) 
{ _Bool err ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
  err = (_Bool)0;
  tmp = shutdown(fd, 2);
  if (tmp != 0) {
    tmp___0 = __errno_location();
    if (*tmp___0 != 107) {
      tmp___1 = __errno_location();
      if (*tmp___1 != 104) {
        err = (_Bool)1;
      }
    }
  }
  tmp___2 = close(fd);
  if (tmp___2 != 0) {
    tmp___3 = __errno_location();
    if (*tmp___3 != 107) {
      tmp___4 = __errno_location();
      if (*tmp___4 != 104) {
        err = (_Bool)1;
      }
    }
  }
  return ((_Bool )(! err));
}
}
TTSOCK *ttsocknew(int fd ) 
{ TTSOCK *sock ;
  void *tmp ;

  {
  tmp = tcmalloc((unsigned int )((int )sizeof(*sock)));
  sock = (TTSOCK *)tmp;
  sock->fd = fd;
  sock->rp = sock->buf;
  sock->ep = sock->buf;
  sock->end = (_Bool)0;
  sock->dl = __builtin_huge_val();
  return (sock);
}
}
void ttsockdel(TTSOCK *sock ) 
{ 

  {
  tcfree((void *)sock);
  return;
}
}
void ttsocksetlife(TTSOCK *sock , double lifetime ) 
{ double tmp ;

  {
  tmp = tctime();
  sock->dl = tmp + lifetime;
  return;
}
}
_Bool ttsocksend(TTSOCK *sock , void const   *buf , int size ) 
{ char const   *rp ;
  int ocs ;
  int wb ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  double tmp___3 ;

  {
  rp = (char const   *)buf;
  while (1) {
    ocs = 1;
    pthread_setcancelstate(0, & ocs);
    tmp = send(sock->fd, (void const   *)rp, (unsigned int )size, 0);
    wb = tmp;
    pthread_setcancelstate(ocs, (int *)((void *)0));
    switch (wb) {
    case -1: 
    tmp___0 = __errno_location();
    if (*tmp___0 != 4) {
      tmp___1 = __errno_location();
      if (*tmp___1 != 11) {
        tmp___2 = __errno_location();
        if (*tmp___2 != 11) {
          sock->end = (_Bool)1;
          return ((_Bool)0);
        }
      }
    }
    tmp___3 = tctime();
    if (tmp___3 > sock->dl) {
      sock->end = (_Bool)1;
      return ((_Bool)0);
    }
    break;
    case 0: 
    break;
    default: 
    rp += wb;
    size -= wb;
    break;
    }
    if (! (size > 0)) {
      break;
    }
  }
  return ((_Bool)1);
}
}
_Bool ttsockprintf(TTSOCK *sock , char const   *format  , ...) 
{ _Bool err ;
  TCXSTR *xstr ;
  TCXSTR *tmp ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;
  va_list ap ;
  char cbuf[32] ;
  int cblen ;
  int lnum ;
  int tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tlen ;
  char *tmp___7 ;
  char tbuf[64] ;
  long long tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  unsigned long long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned int tmp___13 ;
  long double tmp___14 ;
  double tmp___15 ;
  unsigned char c ;
  char *tmp___17 ;
  int tmp___18 ;
  void const   *tmp___19 ;
  _Bool tmp___20 ;

  {
  err = (_Bool)0;
  tmp = tcxstrnew();
  xstr = tmp;
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcxstrdel);
    __cancel_arg = (void *)xstr;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      __builtin_va_start(ap, format);
      while ((int const   )*format != 0) {
        if ((int const   )*format == 37) {
          cbuf[0] = (char )'%';
          cblen = 1;
          lnum = 0;
          format ++;
          while (1) {
            tmp___5 = __builtin_strchr((char *)"0123456789 .+-hlLz", (int )*format);
            if (tmp___5) {
              if ((int const   )*format != 0) {
                if (! (cblen < 31)) {
                  break;
                }
              } else {
                break;
              }
            } else {
              break;
            }
            if ((int const   )*format == 108) {
              lnum ++;
            } else {
              if ((int const   )*format == 76) {
                lnum ++;
              }
            }
            tmp___2 = cblen;
            cblen ++;
            tmp___3 = format;
            format ++;
            cbuf[tmp___2] = (char )*tmp___3;
          }
          tmp___6 = cblen;
          cblen ++;
          cbuf[tmp___6] = (char )*format;
          cbuf[cblen] = (char )'\000';
          switch ((int )*format) {
          case 115: 
          tmp___7 = __builtin_va_arg(ap, char *);
          if (! tmp___7) {
            tmp___7 = (char *)"(null)";
          }
          tcxstrcat2(xstr, (char const   *)tmp___7);
          break;
          case 100: 
          if (lnum >= 2) {
            tmp___8 = __builtin_va_arg(ap, long long );
            tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                           tmp___8);
          } else {
            if (lnum >= 1) {
              tmp___9 = __builtin_va_arg(ap, long );
              tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                             tmp___9);
            } else {
              tmp___10 = __builtin_va_arg(ap, int );
              tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                             tmp___10);
            }
          }
          tcxstrcat(xstr, (void const   *)(tbuf), tlen);
          break;
          case 111: 
          case 117: 
          case 120: 
          case 88: 
          case 99: 
          if (lnum >= 2) {
            tmp___11 = __builtin_va_arg(ap, unsigned long long );
            tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                           tmp___11);
          } else {
            if (lnum >= 1) {
              tmp___12 = __builtin_va_arg(ap, unsigned long );
              tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                             tmp___12);
            } else {
              tmp___13 = __builtin_va_arg(ap, unsigned int );
              tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                             tmp___13);
            }
          }
          tcxstrcat(xstr, (void const   *)(tbuf), tlen);
          break;
          case 101: 
          case 69: 
          case 102: 
          case 103: 
          case 71: 
          if (lnum >= 1) {
            tmp___14 = __builtin_va_arg(ap, long double );
            tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                           tmp___14);
          } else {
            tmp___15 = __builtin_va_arg(ap, double );
            tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )(cbuf),
                           tmp___15);
          }
          tcxstrcat(xstr, (void const   *)(tbuf), tlen);
          break;
          case 64: 
          tmp___7 = __builtin_va_arg(ap, char *);
          if (! tmp___7) {
            tmp___7 = (char *)"(null)";
          }
          while (*tmp___7) {
            switch ((int )*tmp___7) {
            case 38: 
            tcxstrcat(xstr, (void const   *)"&amp;", 5);
            break;
            case 60: 
            tcxstrcat(xstr, (void const   *)"&lt;", 4);
            break;
            case 62: 
            tcxstrcat(xstr, (void const   *)"&gt;", 4);
            break;
            case 34: 
            tcxstrcat(xstr, (void const   *)"&quot;", 6);
            break;
            default: ;
            if ((int )*tmp___7 >= 0) {
              if (! ((int )*tmp___7 <= 8)) {
                goto _L;
              }
            } else {
              _L: 
              if ((int )*tmp___7 >= 14) {
                if (! ((int )*tmp___7 <= 31)) {
                  tcxstrcat(xstr, (void const   *)tmp___7, 1);
                }
              } else {
                tcxstrcat(xstr, (void const   *)tmp___7, 1);
              }
            }
            break;
            }
            tmp___7 ++;
          }
          break;
          case 63: 
          tmp___7 = __builtin_va_arg(ap, char *);
          if (! tmp___7) {
            tmp___7 = (char *)"(null)";
          }
          while (*tmp___7) {
            c = *((unsigned char *)tmp___7);
            if ((int )c >= 65) {
              if ((int )c <= 90) {
                tcxstrcat(xstr, (void const   *)tmp___7, 1);
              } else {
                goto _L___2;
              }
            } else {
              _L___2: 
              if ((int )c >= 97) {
                if ((int )c <= 122) {
                  tcxstrcat(xstr, (void const   *)tmp___7, 1);
                } else {
                  goto _L___1;
                }
              } else {
                _L___1: 
                if ((int )c >= 48) {
                  if ((int )c <= 57) {
                    tcxstrcat(xstr, (void const   *)tmp___7, 1);
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: 
                  if ((int )c != 0) {
                    tmp___17 = __builtin_strchr((char *)"_-.", (int )c);
                    if (tmp___17) {
                      tcxstrcat(xstr, (void const   *)tmp___7, 1);
                    } else {
                      tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )"%%%02X",
                                     c);
                      tcxstrcat(xstr, (void const   *)(tbuf), tlen);
                    }
                  } else {
                    tlen = sprintf((char * __restrict  )(tbuf), (char const   * __restrict  )"%%%02X",
                                   c);
                    tcxstrcat(xstr, (void const   *)(tbuf), tlen);
                  }
                }
              }
            }
            tmp___7 ++;
          }
          break;
          case 37: 
          tcxstrcat(xstr, (void const   *)"%", 1);
          break;
          }
        } else {
          tcxstrcat(xstr, (void const   *)format, 1);
        }
        format ++;
      }
      __builtin_va_end(ap);
      tmp___18 = tcxstrsize((TCXSTR const   *)xstr);
      tmp___19 = tcxstrptr((TCXSTR const   *)xstr);
      tmp___20 = ttsocksend(sock, tmp___19, tmp___18);
      if (! tmp___20) {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
_Bool ttsockrecv(TTSOCK *sock , char *buf , int size ) 
{ _Bool err ;
  char *wp ;
  int c ;
  int tmp ;
  char *tmp___0 ;

  {
  if ((unsigned int )(sock->rp + size) <= (unsigned int )sock->ep) {
    memcpy((void * __restrict  )buf, (void const   * __restrict  )sock->rp, (unsigned int )size);
    sock->rp += size;
    return ((_Bool)1);
  }
  err = (_Bool)0;
  wp = buf;
  while (size > 0) {
    tmp = ttsockgetc(sock);
    c = tmp;
    if (c == -1) {
      err = (_Bool)1;
      break;
    }
    tmp___0 = wp;
    wp ++;
    *tmp___0 = (char )c;
    size --;
  }
  return ((_Bool )(! err));
}
}
int ttsockgetc(TTSOCK *sock ) 
{ char *tmp ;
  int ocs ;
  int rv ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  double tmp___4 ;

  {
  if ((unsigned int )sock->rp < (unsigned int )sock->ep) {
    tmp = sock->rp;
    (sock->rp) ++;
    return ((int )*((unsigned char *)tmp));
  }
  while (1) {
    ocs = 1;
    pthread_setcancelstate(0, & ocs);
    tmp___0 = recv(sock->fd, (void *)(sock->buf), 65536U, 0);
    rv = tmp___0;
    pthread_setcancelstate(ocs, (int *)((void *)0));
    if (rv > 0) {
      sock->rp = sock->buf + 1;
      sock->ep = sock->buf + rv;
      return ((int )*((unsigned char *)(sock->buf)));
    } else {
      if (rv == 0) {
        sock->end = (_Bool)1;
        return (-1);
      }
    }
    tmp___1 = __errno_location();
    if (*tmp___1 == 4) {
      goto _L;
    } else {
      tmp___2 = __errno_location();
      if (*tmp___2 == 11) {
        goto _L;
      } else {
        tmp___3 = __errno_location();
        if (*tmp___3 == 11) {
          _L: 
          tmp___4 = tctime();
          if (! (tmp___4 <= sock->dl)) {
            break;
          }
        } else {
          break;
        }
      }
    }
  }
  sock->end = (_Bool)1;
  return (-1);
}
}
void ttsockungetc(TTSOCK *sock , int c ) 
{ 

  {
  if ((unsigned int )sock->rp <= (unsigned int )(sock->buf)) {
    return;
  }
  (sock->rp) --;
  *((unsigned char *)sock->rp) = (unsigned char )c;
  return;
}
}
_Bool ttsockgets(TTSOCK *sock , char *buf , int size ) 
{ _Bool err ;
  char *wp ;
  int c ;
  int tmp ;
  char *tmp___0 ;

  {
  err = (_Bool)0;
  size --;
  wp = buf;
  while (size > 0) {
    tmp = ttsockgetc(sock);
    c = tmp;
    if (c == 10) {
      break;
    }
    if (c == -1) {
      err = (_Bool)1;
      break;
    }
    if (c != 13) {
      tmp___0 = wp;
      wp ++;
      *tmp___0 = (char )c;
      size --;
    }
  }
  *wp = (char )'\000';
  return ((_Bool )(! err));
}
}
char *ttsockgets2(TTSOCK *sock ) 
{ _Bool err ;
  TCXSTR *xstr ;
  TCXSTR *tmp ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;
  int size ;
  int c ;
  int tmp___2 ;
  unsigned char b ;
  void *tmp___3 ;

  {
  err = (_Bool)0;
  tmp = tcxstrnew3(4096);
  xstr = tmp;
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcxstrdel);
    __cancel_arg = (void *)xstr;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      size = 0;
      while (1) {
        tmp___2 = ttsockgetc(sock);
        c = tmp___2;
        if (c == 10) {
          break;
        }
        if (c == -1) {
          err = (_Bool)1;
          break;
        }
        if (c != 13) {
          b = (unsigned char )c;
          tcxstrcat(xstr, (void const   *)(& b), (int )sizeof(b));
          size ++;
          if (size >= 16777216) {
            err = (_Bool)1;
            break;
          }
        }
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    break;
  }
  tmp___3 = tcxstrtomalloc(xstr);
  return ((char *)tmp___3);
}
}
uint32_t ttsockgetint32(TTSOCK *sock ) 
{ uint32_t num ;

  {
  ttsockrecv(sock, (char *)(& num), (int )sizeof(num));
  return ((unsigned int )((((((unsigned long )num & 255UL) << 24) | (((unsigned long )num & 65280UL) << 8)) | (((unsigned long )num & 16711680UL) >> 8)) | (((unsigned long )num & 4278190080UL) >> 24)));
}
}
uint64_t ttsockgetint64(TTSOCK *sock ) 
{ uint64_t num ;

  {
  ttsockrecv(sock, (char *)(& num), (int )sizeof(num));
  return (((((((((num & 255ULL) << 56) | ((num & 65280ULL) << 40)) | ((num & 16711680ULL) << 24)) | ((num & 4278190080ULL) << 8)) | ((num & 1095216660480ULL) >> 8)) | ((num & 280375465082880ULL) >> 24)) | ((num & 71776119061217280ULL) >> 40)) | ((num & 0xff00000000000000ULL) >> 56));
}
}
_Bool ttsockcheckend(TTSOCK *sock ) 
{ 

  {
  return (sock->end);
}
}
int ttsockcheckpfsiz(TTSOCK *sock ) 
{ 

  {
  if (sock->end) {
    return (0);
  }
  return (sock->ep - sock->rp);
}
}
int tthttpfetch(char const   *url , TCMAP *reqheads , TCMAP *resheads , TCXSTR *resbody ) 
{ int code ;
  TCMAP *elems ;
  TCMAP *tmp ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;
  char const   *scheme ;
  char const   *tmp___2 ;
  char const   *host ;
  char const   *tmp___3 ;
  char const   *port ;
  char const   *tmp___4 ;
  char const   *authority ;
  char const   *tmp___5 ;
  char const   *path ;
  char const   *tmp___6 ;
  char const   *query ;
  char const   *tmp___7 ;
  int pnum ;
  int64_t tmp___8 ;
  int64_t tmp___9 ;
  char addr[1024] ;
  int fd ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___tthttpfetch)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___10 ;
  long tmp___11 ;
  TTSOCK *sock ;
  TTSOCK *tmp___12 ;
  __pthread_unwind_buf_t __cancel_buf___1 ;
  void (*__cancel_routine___1)(void * ) ;
  void *__cancel_arg___1 ;
  int not_first_call___1 ;
  int tmp___13 ;
  long tmp___14 ;
  TCXSTR *obuf ;
  TCXSTR *tmp___15 ;
  __pthread_unwind_buf_t __cancel_buf___2 ;
  void (*__cancel_routine___2)(void * ) ;
  void *__cancel_arg___2 ;
  int not_first_call___2 ;
  int tmp___16 ;
  long tmp___17 ;
  char *enc ;
  size_t tmp___18 ;
  char *tmp___19 ;
  double tout ;
  char const   *name ;
  char *tmp___21 ;
  int tmp___22 ;
  char const   *tmp___23 ;
  char *cap ;
  char *tmp___24 ;
  char *wp ;
  _Bool head ;
  int tmp___25 ;
  char const   *tmp___26 ;
  int tmp___27 ;
  char line[4096] ;
  char const   *rp ;
  char *tmp___29 ;
  int64_t tmp___30 ;
  _Bool tmp___31 ;
  _Bool tmp___32 ;
  int clen ;
  _Bool chunked ;
  char *pv ;
  char *tmp___34 ;
  char *tmp___35 ;
  int64_t tmp___36 ;
  int tmp___37 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___39 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  _Bool tmp___52 ;
  _Bool err ;
  char *body ;
  int bsiz ;
  void *tmp___53 ;
  int asiz ;
  void *tmp___54 ;
  __pthread_unwind_buf_t __cancel_buf___3 ;
  void (*__cancel_routine___3)(void * ) ;
  void *__cancel_arg___3 ;
  int not_first_call___3 ;
  int tmp___55 ;
  long tmp___56 ;
  _Bool tmp___57 ;
  int size ;
  int64_t tmp___58 ;
  void *tmp___59 ;
  __pthread_unwind_buf_t __cancel_buf___4 ;
  void (*__cancel_routine___4)(void * ) ;
  void *__cancel_arg___4 ;
  int not_first_call___4 ;
  int tmp___60 ;
  long tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  void *tmp___64 ;
  void *tmp___65 ;
  __pthread_unwind_buf_t __cancel_buf___5 ;
  void (*__cancel_routine___5)(void * ) ;
  void *__cancel_arg___5 ;
  int not_first_call___5 ;
  int tmp___66 ;
  long tmp___67 ;
  _Bool tmp___68 ;
  int asiz___0 ;
  void *tmp___69 ;
  int c ;
  __pthread_unwind_buf_t __cancel_buf___6 ;
  void (*__cancel_routine___6)(void * ) ;
  void *__cancel_arg___6 ;
  int not_first_call___6 ;
  int tmp___70 ;
  long tmp___71 ;
  void *tmp___72 ;
  int tmp___73 ;
  _Bool tmp___74 ;
  int tmp___75 ;
  void const   *tmp___76 ;
  _Bool tmp___77 ;
  _Bool tmp___78 ;
  int tmp___79 ;

  {
  code = -1;
  tmp = tcurlbreak(url);
  elems = tmp;
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcmapdel);
    __cancel_arg = (void *)elems;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      tmp___2 = tcmapget2((TCMAP const   *)elems, "scheme");
      scheme = tmp___2;
      tmp___3 = tcmapget2((TCMAP const   *)elems, "host");
      host = tmp___3;
      tmp___4 = tcmapget2((TCMAP const   *)elems, "port");
      port = tmp___4;
      tmp___5 = tcmapget2((TCMAP const   *)elems, "authority");
      authority = tmp___5;
      tmp___6 = tcmapget2((TCMAP const   *)elems, "path");
      path = tmp___6;
      tmp___7 = tcmapget2((TCMAP const   *)elems, "query");
      query = tmp___7;
      if (scheme) {
        tmp___79 = tcstricmp(scheme, "http");
        if (! tmp___79) {
          if (host) {
            if ((int const   )*host == 0) {
              host = "127.0.0.1";
            }
            if (port) {
              tmp___8 = tcatoi(port);
              tmp___9 = tmp___8;
            } else {
              tmp___9 = 80LL;
            }
            pnum = (int )tmp___9;
            if (pnum < 1) {
              pnum = 80;
            }
            if (! path) {
              path = "/";
            }
            tmp___78 = ttgethostaddr(host, addr);
            if (tmp___78) {
              fd = ttopensock((char const   *)(addr), pnum);
              if (fd != -1) {
                while (1) {
                  __cancel_routine___tthttpfetch = (void (*)(void * ))(& ttclosesock);
                  __cancel_arg___0 = (void *)fd;
                  tmp___10 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                                         0);
                  not_first_call___0 = tmp___10;
                  tmp___11 = __builtin_expect((long )not_first_call___0, 0L);
                  if (tmp___11) {
                    (*__cancel_routine___tthttpfetch)(__cancel_arg___0);
                    __pthread_unwind_next(& __cancel_buf___0);
                  }
                  __pthread_register_cancel(& __cancel_buf___0);
                  while (1) {
                    tmp___12 = ttsocknew(fd);
                    sock = tmp___12;
                    while (1) {
                      __cancel_routine___1 = (void (*)(void * ))(& ttsockdel);
                      __cancel_arg___1 = (void *)sock;
                      tmp___13 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___1.__cancel_jmp_buf),
                                             0);
                      not_first_call___1 = tmp___13;
                      tmp___14 = __builtin_expect((long )not_first_call___1, 0L);
                      if (tmp___14) {
                        (*__cancel_routine___1)(__cancel_arg___1);
                        __pthread_unwind_next(& __cancel_buf___1);
                      }
                      __pthread_register_cancel(& __cancel_buf___1);
                      while (1) {
                        tmp___15 = tcxstrnew();
                        obuf = tmp___15;
                        while (1) {
                          __cancel_routine___2 = (void (*)(void * ))(& tcxstrdel);
                          __cancel_arg___2 = (void *)obuf;
                          tmp___16 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___2.__cancel_jmp_buf),
                                                 0);
                          not_first_call___2 = tmp___16;
                          tmp___17 = __builtin_expect((long )not_first_call___2, 0L);
                          if (tmp___17) {
                            (*__cancel_routine___2)(__cancel_arg___2);
                            __pthread_unwind_next(& __cancel_buf___2);
                          }
                          __pthread_register_cancel(& __cancel_buf___2);
                          while (1) {
                            if (query) {
                              tcxstrprintf(obuf, "GET %s?%s HTTP/1.1\r\n", path, query);
                            } else {
                              tcxstrprintf(obuf, "GET %s HTTP/1.1\r\n", path);
                            }
                            if (pnum == 80) {
                              tcxstrprintf(obuf, "Host: %s\r\n", host);
                            } else {
                              tcxstrprintf(obuf, "Host: %s:%d\r\n", host, pnum);
                            }
                            tcxstrprintf(obuf, "Connection: close\r\n", host, port);
                            if (authority) {
                              tmp___18 = strlen(authority);
                              tmp___19 = tcbaseencode(authority, (int )tmp___18);
                              enc = tmp___19;
                              tcxstrprintf(obuf, "Authorization: Basic %s\r\n", enc);
                              tcfree((void *)enc);
                            }
                            tout = (double )-1;
                            if (reqheads) {
                              tcmapiterinit(reqheads);
                              while (1) {
                                name = tcmapiternext2(reqheads);
                                if (! ((unsigned int )name != (unsigned int )((void *)0))) {
                                  break;
                                }
                                tmp___21 = __builtin_strchr((char *)name, ':');
                                if (tmp___21) {
                                  continue;
                                } else {
                                  tmp___22 = tcstricmp(name, "connection");
                                  if (! tmp___22) {
                                    continue;
                                  }
                                }
                                tmp___27 = tcstricmp(name, "x-tt-timeout");
                                if (tmp___27) {
                                  tmp___24 = tcstrdup((void const   *)name);
                                  cap = tmp___24;
                                  tcstrtolower(cap);
                                  wp = cap;
                                  head = (_Bool)1;
                                  while ((int )*wp != 0) {
                                    if (head) {
                                      if ((int )*wp >= 97) {
                                        if ((int )*wp <= 122) {
                                          *wp = (char )((int )*wp - 32);
                                        }
                                      }
                                    }
                                    if ((int )*wp == 45) {
                                      tmp___25 = 1;
                                    } else {
                                      if ((int )*wp == 32) {
                                        tmp___25 = 1;
                                      } else {
                                        tmp___25 = 0;
                                      }
                                    }
                                    head = (_Bool )tmp___25;
                                    wp ++;
                                  }
                                  tmp___26 = tcmapget2((TCMAP const   *)reqheads,
                                                       name);
                                  tcxstrprintf(obuf, "%s: %s\r\n", cap, tmp___26);
                                  tcfree((void *)cap);
                                } else {
                                  tmp___23 = tcmapget2((TCMAP const   *)reqheads,
                                                       name);
                                  tout = tcatof(tmp___23);
                                }
                              }
                            }
                            tcxstrprintf(obuf, "\r\n", host);
                            if (tout > (double )0) {
                              ttsocksetlife(sock, tout);
                            }
                            tmp___75 = tcxstrsize((TCXSTR const   *)obuf);
                            tmp___76 = tcxstrptr((TCXSTR const   *)obuf);
                            tmp___77 = ttsocksend(sock, tmp___76, tmp___75);
                            if (tmp___77) {
                              tmp___31 = ttsockgets(sock, line, 4096);
                              if (tmp___31) {
                                tmp___32 = tcstrfwm((char const   *)(line), "HTTP/");
                                if (tmp___32) {
                                  tcstrsqzspc(line);
                                  tmp___29 = __builtin_strchr(line, ' ');
                                  rp = (char const   *)tmp___29;
                                  tmp___30 = tcatoi(rp + 1);
                                  code = (int )tmp___30;
                                  if (resheads) {
                                    tcmapput2(resheads, "STATUS", (char const   *)(line));
                                  }
                                }
                              }
                              if (code > 0) {
                                clen = 0;
                                chunked = (_Bool)0;
                                while (1) {
                                  tmp___52 = ttsockgets(sock, line, 4096);
                                  if (tmp___52) {
                                    if (! ((int )line[0] != 0)) {
                                      break;
                                    }
                                  } else {
                                    break;
                                  }
                                  tcstrsqzspc(line);
                                  tmp___34 = __builtin_strchr(line, ':');
                                  pv = tmp___34;
                                  if (! pv) {
                                    continue;
                                  }
                                  tmp___35 = pv;
                                  pv ++;
                                  *tmp___35 = (char )'\000';
                                  while ((int )*pv == 32) {
                                    pv ++;
                                  }
                                  tcstrtolower(line);
                                  if (0) {
                                    __s1_len___0 = strlen((char const   *)(line));
                                    __s2_len___0 = strlen("content-length");
                                    if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)(line)) == 1U)) {
                                      goto _L___2;
                                    } else {
                                      if (__s1_len___0 >= 4U) {
                                        _L___2: 
                                        if (! ((unsigned int )((void const   *)("content-length" + 1)) - (unsigned int )((void const   *)"content-length") == 1U)) {
                                          tmp___51 = 1;
                                        } else {
                                          if (__s2_len___0 >= 4U) {
                                            tmp___51 = 1;
                                          } else {
                                            tmp___51 = 0;
                                          }
                                        }
                                      } else {
                                        tmp___51 = 0;
                                      }
                                    }
                                    if (tmp___51) {
                                      tmp___46 = __builtin_strcmp((char const   *)(line),
                                                                  "content-length");
                                      tmp___50 = tmp___46;
                                    } else {
                                      tmp___49 = __builtin_strcmp((char const   *)(line),
                                                                  "content-length");
                                      tmp___50 = tmp___49;
                                    }
                                  } else {
                                    tmp___49 = __builtin_strcmp((char const   *)(line),
                                                                "content-length");
                                    tmp___50 = tmp___49;
                                  }
                                  if (tmp___50) {
                                    if (0) {
                                      __s1_len = strlen((char const   *)(line));
                                      __s2_len = strlen("transfer-encoding");
                                      if (! ((unsigned int )((void const   *)(line + 1)) - (unsigned int )((void const   *)(line)) == 1U)) {
                                        goto _L___0;
                                      } else {
                                        if (__s1_len >= 4U) {
                                          _L___0: 
                                          if (! ((unsigned int )((void const   *)("transfer-encoding" + 1)) - (unsigned int )((void const   *)"transfer-encoding") == 1U)) {
                                            tmp___44 = 1;
                                          } else {
                                            if (__s2_len >= 4U) {
                                              tmp___44 = 1;
                                            } else {
                                              tmp___44 = 0;
                                            }
                                          }
                                        } else {
                                          tmp___44 = 0;
                                        }
                                      }
                                      if (tmp___44) {
                                        tmp___39 = __builtin_strcmp((char const   *)(line),
                                                                    "transfer-encoding");
                                        tmp___43 = tmp___39;
                                      } else {
                                        tmp___42 = __builtin_strcmp((char const   *)(line),
                                                                    "transfer-encoding");
                                        tmp___43 = tmp___42;
                                      }
                                    } else {
                                      tmp___42 = __builtin_strcmp((char const   *)(line),
                                                                  "transfer-encoding");
                                      tmp___43 = tmp___42;
                                    }
                                    if (! tmp___43) {
                                      tmp___37 = tcstricmp((char const   *)pv, "chunked");
                                      if (! tmp___37) {
                                        chunked = (_Bool)1;
                                      }
                                    }
                                  } else {
                                    tmp___36 = tcatoi((char const   *)pv);
                                    clen = (int )tmp___36;
                                  }
                                  if (resheads) {
                                    tcmapput2(resheads, (char const   *)(line), (char const   *)pv);
                                  }
                                }
                                tmp___74 = ttsockcheckend(sock);
                                if (! tmp___74) {
                                  if (resbody) {
                                    err = (_Bool)0;
                                    if (code == 304) {
                                      tmp___53 = tcmemdup((void const   *)"", 0U);
                                      body = (char *)tmp___53;
                                      bsiz = 0;
                                    } else {
                                      if (chunked) {
                                        asiz = 4096;
                                        tmp___54 = tcmalloc((unsigned int )asiz);
                                        body = (char *)tmp___54;
                                        bsiz = 0;
                                        while (1) {
                                          while (1) {
                                            __cancel_routine___3 = & free;
                                            __cancel_arg___3 = (void *)body;
                                            tmp___55 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___3.__cancel_jmp_buf),
                                                                   0);
                                            not_first_call___3 = tmp___55;
                                            tmp___56 = __builtin_expect((long )not_first_call___3,
                                                                        0L);
                                            if (tmp___56) {
                                              (*__cancel_routine___3)(__cancel_arg___3);
                                              __pthread_unwind_next(& __cancel_buf___3);
                                            }
                                            __pthread_register_cancel(& __cancel_buf___3);
                                            while (1) {
                                              tmp___57 = ttsockgets(sock, line, 4096);
                                              if (! tmp___57) {
                                                err = (_Bool)1;
                                              }
                                              break;
                                            }
                                            __pthread_unregister_cancel(& __cancel_buf___3);
                                            break;
                                          }
                                          if (err) {
                                            break;
                                          } else {
                                            if ((int )line[0] == 0) {
                                              break;
                                            }
                                          }
                                          tmp___58 = tcatoih((char const   *)(line));
                                          size = (int )tmp___58;
                                          if (bsiz + size > 268435456) {
                                            err = (_Bool)1;
                                            break;
                                          }
                                          if (bsiz + size > asiz) {
                                            asiz = bsiz * 2 + size;
                                            tmp___59 = tcrealloc((void *)body, (unsigned int )asiz);
                                            body = (char *)tmp___59;
                                          }
                                          while (1) {
                                            __cancel_routine___4 = & free;
                                            __cancel_arg___4 = (void *)body;
                                            tmp___60 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___4.__cancel_jmp_buf),
                                                                   0);
                                            not_first_call___4 = tmp___60;
                                            tmp___61 = __builtin_expect((long )not_first_call___4,
                                                                        0L);
                                            if (tmp___61) {
                                              (*__cancel_routine___4)(__cancel_arg___4);
                                              __pthread_unwind_next(& __cancel_buf___4);
                                            }
                                            __pthread_register_cancel(& __cancel_buf___4);
                                            while (1) {
                                              if (size > 0) {
                                                ttsockrecv(sock, body + bsiz, size);
                                              }
                                              tmp___62 = ttsockgetc(sock);
                                              if (tmp___62 != 13) {
                                                err = (_Bool)1;
                                              } else {
                                                tmp___63 = ttsockgetc(sock);
                                                if (tmp___63 != 10) {
                                                  err = (_Bool)1;
                                                }
                                              }
                                              break;
                                            }
                                            __pthread_unregister_cancel(& __cancel_buf___4);
                                            break;
                                          }
                                          if (err) {
                                            break;
                                          } else {
                                            if (size < 1) {
                                              break;
                                            }
                                          }
                                          bsiz += size;
                                        }
                                      } else {
                                        if (clen > 0) {
                                          if (clen > 268435456) {
                                            tmp___64 = tcmemdup((void const   *)"",
                                                                0U);
                                            body = (char *)tmp___64;
                                            bsiz = 0;
                                            err = (_Bool)1;
                                          } else {
                                            tmp___65 = tcmalloc((unsigned int )clen);
                                            body = (char *)tmp___65;
                                            bsiz = 0;
                                            while (1) {
                                              __cancel_routine___5 = & free;
                                              __cancel_arg___5 = (void *)body;
                                              tmp___66 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___5.__cancel_jmp_buf),
                                                                     0);
                                              not_first_call___5 = tmp___66;
                                              tmp___67 = __builtin_expect((long )not_first_call___5,
                                                                          0L);
                                              if (tmp___67) {
                                                (*__cancel_routine___5)(__cancel_arg___5);
                                                __pthread_unwind_next(& __cancel_buf___5);
                                              }
                                              __pthread_register_cancel(& __cancel_buf___5);
                                              while (1) {
                                                tmp___68 = ttsockrecv(sock, body,
                                                                      clen);
                                                if (tmp___68) {
                                                  bsiz = clen;
                                                } else {
                                                  err = (_Bool)1;
                                                }
                                                break;
                                              }
                                              __pthread_unregister_cancel(& __cancel_buf___5);
                                              break;
                                            }
                                          }
                                        } else {
                                          asiz___0 = 4096;
                                          tmp___69 = tcmalloc((unsigned int )asiz___0);
                                          body = (char *)tmp___69;
                                          bsiz = 0;
                                          while (1) {
                                            while (1) {
                                              __cancel_routine___6 = & free;
                                              __cancel_arg___6 = (void *)body;
                                              tmp___70 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___6.__cancel_jmp_buf),
                                                                     0);
                                              not_first_call___6 = tmp___70;
                                              tmp___71 = __builtin_expect((long )not_first_call___6,
                                                                          0L);
                                              if (tmp___71) {
                                                (*__cancel_routine___6)(__cancel_arg___6);
                                                __pthread_unwind_next(& __cancel_buf___6);
                                              }
                                              __pthread_register_cancel(& __cancel_buf___6);
                                              while (1) {
                                                c = ttsockgetc(sock);
                                                break;
                                              }
                                              __pthread_unregister_cancel(& __cancel_buf___6);
                                              break;
                                            }
                                            if (c == -1) {
                                              break;
                                            }
                                            if (bsiz >= 268435456) {
                                              err = (_Bool)1;
                                              break;
                                            }
                                            if (bsiz >= asiz___0) {
                                              asiz___0 = bsiz * 2;
                                              tmp___72 = tcrealloc((void *)body, (unsigned int )asiz___0);
                                              body = (char *)tmp___72;
                                            }
                                            tmp___73 = bsiz;
                                            bsiz ++;
                                            *(body + tmp___73) = (char )c;
                                          }
                                        }
                                      }
                                    }
                                    if (err) {
                                      code = -1;
                                    } else {
                                      if (resbody) {
                                        tcxstrcat(resbody, (void const   *)body, bsiz);
                                      }
                                    }
                                    tcfree((void *)body);
                                  }
                                }
                              }
                            }
                            break;
                          }
                          __pthread_unregister_cancel(& __cancel_buf___2);
                          (*__cancel_routine___2)(__cancel_arg___2);
                          break;
                        }
                        break;
                      }
                      __pthread_unregister_cancel(& __cancel_buf___1);
                      (*__cancel_routine___1)(__cancel_arg___1);
                      break;
                    }
                    break;
                  }
                  __pthread_unregister_cancel(& __cancel_buf___0);
                  (*__cancel_routine___tthttpfetch)(__cancel_arg___0);
                  break;
                }
              }
            }
          }
        }
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (code);
}
}
void ttpackdouble(double num , char *buf ) 
{ double dinteg ;
  double dfract ;
  int64_t linteg ;
  int64_t lfract ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  dfract = modf(num, & dinteg);
  if ((int )sizeof(dinteg) == (int )sizeof(float )) {
    tmp___4 = __fpclassifyf((float )dinteg);
    tmp___8 = tmp___4;
  } else {
    if ((int )sizeof(dinteg) == (int )sizeof(double )) {
      tmp___5 = __fpclassify(dinteg);
      tmp___7 = tmp___5;
    } else {
      tmp___6 = __fpclassifyl((long double )dinteg);
      tmp___7 = tmp___6;
    }
    tmp___8 = tmp___7;
  }
  if (tmp___8 == 4) {
    linteg = (long long )dinteg;
    lfract = (long long )(dfract * (double )1000000000000LL);
  } else {
    if (dinteg == (double )0) {
      linteg = (long long )dinteg;
      lfract = (long long )(dfract * (double )1000000000000LL);
    } else {
      if ((int )sizeof(dinteg) == (int )sizeof(float )) {
        tmp = __isinff((float )dinteg);
        tmp___3 = tmp;
      } else {
        if ((int )sizeof(dinteg) == (int )sizeof(double )) {
          tmp___0 = __isinf(dinteg);
          tmp___2 = tmp___0;
        } else {
          tmp___1 = __isinfl((long double )dinteg);
          tmp___2 = tmp___1;
        }
        tmp___3 = tmp___2;
      }
      if (tmp___3) {
        if (dinteg > (double )0) {
          linteg = 9223372036854775807LL;
        } else {
          linteg = (-0x7FFFFFFFFFFFFFFF-1);
        }
        lfract = 0LL;
      } else {
        linteg = (-0x7FFFFFFFFFFFFFFF-1);
        lfract = (-0x7FFFFFFFFFFFFFFF-1);
      }
    }
  }
  linteg = (long long )((((((((((unsigned long long )linteg & 255ULL) << 56) | (((unsigned long long )linteg & 65280ULL) << 40)) | (((unsigned long long )linteg & 16711680ULL) << 24)) | (((unsigned long long )linteg & 4278190080ULL) << 8)) | (((unsigned long long )linteg & 1095216660480ULL) >> 8)) | (((unsigned long long )linteg & 280375465082880ULL) >> 24)) | (((unsigned long long )linteg & 71776119061217280ULL) >> 40)) | (((unsigned long long )linteg & 0xff00000000000000ULL) >> 56));
  memcpy((void * __restrict  )buf, (void const   * __restrict  )(& linteg), (unsigned int )((int )sizeof(linteg)));
  lfract = (long long )((((((((((unsigned long long )lfract & 255ULL) << 56) | (((unsigned long long )lfract & 65280ULL) << 40)) | (((unsigned long long )lfract & 16711680ULL) << 24)) | (((unsigned long long )lfract & 4278190080ULL) << 8)) | (((unsigned long long )lfract & 1095216660480ULL) >> 8)) | (((unsigned long long )lfract & 280375465082880ULL) >> 24)) | (((unsigned long long )lfract & 71776119061217280ULL) >> 40)) | (((unsigned long long )lfract & 0xff00000000000000ULL) >> 56));
  memcpy((void * __restrict  )(buf + (int )sizeof(linteg)), (void const   * __restrict  )(& lfract),
         (unsigned int )((int )sizeof(lfract)));
  return;
}
}
double ttunpackdouble(char const   *buf ) 
{ int64_t linteg ;
  int64_t lfract ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;

  {
  memcpy((void * __restrict  )(& linteg), (void const   * __restrict  )buf, (unsigned int )((int )sizeof(linteg)));
  linteg = (long long )((((((((((unsigned long long )linteg & 255ULL) << 56) | (((unsigned long long )linteg & 65280ULL) << 40)) | (((unsigned long long )linteg & 16711680ULL) << 24)) | (((unsigned long long )linteg & 4278190080ULL) << 8)) | (((unsigned long long )linteg & 1095216660480ULL) >> 8)) | (((unsigned long long )linteg & 280375465082880ULL) >> 24)) | (((unsigned long long )linteg & 71776119061217280ULL) >> 40)) | (((unsigned long long )linteg & 0xff00000000000000ULL) >> 56));
  memcpy((void * __restrict  )(& lfract), (void const   * __restrict  )(buf + (int )sizeof(linteg)),
         (unsigned int )((int )sizeof(lfract)));
  lfract = (long long )((((((((((unsigned long long )lfract & 255ULL) << 56) | (((unsigned long long )lfract & 65280ULL) << 40)) | (((unsigned long long )lfract & 16711680ULL) << 24)) | (((unsigned long long )lfract & 4278190080ULL) << 8)) | (((unsigned long long )lfract & 1095216660480ULL) >> 8)) | (((unsigned long long )lfract & 280375465082880ULL) >> 24)) | (((unsigned long long )lfract & 71776119061217280ULL) >> 40)) | (((unsigned long long )lfract & 0xff00000000000000ULL) >> 56));
  if (lfract == (-0x7FFFFFFFFFFFFFFF-1)) {
    if (linteg == (-0x7FFFFFFFFFFFFFFF-1)) {
      tmp = __builtin_nanf("");
      return ((double )tmp);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (linteg == 9223372036854775807LL) {
      tmp___0 = __builtin_inff();
      return ((double )tmp___0);
    } else {
      if (linteg == (-0x7FFFFFFFFFFFFFFF-1)) {
        tmp___1 = __builtin_inff();
        return ((double )(- tmp___1));
      }
    }
  }
  return ((double )linteg + (double )lfract / (double )1000000000000LL);
}
}
static void *ttservtimer(void *argp ) ;
static void ttservtask(TTSOCK *sock , TTREQ *req ) ;
static void *ttservdeqtasks(void *argp ) ;
TTSERV *ttservnew(void) 
{ TTSERV *serv ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = tcmalloc((unsigned int )((int )sizeof(*serv)));
  serv = (TTSERV *)tmp;
  serv->host[0] = (char )'\000';
  serv->addr[0] = (char )'\000';
  serv->port = (unsigned short)0;
  serv->queue = tclistnew();
  tmp___0 = pthread_mutex_init(& serv->qmtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___0 != 0) {
    tcmyfatal("pthread_mutex_init failed");
  }
  tmp___1 = pthread_cond_init((pthread_cond_t * __restrict  )(& serv->qcnd), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (tmp___1 != 0) {
    tcmyfatal("pthread_cond_init failed");
  }
  tmp___2 = pthread_mutex_init(& serv->tmtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___2 != 0) {
    tcmyfatal("pthread_mutex_init failed");
  }
  tmp___3 = pthread_cond_init((pthread_cond_t * __restrict  )(& serv->tcnd), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (tmp___3 != 0) {
    tcmyfatal("pthread_cond_init failed");
  }
  serv->thnum = 5;
  serv->timeout = (double )0;
  serv->term = (_Bool)0;
  serv->do_log = (void (*)(int  , char const   * , void * ))((void *)0);
  serv->opq_log = (void *)0;
  serv->timernum = 0;
  serv->do_task = (void (*)(TTSOCK * , void * , TTREQ * ))((void *)0);
  serv->opq_task = (void *)0;
  serv->do_term = (void (*)(void * ))((void *)0);
  serv->opq_term = (void *)0;
  return (serv);
}
}
void ttservdel(TTSERV *serv ) 
{ 

  {
  pthread_cond_destroy(& serv->tcnd);
  pthread_mutex_destroy(& serv->tmtx);
  pthread_cond_destroy(& serv->qcnd);
  pthread_mutex_destroy(& serv->qmtx);
  tclistdel(serv->queue);
  tcfree((void *)serv);
  return;
}
}
_Bool ttservconf(TTSERV *serv , char const   *host , int port ) 
{ _Bool err ;
  _Bool tmp ;
  char const   *tmp___0 ;

  {
  err = (_Bool)0;
  if (port < 1) {
    if (! host) {
      err = (_Bool)1;
      serv->addr[0] = (char )'\000';
      ttservlog(serv, 2, "invalid socket path");
    } else {
      if ((int const   )*(host + 0) == 0) {
        err = (_Bool)1;
        serv->addr[0] = (char )'\000';
        ttservlog(serv, 2, "invalid socket path");
      }
    }
  } else {
    if (host) {
      tmp = ttgethostaddr(host, serv->addr);
      if (! tmp) {
        err = (_Bool)1;
        serv->addr[0] = (char )'\000';
        ttservlog(serv, 2, "ttgethostaddr failed");
      }
    }
  }
  if (host) {
    tmp___0 = host;
  } else {
    tmp___0 = "";
  }
  snprintf((char * __restrict  )(serv->host), (unsigned int )((int )sizeof(serv->host)),
           (char const   * __restrict  )"%s", tmp___0);
  serv->port = (unsigned short )port;
  return ((_Bool )(! err));
}
}
void ttservtune(TTSERV *serv , int thnum , double timeout ) 
{ 

  {
  serv->thnum = thnum;
  serv->timeout = timeout;
  return;
}
}
void ttservsetloghandler(TTSERV *serv , void (*do_log___0)(int  , char const   * ,
                                                           void * ) , void *opq ) 
{ 

  {
  serv->do_log = do_log___0;
  serv->opq_log = opq;
  return;
}
}
void ttservaddtimedhandler(TTSERV *serv , double freq , void (*do_timed)(void * ) ,
                           void *opq ) 
{ TTTIMER *timer ;

  {
  if (serv->timernum >= 7) {
    return;
  }
  timer = serv->timers + serv->timernum;
  timer->freq_timed = freq;
  timer->do_timed = do_timed;
  timer->opq_timed = opq;
  (serv->timernum) ++;
  return;
}
}
void ttservsettaskhandler(TTSERV *serv , void (*do_task___0)(TTSOCK * , void * , TTREQ * ) ,
                          void *opq ) 
{ 

  {
  serv->do_task = do_task___0;
  serv->opq_task = opq;
  return;
}
}
void ttservsettermhandler(TTSERV *serv , void (*do_term___0)(void * ) , void *opq ) 
{ 

  {
  serv->do_term = do_term___0;
  serv->opq_term = opq;
  return;
}
}
_Bool ttservstart(TTSERV *serv ) 
{ int lfd ;
  char *tmp ;
  int epfd ;
  int tmp___0 ;
  __pid_t tmp___1 ;
  _Bool err ;
  int i ;
  TTTIMER *timer ;
  int tmp___2 ;
  int thnum ;
  TTREQ *reqs ;
  unsigned int __lengthofreqs ;
  void *tmp___3 ;
  int i___0 ;
  int tmp___4 ;
  struct epoll_event ev ;
  int tmp___5 ;
  struct epoll_event events[256] ;
  int fdnum ;
  int tmp___6 ;
  int i___1 ;
  char addr[1024] ;
  int port ;
  int cfd ;
  struct epoll_event ev___0 ;
  int tmp___7 ;
  int cfd___0 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  double ctime___0 ;
  double tmp___12 ;
  int i___2 ;
  double itime ;
  void *rv ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int i___3 ;
  int tmp___18 ;
  void *rv___0 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int i___4 ;
  TTTIMER *timer___0 ;
  void *rv___1 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;

  {
  if ((int )serv->port < 1) {
    lfd = ttopenservsockunix((char const   *)(serv->host));
    if (lfd == -1) {
      ttservlog(serv, 2, "ttopenservsockunix failed");
      return ((_Bool)0);
    }
  } else {
    if ((int )serv->addr[0] != 0) {
      tmp = serv->addr;
    } else {
      tmp = (char *)((void *)0);
    }
    lfd = ttopenservsock((char const   *)tmp, (int )serv->port);
    if (lfd == -1) {
      ttservlog(serv, 2, "ttopenservsock failed");
      return ((_Bool)0);
    }
  }
  tmp___0 = epoll_create(256);
  epfd = tmp___0;
  if (epfd == -1) {
    close(lfd);
    ttservlog(serv, 2, "epoll_create failed");
    return ((_Bool)0);
  }
  tmp___1 = getpid();
  ttservlog(serv, 3, "service started: %d", tmp___1);
  err = (_Bool)0;
  i = 0;
  while (i < serv->timernum) {
    timer = serv->timers + i;
    timer->alive = (_Bool)0;
    timer->serv = serv;
    tmp___2 = pthread_create((pthread_t * __restrict  )(& timer->thid), (pthread_attr_t const   * __restrict  )((void *)0),
                             & ttservtimer, (void * __restrict  )timer);
    if (tmp___2 == 0) {
      ttservlog(serv, 1, "timer thread %d started", i + 1);
      timer->alive = (_Bool)1;
    } else {
      ttservlog(serv, 2, "pthread_create (ttservtimer) failed");
      err = (_Bool)1;
    }
    i ++;
  }
  thnum = serv->thnum;
  __lengthofreqs = (unsigned int )thnum;
  tmp___3 = __builtin_alloca(sizeof(*reqs) * __lengthofreqs);
  reqs = (TTREQ *)tmp___3;
  i___0 = 0;
  while (i___0 < thnum) {
    (reqs + i___0)->alive = (_Bool)1;
    (reqs + i___0)->serv = serv;
    (reqs + i___0)->epfd = epfd;
    (reqs + i___0)->mtime = tctime();
    (reqs + i___0)->keep = (_Bool)0;
    (reqs + i___0)->idx = i___0;
    tmp___4 = pthread_create((pthread_t * __restrict  )(& (reqs + i___0)->thid), (pthread_attr_t const   * __restrict  )((void *)0),
                             & ttservdeqtasks, (void * __restrict  )(reqs + i___0));
    if (tmp___4 == 0) {
      ttservlog(serv, 1, "worker thread %d started", i___0 + 1);
    } else {
      (reqs + i___0)->alive = (_Bool)0;
      err = (_Bool)1;
      ttservlog(serv, 2, "pthread_create (ttservdeqtasks) failed");
    }
    i___0 ++;
  }
  memset((void *)(& ev), 0, (unsigned int )((int )sizeof(ev)));
  ev.events = 1U;
  ev.data.fd = lfd;
  tmp___5 = epoll_ctl(epfd, 1, lfd, & ev);
  if (tmp___5 != 0) {
    err = (_Bool)1;
    ttservlog(serv, 2, "epoll_ctl failed");
  }
  ttservlog(serv, 3, "listening started");
  while (! serv->term) {
    tmp___6 = epoll_wait(epfd, events, 256, (int )(0.2 * (double )1000));
    fdnum = tmp___6;
    if (fdnum != -1) {
      i___1 = 0;
      while (i___1 < fdnum) {
        if (events[i___1].data.fd == lfd) {
          if ((int )serv->port < 1) {
            cfd = ttacceptsockunix(lfd);
            sprintf((char * __restrict  )(addr), (char const   * __restrict  )"(unix)");
            port = 0;
          } else {
            cfd = ttacceptsock(lfd, addr, & port);
          }
          if (cfd != -1) {
            ttservlog(serv, 1, "connected: %s:%d", addr, port);
            memset((void *)(& ev___0), 0, (unsigned int )((int )sizeof(ev___0)));
            ev___0.events = 1073741825U;
            ev___0.data.fd = cfd;
            tmp___7 = epoll_ctl(epfd, 1, cfd, & ev___0);
            if (tmp___7 != 0) {
              close(cfd);
              err = (_Bool)1;
              ttservlog(serv, 2, "epoll_ctl failed");
            }
          } else {
            err = (_Bool)1;
            ttservlog(serv, 2, "ttacceptsock failed");
          }
        } else {
          cfd___0 = events[i___1].data.fd;
          tmp___10 = pthread_mutex_lock(& serv->qmtx);
          if (tmp___10 == 0) {
            tclistpush(serv->queue, (void const   *)(& cfd___0), (int )sizeof(cfd___0));
            tmp___8 = pthread_mutex_unlock(& serv->qmtx);
            if (tmp___8 != 0) {
              err = (_Bool)1;
              ttservlog(serv, 2, "pthread_mutex_unlock failed");
            }
            tmp___9 = pthread_cond_signal(& serv->qcnd);
            if (tmp___9 != 0) {
              err = (_Bool)1;
              ttservlog(serv, 2, "pthread_cond_signal failed");
            }
          } else {
            err = (_Bool)1;
            ttservlog(serv, 2, "pthread_mutex_lock failed");
          }
        }
        i___1 ++;
      }
    } else {
      tmp___11 = __errno_location();
      if (*tmp___11 == 4) {
        ttservlog(serv, 1, "signal interruption");
      } else {
        err = (_Bool)1;
        ttservlog(serv, 2, "epoll_wait failed");
      }
    }
    if (serv->timeout > (double )0) {
      tmp___12 = tctime();
      ctime___0 = tmp___12;
      i___2 = 0;
      while (i___2 < thnum) {
        itime = ctime___0 - (reqs + i___2)->mtime;
        if (itime > ((serv->timeout + 0.2) + 0.25) + 0.25) {
          tmp___15 = pthread_cancel((reqs + i___2)->thid);
          if (tmp___15 == 0) {
            ttservlog(serv, 1, "worker thread %d canceled by timeout", i___2 + 1);
            tmp___14 = pthread_join((reqs + i___2)->thid, & rv);
            if (tmp___14 == 0) {
              if (rv) {
                if ((unsigned int )rv != (unsigned int )((void *)-1)) {
                  err = (_Bool)1;
                }
              }
              (reqs + i___2)->mtime = tctime();
              tmp___13 = pthread_create((pthread_t * __restrict  )(& (reqs + i___2)->thid),
                                        (pthread_attr_t const   * __restrict  )((void *)0),
                                        & ttservdeqtasks, (void * __restrict  )(reqs + i___2));
              if (tmp___13 != 0) {
                (reqs + i___2)->alive = (_Bool)0;
                err = (_Bool)1;
                ttservlog(serv, 2, "pthread_create (ttservdeqtasks) failed");
              } else {
                ttservlog(serv, 1, "worker thread %d started", i___2 + 1);
              }
            } else {
              (reqs + i___2)->alive = (_Bool)0;
              err = (_Bool)1;
              ttservlog(serv, 2, "pthread_join failed");
            }
          }
        }
        i___2 ++;
      }
    }
  }
  ttservlog(serv, 3, "listening finished");
  tmp___16 = pthread_cond_broadcast(& serv->qcnd);
  if (tmp___16 != 0) {
    err = (_Bool)1;
    ttservlog(serv, 2, "pthread_cond_broadcast failed");
  }
  tmp___17 = pthread_cond_broadcast(& serv->tcnd);
  if (tmp___17 != 0) {
    err = (_Bool)1;
    ttservlog(serv, 2, "pthread_cond_broadcast failed");
  }
  tcsleep(0.1);
  if (serv->do_term) {
    (*(serv->do_term))(serv->opq_term);
  }
  i___3 = 0;
  while (i___3 < thnum) {
    if (! (reqs + i___3)->alive) {
      goto __Cont;
    }
    tmp___18 = pthread_cancel((reqs + i___3)->thid);
    if (tmp___18 == 0) {
      ttservlog(serv, 1, "worker thread %d was canceled", i___3 + 1);
    }
    tmp___19 = pthread_join((reqs + i___3)->thid, & rv___0);
    if (tmp___19 == 0) {
      ttservlog(serv, 1, "worker thread %d finished", i___3 + 1);
      if (rv___0) {
        if ((unsigned int )rv___0 != (unsigned int )((void *)-1)) {
          err = (_Bool)1;
        }
      }
    } else {
      err = (_Bool)1;
      ttservlog(serv, 2, "pthread_join failed");
    }
    __Cont: 
    i___3 ++;
  }
  tmp___21 = tclistnum((TCLIST const   *)serv->queue);
  if (tmp___21 > 0) {
    tmp___20 = tclistnum((TCLIST const   *)serv->queue);
    ttservlog(serv, 1, "%d requests discarded", tmp___20);
  }
  tclistclear(serv->queue);
  i___4 = 0;
  while (i___4 < serv->timernum) {
    timer___0 = serv->timers + i___4;
    if (! timer___0->alive) {
      goto __Cont___0;
    }
    tmp___22 = pthread_cancel(timer___0->thid);
    if (tmp___22 == 0) {
      ttservlog(serv, 1, "timer thread %d was canceled", i___4 + 1);
    }
    tmp___23 = pthread_join(timer___0->thid, & rv___1);
    if (tmp___23 == 0) {
      ttservlog(serv, 1, "timer thread %d finished", i___4 + 1);
      if (rv___1) {
        if ((unsigned int )rv___1 != (unsigned int )((void *)-1)) {
          err = (_Bool)1;
        }
      }
    } else {
      err = (_Bool)1;
      ttservlog(serv, 2, "pthread_join failed");
    }
    __Cont___0: 
    i___4 ++;
  }
  tmp___24 = close(epfd);
  if (tmp___24 != 0) {
    err = (_Bool)1;
    ttservlog(serv, 2, "epoll_close failed");
  }
  if ((int )serv->port < 1) {
    tmp___25 = unlink((char const   *)(serv->host));
    if (tmp___25 == -1) {
      err = (_Bool)1;
      ttservlog(serv, 2, "unlink failed");
    }
  }
  tmp___26 = close(lfd);
  if (tmp___26 != 0) {
    err = (_Bool)1;
    ttservlog(serv, 2, "close failed");
  }
  ttservlog(serv, 3, "service finished");
  serv->term = (_Bool)0;
  return ((_Bool )(! err));
}
}
_Bool ttservkill(TTSERV *serv ) 
{ 

  {
  serv->term = (_Bool)1;
  return ((_Bool)1);
}
}
void ttservlog(TTSERV *serv , int level , char const   *format  , ...) 
{ char buf[65536] ;
  va_list ap ;

  {
  if (! serv->do_log) {
    return;
  }
  __builtin_va_start(ap, format);
  vsnprintf((char * __restrict  )(buf), 65536U, (char const   * __restrict  )format,
            ap);
  __builtin_va_end(ap);
  (*(serv->do_log))(level, (char const   *)(buf), serv->opq_log);
  return;
}
}
_Bool ttserviskilled(TTSERV *serv ) 
{ 

  {
  return (serv->term);
}
}
char *ttbreakservexpr(char const   *expr , int *pp ) 
{ char *host ;
  char *tmp ;
  char *pv ;
  char *tmp___1 ;
  int port ;
  char *tmp___3 ;
  char *tmp___4 ;
  int64_t tmp___5 ;

  {
  tmp = tcstrdup((void const   *)expr);
  host = tmp;
  tmp___1 = __builtin_strchr(host, '#');
  pv = tmp___1;
  if (pv) {
    *pv = (char )'\000';
  }
  port = -1;
  tmp___3 = __builtin_strchr(host, ':');
  pv = tmp___3;
  if (pv) {
    tmp___4 = pv;
    pv ++;
    *tmp___4 = (char )'\000';
    if ((int )*pv >= 48) {
      if ((int )*pv <= 57) {
        tmp___5 = tcatoi((char const   *)pv);
        port = (int )tmp___5;
      }
    }
  }
  if (port < 0) {
    port = 1978;
  }
  if (pp) {
    *pp = port;
  }
  tcstrtrim(host);
  if ((int )*host == 0) {
    tcfree((void *)host);
    host = tcstrdup((void const   *)"127.0.0.1");
  }
  return (host);
}
}
static void *ttservtimer(void *argp ) 
{ TTTIMER *timer ;
  TTSERV *serv ;
  _Bool err ;
  int tmp ;
  double freqi ;
  double freqd ;
  double tmp___0 ;
  struct timeval tv ;
  struct timespec ts ;
  int tmp___1 ;
  int code ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;

  {
  timer = (TTTIMER *)argp;
  serv = timer->serv;
  err = (_Bool)0;
  tmp = pthread_setcancelstate(1, (int *)((void *)0));
  if (tmp != 0) {
    err = (_Bool)1;
    ttservlog(serv, 2, "pthread_setcancelstate failed");
  }
  tcsleep(0.1);
  tmp___0 = modf(timer->freq_timed, & freqi);
  freqd = tmp___0;
  while (! serv->term) {
    tmp___4 = pthread_mutex_lock(& serv->tmtx);
    if (tmp___4 == 0) {
      tmp___1 = gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
      if (tmp___1 == 0) {
        ts.tv_sec = tv.tv_sec + (long )((int )freqi);
        ts.tv_nsec = (long )((double )tv.tv_usec * 1000.0 + freqd * 1000000000.0);
        if (ts.tv_nsec >= 1000000000L) {
          ts.tv_nsec -= 1000000000L;
          (ts.tv_sec) ++;
        }
      } else {
        ts.tv_sec = (long )((1ULL << ((int )sizeof(time_t ) * 8 - 1)) - 1ULL);
        ts.tv_nsec = 0L;
      }
      tmp___2 = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& serv->tcnd),
                                       (pthread_mutex_t * __restrict  )(& serv->tmtx),
                                       (struct timespec  const  * __restrict  )(& ts));
      code = tmp___2;
      if (code == 0) {
        goto _L;
      } else {
        if (code == 110) {
          goto _L;
        } else {
          if (code == 4) {
            _L: 
            tmp___3 = pthread_mutex_unlock(& serv->tmtx);
            if (tmp___3 != 0) {
              err = (_Bool)1;
              ttservlog(serv, 2, "pthread_mutex_unlock failed");
              break;
            }
            if (code != 0) {
              if (! serv->term) {
                (*(timer->do_timed))(timer->opq_timed);
              }
            }
          } else {
            pthread_mutex_unlock(& serv->tmtx);
            err = (_Bool)1;
            ttservlog(serv, 2, "pthread_cond_timedwait failed");
          }
        }
      }
    } else {
      err = (_Bool)1;
      ttservlog(serv, 2, "pthread_mutex_lock failed");
    }
  }
  if (err) {
    tmp___5 = "error";
  } else {
    tmp___5 = (char const   *)((void *)0);
  }
  return ((void *)tmp___5);
}
}
static void ttservtask(TTSOCK *sock , TTREQ *req ) 
{ TTSERV *serv ;

  {
  serv = req->serv;
  if (! serv->do_task) {
    return;
  }
  (*(serv->do_task))(sock, serv->opq_task, req);
  return;
}
}
static void *ttservdeqtasks(void *argp ) 
{ TTREQ *req ;
  TTSERV *serv ;
  _Bool err ;
  int tmp ;
  sigset_t sigset___0 ;
  sigset_t oldsigset ;
  int tmp___0 ;
  _Bool empty ;
  struct timeval tv ;
  struct timespec ts ;
  int tmp___1 ;
  int code ;
  int tmp___2 ;
  int tmp___3 ;
  void *val ;
  char *tmp___4 ;
  int tmp___5 ;
  int cfd ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___6 ;
  long tmp___7 ;
  TTSOCK *sock ;
  TTSOCK *tmp___8 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___ttservdeqtasks)(void * ) ;
  void *__cancel_arg___0 ;
  int not_first_call___0 ;
  int tmp___9 ;
  long tmp___10 ;
  _Bool reuse ;
  struct epoll_event ev ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char const   *tmp___16 ;

  {
  req = (TTREQ *)argp;
  serv = req->serv;
  err = (_Bool)0;
  tmp = pthread_setcancelstate(1, (int *)((void *)0));
  if (tmp != 0) {
    err = (_Bool)1;
    ttservlog(serv, 2, "pthread_setcancelstate failed");
  }
  sigemptyset(& sigset___0);
  sigaddset(& sigset___0, 13);
  sigemptyset(& sigset___0);
  tmp___0 = pthread_sigmask(0, (__sigset_t const   * __restrict  )(& sigset___0),
                            (__sigset_t * __restrict  )(& oldsigset));
  if (tmp___0 != 0) {
    err = (_Bool)1;
    ttservlog(serv, 2, "pthread_sigmask failed");
  }
  empty = (_Bool)0;
  while (! serv->term) {
    tmp___14 = pthread_mutex_lock(& serv->qmtx);
    if (tmp___14 == 0) {
      tmp___1 = gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
      if (tmp___1 == 0) {
        ts.tv_sec = tv.tv_sec;
        ts.tv_nsec = (long )((double )tv.tv_usec * 1000.0 + 0.2 * 1000000000.0);
        if (ts.tv_nsec >= 1000000000L) {
          ts.tv_nsec -= 1000000000L;
          (ts.tv_sec) ++;
        }
      } else {
        ts.tv_sec = (long )((1ULL << ((int )sizeof(time_t ) * 8 - 1)) - 1ULL);
        ts.tv_nsec = 0L;
      }
      if (empty) {
        tmp___2 = pthread_cond_timedwait((pthread_cond_t * __restrict  )(& serv->qcnd),
                                         (pthread_mutex_t * __restrict  )(& serv->qmtx),
                                         (struct timespec  const  * __restrict  )(& ts));
        tmp___3 = tmp___2;
      } else {
        tmp___3 = 0;
      }
      code = tmp___3;
      if (code == 0) {
        goto _L;
      } else {
        if (code == 110) {
          goto _L;
        } else {
          if (code == 4) {
            _L: 
            tmp___4 = tclistshift2(serv->queue);
            val = (void *)tmp___4;
            tmp___5 = pthread_mutex_unlock(& serv->qmtx);
            if (tmp___5 != 0) {
              err = (_Bool)1;
              ttservlog(serv, 2, "pthread_mutex_unlock failed");
            }
            if (val) {
              empty = (_Bool)0;
              cfd = *((int *)val);
              tcfree(val);
              while (1) {
                __cancel_routine = (void (*)(void * ))(& close);
                __cancel_arg = (void *)cfd;
                tmp___6 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                                      0);
                not_first_call = tmp___6;
                tmp___7 = __builtin_expect((long )not_first_call, 0L);
                if (tmp___7) {
                  (*__cancel_routine)(__cancel_arg);
                  __pthread_unwind_next(& __cancel_buf);
                }
                __pthread_register_cancel(& __cancel_buf);
                while (1) {
                  tmp___8 = ttsocknew(cfd);
                  sock = tmp___8;
                  while (1) {
                    __cancel_routine___ttservdeqtasks = (void (*)(void * ))(& ttsockdel);
                    __cancel_arg___0 = (void *)sock;
                    tmp___9 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                                          0);
                    not_first_call___0 = tmp___9;
                    tmp___10 = __builtin_expect((long )not_first_call___0, 0L);
                    if (tmp___10) {
                      (*__cancel_routine___ttservdeqtasks)(__cancel_arg___0);
                      __pthread_unwind_next(& __cancel_buf___0);
                    }
                    __pthread_register_cancel(& __cancel_buf___0);
                    while (1) {
                      while (1) {
                        if (serv->timeout > (double )0) {
                          ttsocksetlife(sock, serv->timeout);
                        }
                        req->mtime = tctime();
                        req->keep = (_Bool)0;
                        ttservtask(sock, req);
                        reuse = (_Bool)0;
                        if (sock->end) {
                          req->keep = (_Bool)0;
                        } else {
                          if ((unsigned int )sock->ep > (unsigned int )sock->rp) {
                            reuse = (_Bool)1;
                          }
                        }
                        if (! reuse) {
                          break;
                        }
                      }
                      break;
                    }
                    __pthread_unregister_cancel(& __cancel_buf___0);
                    (*__cancel_routine___ttservdeqtasks)(__cancel_arg___0);
                    break;
                  }
                  break;
                }
                __pthread_unregister_cancel(& __cancel_buf);
                break;
              }
              if (req->keep) {
                memset((void *)(& ev), 0, (unsigned int )((int )sizeof(ev)));
                ev.events = 1073741825U;
                ev.data.fd = cfd;
                tmp___11 = epoll_ctl(req->epfd, 3, cfd, & ev);
                if (tmp___11 != 0) {
                  close(cfd);
                  err = (_Bool)1;
                  ttservlog(serv, 2, "epoll_ctl failed");
                }
              } else {
                tmp___12 = epoll_ctl(req->epfd, 2, cfd, (struct epoll_event *)((void *)0));
                if (tmp___12 != 0) {
                  err = (_Bool)1;
                  ttservlog(serv, 2, "epoll_ctl failed");
                }
                tmp___13 = ttclosesock(cfd);
                if (! tmp___13) {
                  err = (_Bool)1;
                  ttservlog(serv, 2, "close failed");
                }
                ttservlog(serv, 1, "connection finished");
              }
            } else {
              empty = (_Bool)1;
            }
          } else {
            pthread_mutex_unlock(& serv->qmtx);
            err = (_Bool)1;
            ttservlog(serv, 2, "pthread_cond_timedwait failed");
          }
        }
      }
    } else {
      err = (_Bool)1;
      ttservlog(serv, 2, "pthread_mutex_lock failed");
    }
    pthread_setcancelstate(0, (int *)((void *)0));
    pthread_testcancel();
    pthread_setcancelstate(1, (int *)((void *)0));
    req->mtime = tctime();
  }
  tmp___15 = pthread_sigmask(2, (__sigset_t const   * __restrict  )(& oldsigset),
                             (__sigset_t * __restrict  )((void *)0));
  if (tmp___15 != 0) {
    err = (_Bool)1;
    ttservlog(serv, 2, "pthread_sigmask failed");
  }
  if (err) {
    tmp___16 = "error";
  } else {
    tmp___16 = (char const   *)((void *)0);
  }
  return ((void *)tmp___16);
}
}
_Bool ttdaemonize(void) 
{ __pid_t tmp ;
  __pid_t tmp___0 ;
  __pid_t tmp___1 ;
  int tmp___2 ;
  int fd ;
  int tmp___3 ;

  {
  fflush(stdout);
  fflush(stderr);
  tmp = fork();
  switch (tmp) {
  case -1: 
  return ((_Bool)0);
  case 0: 
  break;
  default: 
  _exit(0);
  }
  tmp___0 = setsid();
  if (tmp___0 == -1) {
    return ((_Bool)0);
  }
  tmp___1 = fork();
  switch (tmp___1) {
  case -1: 
  return ((_Bool)0);
  case 0: 
  break;
  default: 
  _exit(0);
  }
  umask(0U);
  tmp___2 = chdir("/");
  if (tmp___2 == -1) {
    return ((_Bool)0);
  }
  close(0);
  close(1);
  close(2);
  tmp___3 = open("/dev/null", 2, 0);
  fd = tmp___3;
  if (fd != -1) {
    dup2(fd, 0);
    dup2(fd, 1);
    dup2(fd, 2);
    if (fd > 2) {
      close(fd);
    }
  }
  return ((_Bool)1);
}
}
double ttgetloadavg(void) 
{ double avgs[3] ;
  int anum ;
  int tmp ;
  double tmp___0 ;

  {
  tmp = getloadavg(avgs, (int )sizeof(avgs) / (int )sizeof(avgs[0]));
  anum = tmp;
  if (anum < 1) {
    return (0.0);
  }
  if (anum == 1) {
    tmp___0 = avgs[0];
  } else {
    tmp___0 = avgs[1];
  }
  return (tmp___0);
}
}
uint64_t ttstrtots(char const   *str ) 
{ int tmp ;
  int64_t ts ;
  int64_t tmp___0 ;
  double tmp___1 ;

  {
  tmp = tcstricmp(str, "now");
  if (! tmp) {
    str = "-1";
  }
  tmp___0 = tcatoi(str);
  ts = tmp___0;
  if (ts < 0LL) {
    tmp___1 = tctime();
    ts = (long long )(tmp___1 * (double )1000000);
  }
  return ((unsigned long long )ts);
}
}
char const   *ttcmdidtostr(int id ) 
{ 

  {
  switch (id) {
  case 16: 
  return ("put");
  case 17: 
  return ("putkeep");
  case 18: 
  return ("putcat");
  case 19: 
  return ("putshl");
  case 24: 
  return ("putnr");
  case 32: 
  return ("out");
  case 48: 
  return ("get");
  case 49: 
  return ("mget");
  case 56: 
  return ("vsiz");
  case 80: 
  return ("iterinit");
  case 81: 
  return ("iternext");
  case 88: 
  return ("fwmkeys");
  case 96: 
  return ("addint");
  case 97: 
  return ("adddouble");
  case 104: 
  return ("ext");
  case 112: 
  return ("sync");
  case 113: 
  return ("optimize");
  case 114: 
  return ("vanish");
  case 115: 
  return ("copy");
  case 116: 
  return ("restore");
  case 120: 
  return ("setmst");
  case 128: 
  return ("rnum");
  case 129: 
  return ("size");
  case 136: 
  return ("stat");
  case 144: 
  return ("misc");
  case 160: 
  return ("repl");
  }
  return ("(unknown)");
}
}
#pragma merger(0,"/tmp/cil-SlmFiIYf.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
int tculogrmtxidx(TCULOG *ulog , char const   *kbuf , int ksiz ) ;
_Bool tculogbegin(TCULOG *ulog , int idx ) ;
_Bool tculogend(TCULOG *ulog , int idx ) ;
_Bool tculogwrite(TCULOG *ulog , uint64_t ts , uint32_t sid , uint32_t mid , void const   *ptr ,
                  int size ) ;
extern  __attribute__((__nothrow__)) int aio_write(struct aiocb *__aiocbp )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) int aio_error(struct aiocb  const  *__aiocbp )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) __ssize_t aio_return(struct aiocb *__aiocbp )  __attribute__((__nonnull__(1))) ;
extern int aio_suspend(struct aiocb  const  * const  *__list , int __nent , struct timespec  const  * __restrict  __timeout )  __attribute__((__nonnull__(1))) ;
static _Bool tculogflushaiocbp(struct aiocb *aiocbp ) ;
TCULOG *tculognew(void) 
{ TCULOG *ulog ;
  void *tmp ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  tmp = tcmalloc((unsigned int )((int )sizeof(*ulog)));
  ulog = (TCULOG *)tmp;
  i = 0;
  while (i < 31) {
    tmp___0 = pthread_mutex_init(ulog->rmtxs + i, (pthread_mutexattr_t const   *)((void *)0));
    if (tmp___0 != 0) {
      tcmyfatal("pthread_mutex_init failed");
    }
    i ++;
  }
  tmp___1 = pthread_rwlock_init((pthread_rwlock_t * __restrict  )(& ulog->rwlck),
                                (pthread_rwlockattr_t const   * __restrict  )((void *)0));
  if (tmp___1 != 0) {
    tcmyfatal("pthread_rwlock_init failed");
  }
  tmp___2 = pthread_cond_init((pthread_cond_t * __restrict  )(& ulog->cnd), (pthread_condattr_t const   * __restrict  )((void *)0));
  if (tmp___2 != 0) {
    tcmyfatal("pthread_cond_init failed");
  }
  tmp___3 = pthread_mutex_init(& ulog->wmtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___3 != 0) {
    tcmyfatal("pthread_mutex_init failed");
  }
  ulog->base = (char *)((void *)0);
  ulog->limsiz = 0ULL;
  ulog->max = 0;
  ulog->fd = -1;
  ulog->size = 0ULL;
  ulog->aiocbs = (void *)0;
  ulog->aiocbi = 0;
  ulog->aioend = 0ULL;
  return (ulog);
}
}
void tculogdel(TCULOG *ulog ) 
{ int i ;

  {
  if (ulog->base) {
    tculogclose(ulog);
  }
  if (ulog->aiocbs) {
    tcfree(ulog->aiocbs);
  }
  pthread_mutex_destroy(& ulog->wmtx);
  pthread_cond_destroy(& ulog->cnd);
  pthread_rwlock_destroy(& ulog->rwlck);
  i = 30;
  while (i >= 0) {
    pthread_mutex_destroy(ulog->rmtxs + i);
    i --;
  }
  tcfree((void *)ulog);
  return;
}
}
_Bool tculogsetaio(TCULOG *ulog ) 
{ struct aiocb *aiocbs ;
  void *tmp ;
  int i ;

  {
  if (ulog->base) {
    return ((_Bool)0);
  } else {
    if (ulog->aiocbs) {
      return ((_Bool)0);
    }
  }
  tmp = tcmalloc((unsigned int )((int )sizeof(*aiocbs) * 64));
  aiocbs = (struct aiocb *)tmp;
  i = 0;
  while (i < 64) {
    memset((void *)(aiocbs + i), 0, (unsigned int )((int )sizeof(*aiocbs)));
    i ++;
  }
  ulog->aiocbs = (void *)aiocbs;
  return ((_Bool)1);
}
}
_Bool tculogopen(TCULOG *ulog , char const   *base , uint64_t limsiz ) 
{ struct stat sbuf ;
  int tmp ;
  TCLIST *names ;
  TCLIST *tmp___0 ;
  int ln ;
  int tmp___1 ;
  int max ;
  int i ;
  char const   *name ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;
  int id ;
  int64_t tmp___4 ;
  char *path ;
  char *tmp___5 ;
  int tmp___6 ;
  struct aiocb *aiocbs ;
  int i___0 ;
  struct aiocb *aiocbp ;

  {
  if (ulog->base) {
    return ((_Bool)0);
  }
  tmp = stat((char const   * __restrict  )base, (struct stat * __restrict  )(& sbuf));
  if (tmp == -1) {
    return ((_Bool)0);
  } else {
    if (! ((sbuf.st_mode & 61440U) == 16384U)) {
      return ((_Bool)0);
    }
  }
  tmp___0 = tcreaddir(base);
  names = tmp___0;
  if (! names) {
    return ((_Bool)0);
  }
  tmp___1 = tclistnum((TCLIST const   *)names);
  ln = tmp___1;
  max = 0;
  i = 0;
  while (i < ln) {
    tmp___2 = tclistval2((TCLIST const   *)names, i);
    name = tmp___2;
    tmp___3 = tcstrbwm(name, ".ulog");
    if (! tmp___3) {
      goto __Cont;
    }
    tmp___4 = tcatoi(name);
    id = (int )tmp___4;
    tmp___5 = tcsprintf("%s/%08d%s", base, id, ".ulog");
    path = tmp___5;
    tmp___6 = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
    if (tmp___6 == 0) {
      if ((sbuf.st_mode & 61440U) == 32768U) {
        if (id > max) {
          max = id;
        }
      }
    }
    tcfree((void *)path);
    __Cont: 
    i ++;
  }
  tclistdel(names);
  if (max < 1) {
    max = 1;
  }
  ulog->base = tcstrdup((void const   *)base);
  if (limsiz > 0ULL) {
    ulog->limsiz = limsiz;
  } else {
    ulog->limsiz = 4611686018427387903ULL;
  }
  ulog->max = max;
  ulog->fd = -1;
  ulog->size = (unsigned long long )sbuf.st_size;
  aiocbs = (struct aiocb *)ulog->aiocbs;
  if (aiocbs) {
    i___0 = 0;
    while (i___0 < 64) {
      aiocbp = aiocbs + i___0;
      aiocbp->aio_fildes = 0;
      aiocbp->aio_buf = (void volatile   *)((void *)0);
      aiocbp->aio_nbytes = 0U;
      i___0 ++;
    }
  }
  ulog->aiocbi = 0;
  ulog->aioend = 0ULL;
  return ((_Bool)1);
}
}
_Bool tculogclose(TCULOG *ulog ) 
{ _Bool err ;
  struct aiocb *aiocbs ;
  int i ;
  _Bool tmp ;
  int tmp___0 ;

  {
  if (! ulog->base) {
    return ((_Bool)0);
  }
  err = (_Bool)0;
  aiocbs = (struct aiocb *)ulog->aiocbs;
  if (aiocbs) {
    i = 0;
    while (i < 64) {
      tmp = tculogflushaiocbp(aiocbs + i);
      if (! tmp) {
        err = (_Bool)1;
      }
      i ++;
    }
  }
  if (ulog->fd != -1) {
    tmp___0 = close(ulog->fd);
    if (tmp___0 != 0) {
      err = (_Bool)1;
    }
  }
  tcfree((void *)ulog->base);
  ulog->base = (char *)((void *)0);
  return ((_Bool )(! err));
}
}
int tculogrmtxidx(TCULOG *ulog , char const   *kbuf , int ksiz ) 
{ uint32_t hash ;
  char const   *tmp ;
  int tmp___0 ;

  {
  if (! ulog->base) {
    return (0);
  } else {
    if (! ulog->aiocbs) {
      return (0);
    }
  }
  hash = 19780211U;
  while (1) {
    tmp___0 = ksiz;
    ksiz --;
    if (! tmp___0) {
      break;
    }
    tmp = kbuf;
    kbuf ++;
    hash = hash * 41U + (unsigned int )*((uint8_t *)tmp);
  }
  return ((int )(hash % 31U));
}
}
_Bool tculogbegin(TCULOG *ulog , int idx ) 
{ int i ;
  int tmp ;
  int tmp___0 ;

  {
  if (! ulog->base) {
    return ((_Bool)0);
  }
  if (idx < 0) {
    i = 0;
    while (i < 31) {
      tmp = pthread_mutex_lock(ulog->rmtxs + i);
      if (tmp != 0) {
        i --;
        while (i >= 0) {
          pthread_mutex_unlock(ulog->rmtxs + i);
          i --;
        }
        return ((_Bool)0);
      }
      i ++;
    }
    return ((_Bool)1);
  }
  tmp___0 = pthread_mutex_lock(ulog->rmtxs + idx);
  return ((_Bool )(tmp___0 == 0));
}
}
_Bool tculogend(TCULOG *ulog , int idx ) 
{ _Bool err ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  if (idx < 0) {
    err = (_Bool)0;
    i = 30;
    while (i >= 0) {
      tmp = pthread_mutex_unlock(ulog->rmtxs + i);
      if (tmp != 0) {
        err = (_Bool)1;
      }
      i --;
    }
    return ((_Bool )(! err));
  }
  tmp___0 = pthread_mutex_unlock(ulog->rmtxs + idx);
  return ((_Bool )(tmp___0 == 0));
}
}
_Bool tculogwrite(TCULOG *ulog , uint64_t ts , uint32_t sid , uint32_t mid , void const   *ptr ,
                  int size ) 
{ double tmp ;
  _Bool err ;
  int tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;
  char *path ;
  char *tmp___3 ;
  int fd ;
  int tmp___4 ;
  struct stat sbuf ;
  int tmp___5 ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___6 ;
  unsigned char *tmp___7 ;
  __pthread_unwind_buf_t __cancel_buf___0 ;
  void (*__cancel_routine___tculogwrite)(void * ) ;
  void *__cancel_arg___0 ;
  unsigned char *tmp___8 ;
  int not_first_call___0 ;
  int tmp___9 ;
  long tmp___10 ;
  unsigned char *wp ;
  unsigned char *tmp___11 ;
  uint64_t llnum ;
  uint16_t snum ;
  uint32_t lnum ;
  struct aiocb *aiocbs ;
  struct aiocb *aiocbp ;
  off_t aioend ;
  _Bool tmp___12 ;
  void *tmp___13 ;
  int *tmp___14 ;
  int i ;
  _Bool tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;
  int i___0 ;
  _Bool tmp___18 ;
  char *path___0 ;
  char *tmp___19 ;
  int fd___0 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
  if (! ulog->base) {
    return ((_Bool)0);
  }
  if (ts < 1ULL) {
    tmp = tctime();
    ts = (unsigned long long )(tmp * (double )1000000);
  }
  err = (_Bool)0;
  tmp___0 = pthread_rwlock_wrlock(& ulog->rwlck);
  if (tmp___0 != 0) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& pthread_rwlock_unlock);
    __cancel_arg = (void *)(& ulog->rwlck);
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___1;
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___2) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      if (ulog->fd == -1) {
        tmp___3 = tcsprintf("%s/%08d%s", ulog->base, ulog->max, ".ulog");
        path = tmp___3;
        tmp___4 = open((char const   *)path, 1089, 420);
        fd = tmp___4;
        tcfree((void *)path);
        if (fd != -1) {
          tmp___5 = fstat(fd, & sbuf);
          if (tmp___5 == 0) {
            ulog->fd = fd;
            ulog->size = (unsigned long long )sbuf.st_size;
          } else {
            err = (_Bool)1;
          }
        } else {
          err = (_Bool)1;
        }
      }
      rsiz = (((int )sizeof(uint8_t ) + (int )sizeof(uint64_t )) + (int )sizeof(uint32_t ) * 2) + size;
      if (rsiz < 65536) {
        tmp___7 = stack;
      } else {
        tmp___6 = tcmalloc((unsigned int )rsiz);
        tmp___7 = (unsigned char *)tmp___6;
      }
      buf = tmp___7;
      while (1) {
        __cancel_routine___tculogwrite = & free;
        if ((unsigned int )buf == (unsigned int )(stack)) {
          tmp___8 = (unsigned char *)((void *)0);
        } else {
          tmp___8 = buf;
        }
        __cancel_arg___0 = (void *)tmp___8;
        tmp___9 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf___0.__cancel_jmp_buf),
                              0);
        not_first_call___0 = tmp___9;
        tmp___10 = __builtin_expect((long )not_first_call___0, 0L);
        if (tmp___10) {
          (*__cancel_routine___tculogwrite)(__cancel_arg___0);
          __pthread_unwind_next(& __cancel_buf___0);
        }
        __pthread_register_cancel(& __cancel_buf___0);
        while (1) {
          wp = buf;
          tmp___11 = wp;
          wp ++;
          *tmp___11 = (unsigned char)201;
          llnum = ((((((((ts & 255ULL) << 56) | ((ts & 65280ULL) << 40)) | ((ts & 16711680ULL) << 24)) | ((ts & 4278190080ULL) << 8)) | ((ts & 1095216660480ULL) >> 8)) | ((ts & 280375465082880ULL) >> 24)) | ((ts & 71776119061217280ULL) >> 40)) | ((ts & 0xff00000000000000ULL) >> 56);
          memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum),
                 (unsigned int )((int )sizeof(llnum)));
          wp += (int )sizeof(llnum);
          snum = (unsigned short )(((sid & 255U) << 8) | ((sid & 65280U) >> 8));
          memcpy((void * __restrict  )wp, (void const   * __restrict  )(& snum), (unsigned int )((int )sizeof(snum)));
          wp += (int )sizeof(snum);
          snum = (unsigned short )(((mid & 255U) << 8) | ((mid & 65280U) >> 8));
          memcpy((void * __restrict  )wp, (void const   * __restrict  )(& snum), (unsigned int )((int )sizeof(snum)));
          wp += (int )sizeof(snum);
          lnum = (unsigned int )((((((unsigned long )size & 255UL) << 24) | (((unsigned long )size & 65280UL) << 8)) | (((unsigned long )size & 16711680UL) >> 8)) | (((unsigned long )size & 4278190080UL) >> 24));
          memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
          wp += (int )sizeof(lnum);
          memcpy((void * __restrict  )wp, (void const   * __restrict  )ptr, (unsigned int )size);
          if (ulog->fd != -1) {
            aiocbs = (struct aiocb *)ulog->aiocbs;
            if (aiocbs) {
              aiocbp = aiocbs + ulog->aiocbi;
              if (aiocbp->aio_buf) {
                aioend = (long )((unsigned long )aiocbp->aio_offset + (unsigned long )aiocbp->aio_nbytes);
                tmp___12 = tculogflushaiocbp(aiocbp);
                if (tmp___12) {
                  ulog->aioend = (unsigned long long )aioend;
                } else {
                  err = (_Bool)1;
                }
              }
              aiocbp->aio_fildes = ulog->fd;
              aiocbp->aio_offset = (long )ulog->size;
              tmp___13 = tcmemdup((void const   *)buf, (unsigned int )rsiz);
              aiocbp->aio_buf = (void volatile   *)tmp___13;
              aiocbp->aio_nbytes = (unsigned int )rsiz;
              while (1) {
                tmp___16 = aio_write(aiocbp);
                if (! (tmp___16 != 0)) {
                  break;
                }
                tmp___14 = __errno_location();
                if (*tmp___14 != 11) {
                  tcfree((void *)((char *)aiocbp->aio_buf));
                  aiocbp->aio_buf = (void volatile   *)((void *)0);
                  err = (_Bool)1;
                  break;
                }
                i = 0;
                while (i < 64) {
                  if (i == ulog->aiocbi) {
                    goto __Cont;
                  }
                  tmp___15 = tculogflushaiocbp(aiocbs + i);
                  if (! tmp___15) {
                    err = (_Bool)1;
                    break;
                  }
                  __Cont: 
                  i ++;
                }
              }
              ulog->aiocbi = (ulog->aiocbi + 1) % 64;
            } else {
              tmp___17 = tcwrite(ulog->fd, (void const   *)buf, (unsigned int )rsiz);
              if (! tmp___17) {
                err = (_Bool)1;
              }
            }
            if (! err) {
              ulog->size += (unsigned long long )rsiz;
              if (ulog->size >= ulog->limsiz) {
                if (aiocbs) {
                  i___0 = 0;
                  while (i___0 < 64) {
                    tmp___18 = tculogflushaiocbp(aiocbs + i___0);
                    if (! tmp___18) {
                      err = (_Bool)1;
                    }
                    i___0 ++;
                  }
                  ulog->aiocbi = 0;
                  ulog->aioend = 0ULL;
                }
                tmp___19 = tcsprintf("%s/%08d%s", ulog->base, ulog->max + 1, ".ulog");
                path___0 = tmp___19;
                tmp___20 = open((char const   *)path___0, 1089, 420);
                fd___0 = tmp___20;
                tcfree((void *)path___0);
                if (fd___0 != 0) {
                  tmp___21 = close(ulog->fd);
                  if (tmp___21 != 0) {
                    err = (_Bool)1;
                  }
                  ulog->fd = fd___0;
                  ulog->size = 0ULL;
                  (ulog->max) ++;
                } else {
                  err = (_Bool)1;
                }
              }
              tmp___22 = pthread_cond_broadcast(& ulog->cnd);
              if (tmp___22 != 0) {
                err = (_Bool)1;
              }
            }
          } else {
            err = (_Bool)1;
          }
          break;
        }
        __pthread_unregister_cancel(& __cancel_buf___0);
        (*__cancel_routine___tculogwrite)(__cancel_arg___0);
        break;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
TCULRD *tculrdnew(TCULOG *ulog , uint64_t ts ) 
{ int tmp ;
  TCLIST *names ;
  TCLIST *tmp___0 ;
  int ln ;
  int tmp___1 ;
  int max ;
  int i ;
  char const   *name ;
  char const   *tmp___2 ;
  _Bool tmp___3 ;
  int id ;
  int64_t tmp___4 ;
  char *path ;
  char *tmp___5 ;
  struct stat sbuf ;
  int tmp___6 ;
  uint64_t bts ;
  double tmp___7 ;
  int num ;
  int i___0 ;
  char *path___0 ;
  char *tmp___8 ;
  int fd ;
  int tmp___9 ;
  int rsiz ;
  unsigned char *buf ;
  unsigned int __lengthofbuf ;
  void *tmp___10 ;
  uint64_t fts ;
  _Bool tmp___11 ;
  TCULRD *urld ;
  void *tmp___12 ;
  void *tmp___13 ;

  {
  if (! ulog->base) {
    return ((TCULRD *)((void *)0));
  }
  tmp = pthread_rwlock_rdlock(& ulog->rwlck);
  if (tmp != 0) {
    return ((TCULRD *)((void *)0));
  }
  tmp___0 = tcreaddir((char const   *)ulog->base);
  names = tmp___0;
  if (! names) {
    pthread_rwlock_unlock(& ulog->rwlck);
    return ((TCULRD *)((void *)0));
  }
  tmp___1 = tclistnum((TCLIST const   *)names);
  ln = tmp___1;
  max = 0;
  i = 0;
  while (i < ln) {
    tmp___2 = tclistval2((TCLIST const   *)names, i);
    name = tmp___2;
    tmp___3 = tcstrbwm(name, ".ulog");
    if (! tmp___3) {
      goto __Cont;
    }
    tmp___4 = tcatoi(name);
    id = (int )tmp___4;
    tmp___5 = tcsprintf("%s/%08d%s", ulog->base, id, ".ulog");
    path = tmp___5;
    tmp___6 = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& sbuf));
    if (tmp___6 == 0) {
      if ((sbuf.st_mode & 61440U) == 32768U) {
        if (id > max) {
          max = id;
        }
      }
    }
    tcfree((void *)path);
    __Cont: 
    i ++;
  }
  tclistdel(names);
  if (max < 1) {
    max = 1;
  }
  if ((double )ts > 30.0 * (double )1000000) {
    tmp___7 = (double )ts - 30.0 * (double )1000000;
  } else {
    tmp___7 = (double )0;
  }
  bts = (unsigned long long )tmp___7;
  num = 0;
  i___0 = max;
  while (i___0 > 0) {
    tmp___8 = tcsprintf("%s/%08d%s", ulog->base, i___0, ".ulog");
    path___0 = tmp___8;
    tmp___9 = open((char const   *)path___0, 0, 420);
    fd = tmp___9;
    tcfree((void *)path___0);
    if (fd == -1) {
      break;
    }
    rsiz = (int )sizeof(uint8_t ) + (int )sizeof(uint64_t );
    __lengthofbuf = (unsigned int )rsiz;
    tmp___10 = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
    buf = (unsigned char *)tmp___10;
    fts = 9223372036854775807ULL;
    tmp___11 = tcread(fd, (void *)buf, (unsigned int )rsiz);
    if (tmp___11) {
      memcpy((void * __restrict  )(& fts), (void const   * __restrict  )(buf + (int )sizeof(uint8_t )),
             (unsigned int )((int )sizeof(ts)));
      fts = ((((((((fts & 255ULL) << 56) | ((fts & 65280ULL) << 40)) | ((fts & 16711680ULL) << 24)) | ((fts & 4278190080ULL) << 8)) | ((fts & 1095216660480ULL) >> 8)) | ((fts & 280375465082880ULL) >> 24)) | ((fts & 71776119061217280ULL) >> 40)) | ((fts & 0xff00000000000000ULL) >> 56);
    }
    close(fd);
    num = i___0;
    if (bts >= fts) {
      break;
    }
    i___0 --;
  }
  if (num < 1) {
    num = 1;
  }
  tmp___12 = tcmalloc((unsigned int )((int )sizeof(*urld)));
  urld = (TCULRD *)tmp___12;
  urld->ulog = ulog;
  urld->ts = ts;
  urld->num = num;
  urld->fd = -1;
  tmp___13 = tcmalloc(65536U);
  urld->rbuf = (char *)tmp___13;
  urld->rsiz = 65536;
  pthread_rwlock_unlock(& ulog->rwlck);
  return (urld);
}
}
void tculrddel(TCULRD *ulrd ) 
{ 

  {
  if (ulrd->fd != -1) {
    close(ulrd->fd);
  }
  tcfree((void *)ulrd->rbuf);
  tcfree((void *)ulrd);
  return;
}
}
void tculrdwait(TCULRD *ulrd ) 
{ TCULOG *ulog ;
  int tmp ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;
  int ocs ;
  struct timeval tv ;
  struct timespec ts ;
  int tmp___2 ;

  {
  ulog = ulrd->ulog;
  tmp = pthread_mutex_lock(& ulog->wmtx);
  if (tmp != 0) {
    return;
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& pthread_mutex_unlock);
    __cancel_arg = (void *)(& ulog->wmtx);
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      ocs = 1;
      pthread_setcancelstate(0, & ocs);
      tmp___2 = gettimeofday((struct timeval * __restrict  )(& tv), (struct timezone * __restrict  )((void *)0));
      if (tmp___2 == 0) {
        ts.tv_sec = tv.tv_sec + 1L;
        ts.tv_nsec = tv.tv_usec * 1000L;
      } else {
        ts.tv_sec = (long )((1ULL << ((int )sizeof(time_t ) * 8 - 1)) - 1ULL);
        ts.tv_nsec = 0L;
      }
      pthread_cond_timedwait((pthread_cond_t * __restrict  )(& ulog->cnd), (pthread_mutex_t * __restrict  )(& ulog->wmtx),
                             (struct timespec  const  * __restrict  )(& ts));
      pthread_setcancelstate(ocs, (int *)((void *)0));
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return;
}
}
void const   *tculrdread(TCULRD *ulrd , int *sp , uint64_t *tsp , uint32_t *sidp ,
                         uint32_t *midp ) 
{ TCULOG *ulog ;
  int tmp ;
  char *path ;
  char *tmp___0 ;
  int rsiz ;
  unsigned char *buf ;
  unsigned int __lengthofbuf ;
  void *tmp___1 ;
  uint64_t ts ;
  uint32_t sid ;
  uint32_t mid ;
  uint32_t size ;
  struct stat sbuf ;
  int tmp___2 ;
  char *path___0 ;
  char *tmp___3 ;
  _Bool tmp___4 ;
  unsigned char const   *rp ;
  uint16_t snum ;
  void *tmp___5 ;
  _Bool tmp___6 ;

  {
  ulog = ulrd->ulog;
  tmp = pthread_rwlock_rdlock(& ulog->rwlck);
  if (tmp != 0) {
    return ((void const   *)((void *)0));
  }
  if (ulrd->fd == -1) {
    tmp___0 = tcsprintf("%s/%08d%s", ulog->base, ulrd->num, ".ulog");
    path = tmp___0;
    ulrd->fd = open((char const   *)path, 0, 420);
    tcfree((void *)path);
    if (ulrd->fd == -1) {
      pthread_rwlock_unlock(& ulog->rwlck);
      return ((void const   *)((void *)0));
    }
  }
  rsiz = ((int )sizeof(uint8_t ) + (int )sizeof(uint64_t )) + (int )sizeof(uint32_t ) * 2;
  __lengthofbuf = (unsigned int )rsiz;
  tmp___1 = __builtin_alloca(sizeof(*buf) * __lengthofbuf);
  buf = (unsigned char *)tmp___1;
  while (1) {
    if (ulog->aiocbs) {
      if (ulrd->num == ulog->max) {
        tmp___2 = fstat(ulrd->fd, & sbuf);
        if (tmp___2 == -1) {
          pthread_rwlock_unlock(& ulog->rwlck);
          return ((void const   *)((void *)0));
        } else {
          if ((unsigned long long )sbuf.st_size < ulog->size) {
            if ((unsigned long long )sbuf.st_size >= ulog->aioend) {
              pthread_rwlock_unlock(& ulog->rwlck);
              return ((void const   *)((void *)0));
            }
          }
        }
      }
    }
    tmp___4 = tcread(ulrd->fd, (void *)buf, (unsigned int )rsiz);
    if (! tmp___4) {
      if (ulrd->num < ulog->max) {
        close(ulrd->fd);
        (ulrd->num) ++;
        tmp___3 = tcsprintf("%s/%08d%s", ulog->base, ulrd->num, ".ulog");
        path___0 = tmp___3;
        ulrd->fd = open((char const   *)path___0, 0, 420);
        tcfree((void *)path___0);
        if (ulrd->fd == -1) {
          pthread_rwlock_unlock(& ulog->rwlck);
          return ((void const   *)((void *)0));
        }
        continue;
      }
      pthread_rwlock_unlock(& ulog->rwlck);
      return ((void const   *)((void *)0));
    }
    rp = (unsigned char const   *)buf;
    if ((int const   )*rp != 201) {
      pthread_rwlock_unlock(& ulog->rwlck);
      return ((void const   *)((void *)0));
    }
    rp += (int )sizeof(uint8_t );
    memcpy((void * __restrict  )(& ts), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(ts)));
    ts = ((((((((ts & 255ULL) << 56) | ((ts & 65280ULL) << 40)) | ((ts & 16711680ULL) << 24)) | ((ts & 4278190080ULL) << 8)) | ((ts & 1095216660480ULL) >> 8)) | ((ts & 280375465082880ULL) >> 24)) | ((ts & 71776119061217280ULL) >> 40)) | ((ts & 0xff00000000000000ULL) >> 56);
    rp += (int )sizeof(ts);
    memcpy((void * __restrict  )(& snum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(snum)));
    sid = (((unsigned int )snum & 255U) << 8) | (((unsigned int )snum & 65280U) >> 8);
    rp += (int )sizeof(snum);
    memcpy((void * __restrict  )(& snum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(snum)));
    mid = (((unsigned int )snum & 255U) << 8) | (((unsigned int )snum & 65280U) >> 8);
    rp += (int )sizeof(snum);
    memcpy((void * __restrict  )(& size), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(size)));
    size = (unsigned int )((((((unsigned long )size & 255UL) << 24) | (((unsigned long )size & 65280UL) << 8)) | (((unsigned long )size & 16711680UL) >> 8)) | (((unsigned long )size & 4278190080UL) >> 24));
    rp += (int )sizeof(size);
    if ((unsigned int )ulrd->rsiz < size + 1U) {
      tmp___5 = tcrealloc((void *)ulrd->rbuf, size + 1U);
      ulrd->rbuf = (char *)tmp___5;
      ulrd->rsiz = (int )(size + 1U);
    }
    tmp___6 = tcread(ulrd->fd, (void *)ulrd->rbuf, size);
    if (! tmp___6) {
      pthread_rwlock_unlock(& ulog->rwlck);
      return ((void const   *)((void *)0));
    }
    if (ts < ulrd->ts) {
      continue;
    }
    break;
  }
  *sp = (int )size;
  *tsp = ts;
  *sidp = sid;
  *midp = mid;
  *(ulrd->rbuf + size) = (char )'\000';
  pthread_rwlock_unlock(& ulog->rwlck);
  return ((void const   *)ulrd->rbuf);
}
}
_Bool tculogadbput(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , void const   *kbuf ,
                   int ksiz , void const   *vbuf , int vsiz ) 
{ _Bool err ;
  int rmidx ;
  int tmp ;
  _Bool dolog ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  unsigned char mstack[65536] ;
  int msiz ;
  unsigned char *mbuf ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *wp ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  uint32_t lnum ;
  unsigned char *tmp___6 ;
  _Bool tmp___7 ;

  {
  err = (_Bool)0;
  tmp = tculogrmtxidx(ulog, (char const   *)kbuf, ksiz);
  rmidx = tmp;
  tmp___0 = tculogbegin(ulog, rmidx);
  dolog = tmp___0;
  tmp___1 = tcadbput(adb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  if (dolog) {
    msiz = (((int )sizeof(uint8_t ) * 3 + (int )sizeof(uint32_t ) * 2) + ksiz) + vsiz;
    if (msiz < 65536) {
      tmp___3 = mstack;
    } else {
      tmp___2 = tcmalloc((unsigned int )(msiz + 1));
      tmp___3 = (unsigned char *)tmp___2;
    }
    mbuf = tmp___3;
    wp = mbuf;
    tmp___4 = wp;
    wp ++;
    *tmp___4 = (unsigned char)200;
    tmp___5 = wp;
    wp ++;
    *tmp___5 = (unsigned char)16;
    lnum = (unsigned int )((((((unsigned long )ksiz & 255UL) << 24) | (((unsigned long )ksiz & 65280UL) << 8)) | (((unsigned long )ksiz & 16711680UL) >> 8)) | (((unsigned long )ksiz & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    lnum = (unsigned int )((((((unsigned long )vsiz & 255UL) << 24) | (((unsigned long )vsiz & 65280UL) << 8)) | (((unsigned long )vsiz & 16711680UL) >> 8)) | (((unsigned long )vsiz & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    wp += ksiz;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
    wp += vsiz;
    tmp___6 = wp;
    wp ++;
    if (err) {
      *tmp___6 = (unsigned char)1;
    } else {
      *tmp___6 = (unsigned char)0;
    }
    tmp___7 = tculogwrite(ulog, 0ULL, sid, mid, (void const   *)mbuf, msiz);
    if (! tmp___7) {
      err = (_Bool)1;
    }
    if ((unsigned int )mbuf != (unsigned int )(mstack)) {
      tcfree((void *)mbuf);
    }
    tculogend(ulog, rmidx);
  }
  return ((_Bool )(! err));
}
}
_Bool tculogadbputkeep(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , void const   *kbuf ,
                       int ksiz , void const   *vbuf , int vsiz ) 
{ _Bool err ;
  int rmidx ;
  int tmp ;
  _Bool dolog ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  unsigned char mstack[65536] ;
  int msiz ;
  unsigned char *mbuf ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *wp ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  uint32_t lnum ;
  unsigned char *tmp___6 ;
  _Bool tmp___7 ;

  {
  err = (_Bool)0;
  tmp = tculogrmtxidx(ulog, (char const   *)kbuf, ksiz);
  rmidx = tmp;
  tmp___0 = tculogbegin(ulog, rmidx);
  dolog = tmp___0;
  tmp___1 = tcadbputkeep(adb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  if (dolog) {
    msiz = (((int )sizeof(uint8_t ) * 3 + (int )sizeof(uint32_t ) * 2) + ksiz) + vsiz;
    if (msiz < 65536) {
      tmp___3 = mstack;
    } else {
      tmp___2 = tcmalloc((unsigned int )(msiz + 1));
      tmp___3 = (unsigned char *)tmp___2;
    }
    mbuf = tmp___3;
    wp = mbuf;
    tmp___4 = wp;
    wp ++;
    *tmp___4 = (unsigned char)200;
    tmp___5 = wp;
    wp ++;
    *tmp___5 = (unsigned char)17;
    lnum = (unsigned int )((((((unsigned long )ksiz & 255UL) << 24) | (((unsigned long )ksiz & 65280UL) << 8)) | (((unsigned long )ksiz & 16711680UL) >> 8)) | (((unsigned long )ksiz & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    lnum = (unsigned int )((((((unsigned long )vsiz & 255UL) << 24) | (((unsigned long )vsiz & 65280UL) << 8)) | (((unsigned long )vsiz & 16711680UL) >> 8)) | (((unsigned long )vsiz & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    wp += ksiz;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
    wp += vsiz;
    tmp___6 = wp;
    wp ++;
    if (err) {
      *tmp___6 = (unsigned char)1;
    } else {
      *tmp___6 = (unsigned char)0;
    }
    tmp___7 = tculogwrite(ulog, 0ULL, sid, mid, (void const   *)mbuf, msiz);
    if (! tmp___7) {
      err = (_Bool)1;
    }
    if ((unsigned int )mbuf != (unsigned int )(mstack)) {
      tcfree((void *)mbuf);
    }
    tculogend(ulog, rmidx);
  }
  return ((_Bool )(! err));
}
}
_Bool tculogadbputcat(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , void const   *kbuf ,
                      int ksiz , void const   *vbuf , int vsiz ) 
{ _Bool err ;
  int rmidx ;
  int tmp ;
  _Bool dolog ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  unsigned char mstack[65536] ;
  int msiz ;
  unsigned char *mbuf ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *wp ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  uint32_t lnum ;
  unsigned char *tmp___6 ;
  _Bool tmp___7 ;

  {
  err = (_Bool)0;
  tmp = tculogrmtxidx(ulog, (char const   *)kbuf, ksiz);
  rmidx = tmp;
  tmp___0 = tculogbegin(ulog, rmidx);
  dolog = tmp___0;
  tmp___1 = tcadbputcat(adb, kbuf, ksiz, vbuf, vsiz);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  if (dolog) {
    msiz = (((int )sizeof(uint8_t ) * 3 + (int )sizeof(uint32_t ) * 2) + ksiz) + vsiz;
    if (msiz < 65536) {
      tmp___3 = mstack;
    } else {
      tmp___2 = tcmalloc((unsigned int )(msiz + 1));
      tmp___3 = (unsigned char *)tmp___2;
    }
    mbuf = tmp___3;
    wp = mbuf;
    tmp___4 = wp;
    wp ++;
    *tmp___4 = (unsigned char)200;
    tmp___5 = wp;
    wp ++;
    *tmp___5 = (unsigned char)18;
    lnum = (unsigned int )((((((unsigned long )ksiz & 255UL) << 24) | (((unsigned long )ksiz & 65280UL) << 8)) | (((unsigned long )ksiz & 16711680UL) >> 8)) | (((unsigned long )ksiz & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    lnum = (unsigned int )((((((unsigned long )vsiz & 255UL) << 24) | (((unsigned long )vsiz & 65280UL) << 8)) | (((unsigned long )vsiz & 16711680UL) >> 8)) | (((unsigned long )vsiz & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    wp += ksiz;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
    wp += vsiz;
    tmp___6 = wp;
    wp ++;
    if (err) {
      *tmp___6 = (unsigned char)1;
    } else {
      *tmp___6 = (unsigned char)0;
    }
    tmp___7 = tculogwrite(ulog, 0ULL, sid, mid, (void const   *)mbuf, msiz);
    if (! tmp___7) {
      err = (_Bool)1;
    }
    if ((unsigned int )mbuf != (unsigned int )(mstack)) {
      tcfree((void *)mbuf);
    }
    tculogend(ulog, rmidx);
  }
  return ((_Bool )(! err));
}
}
_Bool tculogadbout(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , void const   *kbuf ,
                   int ksiz ) 
{ _Bool err ;
  int rmidx ;
  int tmp ;
  _Bool dolog ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  unsigned char mstack[65536] ;
  int msiz ;
  unsigned char *mbuf ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *wp ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  uint32_t lnum ;
  unsigned char *tmp___6 ;
  _Bool tmp___7 ;

  {
  err = (_Bool)0;
  tmp = tculogrmtxidx(ulog, (char const   *)kbuf, ksiz);
  rmidx = tmp;
  tmp___0 = tculogbegin(ulog, rmidx);
  dolog = tmp___0;
  tmp___1 = tcadbout(adb, kbuf, ksiz);
  if (! tmp___1) {
    err = (_Bool)1;
  }
  if (dolog) {
    msiz = ((int )sizeof(uint8_t ) * 3 + (int )sizeof(uint32_t )) + ksiz;
    if (msiz < 65536) {
      tmp___3 = mstack;
    } else {
      tmp___2 = tcmalloc((unsigned int )(msiz + 1));
      tmp___3 = (unsigned char *)tmp___2;
    }
    mbuf = tmp___3;
    wp = mbuf;
    tmp___4 = wp;
    wp ++;
    *tmp___4 = (unsigned char)200;
    tmp___5 = wp;
    wp ++;
    *tmp___5 = (unsigned char)32;
    lnum = (unsigned int )((((((unsigned long )ksiz & 255UL) << 24) | (((unsigned long )ksiz & 65280UL) << 8)) | (((unsigned long )ksiz & 16711680UL) >> 8)) | (((unsigned long )ksiz & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    wp += ksiz;
    tmp___6 = wp;
    wp ++;
    if (err) {
      *tmp___6 = (unsigned char)1;
    } else {
      *tmp___6 = (unsigned char)0;
    }
    tmp___7 = tculogwrite(ulog, 0ULL, sid, mid, (void const   *)mbuf, msiz);
    if (! tmp___7) {
      err = (_Bool)1;
    }
    if ((unsigned int )mbuf != (unsigned int )(mstack)) {
      tcfree((void *)mbuf);
    }
    tculogend(ulog, rmidx);
  }
  return ((_Bool )(! err));
}
}
int tculogadbaddint(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , void const   *kbuf ,
                    int ksiz , int num ) 
{ int rmidx ;
  int tmp ;
  _Bool dolog ;
  _Bool tmp___0 ;
  int rnum ;
  int tmp___1 ;
  unsigned char mstack[65536] ;
  int msiz ;
  unsigned char *mbuf ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *wp ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  uint32_t lnum ;
  unsigned char *tmp___6 ;
  _Bool tmp___7 ;

  {
  tmp = tculogrmtxidx(ulog, (char const   *)kbuf, ksiz);
  rmidx = tmp;
  tmp___0 = tculogbegin(ulog, rmidx);
  dolog = tmp___0;
  tmp___1 = tcadbaddint(adb, kbuf, ksiz, num);
  rnum = tmp___1;
  if (dolog) {
    msiz = ((int )sizeof(uint8_t ) * 3 + (int )sizeof(uint32_t ) * 2) + ksiz;
    if (msiz < 65536) {
      tmp___3 = mstack;
    } else {
      tmp___2 = tcmalloc((unsigned int )(msiz + 1));
      tmp___3 = (unsigned char *)tmp___2;
    }
    mbuf = tmp___3;
    wp = mbuf;
    tmp___4 = wp;
    wp ++;
    *tmp___4 = (unsigned char)200;
    tmp___5 = wp;
    wp ++;
    *tmp___5 = (unsigned char)96;
    lnum = (unsigned int )((((((unsigned long )ksiz & 255UL) << 24) | (((unsigned long )ksiz & 65280UL) << 8)) | (((unsigned long )ksiz & 16711680UL) >> 8)) | (((unsigned long )ksiz & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    lnum = (unsigned int )((((((unsigned long )num & 255UL) << 24) | (((unsigned long )num & 65280UL) << 8)) | (((unsigned long )num & 16711680UL) >> 8)) | (((unsigned long )num & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    wp += ksiz;
    tmp___6 = wp;
    wp ++;
    if (rnum == (-0x7FFFFFFF-1)) {
      *tmp___6 = (unsigned char)1;
    } else {
      *tmp___6 = (unsigned char)0;
    }
    tmp___7 = tculogwrite(ulog, 0ULL, sid, mid, (void const   *)mbuf, msiz);
    if (! tmp___7) {
      rnum = (-0x7FFFFFFF-1);
    }
    if ((unsigned int )mbuf != (unsigned int )(mstack)) {
      tcfree((void *)mbuf);
    }
    tculogend(ulog, rmidx);
  }
  return (rnum);
}
}
double tculogadbadddouble(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb ,
                          void const   *kbuf , int ksiz , double num ) 
{ int rmidx ;
  int tmp ;
  _Bool dolog ;
  _Bool tmp___0 ;
  double rnum ;
  double tmp___1 ;
  unsigned char mstack[65536] ;
  int msiz ;
  unsigned char *mbuf ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *wp ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  uint32_t lnum ;
  unsigned char *tmp___6 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;

  {
  tmp = tculogrmtxidx(ulog, (char const   *)kbuf, ksiz);
  rmidx = tmp;
  tmp___0 = tculogbegin(ulog, rmidx);
  dolog = tmp___0;
  tmp___1 = tcadbadddouble(adb, kbuf, ksiz, num);
  rnum = tmp___1;
  if (dolog) {
    msiz = (((int )sizeof(uint8_t ) * 3 + (int )sizeof(uint32_t )) + (int )sizeof(uint64_t ) * 2) + ksiz;
    if (msiz < 65536) {
      tmp___3 = mstack;
    } else {
      tmp___2 = tcmalloc((unsigned int )(msiz + 1));
      tmp___3 = (unsigned char *)tmp___2;
    }
    mbuf = tmp___3;
    wp = mbuf;
    tmp___4 = wp;
    wp ++;
    *tmp___4 = (unsigned char)200;
    tmp___5 = wp;
    wp ++;
    *tmp___5 = (unsigned char)97;
    lnum = (unsigned int )((((((unsigned long )ksiz & 255UL) << 24) | (((unsigned long )ksiz & 65280UL) << 8)) | (((unsigned long )ksiz & 16711680UL) >> 8)) | (((unsigned long )ksiz & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    ttpackdouble(num, (char *)wp);
    wp += (int )sizeof(uint64_t ) * 2;
    memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
    wp += ksiz;
    tmp___6 = wp;
    wp ++;
    if ((int )sizeof(rnum) == (int )sizeof(float )) {
      tmp___12 = __isnanf((float )rnum);
      tmp___16 = tmp___12;
    } else {
      if ((int )sizeof(rnum) == (int )sizeof(double )) {
        tmp___13 = __isnan(rnum);
        tmp___15 = tmp___13;
      } else {
        tmp___14 = __isnanl((long double )rnum);
        tmp___15 = tmp___14;
      }
      tmp___16 = tmp___15;
    }
    if (tmp___16) {
      *tmp___6 = (unsigned char)1;
    } else {
      *tmp___6 = (unsigned char)0;
    }
    tmp___17 = tculogwrite(ulog, 0ULL, sid, mid, (void const   *)mbuf, msiz);
    if (! tmp___17) {
      rnum = (double )(-0x7FFFFFFF-1);
    }
    if ((unsigned int )mbuf != (unsigned int )(mstack)) {
      tcfree((void *)mbuf);
    }
    tculogend(ulog, rmidx);
  }
  return (rnum);
}
}
_Bool tculogadbsync(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb ) 
{ _Bool err ;
  _Bool dolog ;
  _Bool tmp ;
  _Bool tmp___0 ;
  unsigned char mbuf[(int )sizeof(uint8_t ) * 3] ;
  unsigned char *wp ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  _Bool tmp___4 ;

  {
  err = (_Bool)0;
  tmp = tculogbegin(ulog, -1);
  dolog = tmp;
  tmp___0 = tcadbsync(adb);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  if (dolog) {
    wp = mbuf;
    tmp___1 = wp;
    wp ++;
    *tmp___1 = (unsigned char)200;
    tmp___2 = wp;
    wp ++;
    *tmp___2 = (unsigned char)112;
    tmp___3 = wp;
    wp ++;
    if (err) {
      *tmp___3 = (unsigned char)1;
    } else {
      *tmp___3 = (unsigned char)0;
    }
    tmp___4 = tculogwrite(ulog, 0ULL, sid, mid, (void const   *)(mbuf), wp - mbuf);
    if (! tmp___4) {
      err = (_Bool)1;
    }
    tculogend(ulog, -1);
  }
  return ((_Bool )(! err));
}
}
_Bool tculogadboptimize(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb ,
                        char const   *params ) 
{ _Bool err ;
  _Bool dolog ;
  _Bool tmp ;
  _Bool tmp___0 ;
  int psiz ;
  size_t tmp___1 ;
  unsigned char mstack[65536] ;
  int msiz ;
  unsigned char *mbuf ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *wp ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  uint32_t lnum ;
  unsigned char *tmp___6 ;
  _Bool tmp___7 ;

  {
  err = (_Bool)0;
  tmp = tculogbegin(ulog, -1);
  dolog = tmp;
  tmp___0 = tcadboptimize(adb, params);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  if (dolog) {
    tmp___1 = strlen(params);
    psiz = (int )tmp___1;
    msiz = ((int )sizeof(uint8_t ) * 3 + (int )sizeof(uint32_t )) + psiz;
    if (msiz < 65536) {
      tmp___3 = mstack;
    } else {
      tmp___2 = tcmalloc((unsigned int )(msiz + 1));
      tmp___3 = (unsigned char *)tmp___2;
    }
    mbuf = tmp___3;
    wp = mbuf;
    tmp___4 = wp;
    wp ++;
    *tmp___4 = (unsigned char)200;
    tmp___5 = wp;
    wp ++;
    *tmp___5 = (unsigned char)113;
    lnum = (unsigned int )((((((unsigned long )psiz & 255UL) << 24) | (((unsigned long )psiz & 65280UL) << 8)) | (((unsigned long )psiz & 16711680UL) >> 8)) | (((unsigned long )psiz & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    memcpy((void * __restrict  )wp, (void const   * __restrict  )params, (unsigned int )psiz);
    wp += psiz;
    tmp___6 = wp;
    wp ++;
    if (err) {
      *tmp___6 = (unsigned char)1;
    } else {
      *tmp___6 = (unsigned char)0;
    }
    tmp___7 = tculogwrite(ulog, 0ULL, sid, mid, (void const   *)mbuf, msiz);
    if (! tmp___7) {
      err = (_Bool)1;
    }
    if ((unsigned int )mbuf != (unsigned int )(mstack)) {
      tcfree((void *)mbuf);
    }
    tculogend(ulog, -1);
  }
  return ((_Bool )(! err));
}
}
_Bool tculogadbvanish(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb ) 
{ _Bool err ;
  _Bool dolog ;
  _Bool tmp ;
  _Bool tmp___0 ;
  unsigned char mbuf[(int )sizeof(uint8_t ) * 3] ;
  unsigned char *wp ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  _Bool tmp___4 ;

  {
  err = (_Bool)0;
  tmp = tculogbegin(ulog, -1);
  dolog = tmp;
  tmp___0 = tcadbvanish(adb);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  if (dolog) {
    wp = mbuf;
    tmp___1 = wp;
    wp ++;
    *tmp___1 = (unsigned char)200;
    tmp___2 = wp;
    wp ++;
    *tmp___2 = (unsigned char)114;
    tmp___3 = wp;
    wp ++;
    if (err) {
      *tmp___3 = (unsigned char)1;
    } else {
      *tmp___3 = (unsigned char)0;
    }
    tmp___4 = tculogwrite(ulog, 0ULL, sid, mid, (void const   *)(mbuf), wp - mbuf);
    if (! tmp___4) {
      err = (_Bool)1;
    }
    tculogend(ulog, -1);
  }
  return ((_Bool )(! err));
}
}
TCLIST *tculogadbmisc(TCULOG *ulog , uint32_t sid , uint32_t mid , TCADB *adb , char const   *name ,
                      TCLIST const   *args ) 
{ _Bool dolog ;
  _Bool tmp ;
  TCLIST *rv ;
  TCLIST *tmp___0 ;
  int nsiz ;
  size_t tmp___1 ;
  int anum ;
  int tmp___2 ;
  int msiz ;
  int i ;
  int esiz ;
  unsigned char mstack[65536] ;
  unsigned char *mbuf ;
  void *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *wp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  uint32_t lnum ;
  int i___0 ;
  int esiz___0 ;
  char const   *ebuf ;
  void const   *tmp___7 ;
  unsigned char *tmp___8 ;
  _Bool tmp___9 ;

  {
  tmp = tculogbegin(ulog, -1);
  dolog = tmp;
  tmp___0 = tcadbmisc(adb, name, args);
  rv = tmp___0;
  if (dolog) {
    tmp___1 = strlen(name);
    nsiz = (int )tmp___1;
    tmp___2 = tclistnum(args);
    anum = tmp___2;
    msiz = ((int )sizeof(uint8_t ) * 3 + (int )sizeof(uint32_t ) * 2) + nsiz;
    i = 0;
    while (i < anum) {
      tclistval(args, i, & esiz);
      msiz += (int )sizeof(uint32_t ) + esiz;
      i ++;
    }
    if (msiz < 65536) {
      tmp___4 = mstack;
    } else {
      tmp___3 = tcmalloc((unsigned int )(msiz + 1));
      tmp___4 = (unsigned char *)tmp___3;
    }
    mbuf = tmp___4;
    wp = mbuf;
    tmp___5 = wp;
    wp ++;
    *tmp___5 = (unsigned char)200;
    tmp___6 = wp;
    wp ++;
    *tmp___6 = (unsigned char)144;
    lnum = (unsigned int )((((((unsigned long )nsiz & 255UL) << 24) | (((unsigned long )nsiz & 65280UL) << 8)) | (((unsigned long )nsiz & 16711680UL) >> 8)) | (((unsigned long )nsiz & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    lnum = (unsigned int )((((((unsigned long )anum & 255UL) << 24) | (((unsigned long )anum & 65280UL) << 8)) | (((unsigned long )anum & 16711680UL) >> 8)) | (((unsigned long )anum & 4278190080UL) >> 24));
    memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
    wp += (int )sizeof(lnum);
    memcpy((void * __restrict  )wp, (void const   * __restrict  )name, (unsigned int )nsiz);
    wp += nsiz;
    i___0 = 0;
    while (i___0 < anum) {
      tmp___7 = tclistval(args, i___0, & esiz___0);
      ebuf = (char const   *)tmp___7;
      lnum = (unsigned int )((((((unsigned long )esiz___0 & 255UL) << 24) | (((unsigned long )esiz___0 & 65280UL) << 8)) | (((unsigned long )esiz___0 & 16711680UL) >> 8)) | (((unsigned long )esiz___0 & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
      wp += (int )sizeof(lnum);
      memcpy((void * __restrict  )wp, (void const   * __restrict  )ebuf, (unsigned int )esiz___0);
      wp += esiz___0;
      i___0 ++;
    }
    tmp___8 = wp;
    wp ++;
    if (rv) {
      *tmp___8 = (unsigned char)0;
    } else {
      *tmp___8 = (unsigned char)1;
    }
    tmp___9 = tculogwrite(ulog, 0ULL, sid, mid, (void const   *)mbuf, msiz);
    if (! tmp___9) {
      if (rv) {
        tclistdel(rv);
      }
      rv = (TCLIST *)((void *)0);
    }
    if ((unsigned int )mbuf != (unsigned int )(mstack)) {
      tcfree((void *)mbuf);
    }
    tculogend(ulog, -1);
  }
  return (rv);
}
}
_Bool tculogadbrestore(TCADB *adb , char const   *path , uint64_t ts , _Bool con ,
                       TCULOG *ulog ) 
{ _Bool err ;
  TCULOG *sulog ;
  TCULOG *tmp ;
  TCULRD *ulrd ;
  TCULRD *tmp___0 ;
  char const   *rbuf ;
  int rsiz ;
  uint64_t rts ;
  uint32_t rsid ;
  uint32_t rmid ;
  _Bool cc ;
  _Bool tmp___1 ;
  void const   *tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  err = (_Bool)0;
  tmp = tculognew();
  sulog = tmp;
  tmp___4 = tculogopen(sulog, path, 0ULL);
  if (tmp___4) {
    tmp___0 = tculrdnew(sulog, ts);
    ulrd = tmp___0;
    if (ulrd) {
      while (1) {
        tmp___2 = tculrdread(ulrd, & rsiz, & rts, & rsid, & rmid);
        rbuf = (char const   *)tmp___2;
        if (! ((unsigned int )rbuf != (unsigned int )((void *)0))) {
          break;
        }
        tmp___1 = tculogadbredo(adb, rbuf, rsiz, ulog, rsid, rmid, & cc);
        if (tmp___1) {
          if (con) {
            if (! cc) {
              err = (_Bool)1;
              break;
            }
          }
        } else {
          err = (_Bool)1;
          break;
        }
      }
      tculrddel(ulrd);
    } else {
      err = (_Bool)1;
    }
    tmp___3 = tculogclose(sulog);
    if (! tmp___3) {
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  tculogdel(sulog);
  return ((_Bool )(! err));
}
}
_Bool tculogadbredo(TCADB *adb , char const   *ptr , int size , TCULOG *ulog , uint32_t sid ,
                    uint32_t mid , _Bool *cp ) 
{ unsigned char const   *rp ;
  int magic ;
  unsigned char const   *tmp ;
  int cmd ;
  unsigned char const   *tmp___0 ;
  _Bool exp___0 ;
  int tmp___1 ;
  _Bool err ;
  uint32_t ksiz ;
  uint32_t vsiz ;
  _Bool tmp___2 ;
  uint32_t ksiz___0 ;
  uint32_t vsiz___0 ;
  _Bool tmp___3 ;
  uint32_t ksiz___1 ;
  uint32_t vsiz___1 ;
  _Bool tmp___4 ;
  uint32_t ksiz___2 ;
  _Bool tmp___5 ;
  uint32_t ksiz___3 ;
  int32_t num ;
  int rnum ;
  int tmp___6 ;
  uint32_t ksiz___4 ;
  double num___0 ;
  double tmp___7 ;
  double rnum___0 ;
  double tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  _Bool tmp___14 ;
  uint32_t psiz ;
  char *params ;
  void *tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  uint32_t nsiz ;
  uint32_t anum ;
  char *name ;
  void *tmp___18 ;
  TCLIST *args ;
  TCLIST *tmp___19 ;
  int i ;
  uint32_t esiz ;
  TCLIST *res ;
  TCLIST *tmp___20 ;

  {
  if (size < (int )sizeof(uint8_t ) * 3) {
    return ((_Bool)0);
  }
  rp = (unsigned char const   *)((unsigned char *)ptr);
  tmp = rp;
  rp ++;
  magic = (int )*tmp;
  tmp___0 = rp;
  rp ++;
  cmd = (int )*tmp___0;
  if ((int )*((unsigned char *)ptr + (size - 1)) == 0) {
    tmp___1 = 1;
  } else {
    tmp___1 = 0;
  }
  exp___0 = (_Bool )tmp___1;
  size -= (int )sizeof(uint8_t ) * 3;
  if (magic != 200) {
    return ((_Bool)0);
  }
  err = (_Bool)0;
  *cp = (_Bool)1;
  switch (cmd) {
  case 16: 
  if (size >= (int )sizeof(uint32_t ) * 2) {
    memcpy((void * __restrict  )(& ksiz), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(ksiz)));
    ksiz = (unsigned int )((((((unsigned long )ksiz & 255UL) << 24) | (((unsigned long )ksiz & 65280UL) << 8)) | (((unsigned long )ksiz & 16711680UL) >> 8)) | (((unsigned long )ksiz & 4278190080UL) >> 24));
    rp += (int )sizeof(ksiz);
    memcpy((void * __restrict  )(& vsiz), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(vsiz)));
    vsiz = (unsigned int )((((((unsigned long )vsiz & 255UL) << 24) | (((unsigned long )vsiz & 65280UL) << 8)) | (((unsigned long )vsiz & 16711680UL) >> 8)) | (((unsigned long )vsiz & 4278190080UL) >> 24));
    rp += (int )sizeof(vsiz);
    tmp___2 = tculogadbput(ulog, sid, mid, adb, (void const   *)rp, (int )ksiz, (void const   *)(rp + ksiz),
                           (int )vsiz);
    if ((int )tmp___2 != (int )exp___0) {
      *cp = (_Bool)0;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 17: 
  if (size >= (int )sizeof(uint32_t ) * 2) {
    memcpy((void * __restrict  )(& ksiz___0), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(ksiz___0)));
    ksiz___0 = (unsigned int )((((((unsigned long )ksiz___0 & 255UL) << 24) | (((unsigned long )ksiz___0 & 65280UL) << 8)) | (((unsigned long )ksiz___0 & 16711680UL) >> 8)) | (((unsigned long )ksiz___0 & 4278190080UL) >> 24));
    rp += (int )sizeof(ksiz___0);
    memcpy((void * __restrict  )(& vsiz___0), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(vsiz___0)));
    vsiz___0 = (unsigned int )((((((unsigned long )vsiz___0 & 255UL) << 24) | (((unsigned long )vsiz___0 & 65280UL) << 8)) | (((unsigned long )vsiz___0 & 16711680UL) >> 8)) | (((unsigned long )vsiz___0 & 4278190080UL) >> 24));
    rp += (int )sizeof(vsiz___0);
    tmp___3 = tculogadbputkeep(ulog, sid, mid, adb, (void const   *)rp, (int )ksiz___0,
                               (void const   *)(rp + ksiz___0), (int )vsiz___0);
    if ((int )tmp___3 != (int )exp___0) {
      *cp = (_Bool)0;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 18: 
  if (size >= (int )sizeof(uint32_t ) * 2) {
    memcpy((void * __restrict  )(& ksiz___1), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(ksiz___1)));
    ksiz___1 = (unsigned int )((((((unsigned long )ksiz___1 & 255UL) << 24) | (((unsigned long )ksiz___1 & 65280UL) << 8)) | (((unsigned long )ksiz___1 & 16711680UL) >> 8)) | (((unsigned long )ksiz___1 & 4278190080UL) >> 24));
    rp += (int )sizeof(ksiz___1);
    memcpy((void * __restrict  )(& vsiz___1), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(vsiz___1)));
    vsiz___1 = (unsigned int )((((((unsigned long )vsiz___1 & 255UL) << 24) | (((unsigned long )vsiz___1 & 65280UL) << 8)) | (((unsigned long )vsiz___1 & 16711680UL) >> 8)) | (((unsigned long )vsiz___1 & 4278190080UL) >> 24));
    rp += (int )sizeof(vsiz___1);
    tmp___4 = tculogadbputcat(ulog, sid, mid, adb, (void const   *)rp, (int )ksiz___1,
                              (void const   *)(rp + ksiz___1), (int )vsiz___1);
    if ((int )tmp___4 != (int )exp___0) {
      *cp = (_Bool)0;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 32: 
  if (size >= (int )sizeof(uint32_t )) {
    memcpy((void * __restrict  )(& ksiz___2), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(ksiz___2)));
    ksiz___2 = (unsigned int )((((((unsigned long )ksiz___2 & 255UL) << 24) | (((unsigned long )ksiz___2 & 65280UL) << 8)) | (((unsigned long )ksiz___2 & 16711680UL) >> 8)) | (((unsigned long )ksiz___2 & 4278190080UL) >> 24));
    rp += (int )sizeof(ksiz___2);
    tmp___5 = tculogadbout(ulog, sid, mid, adb, (void const   *)rp, (int )ksiz___2);
    if ((int )tmp___5 != (int )exp___0) {
      *cp = (_Bool)0;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 96: 
  if (size >= (int )sizeof(uint32_t ) * 2) {
    memcpy((void * __restrict  )(& ksiz___3), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(ksiz___3)));
    ksiz___3 = (unsigned int )((((((unsigned long )ksiz___3 & 255UL) << 24) | (((unsigned long )ksiz___3 & 65280UL) << 8)) | (((unsigned long )ksiz___3 & 16711680UL) >> 8)) | (((unsigned long )ksiz___3 & 4278190080UL) >> 24));
    rp += (int )sizeof(ksiz___3);
    memcpy((void * __restrict  )(& num), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(num)));
    num = (int )((((((unsigned long )num & 255UL) << 24) | (((unsigned long )num & 65280UL) << 8)) | (((unsigned long )num & 16711680UL) >> 8)) | (((unsigned long )num & 4278190080UL) >> 24));
    rp += (int )sizeof(num);
    tmp___6 = tculogadbaddint(ulog, sid, mid, adb, (void const   *)rp, (int )ksiz___3,
                              num);
    rnum = tmp___6;
    if (exp___0) {
      if (rnum == (-0x7FFFFFFF-1)) {
        *cp = (_Bool)0;
      }
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 97: 
  if (size >= (int )sizeof(uint32_t ) + (int )sizeof(uint64_t ) * 2) {
    memcpy((void * __restrict  )(& ksiz___4), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(ksiz___4)));
    ksiz___4 = (unsigned int )((((((unsigned long )ksiz___4 & 255UL) << 24) | (((unsigned long )ksiz___4 & 65280UL) << 8)) | (((unsigned long )ksiz___4 & 16711680UL) >> 8)) | (((unsigned long )ksiz___4 & 4278190080UL) >> 24));
    rp += (int )sizeof(ksiz___4);
    tmp___7 = ttunpackdouble((char const   *)((char *)rp));
    num___0 = tmp___7;
    rp += (int )sizeof(uint64_t ) * 2;
    tmp___8 = tculogadbadddouble(ulog, sid, mid, adb, (void const   *)rp, (int )ksiz___4,
                                 num___0);
    rnum___0 = tmp___8;
    if (exp___0) {
      if ((int )sizeof(rnum___0) == (int )sizeof(float )) {
        tmp___9 = __isnanf((float )rnum___0);
        tmp___13 = tmp___9;
      } else {
        if ((int )sizeof(rnum___0) == (int )sizeof(double )) {
          tmp___10 = __isnan(rnum___0);
          tmp___12 = tmp___10;
        } else {
          tmp___11 = __isnanl((long double )rnum___0);
          tmp___12 = tmp___11;
        }
        tmp___13 = tmp___12;
      }
      if (tmp___13) {
        *cp = (_Bool)0;
      }
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 112: 
  if (size == 0) {
    tmp___14 = tculogadbsync(ulog, sid, mid, adb);
    if ((int )tmp___14 != (int )exp___0) {
      *cp = (_Bool)0;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 113: 
  if (size >= (int )sizeof(uint32_t )) {
    memcpy((void * __restrict  )(& psiz), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(psiz)));
    psiz = (unsigned int )((((((unsigned long )psiz & 255UL) << 24) | (((unsigned long )psiz & 65280UL) << 8)) | (((unsigned long )psiz & 16711680UL) >> 8)) | (((unsigned long )psiz & 4278190080UL) >> 24));
    rp += (int )sizeof(psiz);
    tmp___15 = tcmemdup((void const   *)rp, psiz);
    params = (char *)tmp___15;
    tmp___16 = tculogadboptimize(ulog, sid, mid, adb, (char const   *)params);
    if ((int )tmp___16 != (int )exp___0) {
      *cp = (_Bool)0;
    }
    tcfree((void *)params);
  } else {
    err = (_Bool)1;
  }
  break;
  case 114: 
  if (size == 0) {
    tmp___17 = tculogadbvanish(ulog, sid, mid, adb);
    if ((int )tmp___17 != (int )exp___0) {
      *cp = (_Bool)0;
    }
  } else {
    err = (_Bool)1;
  }
  break;
  case 144: 
  if (size >= (int )sizeof(uint32_t ) * 2) {
    memcpy((void * __restrict  )(& nsiz), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(nsiz)));
    nsiz = (unsigned int )((((((unsigned long )nsiz & 255UL) << 24) | (((unsigned long )nsiz & 65280UL) << 8)) | (((unsigned long )nsiz & 16711680UL) >> 8)) | (((unsigned long )nsiz & 4278190080UL) >> 24));
    rp += (int )sizeof(nsiz);
    memcpy((void * __restrict  )(& anum), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(anum)));
    anum = (unsigned int )((((((unsigned long )anum & 255UL) << 24) | (((unsigned long )anum & 65280UL) << 8)) | (((unsigned long )anum & 16711680UL) >> 8)) | (((unsigned long )anum & 4278190080UL) >> 24));
    rp += (int )sizeof(anum);
    tmp___18 = tcmemdup((void const   *)rp, nsiz);
    name = (char *)tmp___18;
    rp += nsiz;
    tmp___19 = tclistnew2((int )anum);
    args = tmp___19;
    i = 0;
    while ((unsigned int )i < anum) {
      memcpy((void * __restrict  )(& esiz), (void const   * __restrict  )rp, (unsigned int )((int )sizeof(esiz)));
      esiz = (unsigned int )((((((unsigned long )esiz & 255UL) << 24) | (((unsigned long )esiz & 65280UL) << 8)) | (((unsigned long )esiz & 16711680UL) >> 8)) | (((unsigned long )esiz & 4278190080UL) >> 24));
      rp += (int )sizeof(esiz);
      tclistpush(args, (void const   *)rp, (int )esiz);
      rp += esiz;
      i ++;
    }
    tmp___20 = tculogadbmisc(ulog, sid, mid, adb, (char const   *)name, (TCLIST const   *)args);
    res = tmp___20;
    if (res) {
      if (! exp___0) {
        *cp = (_Bool)0;
      }
      tclistdel(res);
    } else {
      if (exp___0) {
        *cp = (_Bool)0;
      }
    }
    tclistdel(args);
    tcfree((void *)name);
  } else {
    err = (_Bool)1;
  }
  break;
  default: 
  err = (_Bool)1;
  break;
  }
  return ((_Bool )(! err));
}
}
TCREPL *tcreplnew(void) 
{ TCREPL *repl ;
  void *tmp ;

  {
  tmp = tcmalloc((unsigned int )((int )sizeof(*repl)));
  repl = (TCREPL *)tmp;
  repl->fd = -1;
  repl->sock = (TTSOCK *)((void *)0);
  return (repl);
}
}
void tcrepldel(TCREPL *repl ) 
{ 

  {
  if (repl->fd >= 0) {
    tcreplclose(repl);
  }
  tcfree((void *)repl);
  return;
}
}
_Bool tcreplopen(TCREPL *repl , char const   *host , int port , uint64_t ts , uint32_t sid ) 
{ char addr[1024] ;
  _Bool tmp ;
  int fd ;
  int tmp___0 ;
  unsigned char buf[65536] ;
  unsigned char *wp ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  uint64_t llnum ;
  uint32_t lnum ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  uint32_t tmp___5 ;
  _Bool tmp___6 ;

  {
  if (repl->fd >= 0) {
    return ((_Bool)0);
  }
  if (ts < 1ULL) {
    ts = 1ULL;
  }
  if (sid < 1U) {
    sid = 2147483647U;
  }
  tmp = ttgethostaddr(host, addr);
  if (! tmp) {
    return ((_Bool)0);
  }
  tmp___0 = ttopensock((char const   *)(addr), port);
  fd = tmp___0;
  if (fd == -1) {
    return ((_Bool)0);
  }
  wp = buf;
  tmp___1 = wp;
  wp ++;
  *tmp___1 = (unsigned char)200;
  tmp___2 = wp;
  wp ++;
  *tmp___2 = (unsigned char)160;
  llnum = ((((((((ts & 255ULL) << 56) | ((ts & 65280ULL) << 40)) | ((ts & 16711680ULL) << 24)) | ((ts & 4278190080ULL) << 8)) | ((ts & 1095216660480ULL) >> 8)) | ((ts & 280375465082880ULL) >> 24)) | ((ts & 71776119061217280ULL) >> 40)) | ((ts & 0xff00000000000000ULL) >> 56);
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(llnum)));
  wp += (int )sizeof(llnum);
  lnum = (unsigned int )((((((unsigned long )sid & 255UL) << 24) | (((unsigned long )sid & 65280UL) << 8)) | (((unsigned long )sid & 16711680UL) >> 8)) | (((unsigned long )sid & 4278190080UL) >> 24));
  memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(lnum)));
  wp += (int )sizeof(lnum);
  repl->fd = fd;
  repl->sock = ttsocknew(fd);
  tmp___3 = tcmalloc(65536U);
  repl->rbuf = (char *)tmp___3;
  repl->rsiz = 65536;
  tmp___4 = ttsocksend(repl->sock, (void const   *)(buf), wp - buf);
  if (! tmp___4) {
    tcreplclose(repl);
    return ((_Bool)0);
  }
  tmp___5 = ttsockgetint32(repl->sock);
  repl->mid = (unsigned short )tmp___5;
  tmp___6 = ttsockcheckend(repl->sock);
  if (tmp___6) {
    tcreplclose(repl);
    return ((_Bool)0);
  } else {
    if ((int )repl->mid < 1) {
      tcreplclose(repl);
      return ((_Bool)0);
    }
  }
  return ((_Bool)1);
}
}
_Bool tcreplclose(TCREPL *repl ) 
{ _Bool err ;
  _Bool tmp ;

  {
  if (repl->fd < 0) {
    return ((_Bool)0);
  }
  err = (_Bool)0;
  tcfree((void *)repl->rbuf);
  ttsockdel(repl->sock);
  tmp = ttclosesock(repl->fd);
  if (! tmp) {
    err = (_Bool)1;
  }
  repl->fd = -1;
  repl->sock = (TTSOCK *)((void *)0);
  return ((_Bool )(! err));
}
}
char const   *tcreplread(TCREPL *repl , int *sp , uint64_t *tsp , uint32_t *sidp ) 
{ int ocs ;
  int c ;
  int tmp ;
  uint64_t ts ;
  uint64_t tmp___0 ;
  uint32_t sid ;
  uint32_t tmp___1 ;
  uint32_t rsiz ;
  uint32_t tmp___2 ;
  void *tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;

  {
  ocs = 1;
  pthread_setcancelstate(0, & ocs);
  ttsocksetlife(repl->sock, 60.0);
  tmp = ttsockgetc(repl->sock);
  c = tmp;
  if (c == 202) {
    *sp = 0;
    *tsp = 0ULL;
    *sidp = 0U;
    return ("");
  }
  if (c != 201) {
    pthread_setcancelstate(ocs, (int *)((void *)0));
    return ((char const   *)((void *)0));
  }
  tmp___0 = ttsockgetint64(repl->sock);
  ts = tmp___0;
  tmp___1 = ttsockgetint32(repl->sock);
  sid = tmp___1;
  tmp___2 = ttsockgetint32(repl->sock);
  rsiz = tmp___2;
  if ((unsigned int )repl->rsiz < rsiz + 1U) {
    tmp___3 = tcrealloc((void *)repl->rbuf, rsiz + 1U);
    repl->rbuf = (char *)tmp___3;
    repl->rsiz = (int )(rsiz + 1U);
  }
  tmp___4 = ttsockcheckend(repl->sock);
  if (tmp___4) {
    pthread_setcancelstate(ocs, (int *)((void *)0));
    return ((char const   *)((void *)0));
  } else {
    tmp___5 = ttsockrecv(repl->sock, repl->rbuf, (int )rsiz);
    if (tmp___5) {
      tmp___6 = ttsockcheckend(repl->sock);
      if (tmp___6) {
        pthread_setcancelstate(ocs, (int *)((void *)0));
        return ((char const   *)((void *)0));
      }
    } else {
      pthread_setcancelstate(ocs, (int *)((void *)0));
      return ((char const   *)((void *)0));
    }
  }
  *sp = (int )rsiz;
  *tsp = ts;
  *sidp = sid;
  pthread_setcancelstate(ocs, (int *)((void *)0));
  return ((char const   *)repl->rbuf);
}
}
static _Bool tculogflushaiocbp(struct aiocb *aiocbp ) 
{ _Bool err ;
  int rv ;
  int tmp ;
  int tmp___0 ;
  __ssize_t tmp___1 ;

  {
  if (! aiocbp->aio_buf) {
    return ((_Bool)1);
  }
  err = (_Bool)0;
  while (1) {
    tmp = aio_error((struct aiocb  const  *)aiocbp);
    rv = tmp;
    if (rv == 0) {
      break;
    }
    if (rv != 115) {
      err = (_Bool)1;
      break;
    }
    tmp___0 = aio_suspend((struct aiocb  const  * const  *)((void *)(& aiocbp)), 1,
                          (struct timespec  const  * __restrict  )((void *)0));
    if (tmp___0 == -1) {
      err = (_Bool)1;
    }
  }
  tcfree((void *)((char *)aiocbp->aio_buf));
  aiocbp->aio_buf = (void volatile   *)((void *)0);
  tmp___1 = aio_return(aiocbp);
  if ((unsigned int )tmp___1 != aiocbp->aio_nbytes) {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
#pragma merger(0,"/tmp/cil-VMNwvw6C.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
char const   *tcrdberrmsg(int ecode ) ;
TCRDB *tcrdbnew(void) ;
void tcrdbdel(TCRDB *rdb ) ;
int tcrdbecode(TCRDB *rdb ) ;
_Bool tcrdbtune(TCRDB *rdb , double timeout , int opts ) ;
_Bool tcrdbopen(TCRDB *rdb , char const   *host , int port ) ;
_Bool tcrdbopen2(TCRDB *rdb , char const   *expr ) ;
_Bool tcrdbclose(TCRDB *rdb ) ;
_Bool tcrdbput(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) ;
_Bool tcrdbput2(TCRDB *rdb , char const   *kstr , char const   *vstr ) ;
_Bool tcrdbputkeep(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) ;
_Bool tcrdbputkeep2(TCRDB *rdb , char const   *kstr , char const   *vstr ) ;
_Bool tcrdbputcat(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) ;
_Bool tcrdbputcat2(TCRDB *rdb , char const   *kstr , char const   *vstr ) ;
_Bool tcrdbputshl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz , int width ) ;
_Bool tcrdbputshl2(TCRDB *rdb , char const   *kstr , char const   *vstr , int width ) ;
_Bool tcrdbputnr(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                 int vsiz ) ;
_Bool tcrdbputnr2(TCRDB *rdb , char const   *kstr , char const   *vstr ) ;
_Bool tcrdbout(TCRDB *rdb , void const   *kbuf , int ksiz ) ;
_Bool tcrdbout2(TCRDB *rdb , char const   *kstr ) ;
void *tcrdbget(TCRDB *rdb , void const   *kbuf , int ksiz , int *sp ) ;
char *tcrdbget2(TCRDB *rdb , char const   *kstr ) ;
_Bool tcrdbget3(TCRDB *rdb , TCMAP *recs ) ;
int tcrdbvsiz(TCRDB *rdb , void const   *kbuf , int ksiz ) ;
int tcrdbvsiz2(TCRDB *rdb , char const   *kstr ) ;
_Bool tcrdbiterinit(TCRDB *rdb ) ;
void *tcrdbiternext(TCRDB *rdb , int *sp ) ;
char *tcrdbiternext2(TCRDB *rdb ) ;
TCLIST *tcrdbfwmkeys(TCRDB *rdb , void const   *pbuf , int psiz , int max ) ;
TCLIST *tcrdbfwmkeys2(TCRDB *rdb , char const   *pstr , int max ) ;
int tcrdbaddint(TCRDB *rdb , void const   *kbuf , int ksiz , int num ) ;
double tcrdbadddouble(TCRDB *rdb , void const   *kbuf , int ksiz , double num ) ;
void *tcrdbext(TCRDB *rdb , char const   *name , int opts , void const   *kbuf , int ksiz ,
               void const   *vbuf , int vsiz , int *sp ) ;
char *tcrdbext2(TCRDB *rdb , char const   *name , int opts , char const   *kstr ,
                char const   *vstr ) ;
_Bool tcrdbsync(TCRDB *rdb ) ;
_Bool tcrdboptimize(TCRDB *rdb , char const   *params ) ;
_Bool tcrdbvanish(TCRDB *rdb ) ;
_Bool tcrdbcopy(TCRDB *rdb , char const   *path ) ;
_Bool tcrdbrestore(TCRDB *rdb , char const   *path , uint64_t ts , int opts ) ;
_Bool tcrdbsetmst(TCRDB *rdb , char const   *host , int port , uint64_t ts , int opts ) ;
_Bool tcrdbsetmst2(TCRDB *rdb , char const   *expr , uint64_t ts , int opts ) ;
char const   *tcrdbexpr(TCRDB *rdb ) ;
uint64_t tcrdbrnum(TCRDB *rdb ) ;
uint64_t tcrdbsize(TCRDB *rdb ) ;
char *tcrdbstat(TCRDB *rdb ) ;
TCLIST *tcrdbmisc(TCRDB *rdb , char const   *name , int opts , TCLIST const   *args ) ;
_Bool tcrdbtblput(TCRDB *rdb , void const   *pkbuf , int pksiz , TCMAP *cols ) ;
_Bool tcrdbtblputkeep(TCRDB *rdb , void const   *pkbuf , int pksiz , TCMAP *cols ) ;
_Bool tcrdbtblputcat(TCRDB *rdb , void const   *pkbuf , int pksiz , TCMAP *cols ) ;
_Bool tcrdbtblout(TCRDB *rdb , void const   *pkbuf , int pksiz ) ;
TCMAP *tcrdbtblget(TCRDB *rdb , void const   *pkbuf , int pksiz ) ;
_Bool tcrdbtblsetindex(TCRDB *rdb , char const   *name , int type ) ;
int64_t tcrdbtblgenuid(TCRDB *rdb ) ;
RDBQRY *tcrdbqrynew(TCRDB *rdb ) ;
void tcrdbqrydel(RDBQRY *qry ) ;
void tcrdbqryaddcond(RDBQRY *qry , char const   *name , int op , char const   *expr ) ;
void tcrdbqrysetorder(RDBQRY *qry , char const   *name , int type ) ;
void tcrdbqrysetlimit(RDBQRY *qry , int max , int skip ) ;
TCLIST *tcrdbqrysearch(RDBQRY *qry ) ;
_Bool tcrdbqrysearchout(RDBQRY *qry ) ;
TCLIST *tcrdbqrysearchget(RDBQRY *qry ) ;
TCMAP *tcrdbqryrescols(TCLIST *res , int index___0 ) ;
int tcrdbqrysearchcount(RDBQRY *qry ) ;
char const   *tcrdbqryhint(RDBQRY *qry ) ;
TCLIST *tcrdbmetasearch(RDBQRY **qrys , int num , int type ) ;
void tcrdbsetecode(TCRDB *rdb , int ecode ) ;
static _Bool tcrdblockmethod(TCRDB *rdb ) ;
static void tcrdbunlockmethod(TCRDB *rdb ) ;
static _Bool tcrdbreconnect(TCRDB *rdb ) ;
static _Bool tcrdbsend(TCRDB *rdb , void const   *buf , int size ) ;
static _Bool tcrdbtuneimpl(TCRDB *rdb , double timeout , int opts ) ;
static _Bool tcrdbopenimpl(TCRDB *rdb , char const   *host , int port ) ;
static _Bool tcrdbcloseimpl(TCRDB *rdb ) ;
static _Bool tcrdbputimpl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                          int vsiz ) ;
static _Bool tcrdbputkeepimpl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                              int vsiz ) ;
static _Bool tcrdbputcatimpl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                             int vsiz ) ;
static _Bool tcrdbputshlimpl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                             int vsiz , int width ) ;
static _Bool tcrdbputnrimpl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                            int vsiz ) ;
static _Bool tcrdboutimpl(TCRDB *rdb , void const   *kbuf , int ksiz ) ;
static void *tcrdbgetimpl(TCRDB *rdb , void const   *kbuf , int ksiz , int *sp ) ;
static _Bool tcrdbmgetimpl(TCRDB *rdb , TCMAP *recs ) ;
static int tcrdbvsizimpl(TCRDB *rdb , void const   *kbuf , int ksiz ) ;
static _Bool tcrdbiterinitimpl(TCRDB *rdb ) ;
static void *tcrdbiternextimpl(TCRDB *rdb , int *sp ) ;
static TCLIST *tcrdbfwmkeysimpl(TCRDB *rdb , void const   *pbuf , int psiz , int max ) ;
static int tcrdbaddintimpl(TCRDB *rdb , void const   *kbuf , int ksiz , int num ) ;
static double tcrdbadddoubleimpl(TCRDB *rdb , void const   *kbuf , int ksiz , double num ) ;
static void *tcrdbextimpl(TCRDB *rdb , char const   *name , int opts , void const   *kbuf ,
                          int ksiz , void const   *vbuf , int vsiz , int *sp ) ;
static _Bool tcrdbsyncimpl(TCRDB *rdb ) ;
static _Bool tcrdboptimizeimpl(TCRDB *rdb , char const   *params ) ;
static _Bool tcrdbvanishimpl(TCRDB *rdb ) ;
static _Bool tcrdbcopyimpl(TCRDB *rdb , char const   *path ) ;
static _Bool tcrdbrestoreimpl(TCRDB *rdb , char const   *path , uint64_t ts , int opts ) ;
static _Bool tcrdbsetmstimpl(TCRDB *rdb , char const   *host , int port , uint64_t ts ,
                             int opts ) ;
char const   *tcrdbexprimpl(TCRDB *rdb ) ;
static uint64_t tcrdbrnumimpl(TCRDB *rdb ) ;
static uint64_t tcrdbsizeimpl(TCRDB *rdb ) ;
static char *tcrdbstatimpl(TCRDB *rdb ) ;
static TCLIST *tcrdbmiscimpl(TCRDB *rdb , char const   *name , int opts , TCLIST const   *args ) ;
static void tcrdbqrypopmeta(RDBQRY *qry , TCLIST *res ) ;
char const   *tcrdberrmsg(int ecode ) 
{ 

  {
  switch (ecode) {
  case 0: 
  return ("success");
  case 1: 
  return ("invalid operation");
  case 2: 
  return ("host not found");
  case 3: 
  return ("connection refused");
  case 4: 
  return ("send error");
  case 5: 
  return ("recv error");
  case 6: 
  return ("existing record");
  case 7: 
  return ("no record found");
  case 9999: 
  return ("miscellaneous error");
  }
  return ("unknown error");
}
}
TCRDB *tcrdbnew(void) 
{ TCRDB *rdb ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  tmp = tcmalloc((unsigned int )((int )sizeof(*rdb)));
  rdb = (TCRDB *)tmp;
  tmp___0 = pthread_mutex_init(& rdb->mmtx, (pthread_mutexattr_t const   *)((void *)0));
  if (tmp___0 != 0) {
    tcmyfatal("pthread_mutex_init failed");
  }
  tmp___1 = pthread_key_create(& rdb->eckey, (void (*)(void * ))((void *)0));
  if (tmp___1 != 0) {
    tcmyfatal("pthread_key_create failed");
  }
  rdb->host = (char *)((void *)0);
  rdb->port = -1;
  rdb->expr = (char *)((void *)0);
  rdb->fd = -1;
  rdb->sock = (TTSOCK *)((void *)0);
  rdb->timeout = (double )4294967295U;
  rdb->opts = 0;
  tcrdbsetecode(rdb, 0);
  return (rdb);
}
}
void tcrdbdel(TCRDB *rdb ) 
{ 

  {
  if (rdb->fd >= 0) {
    tcrdbclose(rdb);
  }
  if (rdb->expr) {
    tcfree((void *)rdb->expr);
  }
  if (rdb->host) {
    tcfree((void *)rdb->host);
  }
  pthread_key_delete(rdb->eckey);
  pthread_mutex_destroy(& rdb->mmtx);
  tcfree((void *)rdb);
  return;
}
}
int tcrdbecode(TCRDB *rdb ) 
{ void *tmp ;

  {
  tmp = pthread_getspecific(rdb->eckey);
  return ((int )tmp);
}
}
_Bool tcrdbtune(TCRDB *rdb , double timeout , int opts ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbtuneimpl(rdb, timeout, opts);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbopen(TCRDB *rdb , char const   *host , int port ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbopenimpl(rdb, host, port);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbopen2(TCRDB *rdb , char const   *expr ) 
{ _Bool err ;
  int port ;
  char *host ;
  char *tmp ;
  char *pv ;
  char *tmp___1 ;
  double tout ;
  TCLIST *elems ;
  TCLIST *tmp___2 ;
  int ln ;
  int tmp___3 ;
  int i ;
  char const   *elem ;
  char *tmp___5 ;
  char *tmp___6 ;
  int64_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;

  {
  err = (_Bool)0;
  tmp = ttbreakservexpr(expr, & port);
  host = tmp;
  tmp___1 = __builtin_strchr((char *)expr, '#');
  pv = tmp___1;
  tout = 0.0;
  if (pv) {
    tmp___2 = tcstrsplit((char const   *)(pv + 1), "#");
    elems = tmp___2;
    tmp___3 = tclistnum((TCLIST const   *)elems);
    ln = tmp___3;
    i = 0;
    while (i < ln) {
      elem = (char const   *)((void *)(elems->array + (i + elems->start))->ptr);
      tmp___5 = __builtin_strchr((char *)elem, '=');
      pv = tmp___5;
      if (! pv) {
        goto __Cont;
      }
      tmp___6 = pv;
      pv ++;
      *tmp___6 = (char )'\000';
      tmp___11 = tcstricmp(elem, "host");
      if (tmp___11) {
        tmp___12 = tcstricmp(elem, "name");
        if (tmp___12) {
          tmp___10 = tcstricmp(elem, "port");
          if (tmp___10) {
            tmp___8 = tcstricmp(elem, "tout");
            if (tmp___8) {
              tmp___9 = tcstricmp(elem, "timeout");
              if (! tmp___9) {
                tout = tcatof((char const   *)pv);
              }
            } else {
              tout = tcatof((char const   *)pv);
            }
          } else {
            tmp___7 = tcatoi((char const   *)pv);
            port = (int )tmp___7;
          }
        } else {
          tcfree((void *)host);
          host = ttbreakservexpr((char const   *)pv, (int *)((void *)0));
        }
      } else {
        tcfree((void *)host);
        host = ttbreakservexpr((char const   *)pv, (int *)((void *)0));
      }
      __Cont: 
      i ++;
    }
    tclistdel(elems);
  }
  if (tout > (double )0) {
    tcrdbtune(rdb, tout, 1);
  }
  tmp___13 = tcrdbopen(rdb, (char const   *)host, port);
  if (! tmp___13) {
    err = (_Bool)1;
  }
  tcfree((void *)host);
  return ((_Bool )(! err));
}
}
_Bool tcrdbclose(TCRDB *rdb ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbcloseimpl(rdb);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbput(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf , int vsiz ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbputimpl(rdb, kbuf, ksiz, vbuf, vsiz);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbput2(TCRDB *rdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcrdbput(rdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                     (int )tmp);
  return (tmp___1);
}
}
_Bool tcrdbputkeep(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                   int vsiz ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbputkeepimpl(rdb, kbuf, ksiz, vbuf, vsiz);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbputkeep2(TCRDB *rdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcrdbputkeep(rdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                         (int )tmp);
  return (tmp___1);
}
}
_Bool tcrdbputcat(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbputcatimpl(rdb, kbuf, ksiz, vbuf, vsiz);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbputcat2(TCRDB *rdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcrdbputcat(rdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                        (int )tmp);
  return (tmp___1);
}
}
_Bool tcrdbputshl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                  int vsiz , int width ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbputshlimpl(rdb, kbuf, ksiz, vbuf, vsiz, width);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbputshl2(TCRDB *rdb , char const   *kstr , char const   *vstr , int width ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcrdbputshl(rdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                        (int )tmp, width);
  return (tmp___1);
}
}
_Bool tcrdbputnr(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                 int vsiz ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbputnrimpl(rdb, kbuf, ksiz, vbuf, vsiz);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbputnr2(TCRDB *rdb , char const   *kstr , char const   *vstr ) 
{ size_t tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcrdbputnr(rdb, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                       (int )tmp);
  return (tmp___1);
}
}
_Bool tcrdbout(TCRDB *rdb , void const   *kbuf , int ksiz ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdboutimpl(rdb, kbuf, ksiz);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbout2(TCRDB *rdb , char const   *kstr ) 
{ size_t tmp ;
  _Bool tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcrdbout(rdb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
void *tcrdbget(TCRDB *rdb , void const   *kbuf , int ksiz , int *sp ) 
{ _Bool tmp ;
  void *rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((void *)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbgetimpl(rdb, kbuf, ksiz, sp);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
char *tcrdbget2(TCRDB *rdb , char const   *kstr ) 
{ int vsiz ;
  size_t tmp ;
  void *tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcrdbget(rdb, (void const   *)kstr, (int )tmp, & vsiz);
  return ((char *)tmp___0);
}
}
_Bool tcrdbget3(TCRDB *rdb , TCMAP *recs ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbmgetimpl(rdb, recs);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
int tcrdbvsiz(TCRDB *rdb , void const   *kbuf , int ksiz ) 
{ _Bool tmp ;
  int rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return (-1);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbvsizimpl(rdb, kbuf, ksiz);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
int tcrdbvsiz2(TCRDB *rdb , char const   *kstr ) 
{ size_t tmp ;
  int tmp___0 ;

  {
  tmp = strlen(kstr);
  tmp___0 = tcrdbvsiz(rdb, (void const   *)kstr, (int )tmp);
  return (tmp___0);
}
}
_Bool tcrdbiterinit(TCRDB *rdb ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbiterinitimpl(rdb);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
void *tcrdbiternext(TCRDB *rdb , int *sp ) 
{ _Bool tmp ;
  void *rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((void *)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbiternextimpl(rdb, sp);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
char *tcrdbiternext2(TCRDB *rdb ) 
{ int vsiz ;
  void *tmp ;

  {
  tmp = tcrdbiternext(rdb, & vsiz);
  return ((char *)tmp);
}
}
TCLIST *tcrdbfwmkeys(TCRDB *rdb , void const   *pbuf , int psiz , int max ) 
{ TCLIST *tmp ;
  _Bool tmp___0 ;
  TCLIST *rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp___0 = tcrdblockmethod(rdb);
  if (! tmp___0) {
    tmp = tclistnew2(1);
    return (tmp);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___1;
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___2) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbfwmkeysimpl(rdb, pbuf, psiz, max);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
TCLIST *tcrdbfwmkeys2(TCRDB *rdb , char const   *pstr , int max ) 
{ size_t tmp ;
  TCLIST *tmp___0 ;

  {
  tmp = strlen(pstr);
  tmp___0 = tcrdbfwmkeys(rdb, (void const   *)pstr, (int )tmp, max);
  return (tmp___0);
}
}
int tcrdbaddint(TCRDB *rdb , void const   *kbuf , int ksiz , int num ) 
{ _Bool tmp ;
  int rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((-0x7FFFFFFF-1));
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbaddintimpl(rdb, kbuf, ksiz, num);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
double tcrdbadddouble(TCRDB *rdb , void const   *kbuf , int ksiz , double num ) 
{ double tmp ;
  _Bool tmp___0 ;
  double rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;

  {
  tmp___0 = tcrdblockmethod(rdb);
  if (! tmp___0) {
    tmp = nan("");
    return (tmp);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___1;
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___2) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbadddoubleimpl(rdb, kbuf, ksiz, num);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
void *tcrdbext(TCRDB *rdb , char const   *name , int opts , void const   *kbuf , int ksiz ,
               void const   *vbuf , int vsiz , int *sp ) 
{ _Bool tmp ;
  void *rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((void *)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbextimpl(rdb, name, opts, kbuf, ksiz, vbuf, vsiz, sp);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
char *tcrdbext2(TCRDB *rdb , char const   *name , int opts , char const   *kstr ,
                char const   *vstr ) 
{ int vsiz ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  tmp = strlen(vstr);
  tmp___0 = strlen(kstr);
  tmp___1 = tcrdbext(rdb, name, opts, (void const   *)kstr, (int )tmp___0, (void const   *)vstr,
                     (int )tmp, & vsiz);
  return ((char *)tmp___1);
}
}
_Bool tcrdbsync(TCRDB *rdb ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbsyncimpl(rdb);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdboptimize(TCRDB *rdb , char const   *params ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdboptimizeimpl(rdb, params);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbvanish(TCRDB *rdb ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbvanishimpl(rdb);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbcopy(TCRDB *rdb , char const   *path ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbcopyimpl(rdb, path);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbrestore(TCRDB *rdb , char const   *path , uint64_t ts , int opts ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbrestoreimpl(rdb, path, ts, opts);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbsetmst(TCRDB *rdb , char const   *host , int port , uint64_t ts , int opts ) 
{ _Bool tmp ;
  _Bool rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((_Bool)0);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbsetmstimpl(rdb, host, port, ts, opts);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbsetmst2(TCRDB *rdb , char const   *expr , uint64_t ts , int opts ) 
{ _Bool err ;
  int port ;
  char *host ;
  char *tmp ;
  _Bool tmp___0 ;

  {
  err = (_Bool)0;
  tmp = ttbreakservexpr(expr, & port);
  host = tmp;
  tmp___0 = tcrdbsetmst(rdb, (char const   *)host, port, ts, opts);
  if (! tmp___0) {
    err = (_Bool)1;
  }
  tcfree((void *)host);
  return ((_Bool )(! err));
}
}
char const   *tcrdbexpr(TCRDB *rdb ) 
{ _Bool tmp ;
  char const   *rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((char const   *)((void *)0));
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbexprimpl(rdb);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
uint64_t tcrdbrnum(TCRDB *rdb ) 
{ _Bool tmp ;
  uint64_t rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return (0ULL);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbrnumimpl(rdb);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
uint64_t tcrdbsize(TCRDB *rdb ) 
{ _Bool tmp ;
  uint64_t rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return (0ULL);
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbsizeimpl(rdb);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
char *tcrdbstat(TCRDB *rdb ) 
{ _Bool tmp ;
  char *rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((char *)((void *)0));
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbstatimpl(rdb);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
TCLIST *tcrdbmisc(TCRDB *rdb , char const   *name , int opts , TCLIST const   *args ) 
{ _Bool tmp ;
  TCLIST *rv ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___0 ;
  long tmp___1 ;

  {
  tmp = tcrdblockmethod(rdb);
  if (! tmp) {
    return ((TCLIST *)((void *)0));
  }
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcrdbunlockmethod);
    __cancel_arg = (void *)rdb;
    tmp___0 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___0;
    tmp___1 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___1) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      rv = tcrdbmiscimpl(rdb, name, opts, args);
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (rv);
}
}
_Bool tcrdbtblput(TCRDB *rdb , void const   *pkbuf , int pksiz , TCMAP *cols ) 
{ TCLIST *args ;
  uint64_t tmp ;
  TCLIST *tmp___0 ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___1 ;
  void const   *tmp___2 ;
  TCLIST *rv ;
  TCLIST *tmp___3 ;

  {
  tmp = tcmaprnum((TCMAP const   *)cols);
  tmp___0 = tclistnew2((int )(tmp * 2ULL + 1ULL));
  args = tmp___0;
  tclistpush(args, pkbuf, pksiz);
  tcmapiterinit(cols);
  while (1) {
    tmp___2 = tcmapiternext(cols, & ksiz);
    kbuf = (char const   *)tmp___2;
    if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
      break;
    }
    tmp___1 = tcmapiterval((void const   *)kbuf, & vsiz);
    vbuf = (char const   *)tmp___1;
    tclistpush(args, (void const   *)kbuf, ksiz);
    tclistpush(args, (void const   *)vbuf, vsiz);
  }
  tmp___3 = tcrdbmisc(rdb, "put", 0, (TCLIST const   *)args);
  rv = tmp___3;
  tclistdel(args);
  if (! rv) {
    return ((_Bool)0);
  }
  tclistdel(rv);
  return ((_Bool)1);
}
}
_Bool tcrdbtblputkeep(TCRDB *rdb , void const   *pkbuf , int pksiz , TCMAP *cols ) 
{ TCLIST *args ;
  uint64_t tmp ;
  TCLIST *tmp___0 ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___1 ;
  void const   *tmp___2 ;
  TCLIST *rv ;
  TCLIST *tmp___3 ;
  int tmp___4 ;

  {
  tmp = tcmaprnum((TCMAP const   *)cols);
  tmp___0 = tclistnew2((int )(tmp * 2ULL + 1ULL));
  args = tmp___0;
  tclistpush(args, pkbuf, pksiz);
  tcmapiterinit(cols);
  while (1) {
    tmp___2 = tcmapiternext(cols, & ksiz);
    kbuf = (char const   *)tmp___2;
    if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
      break;
    }
    tmp___1 = tcmapiterval((void const   *)kbuf, & vsiz);
    vbuf = (char const   *)tmp___1;
    tclistpush(args, (void const   *)kbuf, ksiz);
    tclistpush(args, (void const   *)vbuf, vsiz);
  }
  tmp___3 = tcrdbmisc(rdb, "putkeep", 0, (TCLIST const   *)args);
  rv = tmp___3;
  tclistdel(args);
  if (! rv) {
    tmp___4 = tcrdbecode(rdb);
    if (tmp___4 == 9999) {
      tcrdbsetecode(rdb, 6);
    }
    return ((_Bool)0);
  }
  tclistdel(rv);
  return ((_Bool)1);
}
}
_Bool tcrdbtblputcat(TCRDB *rdb , void const   *pkbuf , int pksiz , TCMAP *cols ) 
{ TCLIST *args ;
  uint64_t tmp ;
  TCLIST *tmp___0 ;
  char const   *kbuf ;
  int ksiz ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___1 ;
  void const   *tmp___2 ;
  TCLIST *rv ;
  TCLIST *tmp___3 ;

  {
  tmp = tcmaprnum((TCMAP const   *)cols);
  tmp___0 = tclistnew2((int )(tmp * 2ULL + 1ULL));
  args = tmp___0;
  tclistpush(args, pkbuf, pksiz);
  tcmapiterinit(cols);
  while (1) {
    tmp___2 = tcmapiternext(cols, & ksiz);
    kbuf = (char const   *)tmp___2;
    if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
      break;
    }
    tmp___1 = tcmapiterval((void const   *)kbuf, & vsiz);
    vbuf = (char const   *)tmp___1;
    tclistpush(args, (void const   *)kbuf, ksiz);
    tclistpush(args, (void const   *)vbuf, vsiz);
  }
  tmp___3 = tcrdbmisc(rdb, "putcat", 0, (TCLIST const   *)args);
  rv = tmp___3;
  tclistdel(args);
  if (! rv) {
    return ((_Bool)0);
  }
  tclistdel(rv);
  return ((_Bool)1);
}
}
_Bool tcrdbtblout(TCRDB *rdb , void const   *pkbuf , int pksiz ) 
{ TCLIST *args ;
  TCLIST *tmp ;
  TCLIST *rv ;
  TCLIST *tmp___0 ;
  int tmp___1 ;

  {
  tmp = tclistnew2(1);
  args = tmp;
  tclistpush(args, pkbuf, pksiz);
  tmp___0 = tcrdbmisc(rdb, "out", 0, (TCLIST const   *)args);
  rv = tmp___0;
  tclistdel(args);
  if (! rv) {
    tmp___1 = tcrdbecode(rdb);
    if (tmp___1 == 9999) {
      tcrdbsetecode(rdb, 7);
    }
    return ((_Bool)0);
  }
  tclistdel(rv);
  return ((_Bool)1);
}
}
TCMAP *tcrdbtblget(TCRDB *rdb , void const   *pkbuf , int pksiz ) 
{ TCLIST *args ;
  TCLIST *tmp ;
  TCLIST *rv ;
  TCLIST *tmp___0 ;
  int tmp___1 ;
  int num ;
  int tmp___2 ;
  TCMAP *cols ;
  TCMAP *tmp___3 ;
  int i ;
  int ksiz ;
  char const   *kbuf ;
  void const   *tmp___4 ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___5 ;

  {
  tmp = tclistnew2(1);
  args = tmp;
  tclistpush(args, pkbuf, pksiz);
  tmp___0 = tcrdbmisc(rdb, "get", 1, (TCLIST const   *)args);
  rv = tmp___0;
  tclistdel(args);
  if (! rv) {
    tmp___1 = tcrdbecode(rdb);
    if (tmp___1 == 9999) {
      tcrdbsetecode(rdb, 7);
    }
    return ((TCMAP *)((void *)0));
  }
  tmp___2 = tclistnum((TCLIST const   *)rv);
  num = tmp___2;
  tmp___3 = tcmapnew2((unsigned int )(num / 2 + 1));
  cols = tmp___3;
  num --;
  i = 0;
  while (i < num) {
    tmp___4 = tclistval((TCLIST const   *)rv, i, & ksiz);
    kbuf = (char const   *)tmp___4;
    tmp___5 = tclistval((TCLIST const   *)rv, i + 1, & vsiz);
    vbuf = (char const   *)tmp___5;
    tcmapput(cols, (void const   *)kbuf, ksiz, (void const   *)vbuf, vsiz);
    i += 2;
  }
  tclistdel(rv);
  return (cols);
}
}
_Bool tcrdbtblsetindex(TCRDB *rdb , char const   *name , int type ) 
{ TCLIST *args ;
  TCLIST *tmp ;
  char typestr[32] ;
  TCLIST *rv ;
  TCLIST *tmp___0 ;

  {
  tmp = tclistnew2(2);
  args = tmp;
  tclistpush2(args, name);
  sprintf((char * __restrict  )(typestr), (char const   * __restrict  )"%d", type);
  tclistpush2(args, (char const   *)(typestr));
  tmp___0 = tcrdbmisc(rdb, "setindex", 0, (TCLIST const   *)args);
  rv = tmp___0;
  tclistdel(args);
  if (! rv) {
    return ((_Bool)0);
  }
  tclistdel(rv);
  return ((_Bool)1);
}
}
int64_t tcrdbtblgenuid(TCRDB *rdb ) 
{ TCLIST *args ;
  TCLIST *tmp ;
  TCLIST *rv ;
  TCLIST *tmp___0 ;
  int64_t uid ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  tmp = tclistnew2(1);
  args = tmp;
  tmp___0 = tcrdbmisc(rdb, "genuid", 0, (TCLIST const   *)args);
  rv = tmp___0;
  tclistdel(args);
  if (! rv) {
    return (-1LL);
  }
  uid = -1LL;
  tmp___2 = tclistnum((TCLIST const   *)rv);
  if (tmp___2 > 0) {
    tmp___1 = tclistval2((TCLIST const   *)rv, 0);
    uid = tcatoi(tmp___1);
  }
  tclistdel(rv);
  return (uid);
}
}
RDBQRY *tcrdbqrynew(TCRDB *rdb ) 
{ RDBQRY *qry ;
  void *tmp ;

  {
  tmp = tcmalloc((unsigned int )((int )sizeof(*qry)));
  qry = (RDBQRY *)tmp;
  qry->rdb = rdb;
  qry->args = tclistnew();
  qry->hint = tcxstrnew();
  tclistpush(qry->args, (void const   *)"hint", 4);
  return (qry);
}
}
void tcrdbqrydel(RDBQRY *qry ) 
{ 

  {
  tcxstrdel(qry->hint);
  tclistdel(qry->args);
  tcfree((void *)qry);
  return;
}
}
void tcrdbqryaddcond(RDBQRY *qry , char const   *name , int op , char const   *expr ) 
{ TCXSTR *xstr ;
  TCXSTR *tmp ;
  int tmp___0 ;
  void const   *tmp___1 ;

  {
  tmp = tcxstrnew();
  xstr = tmp;
  tcxstrcat2(xstr, "addcond");
  tcxstrcat(xstr, (void const   *)"\000", 1);
  tcxstrcat2(xstr, name);
  tcxstrcat(xstr, (void const   *)"\000", 1);
  tcxstrprintf(xstr, "%d", op);
  tcxstrcat(xstr, (void const   *)"\000", 1);
  tcxstrcat2(xstr, expr);
  tmp___0 = tcxstrsize((TCXSTR const   *)xstr);
  tmp___1 = tcxstrptr((TCXSTR const   *)xstr);
  tclistpush(qry->args, tmp___1, tmp___0);
  tcxstrdel(xstr);
  return;
}
}
void tcrdbqrysetorder(RDBQRY *qry , char const   *name , int type ) 
{ TCXSTR *xstr ;
  TCXSTR *tmp ;
  int tmp___0 ;
  void const   *tmp___1 ;

  {
  tmp = tcxstrnew();
  xstr = tmp;
  tcxstrcat2(xstr, "setorder");
  tcxstrcat(xstr, (void const   *)"\000", 1);
  tcxstrcat2(xstr, name);
  tcxstrcat(xstr, (void const   *)"\000", 1);
  tcxstrprintf(xstr, "%d", type);
  tmp___0 = tcxstrsize((TCXSTR const   *)xstr);
  tmp___1 = tcxstrptr((TCXSTR const   *)xstr);
  tclistpush(qry->args, tmp___1, tmp___0);
  tcxstrdel(xstr);
  return;
}
}
void tcrdbqrysetlimit(RDBQRY *qry , int max , int skip ) 
{ TCXSTR *xstr ;
  TCXSTR *tmp ;
  int tmp___0 ;
  void const   *tmp___1 ;

  {
  tmp = tcxstrnew();
  xstr = tmp;
  tcxstrcat2(xstr, "setlimit");
  tcxstrcat(xstr, (void const   *)"\000", 1);
  tcxstrprintf(xstr, "%d", max);
  tcxstrcat(xstr, (void const   *)"\000", 1);
  tcxstrprintf(xstr, "%d", skip);
  tmp___0 = tcxstrsize((TCXSTR const   *)xstr);
  tmp___1 = tcxstrptr((TCXSTR const   *)xstr);
  tclistpush(qry->args, tmp___1, tmp___0);
  tcxstrdel(xstr);
  return;
}
}
TCLIST *tcrdbqrysearch(RDBQRY *qry ) 
{ TCLIST *rv ;
  TCLIST *tmp ;
  TCLIST *tmp___0 ;

  {
  tcxstrclear(qry->hint);
  tmp = tcrdbmisc(qry->rdb, "search", 1, (TCLIST const   *)qry->args);
  rv = tmp;
  if (! rv) {
    tmp___0 = tclistnew2(1);
    return (tmp___0);
  }
  tcrdbqrypopmeta(qry, rv);
  return (rv);
}
}
_Bool tcrdbqrysearchout(RDBQRY *qry ) 
{ TCLIST *args ;
  TCLIST *tmp ;
  TCLIST *rv ;
  TCLIST *tmp___0 ;

  {
  tmp = tclistdup((TCLIST const   *)qry->args);
  args = tmp;
  tclistpush2(args, "out");
  tcxstrclear(qry->hint);
  tmp___0 = tcrdbmisc(qry->rdb, "search", 0, (TCLIST const   *)args);
  rv = tmp___0;
  tclistdel(args);
  if (! rv) {
    return ((_Bool)0);
  }
  tcrdbqrypopmeta(qry, rv);
  tclistdel(rv);
  return ((_Bool)1);
}
}
TCLIST *tcrdbqrysearchget(RDBQRY *qry ) 
{ TCLIST *args ;
  TCLIST *tmp ;
  TCLIST *rv ;
  TCLIST *tmp___0 ;
  TCLIST *tmp___1 ;

  {
  tmp = tclistdup((TCLIST const   *)qry->args);
  args = tmp;
  tclistpush2(args, "get");
  tcxstrclear(qry->hint);
  tmp___0 = tcrdbmisc(qry->rdb, "search", 1, (TCLIST const   *)args);
  rv = tmp___0;
  tclistdel(args);
  if (! rv) {
    tmp___1 = tclistnew2(1);
    return (tmp___1);
  }
  tcrdbqrypopmeta(qry, rv);
  return (rv);
}
}
TCMAP *tcrdbqryrescols(TCLIST *res , int index___0 ) 
{ int tmp ;
  int csiz ;
  char const   *cbuf ;
  void const   *tmp___0 ;
  TCMAP *tmp___1 ;

  {
  tmp = tclistnum((TCLIST const   *)res);
  if (index___0 >= tmp) {
    return ((TCMAP *)((void *)0));
  }
  tmp___0 = tclistval((TCLIST const   *)res, index___0, & csiz);
  cbuf = (char const   *)tmp___0;
  tmp___1 = tcstrsplit4((void const   *)cbuf, csiz);
  return (tmp___1);
}
}
int tcrdbqrysearchcount(RDBQRY *qry ) 
{ TCLIST *args ;
  TCLIST *tmp ;
  TCLIST *rv ;
  TCLIST *tmp___0 ;
  int count ;
  char const   *tmp___2 ;
  int64_t tmp___3 ;
  int64_t tmp___4 ;
  int tmp___5 ;

  {
  tmp = tclistdup((TCLIST const   *)qry->args);
  args = tmp;
  tclistpush2(args, "count");
  tcxstrclear(qry->hint);
  tmp___0 = tcrdbmisc(qry->rdb, "search", 1, (TCLIST const   *)args);
  rv = tmp___0;
  tclistdel(args);
  if (! rv) {
    return (0);
  }
  tcrdbqrypopmeta(qry, rv);
  tmp___5 = tclistnum((TCLIST const   *)rv);
  if (tmp___5 > 0) {
    tmp___2 = tclistval2((TCLIST const   *)rv, 0);
    tmp___3 = tcatoi(tmp___2);
    tmp___4 = tmp___3;
  } else {
    tmp___4 = 0LL;
  }
  count = (int )tmp___4;
  tclistdel(rv);
  return (count);
}
}
char const   *tcrdbqryhint(RDBQRY *qry ) 
{ void const   *tmp ;

  {
  tmp = tcxstrptr((TCXSTR const   *)qry->hint);
  return ((char const   *)tmp);
}
}
TCLIST *tcrdbmetasearch(RDBQRY **qrys , int num , int type ) 
{ TCLIST *tmp ;
  TCLIST *tmp___0 ;
  RDBQRY *qry ;
  TCLIST *args ;
  TCLIST *tmp___1 ;
  int i ;
  TCLIST const   *targs ;
  int tanum ;
  int tmp___2 ;
  int j ;
  int vsiz ;
  char const   *vbuf ;
  void const   *tmp___3 ;
  char buf[32] ;
  int len ;
  int tmp___4 ;
  int tmp___5 ;
  TCLIST *rv ;
  TCLIST *tmp___6 ;

  {
  if (num < 1) {
    tmp = tclistnew2(1);
    return (tmp);
  }
  if (num < 2) {
    tmp___0 = tcrdbqrysearch(*(qrys + 0));
    return (tmp___0);
  }
  qry = *(qrys + 0);
  tmp___1 = tclistdup((TCLIST const   *)qry->args);
  args = tmp___1;
  i = 1;
  while (i < num) {
    tclistpush(args, (void const   *)"next", 4);
    targs = (TCLIST const   *)(*(qrys + i))->args;
    tmp___2 = tclistnum(targs);
    tanum = tmp___2;
    j = 0;
    while (j < tanum) {
      tmp___3 = tclistval(targs, j, & vsiz);
      vbuf = (char const   *)tmp___3;
      tclistpush(args, (void const   *)vbuf, vsiz);
      j ++;
    }
    i ++;
  }
  tmp___4 = sprintf((char * __restrict  )(buf), (char const   * __restrict  )"mstype");
  len = tmp___4;
  tmp___5 = sprintf((char * __restrict  )((buf + len) + 1), (char const   * __restrict  )"%d",
                    type);
  len += 1 + tmp___5;
  tclistpush(args, (void const   *)(buf), len);
  tcxstrclear(qry->hint);
  tmp___6 = tcrdbmisc(qry->rdb, "metasearch", 1, (TCLIST const   *)args);
  rv = tmp___6;
  tclistdel(args);
  if (! rv) {
    rv = tclistnew2(1);
  }
  tcrdbqrypopmeta(*(qrys + 0), rv);
  return (rv);
}
}
void tcrdbsetecode(TCRDB *rdb , int ecode ) 
{ 

  {
  pthread_setspecific(rdb->eckey, (void const   *)((void *)ecode));
  return;
}
}
static _Bool tcrdblockmethod(TCRDB *rdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_lock(& rdb->mmtx);
  if (tmp != 0) {
    tcrdbsetecode(rdb, 9999);
    return ((_Bool)0);
  }
  return ((_Bool)1);
}
}
static void tcrdbunlockmethod(TCRDB *rdb ) 
{ int tmp ;

  {
  tmp = pthread_mutex_unlock(& rdb->mmtx);
  if (tmp != 0) {
    tcrdbsetecode(rdb, 9999);
  }
  return;
}
}
static _Bool tcrdbreconnect(TCRDB *rdb ) 
{ int fd ;
  char addr[1024] ;
  _Bool tmp ;

  {
  if (rdb->sock) {
    ttsockdel(rdb->sock);
    ttclosesock(rdb->fd);
    rdb->fd = -1;
    rdb->sock = (TTSOCK *)((void *)0);
  }
  if (rdb->port < 1) {
    fd = ttopensockunix((char const   *)rdb->host);
  } else {
    tmp = ttgethostaddr((char const   *)rdb->host, addr);
    if (! tmp) {
      tcrdbsetecode(rdb, 2);
      return ((_Bool)0);
    }
    fd = ttopensock((char const   *)(addr), rdb->port);
  }
  if (fd == -1) {
    tcrdbsetecode(rdb, 3);
    return ((_Bool)0);
  }
  rdb->fd = fd;
  rdb->sock = ttsocknew(fd);
  return ((_Bool)1);
}
}
static _Bool tcrdbsend(TCRDB *rdb , void const   *buf , int size ) 
{ _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;

  {
  tmp___1 = ttsockcheckend(rdb->sock);
  if (tmp___1) {
    if (! (rdb->opts & 1)) {
      return ((_Bool)0);
    }
    tcsleep(0.1);
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
    tmp___0 = ttsocksend(rdb->sock, buf, size);
    if (tmp___0) {
      return ((_Bool)1);
    }
    tcrdbsetecode(rdb, 4);
    return ((_Bool)0);
  }
  ttsocksetlife(rdb->sock, rdb->timeout);
  tmp___2 = ttsocksend(rdb->sock, buf, size);
  if (tmp___2) {
    return ((_Bool)1);
  }
  tcrdbsetecode(rdb, 4);
  if (! (rdb->opts & 1)) {
    return ((_Bool)0);
  }
  tcsleep(0.1);
  tmp___3 = tcrdbreconnect(rdb);
  if (! tmp___3) {
    return ((_Bool)0);
  }
  ttsocksetlife(rdb->sock, rdb->timeout);
  tmp___4 = ttsocksend(rdb->sock, buf, size);
  if (tmp___4) {
    return ((_Bool)1);
  }
  tcrdbsetecode(rdb, 4);
  return ((_Bool)0);
}
}
static _Bool tcrdbtuneimpl(TCRDB *rdb , double timeout , int opts ) 
{ 

  {
  if (rdb->fd >= 0) {
    tcrdbsetecode(rdb, 1);
    return ((_Bool)0);
  }
  if (timeout > 0.0) {
    rdb->timeout = timeout;
  } else {
    rdb->timeout = (double )4294967295U;
  }
  rdb->opts = opts;
  return ((_Bool)1);
}
}
static _Bool tcrdbopenimpl(TCRDB *rdb , char const   *host , int port ) 
{ int fd ;
  char addr[1024] ;
  _Bool tmp ;

  {
  if (rdb->fd >= 0) {
    tcrdbsetecode(rdb, 1);
    return ((_Bool)0);
  }
  if (port < 1) {
    fd = ttopensockunix(host);
  } else {
    tmp = ttgethostaddr(host, addr);
    if (! tmp) {
      tcrdbsetecode(rdb, 2);
      return ((_Bool)0);
    }
    fd = ttopensock((char const   *)(addr), port);
  }
  if (fd == -1) {
    tcrdbsetecode(rdb, 3);
    return ((_Bool)0);
  }
  if (rdb->host) {
    tcfree((void *)rdb->host);
  }
  rdb->host = tcstrdup((void const   *)host);
  rdb->port = port;
  rdb->expr = tcsprintf("%s:%d", host, port);
  rdb->fd = fd;
  rdb->sock = ttsocknew(fd);
  return ((_Bool)1);
}
}
static _Bool tcrdbcloseimpl(TCRDB *rdb ) 
{ _Bool err ;
  _Bool tmp ;

  {
  if (rdb->fd < 0) {
    tcrdbsetecode(rdb, 1);
    return ((_Bool)0);
  }
  err = (_Bool)0;
  ttsockdel(rdb->sock);
  tmp = ttclosesock(rdb->fd);
  if (! tmp) {
    tcrdbsetecode(rdb, 9999);
    err = (_Bool)1;
  }
  tcfree((void *)rdb->expr);
  tcfree((void *)rdb->host);
  rdb->expr = (char *)((void *)0);
  rdb->host = (char *)((void *)0);
  rdb->port = -1;
  rdb->fd = -1;
  rdb->sock = (TTSOCK *)((void *)0);
  return ((_Bool )(! err));
}
}
static _Bool tcrdbputimpl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                          int vsiz ) 
{ _Bool tmp ;
  _Bool err ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___2 ;
  int not_first_call ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *wp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  uint32_t num ;
  int code ;
  int tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  rsiz = ((2 + (int )sizeof(uint32_t ) * 2) + ksiz) + vsiz;
  if (rsiz < 65536) {
    tmp___1 = stack;
  } else {
    tmp___0 = tcmalloc((unsigned int )rsiz);
    tmp___1 = (unsigned char *)tmp___0;
  }
  buf = tmp___1;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___2 = (unsigned char *)((void *)0);
    } else {
      tmp___2 = buf;
    }
    __cancel_arg = (void *)tmp___2;
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___3;
    tmp___4 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___4) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___5 = wp;
      wp ++;
      *tmp___5 = (unsigned char)200;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)16;
      num = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      num = (unsigned int )((((((unsigned long )((unsigned int )vsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )vsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )vsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )vsiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      wp += vsiz;
      tmp___9 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___9) {
        tmp___7 = ttsockgetc(rdb->sock);
        code = tmp___7;
        if (code != 0) {
          if (code == -1) {
            tmp___8 = 5;
          } else {
            tmp___8 = 9999;
          }
          tcrdbsetecode(rdb, tmp___8);
          err = (_Bool)1;
        }
      } else {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcrdbputkeepimpl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                              int vsiz ) 
{ _Bool tmp ;
  _Bool err ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___2 ;
  int not_first_call ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *wp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  uint32_t num ;
  int code ;
  int tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  rsiz = ((2 + (int )sizeof(uint32_t ) * 2) + ksiz) + vsiz;
  if (rsiz < 65536) {
    tmp___1 = stack;
  } else {
    tmp___0 = tcmalloc((unsigned int )rsiz);
    tmp___1 = (unsigned char *)tmp___0;
  }
  buf = tmp___1;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___2 = (unsigned char *)((void *)0);
    } else {
      tmp___2 = buf;
    }
    __cancel_arg = (void *)tmp___2;
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___3;
    tmp___4 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___4) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___5 = wp;
      wp ++;
      *tmp___5 = (unsigned char)200;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)17;
      num = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      num = (unsigned int )((((((unsigned long )((unsigned int )vsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )vsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )vsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )vsiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      wp += vsiz;
      tmp___9 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___9) {
        tmp___7 = ttsockgetc(rdb->sock);
        code = tmp___7;
        if (code != 0) {
          if (code == -1) {
            tmp___8 = 5;
          } else {
            tmp___8 = 6;
          }
          tcrdbsetecode(rdb, tmp___8);
          err = (_Bool)1;
        }
      } else {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcrdbputcatimpl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                             int vsiz ) 
{ _Bool tmp ;
  _Bool err ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___2 ;
  int not_first_call ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *wp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  uint32_t num ;
  int code ;
  int tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  rsiz = ((2 + (int )sizeof(uint32_t ) * 2) + ksiz) + vsiz;
  if (rsiz < 65536) {
    tmp___1 = stack;
  } else {
    tmp___0 = tcmalloc((unsigned int )rsiz);
    tmp___1 = (unsigned char *)tmp___0;
  }
  buf = tmp___1;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___2 = (unsigned char *)((void *)0);
    } else {
      tmp___2 = buf;
    }
    __cancel_arg = (void *)tmp___2;
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___3;
    tmp___4 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___4) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___5 = wp;
      wp ++;
      *tmp___5 = (unsigned char)200;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)18;
      num = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      num = (unsigned int )((((((unsigned long )((unsigned int )vsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )vsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )vsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )vsiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      wp += vsiz;
      tmp___9 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___9) {
        tmp___7 = ttsockgetc(rdb->sock);
        code = tmp___7;
        if (code != 0) {
          if (code == -1) {
            tmp___8 = 5;
          } else {
            tmp___8 = 9999;
          }
          tcrdbsetecode(rdb, tmp___8);
          err = (_Bool)1;
        }
      } else {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcrdbputshlimpl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                             int vsiz , int width ) 
{ _Bool tmp ;
  _Bool err ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___2 ;
  int not_first_call ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *wp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  uint32_t num ;
  int code ;
  int tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  rsiz = ((2 + (int )sizeof(uint32_t ) * 3) + ksiz) + vsiz;
  if (rsiz < 65536) {
    tmp___1 = stack;
  } else {
    tmp___0 = tcmalloc((unsigned int )rsiz);
    tmp___1 = (unsigned char *)tmp___0;
  }
  buf = tmp___1;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___2 = (unsigned char *)((void *)0);
    } else {
      tmp___2 = buf;
    }
    __cancel_arg = (void *)tmp___2;
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___3;
    tmp___4 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___4) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___5 = wp;
      wp ++;
      *tmp___5 = (unsigned char)200;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)19;
      num = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      num = (unsigned int )((((((unsigned long )((unsigned int )vsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )vsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )vsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )vsiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      num = (unsigned int )((((((unsigned long )((unsigned int )width) & 255UL) << 24) | (((unsigned long )((unsigned int )width) & 65280UL) << 8)) | (((unsigned long )((unsigned int )width) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )width) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      wp += vsiz;
      tmp___9 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___9) {
        tmp___7 = ttsockgetc(rdb->sock);
        code = tmp___7;
        if (code != 0) {
          if (code == -1) {
            tmp___8 = 5;
          } else {
            tmp___8 = 9999;
          }
          tcrdbsetecode(rdb, tmp___8);
          err = (_Bool)1;
        }
      } else {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcrdbputnrimpl(TCRDB *rdb , void const   *kbuf , int ksiz , void const   *vbuf ,
                            int vsiz ) 
{ _Bool tmp ;
  _Bool err ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___2 ;
  int not_first_call ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *wp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  uint32_t num ;
  _Bool tmp___7 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  rsiz = ((2 + (int )sizeof(uint32_t ) * 2) + ksiz) + vsiz;
  if (rsiz < 65536) {
    tmp___1 = stack;
  } else {
    tmp___0 = tcmalloc((unsigned int )rsiz);
    tmp___1 = (unsigned char *)tmp___0;
  }
  buf = tmp___1;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___2 = (unsigned char *)((void *)0);
    } else {
      tmp___2 = buf;
    }
    __cancel_arg = (void *)tmp___2;
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___3;
    tmp___4 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___4) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___5 = wp;
      wp ++;
      *tmp___5 = (unsigned char)200;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)24;
      num = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      num = (unsigned int )((((((unsigned long )((unsigned int )vsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )vsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )vsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )vsiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      wp += vsiz;
      tmp___7 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (! tmp___7) {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcrdboutimpl(TCRDB *rdb , void const   *kbuf , int ksiz ) 
{ _Bool tmp ;
  _Bool err ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___2 ;
  int not_first_call ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *wp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  uint32_t num ;
  int code ;
  int tmp___7 ;
  int tmp___8 ;
  _Bool tmp___9 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  rsiz = (2 + (int )sizeof(uint32_t )) + ksiz;
  if (rsiz < 65536) {
    tmp___1 = stack;
  } else {
    tmp___0 = tcmalloc((unsigned int )rsiz);
    tmp___1 = (unsigned char *)tmp___0;
  }
  buf = tmp___1;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___2 = (unsigned char *)((void *)0);
    } else {
      tmp___2 = buf;
    }
    __cancel_arg = (void *)tmp___2;
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___3;
    tmp___4 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___4) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___5 = wp;
      wp ++;
      *tmp___5 = (unsigned char)200;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)32;
      num = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      tmp___9 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___9) {
        tmp___7 = ttsockgetc(rdb->sock);
        code = tmp___7;
        if (code != 0) {
          if (code == -1) {
            tmp___8 = 5;
          } else {
            tmp___8 = 7;
          }
          tcrdbsetecode(rdb, tmp___8);
          err = (_Bool)1;
        }
      } else {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
static void *tcrdbgetimpl(TCRDB *rdb , void const   *kbuf , int ksiz , int *sp ) 
{ _Bool tmp ;
  char *vbuf ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___2 ;
  int not_first_call ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *wp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  uint32_t num ;
  int code ;
  int tmp___7 ;
  int vsiz ;
  uint32_t tmp___8 ;
  void *tmp___9 ;
  _Bool tmp___10 ;
  _Bool tmp___11 ;
  int tmp___12 ;
  _Bool tmp___13 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((void *)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((void *)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((void *)0);
    }
  }
  vbuf = (char *)((void *)0);
  rsiz = (2 + (int )sizeof(uint32_t )) + ksiz;
  if (rsiz < 65536) {
    tmp___1 = stack;
  } else {
    tmp___0 = tcmalloc((unsigned int )rsiz);
    tmp___1 = (unsigned char *)tmp___0;
  }
  buf = tmp___1;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___2 = (unsigned char *)((void *)0);
    } else {
      tmp___2 = buf;
    }
    __cancel_arg = (void *)tmp___2;
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___3;
    tmp___4 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___4) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___5 = wp;
      wp ++;
      *tmp___5 = (unsigned char)200;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)48;
      num = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      tmp___13 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___13) {
        tmp___7 = ttsockgetc(rdb->sock);
        code = tmp___7;
        if (code == 0) {
          tmp___8 = ttsockgetint32(rdb->sock);
          vsiz = (int )tmp___8;
          tmp___11 = ttsockcheckend(rdb->sock);
          if (tmp___11) {
            tcrdbsetecode(rdb, 5);
          } else {
            if (vsiz >= 0) {
              tmp___9 = tcmalloc((unsigned int )(vsiz + 1));
              vbuf = (char *)tmp___9;
              tmp___10 = ttsockrecv(rdb->sock, vbuf, vsiz);
              if (tmp___10) {
                *(vbuf + vsiz) = (char )'\000';
                *sp = vsiz;
              } else {
                tcrdbsetecode(rdb, 5);
                tcfree((void *)vbuf);
                vbuf = (char *)((void *)0);
              }
            } else {
              tcrdbsetecode(rdb, 5);
            }
          }
        } else {
          if (code == -1) {
            tmp___12 = 5;
          } else {
            tmp___12 = 7;
          }
          tcrdbsetecode(rdb, tmp___12);
        }
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((void *)vbuf);
}
}
static _Bool tcrdbmgetimpl(TCRDB *rdb , TCMAP *recs ) 
{ _Bool tmp ;
  _Bool err ;
  TCXSTR *xstr ;
  TCXSTR *tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;
  uint8_t magic[2] ;
  uint32_t num ;
  uint64_t tmp___3 ;
  char const   *kbuf ;
  int ksiz ;
  void const   *tmp___4 ;
  char stack[65536] ;
  int code ;
  int tmp___5 ;
  int rnum ;
  uint32_t tmp___6 ;
  int i ;
  int rksiz ;
  uint32_t tmp___7 ;
  int rvsiz ;
  uint32_t tmp___8 ;
  _Bool tmp___9 ;
  int rsiz ;
  char *rbuf ;
  void *tmp___10 ;
  char *tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void const   *tmp___16 ;
  _Bool tmp___17 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  tmp___0 = tcxstrnew();
  xstr = tmp___0;
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcxstrdel);
    __cancel_arg = (void *)xstr;
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___1;
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___2) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      magic[0] = (unsigned char)200;
      magic[1] = (unsigned char)49;
      tcxstrcat(xstr, (void const   *)(magic), (int )sizeof(magic));
      tmp___3 = tcmaprnum((TCMAP const   *)recs);
      num = (unsigned int )tmp___3;
      num = (unsigned int )((((((unsigned long )num & 255UL) << 24) | (((unsigned long )num & 65280UL) << 8)) | (((unsigned long )num & 16711680UL) >> 8)) | (((unsigned long )num & 4278190080UL) >> 24));
      tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
      tcmapiterinit(recs);
      while (1) {
        tmp___4 = tcmapiternext(recs, & ksiz);
        kbuf = (char const   *)tmp___4;
        if (! ((unsigned int )kbuf != (unsigned int )((void *)0))) {
          break;
        }
        num = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
        tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
        tcxstrcat(xstr, (void const   *)kbuf, ksiz);
      }
      tcmapclear(recs);
      tmp___15 = tcxstrsize((TCXSTR const   *)xstr);
      tmp___16 = tcxstrptr((TCXSTR const   *)xstr);
      tmp___17 = tcrdbsend(rdb, tmp___16, tmp___15);
      if (tmp___17) {
        tmp___5 = ttsockgetc(rdb->sock);
        code = tmp___5;
        tmp___6 = ttsockgetint32(rdb->sock);
        rnum = (int )tmp___6;
        if (code == 0) {
          tmp___13 = ttsockcheckend(rdb->sock);
          if (tmp___13) {
            tcrdbsetecode(rdb, 5);
            err = (_Bool)1;
          } else {
            if (rnum >= 0) {
              i = 0;
              while (i < rnum) {
                tmp___7 = ttsockgetint32(rdb->sock);
                rksiz = (int )tmp___7;
                tmp___8 = ttsockgetint32(rdb->sock);
                rvsiz = (int )tmp___8;
                tmp___9 = ttsockcheckend(rdb->sock);
                if (tmp___9) {
                  tcrdbsetecode(rdb, 5);
                  err = (_Bool)1;
                  break;
                }
                rsiz = rksiz + rvsiz;
                if (rsiz < 65536) {
                  tmp___11 = stack;
                } else {
                  tmp___10 = tcmalloc((unsigned int )(rsiz + 1));
                  tmp___11 = (char *)tmp___10;
                }
                rbuf = tmp___11;
                tmp___12 = ttsockrecv(rdb->sock, rbuf, rsiz);
                if (tmp___12) {
                  tcmapput(recs, (void const   *)rbuf, rksiz, (void const   *)(rbuf + rksiz),
                           rvsiz);
                } else {
                  tcrdbsetecode(rdb, 5);
                  err = (_Bool)1;
                }
                if ((unsigned int )rbuf != (unsigned int )(stack)) {
                  tcfree((void *)rbuf);
                }
                i ++;
              }
            } else {
              tcrdbsetecode(rdb, 5);
              err = (_Bool)1;
            }
          }
        } else {
          if (code == -1) {
            tmp___14 = 5;
          } else {
            tmp___14 = 7;
          }
          tcrdbsetecode(rdb, tmp___14);
          err = (_Bool)1;
        }
      } else {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
static int tcrdbvsizimpl(TCRDB *rdb , void const   *kbuf , int ksiz ) 
{ _Bool tmp ;
  int vsiz ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___2 ;
  int not_first_call ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *wp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  uint32_t num ;
  int code ;
  int tmp___7 ;
  uint32_t tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return (-1);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return (-1);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return (-1);
    }
  }
  vsiz = -1;
  rsiz = (2 + (int )sizeof(uint32_t )) + ksiz;
  if (rsiz < 65536) {
    tmp___1 = stack;
  } else {
    tmp___0 = tcmalloc((unsigned int )rsiz);
    tmp___1 = (unsigned char *)tmp___0;
  }
  buf = tmp___1;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___2 = (unsigned char *)((void *)0);
    } else {
      tmp___2 = buf;
    }
    __cancel_arg = (void *)tmp___2;
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___3;
    tmp___4 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___4) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___5 = wp;
      wp ++;
      *tmp___5 = (unsigned char)200;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)56;
      num = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      tmp___11 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___11) {
        tmp___7 = ttsockgetc(rdb->sock);
        code = tmp___7;
        if (code == 0) {
          tmp___8 = ttsockgetint32(rdb->sock);
          vsiz = (int )tmp___8;
          tmp___9 = ttsockcheckend(rdb->sock);
          if (tmp___9) {
            tcrdbsetecode(rdb, 5);
            vsiz = -1;
          }
        } else {
          if (code == -1) {
            tmp___10 = 5;
          } else {
            tmp___10 = 7;
          }
          tcrdbsetecode(rdb, tmp___10);
        }
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (vsiz);
}
}
static _Bool tcrdbiterinitimpl(TCRDB *rdb ) 
{ _Bool tmp ;
  _Bool err ;
  unsigned char buf[65536] ;
  unsigned char *wp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int code ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  wp = buf;
  tmp___0 = wp;
  wp ++;
  *tmp___0 = (unsigned char)200;
  tmp___1 = wp;
  wp ++;
  *tmp___1 = (unsigned char)80;
  tmp___4 = tcrdbsend(rdb, (void const   *)(buf), wp - buf);
  if (tmp___4) {
    tmp___2 = ttsockgetc(rdb->sock);
    code = tmp___2;
    if (code != 0) {
      if (code == -1) {
        tmp___3 = 5;
      } else {
        tmp___3 = 9999;
      }
      tcrdbsetecode(rdb, tmp___3);
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
static void *tcrdbiternextimpl(TCRDB *rdb , int *sp ) 
{ _Bool tmp ;
  char *vbuf ;
  unsigned char buf[65536] ;
  unsigned char *wp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int code ;
  int tmp___2 ;
  int vsiz ;
  uint32_t tmp___3 ;
  void *tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  int tmp___7 ;
  _Bool tmp___8 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((void *)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((void *)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((void *)0);
    }
  }
  vbuf = (char *)((void *)0);
  wp = buf;
  tmp___0 = wp;
  wp ++;
  *tmp___0 = (unsigned char)200;
  tmp___1 = wp;
  wp ++;
  *tmp___1 = (unsigned char)81;
  tmp___8 = tcrdbsend(rdb, (void const   *)(buf), wp - buf);
  if (tmp___8) {
    tmp___2 = ttsockgetc(rdb->sock);
    code = tmp___2;
    if (code == 0) {
      tmp___3 = ttsockgetint32(rdb->sock);
      vsiz = (int )tmp___3;
      tmp___6 = ttsockcheckend(rdb->sock);
      if (tmp___6) {
        tcrdbsetecode(rdb, 5);
      } else {
        if (vsiz >= 0) {
          tmp___4 = tcmalloc((unsigned int )(vsiz + 1));
          vbuf = (char *)tmp___4;
          tmp___5 = ttsockrecv(rdb->sock, vbuf, vsiz);
          if (tmp___5) {
            *(vbuf + vsiz) = (char )'\000';
            *sp = vsiz;
          } else {
            tcrdbsetecode(rdb, 5);
            tcfree((void *)vbuf);
            vbuf = (char *)((void *)0);
          }
        } else {
          tcrdbsetecode(rdb, 5);
        }
      }
    } else {
      if (code == -1) {
        tmp___7 = 5;
      } else {
        tmp___7 = 7;
      }
      tcrdbsetecode(rdb, tmp___7);
    }
  }
  return ((void *)vbuf);
}
}
static TCLIST *tcrdbfwmkeysimpl(TCRDB *rdb , void const   *pbuf , int psiz , int max ) 
{ TCLIST *keys ;
  TCLIST *tmp ;
  _Bool tmp___0 ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___1 ;
  unsigned char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___3 ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  unsigned char *wp ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  uint32_t num ;
  int code ;
  int tmp___8 ;
  int knum ;
  uint32_t tmp___9 ;
  int i ;
  int ksiz ;
  uint32_t tmp___10 ;
  _Bool tmp___11 ;
  char *kbuf ;
  void *tmp___12 ;
  unsigned char *tmp___13 ;
  _Bool tmp___14 ;
  _Bool tmp___15 ;
  int tmp___16 ;
  _Bool tmp___17 ;

  {
  tmp = tclistnew();
  keys = tmp;
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((TCLIST *)((void *)0));
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((TCLIST *)((void *)0));
      }
    }
    tmp___0 = tcrdbreconnect(rdb);
    if (! tmp___0) {
      return ((TCLIST *)((void *)0));
    }
  }
  rsiz = (2 + (int )sizeof(uint32_t ) * 2) + psiz;
  if (max < 0) {
    max = 2147483647;
  }
  if (rsiz < 65536) {
    tmp___2 = stack;
  } else {
    tmp___1 = tcmalloc((unsigned int )rsiz);
    tmp___2 = (unsigned char *)tmp___1;
  }
  buf = tmp___2;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___3 = (unsigned char *)((void *)0);
    } else {
      tmp___3 = buf;
    }
    __cancel_arg = (void *)tmp___3;
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___4;
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___5) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)200;
      tmp___7 = wp;
      wp ++;
      *tmp___7 = (unsigned char)88;
      num = (unsigned int )((((((unsigned long )((unsigned int )psiz) & 255UL) << 24) | (((unsigned long )((unsigned int )psiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )psiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )psiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      num = (unsigned int )((((((unsigned long )((unsigned int )max) & 255UL) << 24) | (((unsigned long )((unsigned int )max) & 65280UL) << 8)) | (((unsigned long )((unsigned int )max) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )max) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )pbuf, (unsigned int )psiz);
      wp += psiz;
      tmp___17 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___17) {
        tmp___8 = ttsockgetc(rdb->sock);
        code = tmp___8;
        if (code == 0) {
          tmp___9 = ttsockgetint32(rdb->sock);
          knum = (int )tmp___9;
          tmp___15 = ttsockcheckend(rdb->sock);
          if (tmp___15) {
            tcrdbsetecode(rdb, 5);
          } else {
            if (knum >= 0) {
              i = 0;
              while (i < knum) {
                tmp___10 = ttsockgetint32(rdb->sock);
                ksiz = (int )tmp___10;
                tmp___11 = ttsockcheckend(rdb->sock);
                if (tmp___11) {
                  tcrdbsetecode(rdb, 5);
                  break;
                }
                if (ksiz < 65536) {
                  tmp___13 = stack;
                } else {
                  tmp___12 = tcmalloc((unsigned int )(ksiz + 1));
                  tmp___13 = (unsigned char *)tmp___12;
                }
                kbuf = (char *)tmp___13;
                tmp___14 = ttsockrecv(rdb->sock, kbuf, ksiz);
                if (tmp___14) {
                  tclistpush(keys, (void const   *)kbuf, ksiz);
                } else {
                  tcrdbsetecode(rdb, 5);
                }
                if ((unsigned int )kbuf != (unsigned int )((char *)(stack))) {
                  tcfree((void *)kbuf);
                }
                i ++;
              }
            } else {
              tcrdbsetecode(rdb, 5);
            }
          }
        } else {
          if (code == -1) {
            tmp___16 = 5;
          } else {
            tmp___16 = 7;
          }
          tcrdbsetecode(rdb, tmp___16);
        }
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (keys);
}
}
static int tcrdbaddintimpl(TCRDB *rdb , void const   *kbuf , int ksiz , int num ) 
{ _Bool tmp ;
  int sum ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___2 ;
  int not_first_call ;
  int tmp___3 ;
  long tmp___4 ;
  unsigned char *wp ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  uint32_t lnum ;
  int code ;
  int tmp___7 ;
  uint32_t tmp___8 ;
  _Bool tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((-0x7FFFFFFF-1));
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((-0x7FFFFFFF-1));
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((-0x7FFFFFFF-1));
    }
  }
  sum = (-0x7FFFFFFF-1);
  rsiz = (2 + (int )sizeof(uint32_t ) * 2) + ksiz;
  if (rsiz < 65536) {
    tmp___1 = stack;
  } else {
    tmp___0 = tcmalloc((unsigned int )rsiz);
    tmp___1 = (unsigned char *)tmp___0;
  }
  buf = tmp___1;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___2 = (unsigned char *)((void *)0);
    } else {
      tmp___2 = buf;
    }
    __cancel_arg = (void *)tmp___2;
    tmp___3 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___3;
    tmp___4 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___4) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___5 = wp;
      wp ++;
      *tmp___5 = (unsigned char)200;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)96;
      lnum = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      lnum = (unsigned int )((((((unsigned long )((unsigned int )num) & 255UL) << 24) | (((unsigned long )((unsigned int )num) & 65280UL) << 8)) | (((unsigned long )((unsigned int )num) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )num) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      tmp___11 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___11) {
        tmp___7 = ttsockgetc(rdb->sock);
        code = tmp___7;
        if (code == 0) {
          tmp___8 = ttsockgetint32(rdb->sock);
          sum = (int )tmp___8;
          tmp___9 = ttsockcheckend(rdb->sock);
          if (tmp___9) {
            tcrdbsetecode(rdb, 5);
            sum = -1;
          }
        } else {
          if (code == -1) {
            tmp___10 = 5;
          } else {
            tmp___10 = 6;
          }
          tcrdbsetecode(rdb, tmp___10);
        }
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (sum);
}
}
static double tcrdbadddoubleimpl(TCRDB *rdb , void const   *kbuf , int ksiz , double num ) 
{ double tmp ;
  double tmp___0 ;
  _Bool tmp___1 ;
  double sum ;
  double tmp___2 ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___3 ;
  unsigned char *tmp___4 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___5 ;
  int not_first_call ;
  int tmp___6 ;
  long tmp___7 ;
  unsigned char *wp ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  uint32_t lnum ;
  char dbuf[(int )sizeof(uint64_t ) * 2] ;
  int code ;
  int tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;
  _Bool tmp___14 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      tmp = nan("");
      return (tmp);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        tmp = nan("");
        return (tmp);
      }
    }
    tmp___1 = tcrdbreconnect(rdb);
    if (! tmp___1) {
      tmp___0 = nan("");
      return (tmp___0);
    }
  }
  tmp___2 = nan("");
  sum = tmp___2;
  rsiz = ((2 + (int )sizeof(uint32_t )) + (int )sizeof(uint64_t ) * 2) + ksiz;
  if (rsiz < 65536) {
    tmp___4 = stack;
  } else {
    tmp___3 = tcmalloc((unsigned int )rsiz);
    tmp___4 = (unsigned char *)tmp___3;
  }
  buf = tmp___4;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___5 = (unsigned char *)((void *)0);
    } else {
      tmp___5 = buf;
    }
    __cancel_arg = (void *)tmp___5;
    tmp___6 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___6;
    tmp___7 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___7) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___8 = wp;
      wp ++;
      *tmp___8 = (unsigned char)200;
      tmp___9 = wp;
      wp ++;
      *tmp___9 = (unsigned char)97;
      lnum = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      ttpackdouble(num, (char *)wp);
      wp += (int )sizeof(dbuf);
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      tmp___14 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___14) {
        tmp___10 = ttsockgetc(rdb->sock);
        code = tmp___10;
        if (code == 0) {
          tmp___11 = ttsockrecv(rdb->sock, dbuf, (int )sizeof(dbuf));
          if (tmp___11) {
            tmp___12 = ttsockcheckend(rdb->sock);
            if (tmp___12) {
              tcrdbsetecode(rdb, 5);
            } else {
              sum = ttunpackdouble((char const   *)(dbuf));
            }
          } else {
            tcrdbsetecode(rdb, 5);
          }
        } else {
          if (code == -1) {
            tmp___13 = 5;
          } else {
            tmp___13 = 6;
          }
          tcrdbsetecode(rdb, tmp___13);
        }
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return (sum);
}
}
static void *tcrdbextimpl(TCRDB *rdb , char const   *name , int opts , void const   *kbuf ,
                          int ksiz , void const   *vbuf , int vsiz , int *sp ) 
{ _Bool tmp ;
  char *xbuf ;
  int nsiz ;
  size_t tmp___0 ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___1 ;
  unsigned char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___3 ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  unsigned char *wp ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  uint32_t num ;
  int code ;
  int tmp___8 ;
  int xsiz ;
  uint32_t tmp___9 ;
  void *tmp___10 ;
  _Bool tmp___11 ;
  _Bool tmp___12 ;
  int tmp___13 ;
  _Bool tmp___14 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((void *)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((void *)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((void *)0);
    }
  }
  xbuf = (char *)((void *)0);
  tmp___0 = strlen(name);
  nsiz = (int )tmp___0;
  rsiz = (((2 + (int )sizeof(uint32_t ) * 4) + nsiz) + ksiz) + vsiz;
  if (rsiz < 65536) {
    tmp___2 = stack;
  } else {
    tmp___1 = tcmalloc((unsigned int )rsiz);
    tmp___2 = (unsigned char *)tmp___1;
  }
  buf = tmp___2;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___3 = (unsigned char *)((void *)0);
    } else {
      tmp___3 = buf;
    }
    __cancel_arg = (void *)tmp___3;
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___4;
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___5) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)200;
      tmp___7 = wp;
      wp ++;
      *tmp___7 = (unsigned char)104;
      num = (unsigned int )((((((unsigned long )((unsigned int )nsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )nsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )nsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )nsiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      num = (unsigned int )((((((unsigned long )((unsigned int )opts) & 255UL) << 24) | (((unsigned long )((unsigned int )opts) & 65280UL) << 8)) | (((unsigned long )((unsigned int )opts) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )opts) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      num = (unsigned int )((((((unsigned long )((unsigned int )ksiz) & 255UL) << 24) | (((unsigned long )((unsigned int )ksiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )ksiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )ksiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      num = (unsigned int )((((((unsigned long )((unsigned int )vsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )vsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )vsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )vsiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )name, (unsigned int )nsiz);
      wp += nsiz;
      memcpy((void * __restrict  )wp, (void const   * __restrict  )kbuf, (unsigned int )ksiz);
      wp += ksiz;
      memcpy((void * __restrict  )wp, (void const   * __restrict  )vbuf, (unsigned int )vsiz);
      wp += vsiz;
      tmp___14 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___14) {
        tmp___8 = ttsockgetc(rdb->sock);
        code = tmp___8;
        if (code == 0) {
          tmp___9 = ttsockgetint32(rdb->sock);
          xsiz = (int )tmp___9;
          tmp___12 = ttsockcheckend(rdb->sock);
          if (tmp___12) {
            tcrdbsetecode(rdb, 5);
          } else {
            if (xsiz >= 0) {
              tmp___10 = tcmalloc((unsigned int )(xsiz + 1));
              xbuf = (char *)tmp___10;
              tmp___11 = ttsockrecv(rdb->sock, xbuf, xsiz);
              if (tmp___11) {
                *(xbuf + xsiz) = (char )'\000';
                *sp = xsiz;
              } else {
                tcrdbsetecode(rdb, 5);
                tcfree((void *)xbuf);
                xbuf = (char *)((void *)0);
              }
            } else {
              tcrdbsetecode(rdb, 5);
            }
          }
        } else {
          if (code == -1) {
            tmp___13 = 5;
          } else {
            tmp___13 = 9999;
          }
          tcrdbsetecode(rdb, tmp___13);
        }
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((void *)xbuf);
}
}
static _Bool tcrdbsyncimpl(TCRDB *rdb ) 
{ _Bool tmp ;
  _Bool err ;
  unsigned char buf[65536] ;
  unsigned char *wp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int code ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  wp = buf;
  tmp___0 = wp;
  wp ++;
  *tmp___0 = (unsigned char)200;
  tmp___1 = wp;
  wp ++;
  *tmp___1 = (unsigned char)112;
  tmp___4 = tcrdbsend(rdb, (void const   *)(buf), wp - buf);
  if (tmp___4) {
    tmp___2 = ttsockgetc(rdb->sock);
    code = tmp___2;
    if (code != 0) {
      if (code == -1) {
        tmp___3 = 5;
      } else {
        tmp___3 = 9999;
      }
      tcrdbsetecode(rdb, tmp___3);
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcrdboptimizeimpl(TCRDB *rdb , char const   *params ) 
{ _Bool tmp ;
  int psiz ;
  size_t tmp___0 ;
  _Bool err ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___1 ;
  unsigned char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___3 ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  unsigned char *wp ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  uint32_t num ;
  int code ;
  int tmp___8 ;
  int tmp___9 ;
  _Bool tmp___10 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  if (! params) {
    params = "";
  }
  tmp___0 = strlen(params);
  psiz = (int )tmp___0;
  err = (_Bool)0;
  rsiz = (2 + (int )sizeof(uint32_t )) + psiz;
  if (rsiz < 65536) {
    tmp___2 = stack;
  } else {
    tmp___1 = tcmalloc((unsigned int )rsiz);
    tmp___2 = (unsigned char *)tmp___1;
  }
  buf = tmp___2;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___3 = (unsigned char *)((void *)0);
    } else {
      tmp___3 = buf;
    }
    __cancel_arg = (void *)tmp___3;
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___4;
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___5) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)200;
      tmp___7 = wp;
      wp ++;
      *tmp___7 = (unsigned char)113;
      num = (unsigned int )((((((unsigned long )((unsigned int )psiz) & 255UL) << 24) | (((unsigned long )((unsigned int )psiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )psiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )psiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )params, (unsigned int )psiz);
      wp += psiz;
      tmp___10 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___10) {
        tmp___8 = ttsockgetc(rdb->sock);
        code = tmp___8;
        if (code != 0) {
          if (code == -1) {
            tmp___9 = 5;
          } else {
            tmp___9 = 9999;
          }
          tcrdbsetecode(rdb, tmp___9);
          err = (_Bool)1;
        }
      } else {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcrdbvanishimpl(TCRDB *rdb ) 
{ _Bool tmp ;
  _Bool err ;
  unsigned char buf[65536] ;
  unsigned char *wp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  int code ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  wp = buf;
  tmp___0 = wp;
  wp ++;
  *tmp___0 = (unsigned char)200;
  tmp___1 = wp;
  wp ++;
  *tmp___1 = (unsigned char)114;
  tmp___4 = tcrdbsend(rdb, (void const   *)(buf), wp - buf);
  if (tmp___4) {
    tmp___2 = ttsockgetc(rdb->sock);
    code = tmp___2;
    if (code != 0) {
      if (code == -1) {
        tmp___3 = 5;
      } else {
        tmp___3 = 9999;
      }
      tcrdbsetecode(rdb, tmp___3);
      err = (_Bool)1;
    }
  } else {
    err = (_Bool)1;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcrdbcopyimpl(TCRDB *rdb , char const   *path ) 
{ _Bool tmp ;
  _Bool err ;
  int psiz ;
  size_t tmp___0 ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___1 ;
  unsigned char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___3 ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  unsigned char *wp ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  uint32_t num ;
  int code ;
  int tmp___8 ;
  int tmp___9 ;
  _Bool tmp___10 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  tmp___0 = strlen(path);
  psiz = (int )tmp___0;
  rsiz = (2 + (int )sizeof(uint32_t )) + psiz;
  if (rsiz < 65536) {
    tmp___2 = stack;
  } else {
    tmp___1 = tcmalloc((unsigned int )rsiz);
    tmp___2 = (unsigned char *)tmp___1;
  }
  buf = tmp___2;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___3 = (unsigned char *)((void *)0);
    } else {
      tmp___3 = buf;
    }
    __cancel_arg = (void *)tmp___3;
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___4;
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___5) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)200;
      tmp___7 = wp;
      wp ++;
      *tmp___7 = (unsigned char)115;
      num = (unsigned int )((((((unsigned long )((unsigned int )psiz) & 255UL) << 24) | (((unsigned long )((unsigned int )psiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )psiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )psiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& num), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )path, (unsigned int )psiz);
      wp += psiz;
      tmp___10 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___10) {
        tmp___8 = ttsockgetc(rdb->sock);
        code = tmp___8;
        if (code != 0) {
          if (code == -1) {
            tmp___9 = 5;
          } else {
            tmp___9 = 9999;
          }
          tcrdbsetecode(rdb, tmp___9);
          err = (_Bool)1;
        }
      } else {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcrdbrestoreimpl(TCRDB *rdb , char const   *path , uint64_t ts , int opts ) 
{ _Bool tmp ;
  _Bool err ;
  int psiz ;
  size_t tmp___0 ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___1 ;
  unsigned char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___3 ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  unsigned char *wp ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  uint32_t lnum ;
  uint64_t llnum ;
  int code ;
  int tmp___8 ;
  int tmp___9 ;
  _Bool tmp___10 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  err = (_Bool)0;
  tmp___0 = strlen(path);
  psiz = (int )tmp___0;
  rsiz = (((2 + (int )sizeof(uint32_t )) + (int )sizeof(uint64_t )) + (int )sizeof(uint32_t )) + psiz;
  if (rsiz < 65536) {
    tmp___2 = stack;
  } else {
    tmp___1 = tcmalloc((unsigned int )rsiz);
    tmp___2 = (unsigned char *)tmp___1;
  }
  buf = tmp___2;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___3 = (unsigned char *)((void *)0);
    } else {
      tmp___3 = buf;
    }
    __cancel_arg = (void *)tmp___3;
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___4;
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___5) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)200;
      tmp___7 = wp;
      wp ++;
      *tmp___7 = (unsigned char)116;
      lnum = (unsigned int )((((((unsigned long )((unsigned int )psiz) & 255UL) << 24) | (((unsigned long )((unsigned int )psiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )psiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )psiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      llnum = ((((((((ts & 255ULL) << 56) | ((ts & 65280ULL) << 40)) | ((ts & 16711680ULL) << 24)) | ((ts & 4278190080ULL) << 8)) | ((ts & 1095216660480ULL) >> 8)) | ((ts & 280375465082880ULL) >> 24)) | ((ts & 71776119061217280ULL) >> 40)) | ((ts & 0xff00000000000000ULL) >> 56);
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(uint64_t )));
      wp += (int )sizeof(uint64_t );
      lnum = (unsigned int )((((((unsigned long )((unsigned int )opts) & 255UL) << 24) | (((unsigned long )((unsigned int )opts) & 65280UL) << 8)) | (((unsigned long )((unsigned int )opts) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )opts) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )path, (unsigned int )psiz);
      wp += psiz;
      tmp___10 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___10) {
        tmp___8 = ttsockgetc(rdb->sock);
        code = tmp___8;
        if (code != 0) {
          if (code == -1) {
            tmp___9 = 5;
          } else {
            tmp___9 = 9999;
          }
          tcrdbsetecode(rdb, tmp___9);
          err = (_Bool)1;
        }
      } else {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
static _Bool tcrdbsetmstimpl(TCRDB *rdb , char const   *host , int port , uint64_t ts ,
                             int opts ) 
{ _Bool tmp ;
  _Bool err ;
  int hsiz ;
  size_t tmp___0 ;
  int rsiz ;
  unsigned char stack[65536] ;
  unsigned char *buf ;
  void *tmp___1 ;
  unsigned char *tmp___2 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  unsigned char *tmp___3 ;
  int not_first_call ;
  int tmp___4 ;
  long tmp___5 ;
  unsigned char *wp ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  uint32_t lnum ;
  uint64_t llnum ;
  int code ;
  int tmp___8 ;
  int tmp___9 ;
  _Bool tmp___10 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((_Bool)0);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((_Bool)0);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((_Bool)0);
    }
  }
  if (! host) {
    host = "";
  }
  if (port < 0) {
    port = 0;
  }
  err = (_Bool)0;
  tmp___0 = strlen(host);
  hsiz = (int )tmp___0;
  rsiz = (2 + (int )sizeof(uint32_t ) * 3) + hsiz;
  if (rsiz < 65536) {
    tmp___2 = stack;
  } else {
    tmp___1 = tcmalloc((unsigned int )rsiz);
    tmp___2 = (unsigned char *)tmp___1;
  }
  buf = tmp___2;
  while (1) {
    __cancel_routine = & free;
    if ((unsigned int )buf == (unsigned int )(stack)) {
      tmp___3 = (unsigned char *)((void *)0);
    } else {
      tmp___3 = buf;
    }
    __cancel_arg = (void *)tmp___3;
    tmp___4 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___4;
    tmp___5 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___5) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      wp = buf;
      tmp___6 = wp;
      wp ++;
      *tmp___6 = (unsigned char)200;
      tmp___7 = wp;
      wp ++;
      *tmp___7 = (unsigned char)120;
      lnum = (unsigned int )((((((unsigned long )((unsigned int )hsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )hsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )hsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )hsiz) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      lnum = (unsigned int )((((((unsigned long )((unsigned int )port) & 255UL) << 24) | (((unsigned long )((unsigned int )port) & 65280UL) << 8)) | (((unsigned long )((unsigned int )port) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )port) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      llnum = ((((((((ts & 255ULL) << 56) | ((ts & 65280ULL) << 40)) | ((ts & 16711680ULL) << 24)) | ((ts & 4278190080ULL) << 8)) | ((ts & 1095216660480ULL) >> 8)) | ((ts & 280375465082880ULL) >> 24)) | ((ts & 71776119061217280ULL) >> 40)) | ((ts & 0xff00000000000000ULL) >> 56);
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& llnum), (unsigned int )((int )sizeof(uint64_t )));
      wp += (int )sizeof(uint64_t );
      lnum = (unsigned int )((((((unsigned long )((unsigned int )opts) & 255UL) << 24) | (((unsigned long )((unsigned int )opts) & 65280UL) << 8)) | (((unsigned long )((unsigned int )opts) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )opts) & 4278190080UL) >> 24));
      memcpy((void * __restrict  )wp, (void const   * __restrict  )(& lnum), (unsigned int )((int )sizeof(uint32_t )));
      wp += (int )sizeof(uint32_t );
      memcpy((void * __restrict  )wp, (void const   * __restrict  )host, (unsigned int )hsiz);
      wp += hsiz;
      tmp___10 = tcrdbsend(rdb, (void const   *)buf, wp - buf);
      if (tmp___10) {
        tmp___8 = ttsockgetc(rdb->sock);
        code = tmp___8;
        if (code != 0) {
          if (code == -1) {
            tmp___9 = 5;
          } else {
            tmp___9 = 9999;
          }
          tcrdbsetecode(rdb, tmp___9);
          err = (_Bool)1;
        }
      } else {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  return ((_Bool )(! err));
}
}
char const   *tcrdbexprimpl(TCRDB *rdb ) 
{ 

  {
  if (! rdb->host) {
    tcrdbsetecode(rdb, 1);
    return ((char const   *)((void *)0));
  }
  return ((char const   *)rdb->expr);
}
}
static uint64_t tcrdbrnumimpl(TCRDB *rdb ) 
{ _Bool tmp ;
  unsigned char buf[65536] ;
  unsigned char *wp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  uint64_t rnum ;
  int code ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return (0ULL);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return (0ULL);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return (0ULL);
    }
  }
  wp = buf;
  tmp___0 = wp;
  wp ++;
  *tmp___0 = (unsigned char)200;
  tmp___1 = wp;
  wp ++;
  *tmp___1 = (unsigned char)128;
  rnum = 0ULL;
  tmp___5 = tcrdbsend(rdb, (void const   *)(buf), wp - buf);
  if (tmp___5) {
    tmp___2 = ttsockgetc(rdb->sock);
    code = tmp___2;
    if (code == 0) {
      rnum = ttsockgetint64(rdb->sock);
      tmp___3 = ttsockcheckend(rdb->sock);
      if (tmp___3) {
        rnum = 0ULL;
        tcrdbsetecode(rdb, 5);
      }
    } else {
      if (code == -1) {
        tmp___4 = 5;
      } else {
        tmp___4 = 9999;
      }
      tcrdbsetecode(rdb, tmp___4);
    }
  }
  return (rnum);
}
}
static uint64_t tcrdbsizeimpl(TCRDB *rdb ) 
{ _Bool tmp ;
  unsigned char buf[65536] ;
  unsigned char *wp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  uint64_t size ;
  int code ;
  int tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return (0ULL);
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return (0ULL);
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return (0ULL);
    }
  }
  wp = buf;
  tmp___0 = wp;
  wp ++;
  *tmp___0 = (unsigned char)200;
  tmp___1 = wp;
  wp ++;
  *tmp___1 = (unsigned char)129;
  size = 0ULL;
  tmp___5 = tcrdbsend(rdb, (void const   *)(buf), wp - buf);
  if (tmp___5) {
    tmp___2 = ttsockgetc(rdb->sock);
    code = tmp___2;
    if (code == 0) {
      size = ttsockgetint64(rdb->sock);
      tmp___3 = ttsockcheckend(rdb->sock);
      if (tmp___3) {
        size = 0ULL;
        tcrdbsetecode(rdb, 5);
      }
    } else {
      if (code == -1) {
        tmp___4 = 5;
      } else {
        tmp___4 = 9999;
      }
      tcrdbsetecode(rdb, tmp___4);
    }
  }
  return (size);
}
}
static char *tcrdbstatimpl(TCRDB *rdb ) 
{ _Bool tmp ;
  unsigned char buf[65536] ;
  unsigned char *wp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  uint32_t size ;
  int code ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  int tmp___5 ;
  _Bool tmp___6 ;
  void *tmp___7 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((char *)((void *)0));
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((char *)((void *)0));
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((char *)((void *)0));
    }
  }
  wp = buf;
  tmp___0 = wp;
  wp ++;
  *tmp___0 = (unsigned char)200;
  tmp___1 = wp;
  wp ++;
  *tmp___1 = (unsigned char)136;
  size = 0U;
  tmp___6 = tcrdbsend(rdb, (void const   *)(buf), wp - buf);
  if (tmp___6) {
    tmp___2 = ttsockgetc(rdb->sock);
    code = tmp___2;
    if (code == 0) {
      size = ttsockgetint32(rdb->sock);
      tmp___3 = ttsockcheckend(rdb->sock);
      if (tmp___3) {
        size = 0U;
        tcrdbsetecode(rdb, 5);
      } else {
        if (size >= 65536U) {
          size = 0U;
          tcrdbsetecode(rdb, 5);
        } else {
          tmp___4 = ttsockrecv(rdb->sock, (char *)(buf), (int )size);
          if (! tmp___4) {
            size = 0U;
            tcrdbsetecode(rdb, 5);
          }
        }
      }
    } else {
      if (code == -1) {
        tmp___5 = 5;
      } else {
        tmp___5 = 9999;
      }
      tcrdbsetecode(rdb, tmp___5);
    }
  }
  if (size < 1U) {
    tcrdbsetecode(rdb, 9999);
    return ((char *)((void *)0));
  }
  tmp___7 = tcmemdup((void const   *)(buf), size);
  return ((char *)tmp___7);
}
}
static TCLIST *tcrdbmiscimpl(TCRDB *rdb , char const   *name , int opts , TCLIST const   *args ) 
{ _Bool tmp ;
  _Bool err ;
  TCLIST *res ;
  TCXSTR *xstr ;
  TCXSTR *tmp___0 ;
  __pthread_unwind_buf_t __cancel_buf ;
  void (*__cancel_routine)(void * ) ;
  void *__cancel_arg ;
  int not_first_call ;
  int tmp___1 ;
  long tmp___2 ;
  uint8_t magic[2] ;
  int nsiz ;
  size_t tmp___3 ;
  uint32_t num ;
  int tmp___4 ;
  int i ;
  int rsiz ;
  char const   *rbuf ;
  void const   *tmp___5 ;
  int tmp___6 ;
  char stack[65536] ;
  int code ;
  int tmp___7 ;
  int rnum ;
  uint32_t tmp___8 ;
  int i___0 ;
  int esiz ;
  uint32_t tmp___9 ;
  _Bool tmp___10 ;
  char *ebuf ;
  void *tmp___11 ;
  char *tmp___12 ;
  _Bool tmp___13 ;
  _Bool tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  void const   *tmp___17 ;
  _Bool tmp___18 ;

  {
  if (rdb->fd < 0) {
    if (! rdb->host) {
      tcrdbsetecode(rdb, 1);
      return ((TCLIST *)((void *)0));
    } else {
      if (! (rdb->opts & 1)) {
        tcrdbsetecode(rdb, 1);
        return ((TCLIST *)((void *)0));
      }
    }
    tmp = tcrdbreconnect(rdb);
    if (! tmp) {
      return ((TCLIST *)((void *)0));
    }
  }
  err = (_Bool)0;
  res = (TCLIST *)((void *)0);
  tmp___0 = tcxstrnew();
  xstr = tmp___0;
  while (1) {
    __cancel_routine = (void (*)(void * ))(& tcxstrdel);
    __cancel_arg = (void *)xstr;
    tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(__cancel_buf.__cancel_jmp_buf),
                          0);
    not_first_call = tmp___1;
    tmp___2 = __builtin_expect((long )not_first_call, 0L);
    if (tmp___2) {
      (*__cancel_routine)(__cancel_arg);
      __pthread_unwind_next(& __cancel_buf);
    }
    __pthread_register_cancel(& __cancel_buf);
    while (1) {
      magic[0] = (unsigned char)200;
      magic[1] = (unsigned char)144;
      tcxstrcat(xstr, (void const   *)(magic), (int )sizeof(magic));
      tmp___3 = strlen(name);
      nsiz = (int )tmp___3;
      num = (unsigned int )((((((unsigned long )((unsigned int )nsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )nsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )nsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )nsiz) & 4278190080UL) >> 24));
      tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
      num = (unsigned int )((((((unsigned long )((unsigned int )opts) & 255UL) << 24) | (((unsigned long )((unsigned int )opts) & 65280UL) << 8)) | (((unsigned long )((unsigned int )opts) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )opts) & 4278190080UL) >> 24));
      tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
      tmp___4 = tclistnum(args);
      num = (unsigned int )tmp___4;
      num = (unsigned int )((((((unsigned long )num & 255UL) << 24) | (((unsigned long )num & 65280UL) << 8)) | (((unsigned long )num & 16711680UL) >> 8)) | (((unsigned long )num & 4278190080UL) >> 24));
      tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
      tcxstrcat(xstr, (void const   *)name, nsiz);
      i = 0;
      while (1) {
        tmp___6 = tclistnum(args);
        if (! (i < tmp___6)) {
          break;
        }
        tmp___5 = tclistval(args, i, & rsiz);
        rbuf = (char const   *)tmp___5;
        num = (unsigned int )((((((unsigned long )((unsigned int )rsiz) & 255UL) << 24) | (((unsigned long )((unsigned int )rsiz) & 65280UL) << 8)) | (((unsigned long )((unsigned int )rsiz) & 16711680UL) >> 8)) | (((unsigned long )((unsigned int )rsiz) & 4278190080UL) >> 24));
        tcxstrcat(xstr, (void const   *)(& num), (int )sizeof(num));
        tcxstrcat(xstr, (void const   *)rbuf, rsiz);
        i ++;
      }
      tmp___16 = tcxstrsize((TCXSTR const   *)xstr);
      tmp___17 = tcxstrptr((TCXSTR const   *)xstr);
      tmp___18 = tcrdbsend(rdb, tmp___17, tmp___16);
      if (tmp___18) {
        tmp___7 = ttsockgetc(rdb->sock);
        code = tmp___7;
        tmp___8 = ttsockgetint32(rdb->sock);
        rnum = (int )tmp___8;
        if (code == 0) {
          tmp___14 = ttsockcheckend(rdb->sock);
          if (tmp___14) {
            tcrdbsetecode(rdb, 5);
            err = (_Bool)1;
          } else {
            if (rnum >= 0) {
              res = tclistnew2(rnum);
              i___0 = 0;
              while (i___0 < rnum) {
                tmp___9 = ttsockgetint32(rdb->sock);
                esiz = (int )tmp___9;
                tmp___10 = ttsockcheckend(rdb->sock);
                if (tmp___10) {
                  tcrdbsetecode(rdb, 5);
                  err = (_Bool)1;
                  break;
                }
                if (esiz < 65536) {
                  tmp___12 = stack;
                } else {
                  tmp___11 = tcmalloc((unsigned int )(esiz + 1));
                  tmp___12 = (char *)tmp___11;
                }
                ebuf = tmp___12;
                tmp___13 = ttsockrecv(rdb->sock, ebuf, esiz);
                if (tmp___13) {
                  tclistpush(res, (void const   *)ebuf, esiz);
                } else {
                  tcrdbsetecode(rdb, 5);
                  err = (_Bool)1;
                }
                if ((unsigned int )ebuf != (unsigned int )(stack)) {
                  tcfree((void *)ebuf);
                }
                i___0 ++;
              }
            } else {
              tcrdbsetecode(rdb, 5);
              err = (_Bool)1;
            }
          }
        } else {
          if (code == -1) {
            tmp___15 = 5;
          } else {
            tmp___15 = 9999;
          }
          tcrdbsetecode(rdb, tmp___15);
          err = (_Bool)1;
        }
      } else {
        err = (_Bool)1;
      }
      break;
    }
    __pthread_unregister_cancel(& __cancel_buf);
    (*__cancel_routine)(__cancel_arg);
    break;
  }
  if (res) {
    if (err) {
      tclistdel(res);
      res = (TCLIST *)((void *)0);
    }
  }
  return (res);
}
}
static void tcrdbqrypopmeta(RDBQRY *qry , TCLIST *res ) 
{ int i ;
  int tmp ;
  int pksiz ;
  char const   *pkbuf ;
  void const   *tmp___0 ;
  int hsiz ;
  char *hbuf ;
  void *tmp___1 ;
  int tmp___2 ;

  {
  tmp = tclistnum((TCLIST const   *)res);
  i = tmp - 1;
  while (i >= 0) {
    tmp___0 = tclistval((TCLIST const   *)res, i, & pksiz);
    pkbuf = (char const   *)tmp___0;
    if (pksiz >= 11) {
      if ((int const   )*(pkbuf + 0) == 0) {
        if ((int const   )*(pkbuf + 1) == 0) {
          tmp___2 = memcmp((void const   *)(pkbuf + 2), (void const   *)"[[HINT]]\n",
                           9U);
          if (tmp___2) {
            break;
          } else {
            tmp___1 = tclistpop(res, & hsiz);
            hbuf = (char *)tmp___1;
            tcxstrcat(qry->hint, (void const   *)(hbuf + 10), hsiz - 10);
            tcfree((void *)hbuf);
          }
        } else {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    i --;
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-3cd3H9YR.i","-g,-O2,-std=c99,-Wall,-fPIC,-fsigned-char,-O2")
int _tt_dummyfunc(void) ;
int _tt_dummyfuncv(int a  , ...) ;
int _tt_dummyfunc(void) 
{ 

  {
  return (0);
}
}
int _tt_dummyfuncv(int a  , ...) 
{ 

  {
  return (0);
}
}
