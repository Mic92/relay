/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef unsigned char UBYTE;
typedef unsigned long UDWORD;
struct _pairPtr {
   void *fst ;
   void *snd ;
};
typedef struct _pairPtr pairPtr;
struct _hashThing {
   unsigned long hash ;
   pairPtr kids ;
};
typedef struct _hashThing hashThing;
struct AudioVariables {
   int K1 ;
   int K2 ;
   int K3 ;
   int K4 ;
   int K5 ;
   int D1 ;
   int D2 ;
   int D3 ;
   int D4 ;
   int LastDelta ;
   unsigned int Dif[11] ;
   unsigned int ByteCount ;
   int LastChar ;
};
typedef unsigned int size_t___0;
typedef unsigned int __u_int___0;
typedef unsigned long __u_long___0;
typedef long long __quad_t___0;
typedef long __off_t___0;
typedef __quad_t___0 __off64_t___0;
typedef long __time_t___0;
typedef int __ssize_t___0;
typedef __u_int___0 u_int___0;
typedef __u_long___0 u_long___0;
typedef __ssize_t___0 ssize_t___0;
typedef __time_t___0 time_t___0;
typedef int int32_t___0;
typedef unsigned char u_int8_t___0;
typedef unsigned int u_int32_t___1;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t___0 _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t___0 _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[(int )(15U * sizeof(int ) - 2U * sizeof(void *))] ;
};
typedef u_int32_t___1 db_pgno_t;
typedef u_int32_t___1 db_recno_t;
typedef u_int32_t___1 db_timeout_t;
typedef u_int32_t___1 roff_t;
struct __db;
typedef struct __db DB;
struct __db_dbt;
typedef struct __db_dbt DBT;
struct __db_env;
typedef struct __db_env DB_ENV;
struct __db_ilock;
typedef struct __db_ilock DB_LOCK_ILOCK;
struct __db_lock_stat;
typedef struct __db_lock_stat DB_LOCK_STAT;
struct __db_lock_u;
typedef struct __db_lock_u DB_LOCK;
struct __db_lockreq;
typedef struct __db_lockreq DB_LOCKREQ;
struct __db_log_cursor;
typedef struct __db_log_cursor DB_LOGC;
struct __db_log_stat;
typedef struct __db_log_stat DB_LOG_STAT;
struct __db_lsn;
typedef struct __db_lsn DB_LSN;
struct __db_mpool_fstat;
typedef struct __db_mpool_fstat DB_MPOOL_FSTAT;
struct __db_mpool_stat;
typedef struct __db_mpool_stat DB_MPOOL_STAT;
struct __db_mpoolfile;
typedef struct __db_mpoolfile DB_MPOOLFILE;
struct __db_preplist;
typedef struct __db_preplist DB_PREPLIST;
struct __db_rep_stat;
typedef struct __db_rep_stat DB_REP_STAT;
struct __db_txn;
typedef struct __db_txn DB_TXN;
struct __db_txn_active;
typedef struct __db_txn_active DB_TXN_ACTIVE;
struct __db_txn_stat;
typedef struct __db_txn_stat DB_TXN_STAT;
struct __db_txnmgr;
typedef struct __db_txnmgr DB_TXNMGR;
struct __dbc;
typedef struct __dbc DBC;
struct __dbc_internal;
typedef struct __dbc_internal DBC_INTERNAL;
struct __fh_t;
typedef struct __fh_t DB_FH;
struct __fname;
typedef struct __fname FNAME;
struct __key_range;
typedef struct __key_range DB_KEY_RANGE;
struct __mpoolfile;
typedef struct __mpoolfile MPOOLFILE;
struct __mutex_t;
typedef struct __mutex_t DB_MUTEX;
struct __db_dbt {
   void *data ;
   u_int32_t___1 size ;
   u_int32_t___1 ulen ;
   u_int32_t___1 dlen ;
   u_int32_t___1 doff ;
   u_int32_t___1 flags ;
};
enum __anonenum_db_lockmode_t_50 {
    DB_LOCK_NG = 0,
    DB_LOCK_READ = 1,
    DB_LOCK_WRITE = 2,
    DB_LOCK_WAIT = 3,
    DB_LOCK_IWRITE = 4,
    DB_LOCK_IREAD = 5,
    DB_LOCK_IWR = 6,
    DB_LOCK_DIRTY = 7,
    DB_LOCK_WWRITE = 8
} ;
typedef enum __anonenum_db_lockmode_t_50 db_lockmode_t;
enum __anonenum_db_lockop_t_51 {
    DB_LOCK_DUMP = 0,
    DB_LOCK_GET = 1,
    DB_LOCK_GET_TIMEOUT = 2,
    DB_LOCK_INHERIT = 3,
    DB_LOCK_PUT = 4,
    DB_LOCK_PUT_ALL = 5,
    DB_LOCK_PUT_OBJ = 6,
    DB_LOCK_PUT_READ = 7,
    DB_LOCK_TIMEOUT = 8,
    DB_LOCK_TRADE = 9,
    DB_LOCK_UPGRADE_WRITE = 10
} ;
typedef enum __anonenum_db_lockop_t_51 db_lockop_t;
struct __db_lock_stat {
   u_int32_t___1 st_id ;
   u_int32_t___1 st_cur_maxid ;
   u_int32_t___1 st_maxlocks ;
   u_int32_t___1 st_maxlockers ;
   u_int32_t___1 st_maxobjects ;
   u_int32_t___1 st_nmodes ;
   u_int32_t___1 st_nlocks ;
   u_int32_t___1 st_maxnlocks ;
   u_int32_t___1 st_nlockers ;
   u_int32_t___1 st_maxnlockers ;
   u_int32_t___1 st_nobjects ;
   u_int32_t___1 st_maxnobjects ;
   u_int32_t___1 st_nconflicts ;
   u_int32_t___1 st_nrequests ;
   u_int32_t___1 st_nreleases ;
   u_int32_t___1 st_nnowaits ;
   u_int32_t___1 st_ndeadlocks ;
   db_timeout_t st_locktimeout ;
   u_int32_t___1 st_nlocktimeouts ;
   db_timeout_t st_txntimeout ;
   u_int32_t___1 st_ntxntimeouts ;
   u_int32_t___1 st_region_wait ;
   u_int32_t___1 st_region_nowait ;
   u_int32_t___1 st_regsize ;
};
struct __db_ilock {
   db_pgno_t pgno ;
   u_int8_t___0 fileid[20] ;
   u_int32_t___1 type ;
};
struct __db_lock_u {
   size_t___0 off ;
   u_int32_t___1 ndx ;
   u_int32_t___1 gen ;
   db_lockmode_t mode ;
};
struct __db_lockreq {
   db_lockop_t op ;
   db_lockmode_t mode ;
   db_timeout_t timeout ;
   DBT *obj ;
   DB_LOCK lock ;
};
struct __db_lsn {
   u_int32_t___1 file ;
   u_int32_t___1 offset ;
};
struct __db_log_cursor {
   DB_ENV *dbenv ;
   DB_FH *c_fhp ;
   DB_LSN c_lsn ;
   u_int32_t___1 c_len ;
   u_int32_t___1 c_prev ;
   DBT c_dbt ;
   u_int8_t___0 *bp ;
   u_int32_t___1 bp_size ;
   u_int32_t___1 bp_rlen ;
   DB_LSN bp_lsn ;
   u_int32_t___1 bp_maxrec ;
   int (*close)(DB_LOGC * , u_int32_t___1  ) ;
   int (*get)(DB_LOGC * , DB_LSN * , DBT * , u_int32_t___1  ) ;
   u_int32_t___1 flags ;
};
struct __db_log_stat {
   u_int32_t___1 st_magic ;
   u_int32_t___1 st_version ;
   int st_mode ;
   u_int32_t___1 st_lg_bsize ;
   u_int32_t___1 st_lg_size ;
   u_int32_t___1 st_w_bytes ;
   u_int32_t___1 st_w_mbytes ;
   u_int32_t___1 st_wc_bytes ;
   u_int32_t___1 st_wc_mbytes ;
   u_int32_t___1 st_wcount ;
   u_int32_t___1 st_wcount_fill ;
   u_int32_t___1 st_scount ;
   u_int32_t___1 st_region_wait ;
   u_int32_t___1 st_region_nowait ;
   u_int32_t___1 st_cur_file ;
   u_int32_t___1 st_cur_offset ;
   u_int32_t___1 st_disk_file ;
   u_int32_t___1 st_disk_offset ;
   u_int32_t___1 st_regsize ;
   u_int32_t___1 st_maxcommitperflush ;
   u_int32_t___1 st_mincommitperflush ;
};
enum __anonenum_DB_CACHE_PRIORITY_53 {
    DB_PRIORITY_VERY_LOW = 1,
    DB_PRIORITY_LOW = 2,
    DB_PRIORITY_DEFAULT = 3,
    DB_PRIORITY_HIGH = 4,
    DB_PRIORITY_VERY_HIGH = 5
} ;
typedef enum __anonenum_DB_CACHE_PRIORITY_53 DB_CACHE_PRIORITY;
struct __anonstruct_q_54 {
   struct __db_mpoolfile *tqe_next ;
   struct __db_mpoolfile **tqe_prev ;
};
struct __db_mpoolfile {
   DB_FH *fhp ;
   u_int32_t___1 ref ;
   u_int32_t___1 pinref ;
   struct __anonstruct_q_54 q ;
   DB_ENV *dbenv ;
   MPOOLFILE *mfp ;
   u_int32_t___1 clear_len ;
   u_int8_t___0 fileid[20] ;
   int ftype ;
   int32_t___0 lsn_offset ;
   u_int32_t___1 gbytes ;
   u_int32_t___1 bytes ;
   DBT *pgcookie ;
   DB_CACHE_PRIORITY priority ;
   void *addr ;
   size_t___0 len ;
   u_int32_t___1 config_flags ;
   int (*close)(DB_MPOOLFILE * , u_int32_t___1  ) ;
   int (*get)(DB_MPOOLFILE * , db_pgno_t * , u_int32_t___1  , void * ) ;
   int (*open)(DB_MPOOLFILE * , char const   * , u_int32_t___1  , int  , size_t___0  ) ;
   int (*put)(DB_MPOOLFILE * , void * , u_int32_t___1  ) ;
   int (*set)(DB_MPOOLFILE * , void * , u_int32_t___1  ) ;
   int (*get_clear_len)(DB_MPOOLFILE * , u_int32_t___1 * ) ;
   int (*set_clear_len)(DB_MPOOLFILE * , u_int32_t___1  ) ;
   int (*get_fileid)(DB_MPOOLFILE * , u_int8_t___0 * ) ;
   int (*set_fileid)(DB_MPOOLFILE * , u_int8_t___0 * ) ;
   int (*get_flags)(DB_MPOOLFILE * , u_int32_t___1 * ) ;
   int (*set_flags)(DB_MPOOLFILE * , u_int32_t___1  , int  ) ;
   int (*get_ftype)(DB_MPOOLFILE * , int * ) ;
   int (*set_ftype)(DB_MPOOLFILE * , int  ) ;
   int (*get_lsn_offset)(DB_MPOOLFILE * , int32_t___0 * ) ;
   int (*set_lsn_offset)(DB_MPOOLFILE * , int32_t___0  ) ;
   int (*get_maxsize)(DB_MPOOLFILE * , u_int32_t___1 * , u_int32_t___1 * ) ;
   int (*set_maxsize)(DB_MPOOLFILE * , u_int32_t___1  , u_int32_t___1  ) ;
   int (*get_pgcookie)(DB_MPOOLFILE * , DBT * ) ;
   int (*set_pgcookie)(DB_MPOOLFILE * , DBT * ) ;
   int (*get_priority)(DB_MPOOLFILE * , DB_CACHE_PRIORITY * ) ;
   int (*set_priority)(DB_MPOOLFILE * , DB_CACHE_PRIORITY  ) ;
   int (*sync)(DB_MPOOLFILE * ) ;
   u_int32_t___1 flags ;
};
struct __db_mpool_stat {
   u_int32_t___1 st_gbytes ;
   u_int32_t___1 st_bytes ;
   u_int32_t___1 st_ncache ;
   u_int32_t___1 st_regsize ;
   u_int32_t___1 st_map ;
   u_int32_t___1 st_cache_hit ;
   u_int32_t___1 st_cache_miss ;
   u_int32_t___1 st_page_create ;
   u_int32_t___1 st_page_in ;
   u_int32_t___1 st_page_out ;
   u_int32_t___1 st_ro_evict ;
   u_int32_t___1 st_rw_evict ;
   u_int32_t___1 st_page_trickle ;
   u_int32_t___1 st_pages ;
   u_int32_t___1 st_page_clean ;
   u_int32_t___1 st_page_dirty ;
   u_int32_t___1 st_hash_buckets ;
   u_int32_t___1 st_hash_searches ;
   u_int32_t___1 st_hash_longest ;
   u_int32_t___1 st_hash_examined ;
   u_int32_t___1 st_hash_nowait ;
   u_int32_t___1 st_hash_wait ;
   u_int32_t___1 st_hash_max_wait ;
   u_int32_t___1 st_region_nowait ;
   u_int32_t___1 st_region_wait ;
   u_int32_t___1 st_alloc ;
   u_int32_t___1 st_alloc_buckets ;
   u_int32_t___1 st_alloc_max_buckets ;
   u_int32_t___1 st_alloc_pages ;
   u_int32_t___1 st_alloc_max_pages ;
};
struct __db_mpool_fstat {
   char *file_name ;
   size_t___0 st_pagesize ;
   u_int32_t___1 st_map ;
   u_int32_t___1 st_cache_hit ;
   u_int32_t___1 st_cache_miss ;
   u_int32_t___1 st_page_create ;
   u_int32_t___1 st_page_in ;
   u_int32_t___1 st_page_out ;
};
enum __anonenum_db_recops_55 {
    DB_TXN_ABORT = 0,
    DB_TXN_APPLY = 1,
    DB_TXN_BACKWARD_ALLOC = 2,
    DB_TXN_BACKWARD_ROLL = 3,
    DB_TXN_FORWARD_ROLL = 4,
    DB_TXN_GETPGNOS = 5,
    DB_TXN_OPENFILES = 6,
    DB_TXN_POPENFILES = 7,
    DB_TXN_PRINT = 8
} ;
typedef enum __anonenum_db_recops_55 db_recops;
struct __anonstruct_links_56 {
   struct __db_txn *tqe_next ;
   struct __db_txn **tqe_prev ;
};
struct __anonstruct_xalinks_57 {
   struct __db_txn *tqe_next ;
   struct __db_txn **tqe_prev ;
};
struct __txn_event;
struct __anonstruct_events_58 {
   struct __txn_event *tqh_first ;
   struct __txn_event **tqh_last ;
};
struct __txn_logrec;
struct __anonstruct_logs_59 {
   struct __txn_logrec *stqh_first ;
   struct __txn_logrec **stqh_last ;
};
struct __kids {
   struct __db_txn *tqh_first ;
   struct __db_txn **tqh_last ;
};
struct __anonstruct_klinks_60 {
   struct __db_txn *tqe_next ;
   struct __db_txn **tqe_prev ;
};
struct __db_txn {
   DB_TXNMGR *mgrp ;
   DB_TXN *parent ;
   DB_LSN last_lsn ;
   u_int32_t___1 txnid ;
   u_int32_t___1 tid ;
   roff_t off ;
   db_timeout_t lock_timeout ;
   db_timeout_t expire ;
   void *txn_list ;
   struct __anonstruct_links_56 links ;
   struct __anonstruct_xalinks_57 xalinks ;
   struct __anonstruct_events_58 events ;
   struct __anonstruct_logs_59 logs ;
   struct __kids kids ;
   struct __anonstruct_klinks_60 klinks ;
   void *api_internal ;
   u_int32_t___1 cursors ;
   int (*abort)(DB_TXN * ) ;
   int (*commit)(DB_TXN * , u_int32_t___1  ) ;
   int (*discard)(DB_TXN * , u_int32_t___1  ) ;
   u_int32_t___1 (*id)(DB_TXN * ) ;
   int (*prepare)(DB_TXN * , u_int8_t___0 * ) ;
   int (*set_timeout)(DB_TXN * , db_timeout_t  , u_int32_t___1  ) ;
   u_int32_t___1 flags ;
};
struct __db_preplist {
   DB_TXN *txn ;
   u_int8_t___0 gid[128] ;
};
struct __db_txn_active {
   u_int32_t___1 txnid ;
   u_int32_t___1 parentid ;
   DB_LSN lsn ;
   u_int32_t___1 xa_status ;
   u_int8_t___0 xid[128] ;
};
struct __db_txn_stat {
   DB_LSN st_last_ckp ;
   time_t___0 st_time_ckp ;
   u_int32_t___1 st_last_txnid ;
   u_int32_t___1 st_maxtxns ;
   u_int32_t___1 st_naborts ;
   u_int32_t___1 st_nbegins ;
   u_int32_t___1 st_ncommits ;
   u_int32_t___1 st_nactive ;
   u_int32_t___1 st_nrestores ;
   u_int32_t___1 st_maxnactive ;
   DB_TXN_ACTIVE *st_txnarray ;
   u_int32_t___1 st_region_wait ;
   u_int32_t___1 st_region_nowait ;
   u_int32_t___1 st_regsize ;
};
struct __db_rep_stat {
   u_int32_t___1 st_status ;
   DB_LSN st_next_lsn ;
   DB_LSN st_waiting_lsn ;
   u_int32_t___1 st_dupmasters ;
   int st_env_id ;
   int st_env_priority ;
   u_int32_t___1 st_gen ;
   u_int32_t___1 st_in_recovery ;
   u_int32_t___1 st_log_duplicated ;
   u_int32_t___1 st_log_queued ;
   u_int32_t___1 st_log_queued_max ;
   u_int32_t___1 st_log_queued_total ;
   u_int32_t___1 st_log_records ;
   u_int32_t___1 st_log_requested ;
   int st_master ;
   u_int32_t___1 st_master_changes ;
   u_int32_t___1 st_msgs_badgen ;
   u_int32_t___1 st_msgs_processed ;
   u_int32_t___1 st_msgs_recover ;
   u_int32_t___1 st_msgs_send_failures ;
   u_int32_t___1 st_msgs_sent ;
   u_int32_t___1 st_newsites ;
   int st_nsites ;
   u_int32_t___1 st_nthrottles ;
   u_int32_t___1 st_outdated ;
   u_int32_t___1 st_txns_applied ;
   u_int32_t___1 st_elections ;
   u_int32_t___1 st_elections_won ;
   int st_election_cur_winner ;
   u_int32_t___1 st_election_gen ;
   DB_LSN st_election_lsn ;
   int st_election_nsites ;
   int st_election_priority ;
   int st_election_status ;
   int st_election_tiebreaker ;
   int st_election_votes ;
};
enum __anonenum_DBTYPE_61 {
    DB_BTREE = 1,
    DB_HASH = 2,
    DB_RECNO = 3,
    DB_QUEUE = 4,
    DB_UNKNOWN = 5
} ;
typedef enum __anonenum_DBTYPE_61 DBTYPE;
struct __anonstruct_dblistlinks_62 {
   struct __db *le_next ;
   struct __db **le_prev ;
};
struct __cq_fq {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
struct __cq_aq {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
struct __cq_jq {
   struct __dbc *tqh_first ;
   struct __dbc **tqh_last ;
};
struct __anonstruct_s_secondaries_63 {
   struct __db *lh_first ;
};
struct __anonstruct_s_links_64 {
   struct __db *le_next ;
   struct __db **le_prev ;
};
struct __db {
   u_int32_t___1 pgsize ;
   int (*db_append_recno)(DB * , DBT * , db_recno_t  ) ;
   void (*db_feedback)(DB * , int  , int  ) ;
   int (*dup_compare)(DB * , DBT const   * , DBT const   * ) ;
   void *app_private ;
   DB_ENV *dbenv ;
   DBTYPE type ;
   DB_MPOOLFILE *mpf ;
   DB_MUTEX *mutexp ;
   char *fname ;
   char *dname ;
   u_int32_t___1 open_flags ;
   u_int8_t___0 fileid[20] ;
   u_int32_t___1 adj_fileid ;
   FNAME *log_filename ;
   db_pgno_t meta_pgno ;
   u_int32_t___1 lid ;
   u_int32_t___1 cur_lid ;
   u_int32_t___1 associate_lid ;
   DB_LOCK handle_lock ;
   long cl_id ;
   time_t___0 timestamp ;
   DBT my_rskey ;
   DBT my_rkey ;
   DBT my_rdata ;
   DB_FH *saved_open_fhp ;
   struct __anonstruct_dblistlinks_62 dblistlinks ;
   struct __cq_fq free_queue ;
   struct __cq_aq active_queue ;
   struct __cq_jq join_queue ;
   struct __anonstruct_s_secondaries_63 s_secondaries ;
   struct __anonstruct_s_links_64 s_links ;
   u_int32_t___1 s_refcnt ;
   int (*s_callback)(DB * , DBT const   * , DBT const   * , DBT * ) ;
   DB *s_primary ;
   void *api_internal ;
   void *bt_internal ;
   void *h_internal ;
   void *q_internal ;
   void *xa_internal ;
   int (*associate)(DB * , DB_TXN * , DB * , int (*)(DB * , DBT const   * , DBT const   * ,
                                                     DBT * ) , u_int32_t___1  ) ;
   int (*close)(DB * , u_int32_t___1  ) ;
   int (*cursor)(DB * , DB_TXN * , DBC ** , u_int32_t___1  ) ;
   int (*del)(DB * , DB_TXN * , DBT * , u_int32_t___1  ) ;
   void (*err)(DB * , int  , char const   *  , ...) ;
   void (*errx)(DB * , char const   *  , ...) ;
   int (*fd)(DB * , int * ) ;
   int (*get)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t___1  ) ;
   int (*pget)(DB * , DB_TXN * , DBT * , DBT * , DBT * , u_int32_t___1  ) ;
   int (*get_byteswapped)(DB * , int * ) ;
   int (*get_cachesize)(DB * , u_int32_t___1 * , u_int32_t___1 * , int * ) ;
   int (*get_dbname)(DB * , char const   ** , char const   ** ) ;
   int (*get_encrypt_flags)(DB * , u_int32_t___1 * ) ;
   int (*get_env)(DB * , DB_ENV ** ) ;
   void (*get_errfile)(DB * , FILE ** ) ;
   void (*get_errpfx)(DB * , char const   ** ) ;
   int (*get_flags)(DB * , u_int32_t___1 * ) ;
   int (*get_lorder)(DB * , int * ) ;
   int (*get_open_flags)(DB * , u_int32_t___1 * ) ;
   int (*get_pagesize)(DB * , u_int32_t___1 * ) ;
   int (*get_transactional)(DB * , int * ) ;
   int (*get_type)(DB * , DBTYPE * ) ;
   int (*join)(DB * , DBC ** , DBC ** , u_int32_t___1  ) ;
   int (*key_range)(DB * , DB_TXN * , DBT * , DB_KEY_RANGE * , u_int32_t___1  ) ;
   int (*open)(DB * , DB_TXN * , char const   * , char const   * , DBTYPE  , u_int32_t___1  ,
               int  ) ;
   int (*put)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t___1  ) ;
   int (*remove)(DB * , char const   * , char const   * , u_int32_t___1  ) ;
   int (*rename)(DB * , char const   * , char const   * , char const   * , u_int32_t___1  ) ;
   int (*truncate)(DB * , DB_TXN * , u_int32_t___1 * , u_int32_t___1  ) ;
   int (*set_append_recno)(DB * , int (*)(DB * , DBT * , db_recno_t  ) ) ;
   int (*set_alloc)(DB * , void *(*)(size_t___0  ) , void *(*)(void * , size_t___0  ) ,
                    void (*)(void * ) ) ;
   int (*set_cachesize)(DB * , u_int32_t___1  , u_int32_t___1  , int  ) ;
   int (*set_dup_compare)(DB * , int (*)(DB * , DBT const   * , DBT const   * ) ) ;
   int (*set_encrypt)(DB * , char const   * , u_int32_t___1  ) ;
   void (*set_errcall)(DB * , void (*)(char const   * , char * ) ) ;
   void (*set_errfile)(DB * , FILE * ) ;
   void (*set_errpfx)(DB * , char const   * ) ;
   int (*set_feedback)(DB * , void (*)(DB * , int  , int  ) ) ;
   int (*set_flags)(DB * , u_int32_t___1  ) ;
   int (*set_lorder)(DB * , int  ) ;
   int (*set_pagesize)(DB * , u_int32_t___1  ) ;
   int (*set_paniccall)(DB * , void (*)(DB_ENV * , int  ) ) ;
   int (*stat)(DB * , void * , u_int32_t___1  ) ;
   int (*sync)(DB * , u_int32_t___1  ) ;
   int (*upgrade)(DB * , char const   * , u_int32_t___1  ) ;
   int (*verify)(DB * , char const   * , char const   * , FILE * , u_int32_t___1  ) ;
   int (*get_bt_minkey)(DB * , u_int32_t___1 * ) ;
   int (*set_bt_compare)(DB * , int (*)(DB * , DBT const   * , DBT const   * ) ) ;
   int (*set_bt_maxkey)(DB * , u_int32_t___1  ) ;
   int (*set_bt_minkey)(DB * , u_int32_t___1  ) ;
   int (*set_bt_prefix)(DB * , size_t___0 (*)(DB * , DBT const   * , DBT const   * ) ) ;
   int (*get_h_ffactor)(DB * , u_int32_t___1 * ) ;
   int (*get_h_nelem)(DB * , u_int32_t___1 * ) ;
   int (*set_h_ffactor)(DB * , u_int32_t___1  ) ;
   int (*set_h_hash)(DB * , u_int32_t___1 (*)(DB * , void const   * , u_int32_t___1  ) ) ;
   int (*set_h_nelem)(DB * , u_int32_t___1  ) ;
   int (*get_re_delim)(DB * , int * ) ;
   int (*get_re_len)(DB * , u_int32_t___1 * ) ;
   int (*get_re_pad)(DB * , int * ) ;
   int (*get_re_source)(DB * , char const   ** ) ;
   int (*set_re_delim)(DB * , int  ) ;
   int (*set_re_len)(DB * , u_int32_t___1  ) ;
   int (*set_re_pad)(DB * , int  ) ;
   int (*set_re_source)(DB * , char const   * ) ;
   int (*get_q_extentsize)(DB * , u_int32_t___1 * ) ;
   int (*set_q_extentsize)(DB * , u_int32_t___1  ) ;
   int (*db_am_remove)(DB * , DB_TXN * , char const   * , char const   * , DB_LSN * ) ;
   int (*db_am_rename)(DB * , DB_TXN * , char const   * , char const   * , char const   * ) ;
   int (*stored_get)(DB * , DB_TXN * , DBT * , DBT * , u_int32_t___1  ) ;
   int (*stored_close)(DB * , u_int32_t___1  ) ;
   u_int32_t___1 am_ok ;
   u_int32_t___1 orig_flags ;
   u_int32_t___1 flags ;
};
struct __anonstruct_links_65 {
   DBC *tqe_next ;
   DBC **tqe_prev ;
};
struct __dbc {
   DB *dbp ;
   DB_TXN *txn ;
   struct __anonstruct_links_65 links ;
   DBT *rskey ;
   DBT *rkey ;
   DBT *rdata ;
   DBT my_rskey ;
   DBT my_rkey ;
   DBT my_rdata ;
   u_int32_t___1 lid ;
   u_int32_t___1 locker ;
   DBT lock_dbt ;
   DB_LOCK_ILOCK lock ;
   DB_LOCK mylock ;
   long cl_id ;
   DBTYPE dbtype ;
   DBC_INTERNAL *internal ;
   int (*c_close)(DBC * ) ;
   int (*c_count)(DBC * , db_recno_t * , u_int32_t___1  ) ;
   int (*c_del)(DBC * , u_int32_t___1  ) ;
   int (*c_dup)(DBC * , DBC ** , u_int32_t___1  ) ;
   int (*c_get)(DBC * , DBT * , DBT * , u_int32_t___1  ) ;
   int (*c_pget)(DBC * , DBT * , DBT * , DBT * , u_int32_t___1  ) ;
   int (*c_put)(DBC * , DBT * , DBT * , u_int32_t___1  ) ;
   int (*c_am_bulk)(DBC * , DBT * , u_int32_t___1  ) ;
   int (*c_am_close)(DBC * , db_pgno_t  , int * ) ;
   int (*c_am_del)(DBC * ) ;
   int (*c_am_destroy)(DBC * ) ;
   int (*c_am_get)(DBC * , DBT * , DBT * , u_int32_t___1  , db_pgno_t * ) ;
   int (*c_am_put)(DBC * , DBT * , DBT * , u_int32_t___1  , db_pgno_t * ) ;
   int (*c_am_writelock)(DBC * ) ;
   u_int32_t___1 flags ;
};
struct __key_range {
   double less ;
   double equal ;
   double greater ;
};
struct __anonstruct_dblist_66 {
   struct __db *lh_first ;
};
struct __anonstruct_links_67 {
   struct __db_env *tqe_next ;
   struct __db_env **tqe_prev ;
};
struct __xa_txn {
   struct __db_txn *tqh_first ;
   struct __db_txn **tqh_last ;
};
struct __db_env {
   FILE *db_errfile ;
   char const   *db_errpfx ;
   void (*db_errcall)(char const   * , char * ) ;
   void (*db_feedback)(DB_ENV * , int  , int  ) ;
   void (*db_paniccall)(DB_ENV * , int  ) ;
   void *(*db_malloc)(size_t___0  ) ;
   void *(*db_realloc)(void * , size_t___0  ) ;
   void (*db_free)(void * ) ;
   u_int32_t___1 verbose ;
   void *app_private ;
   int (*app_dispatch)(DB_ENV * , DBT * , DB_LSN * , db_recops  ) ;
   u_int8_t___0 *lk_conflicts ;
   u_int32_t___1 lk_modes ;
   u_int32_t___1 lk_max ;
   u_int32_t___1 lk_max_lockers ;
   u_int32_t___1 lk_max_objects ;
   u_int32_t___1 lk_detect ;
   db_timeout_t lk_timeout ;
   u_int32_t___1 lg_bsize ;
   u_int32_t___1 lg_size ;
   u_int32_t___1 lg_regionmax ;
   u_int32_t___1 mp_gbytes ;
   u_int32_t___1 mp_bytes ;
   size_t___0 mp_size ;
   int mp_ncache ;
   size_t___0 mp_mmapsize ;
   int mp_maxwrite ;
   int mp_maxwrite_sleep ;
   int rep_eid ;
   int (*rep_send)(DB_ENV * , DBT const   * , DBT const   * , DB_LSN const   * , int  ,
                   u_int32_t___1  ) ;
   u_int32_t___1 tx_max ;
   time_t___0 tx_timestamp ;
   db_timeout_t tx_timeout ;
   char *db_home ;
   char *db_log_dir ;
   char *db_tmp_dir ;
   char **db_data_dir ;
   int data_cnt ;
   int data_next ;
   int db_mode ;
   u_int32_t___1 open_flags ;
   void *reginfo ;
   DB_FH *lockfhp ;
   int (**recover_dtab)(DB_ENV * , DBT * , DB_LSN * , db_recops  , void * ) ;
   size_t___0 recover_dtab_size ;
   void *cl_handle ;
   long cl_id ;
   int db_ref ;
   long shm_key ;
   u_int32_t___1 tas_spins ;
   DB_MUTEX *dblist_mutexp ;
   struct __anonstruct_dblist_66 dblist ;
   struct __anonstruct_links_67 links ;
   struct __xa_txn xa_txn ;
   int xa_rmid ;
   void *api1_internal ;
   void *api2_internal ;
   char *passwd ;
   size_t___0 passwd_len ;
   void *crypto_handle ;
   DB_MUTEX *mt_mutexp ;
   int mti ;
   u_long___0 *mt ;
   int (*close)(DB_ENV * , u_int32_t___1  ) ;
   int (*dbremove)(DB_ENV * , DB_TXN * , char const   * , char const   * , u_int32_t___1  ) ;
   int (*dbrename)(DB_ENV * , DB_TXN * , char const   * , char const   * , char const   * ,
                   u_int32_t___1  ) ;
   void (*err)(DB_ENV const   * , int  , char const   *  , ...) ;
   void (*errx)(DB_ENV const   * , char const   *  , ...) ;
   int (*get_home)(DB_ENV * , char const   ** ) ;
   int (*get_open_flags)(DB_ENV * , u_int32_t___1 * ) ;
   int (*open)(DB_ENV * , char const   * , u_int32_t___1  , int  ) ;
   int (*remove)(DB_ENV * , char const   * , u_int32_t___1  ) ;
   int (*set_alloc)(DB_ENV * , void *(*)(size_t___0  ) , void *(*)(void * , size_t___0  ) ,
                    void (*)(void * ) ) ;
   int (*set_app_dispatch)(DB_ENV * , int (*)(DB_ENV * , DBT * , DB_LSN * , db_recops  ) ) ;
   int (*get_data_dirs)(DB_ENV * , char const   *** ) ;
   int (*set_data_dir)(DB_ENV * , char const   * ) ;
   int (*get_encrypt_flags)(DB_ENV * , u_int32_t___1 * ) ;
   int (*set_encrypt)(DB_ENV * , char const   * , u_int32_t___1  ) ;
   void (*set_errcall)(DB_ENV * , void (*)(char const   * , char * ) ) ;
   void (*get_errfile)(DB_ENV * , FILE ** ) ;
   void (*set_errfile)(DB_ENV * , FILE * ) ;
   void (*get_errpfx)(DB_ENV * , char const   ** ) ;
   void (*set_errpfx)(DB_ENV * , char const   * ) ;
   int (*set_feedback)(DB_ENV * , void (*)(DB_ENV * , int  , int  ) ) ;
   int (*get_flags)(DB_ENV * , u_int32_t___1 * ) ;
   int (*set_flags)(DB_ENV * , u_int32_t___1  , int  ) ;
   int (*set_paniccall)(DB_ENV * , void (*)(DB_ENV * , int  ) ) ;
   int (*set_rpc_server)(DB_ENV * , void * , char const   * , long  , long  , u_int32_t___1  ) ;
   int (*get_shm_key)(DB_ENV * , long * ) ;
   int (*set_shm_key)(DB_ENV * , long  ) ;
   int (*get_tas_spins)(DB_ENV * , u_int32_t___1 * ) ;
   int (*set_tas_spins)(DB_ENV * , u_int32_t___1  ) ;
   int (*get_tmp_dir)(DB_ENV * , char const   ** ) ;
   int (*set_tmp_dir)(DB_ENV * , char const   * ) ;
   int (*get_verbose)(DB_ENV * , u_int32_t___1  , int * ) ;
   int (*set_verbose)(DB_ENV * , u_int32_t___1  , int  ) ;
   void *lg_handle ;
   int (*get_lg_bsize)(DB_ENV * , u_int32_t___1 * ) ;
   int (*set_lg_bsize)(DB_ENV * , u_int32_t___1  ) ;
   int (*get_lg_dir)(DB_ENV * , char const   ** ) ;
   int (*set_lg_dir)(DB_ENV * , char const   * ) ;
   int (*get_lg_max)(DB_ENV * , u_int32_t___1 * ) ;
   int (*set_lg_max)(DB_ENV * , u_int32_t___1  ) ;
   int (*get_lg_regionmax)(DB_ENV * , u_int32_t___1 * ) ;
   int (*set_lg_regionmax)(DB_ENV * , u_int32_t___1  ) ;
   int (*log_archive)(DB_ENV * , char *** , u_int32_t___1  ) ;
   int (*log_cursor)(DB_ENV * , DB_LOGC ** , u_int32_t___1  ) ;
   int (*log_file)(DB_ENV * , DB_LSN const   * , char * , size_t___0  ) ;
   int (*log_flush)(DB_ENV * , DB_LSN const   * ) ;
   int (*log_put)(DB_ENV * , DB_LSN * , DBT const   * , u_int32_t___1  ) ;
   int (*log_stat)(DB_ENV * , DB_LOG_STAT ** , u_int32_t___1  ) ;
   void *lk_handle ;
   int (*get_lk_conflicts)(DB_ENV * , u_int8_t___0 const   ** , int * ) ;
   int (*set_lk_conflicts)(DB_ENV * , u_int8_t___0 * , int  ) ;
   int (*get_lk_detect)(DB_ENV * , u_int32_t___1 * ) ;
   int (*set_lk_detect)(DB_ENV * , u_int32_t___1  ) ;
   int (*set_lk_max)(DB_ENV * , u_int32_t___1  ) ;
   int (*get_lk_max_locks)(DB_ENV * , u_int32_t___1 * ) ;
   int (*set_lk_max_locks)(DB_ENV * , u_int32_t___1  ) ;
   int (*get_lk_max_lockers)(DB_ENV * , u_int32_t___1 * ) ;
   int (*set_lk_max_lockers)(DB_ENV * , u_int32_t___1  ) ;
   int (*get_lk_max_objects)(DB_ENV * , u_int32_t___1 * ) ;
   int (*set_lk_max_objects)(DB_ENV * , u_int32_t___1  ) ;
   int (*lock_detect)(DB_ENV * , u_int32_t___1  , u_int32_t___1  , int * ) ;
   int (*lock_dump_region)(DB_ENV * , char const   * , FILE * ) ;
   int (*lock_get)(DB_ENV * , u_int32_t___1  , u_int32_t___1  , DBT const   * , db_lockmode_t  ,
                   DB_LOCK * ) ;
   int (*lock_put)(DB_ENV * , DB_LOCK * ) ;
   int (*lock_id)(DB_ENV * , u_int32_t___1 * ) ;
   int (*lock_id_free)(DB_ENV * , u_int32_t___1  ) ;
   int (*lock_stat)(DB_ENV * , DB_LOCK_STAT ** , u_int32_t___1  ) ;
   int (*lock_vec)(DB_ENV * , u_int32_t___1  , u_int32_t___1  , DB_LOCKREQ * , int  ,
                   DB_LOCKREQ ** ) ;
   void *mp_handle ;
   int (*get_cachesize)(DB_ENV * , u_int32_t___1 * , u_int32_t___1 * , int * ) ;
   int (*set_cachesize)(DB_ENV * , u_int32_t___1  , u_int32_t___1  , int  ) ;
   int (*get_mp_mmapsize)(DB_ENV * , size_t___0 * ) ;
   int (*set_mp_mmapsize)(DB_ENV * , size_t___0  ) ;
   int (*get_mp_maxwrite)(DB_ENV * , int * , int * ) ;
   int (*set_mp_maxwrite)(DB_ENV * , int  , int  ) ;
   int (*memp_dump_region)(DB_ENV * , char const   * , FILE * ) ;
   int (*memp_fcreate)(DB_ENV * , DB_MPOOLFILE ** , u_int32_t___1  ) ;
   int (*memp_register)(DB_ENV * , int  , int (*)(DB_ENV * , db_pgno_t  , void * ,
                                                  DBT * ) , int (*)(DB_ENV * , db_pgno_t  ,
                                                                    void * , DBT * ) ) ;
   int (*memp_stat)(DB_ENV * , DB_MPOOL_STAT ** , DB_MPOOL_FSTAT *** , u_int32_t___1  ) ;
   int (*memp_sync)(DB_ENV * , DB_LSN * ) ;
   int (*memp_trickle)(DB_ENV * , int  , int * ) ;
   void *rep_handle ;
   int (*rep_elect)(DB_ENV * , int  , int  , u_int32_t___1  , int * ) ;
   int (*rep_flush)(DB_ENV * ) ;
   int (*rep_process_message)(DB_ENV * , DBT * , DBT * , int * , DB_LSN * ) ;
   int (*rep_start)(DB_ENV * , DBT * , u_int32_t___1  ) ;
   int (*rep_stat)(DB_ENV * , DB_REP_STAT ** , u_int32_t___1  ) ;
   int (*get_rep_limit)(DB_ENV * , u_int32_t___1 * , u_int32_t___1 * ) ;
   int (*set_rep_limit)(DB_ENV * , u_int32_t___1  , u_int32_t___1  ) ;
   int (*set_rep_request)(DB_ENV * , u_int32_t___1  , u_int32_t___1  ) ;
   int (*set_rep_transport)(DB_ENV * , int  , int (*)(DB_ENV * , DBT const   * , DBT const   * ,
                                                      DB_LSN const   * , int  , u_int32_t___1  ) ) ;
   void *tx_handle ;
   int (*get_tx_max)(DB_ENV * , u_int32_t___1 * ) ;
   int (*set_tx_max)(DB_ENV * , u_int32_t___1  ) ;
   int (*get_tx_timestamp)(DB_ENV * , time_t___0 * ) ;
   int (*set_tx_timestamp)(DB_ENV * , time_t___0 * ) ;
   int (*txn_begin)(DB_ENV * , DB_TXN * , DB_TXN ** , u_int32_t___1  ) ;
   int (*txn_checkpoint)(DB_ENV * , u_int32_t___1  , u_int32_t___1  , u_int32_t___1  ) ;
   int (*txn_recover)(DB_ENV * , DB_PREPLIST * , long  , long * , u_int32_t___1  ) ;
   int (*txn_stat)(DB_ENV * , DB_TXN_STAT ** , u_int32_t___1  ) ;
   int (*get_timeout)(DB_ENV * , db_timeout_t * , u_int32_t___1  ) ;
   int (*set_timeout)(DB_ENV * , db_timeout_t  , u_int32_t___1  ) ;
   int test_abort ;
   int test_copy ;
   u_int32_t___1 flags ;
};
struct _statistics {
   int aborted ;
   int aborts ;
   int adds ;
   int deletes ;
   int txns ;
   int found ;
   int notfound ;
};
typedef unsigned short u_int16_t___0;
struct _pthread_fastlock {
   long __status ;
   int __spinlock ;
};
struct _pthread_descr_struct;
typedef struct _pthread_descr_struct *_pthread_descr;
typedef long long __pthread_cond_align_t;
struct __anonstruct_pthread_cond_t_4 {
   struct _pthread_fastlock __c_lock ;
   _pthread_descr __c_waiting ;
   char __padding[(int )(((48U - sizeof(struct _pthread_fastlock )) - sizeof(_pthread_descr )) - sizeof(__pthread_cond_align_t ))] ;
   __pthread_cond_align_t __align ;
};
typedef struct __anonstruct_pthread_cond_t_4 pthread_cond_t___0;
struct __anonstruct_pthread_condattr_t_5 {
   int __dummy ;
};
typedef struct __anonstruct_pthread_condattr_t_5 pthread_condattr_t___0;
struct __anonstruct_pthread_mutex_t_6 {
   int __m_reserved ;
   int __m_count ;
   _pthread_descr __m_owner ;
   int __m_kind ;
   struct _pthread_fastlock __m_lock ;
};
typedef struct __anonstruct_pthread_mutex_t_6 pthread_mutex_t___0;
struct __anonstruct_pthread_mutexattr_t_7 {
   int __mutexkind ;
};
typedef struct __anonstruct_pthread_mutexattr_t_7 pthread_mutexattr_t___0;
typedef u_int16_t___0 db_indx_t;
struct __dbc_internal {
   DBC *opd ;
   void *page ;
   db_pgno_t root ;
   db_pgno_t pgno ;
   db_indx_t indx ;
   DB_LOCK lock ;
   db_lockmode_t lock_mode ;
};
struct __mutex_t {
   pthread_mutex_t___0 mutex ;
   pthread_cond_t___0 cond ;
   u_int32_t___1 locked ;
   u_int32_t___1 mutex_set_wait ;
   u_int32_t___1 mutex_set_nowait ;
   u_int32_t___1 mutex_set_spin ;
   u_int32_t___1 mutex_set_spins ;
   u_int32_t___1 flags ;
};
struct __fh_t {
   DB_MUTEX *mutexp ;
   int ref ;
   int fd ;
   char *name ;
   u_int32_t___1 pgno ;
   u_int32_t___1 pgsize ;
   u_int32_t___1 offset ;
   u_int8_t___0 flags ;
};
struct _db_page {
   DB_LSN lsn ;
   db_pgno_t pgno ;
   db_pgno_t prev_pgno ;
   db_pgno_t next_pgno ;
   db_indx_t entries ;
   db_indx_t hf_offset ;
   u_int8_t___0 level ;
   u_int8_t___0 type ;
};
typedef struct _db_page PAGE;
struct __dbpginfo {
   size_t___0 db_pagesize ;
   u_int32_t___1 flags ;
   DBTYPE type ;
};
typedef struct __dbpginfo DB_PGINFO;
struct _dbmeta33 {
   DB_LSN lsn ;
   db_pgno_t pgno ;
   u_int32_t___1 magic ;
   u_int32_t___1 version ;
   u_int32_t___1 pagesize ;
   u_int8_t___0 encrypt_alg ;
   u_int8_t___0 type ;
   u_int8_t___0 metaflags ;
   u_int8_t___0 unused1 ;
   u_int32_t___1 free ;
   db_pgno_t last_pgno ;
   u_int32_t___1 unused3 ;
   u_int32_t___1 key_count ;
   u_int32_t___1 record_count ;
   u_int32_t___1 flags ;
   u_int8_t___0 uid[20] ;
};
typedef struct _dbmeta33 DBMETA;
struct __btree;
typedef struct __btree BTREE;
struct __btree {
   db_pgno_t bt_meta ;
   db_pgno_t bt_root ;
   u_int32_t___1 bt_maxkey ;
   u_int32_t___1 bt_minkey ;
   int (*bt_compare)(DB * , DBT const   * , DBT const   * ) ;
   size_t___0 (*bt_prefix)(DB * , DBT const   * , DBT const   * ) ;
   int re_pad ;
   int re_delim ;
   u_int32_t___1 re_len ;
   char *re_source ;
   db_pgno_t bt_lpgno ;
   int re_modified ;
   FILE *re_fp ;
   int re_eof ;
   db_recno_t re_last ;
};
struct __anonstruct_q_74 {
   ssize_t___0 stqe_next ;
   ssize_t___0 stqe_prev ;
};
struct __mpoolfile {
   DB_MUTEX mutex ;
   u_int32_t___1 mpf_cnt ;
   u_int32_t___1 block_cnt ;
   roff_t path_off ;
   int32_t___0 deadfile ;
   struct __anonstruct_q_74 q ;
   db_pgno_t last_pgno ;
   db_pgno_t orig_last_pgno ;
   db_pgno_t maxpgno ;
   int32_t___0 ftype ;
   int32_t___0 priority ;
   int32_t___0 file_written ;
   int32_t___0 no_backing_file ;
   int32_t___0 unlink_on_close ;
   DB_MPOOL_FSTAT stat ;
   int32_t___0 lsn_off ;
   u_int32_t___1 clear_len ;
   roff_t fileid_off ;
   roff_t pgcookie_len ;
   roff_t pgcookie_off ;
   u_int32_t___1 flags ;
};
struct __queue;
typedef struct __queue QUEUE;
struct __qmpf {
   int pinref ;
   DB_MPOOLFILE *mpf ;
};
struct __mpfarray {
   u_int32_t___1 n_extent ;
   u_int32_t___1 low_extent ;
   u_int32_t___1 hi_extent ;
   struct __qmpf *mpfarray ;
};
typedef struct __mpfarray MPFARRAY;
struct __queue {
   db_pgno_t q_meta ;
   db_pgno_t q_root ;
   int re_pad ;
   u_int32_t___1 re_len ;
   u_int32_t___1 rec_page ;
   u_int32_t___1 page_ext ;
   MPFARRAY array1 ;
   MPFARRAY array2 ;
   DBT pgcookie ;
   DB_PGINFO pginfo ;
   char *path ;
   char *name ;
   char *dir ;
   int mode ;
};
struct __db_cipher;
typedef struct __db_cipher DB_CIPHER;
enum __anonenum_APPNAME_39 {
    DB_APP_NONE = 0,
    DB_APP_DATA = 1,
    DB_APP_LOG = 2,
    DB_APP_TMP = 3
} ;
typedef enum __anonenum_APPNAME_39 APPNAME;
struct __db_reginfo_t;
typedef struct __db_reginfo_t REGINFO;
enum __anonenum_reg_type_50 {
    INVALID_REGION_TYPE = 0,
    REGION_TYPE_ENV = 1,
    REGION_TYPE_LOCK = 2,
    REGION_TYPE_LOG = 3,
    REGION_TYPE_MPOOL = 4,
    REGION_TYPE_MUTEX = 5,
    REGION_TYPE_TXN = 6
} ;
typedef enum __anonenum_reg_type_50 reg_type;
struct __anonstruct_q_51 {
   ssize_t___0 sle_next ;
   ssize_t___0 sle_prev ;
};
struct __db_region {
   DB_MUTEX mutex ;
   struct __anonstruct_q_51 q ;
   reg_type type ;
   u_int32_t___1 id ;
   roff_t size ;
   roff_t primary ;
   long segid ;
};
typedef struct __db_region REGION;
struct __db_reginfo_t {
   reg_type type ;
   u_int32_t___1 id ;
   int mode ;
   REGION *rp ;
   char *name ;
   void *addr ;
   void *primary ;
   u_int32_t___1 flags ;
};
struct __db_cipher {
   u_int___0 (*adj_size)(size_t___0  ) ;
   int (*close)(DB_ENV * , void * ) ;
   int (*decrypt)(DB_ENV * , void * , void * , u_int8_t___0 * , size_t___0  ) ;
   int (*encrypt)(DB_ENV * , void * , void * , u_int8_t___0 * , size_t___0  ) ;
   int (*init)(DB_ENV * , DB_CIPHER * ) ;
   u_int8_t___0 mac_key[20] ;
   void *data ;
   u_int8_t___0 alg ;
   u_int8_t___0 spare[3] ;
   u_int32_t___1 flags ;
};
struct __db_entry {
   DB *dbp ;
   int deleted ;
};
typedef struct __db_entry DB_ENTRY;
struct __anonstruct_q_74___0 {
   ssize_t___0 stqe_next ;
   ssize_t___0 stqe_prev ;
};
struct __fname {
   struct __anonstruct_q_74___0 q ;
   int32_t___0 id ;
   DBTYPE s_type ;
   roff_t name_off ;
   db_pgno_t meta_pgno ;
   u_int8_t___0 ufid[20] ;
   u_int32_t___1 create_txnid ;
   int is_durable ;
};
struct __db_log;
typedef struct __db_log DB_LOG;
struct __db_log {
   DB_MUTEX *mutexp ;
   DB_ENTRY *dbentry ;
   int32_t___0 dbentry_cnt ;
   u_int32_t___1 lfname ;
   DB_FH *lfhp ;
   u_int8_t___0 *bufp ;
   DB_ENV *dbenv ;
   REGINFO reginfo ;
   u_int32_t___1 flags ;
};
struct _chain {
   struct __db_txn *tqh_first ;
   struct __db_txn **tqh_last ;
};
struct __db_txnmgr {
   DB_MUTEX *mutexp ;
   struct _chain txn_chain ;
   u_int32_t___1 n_discards ;
   DB_ENV *dbenv ;
   REGINFO reginfo ;
};
struct __anonstruct_links_72 {
   struct __txn_logrec *stqe_next ;
};
struct __txn_logrec {
   struct __anonstruct_links_72 links ;
   u_int8_t___0 data[1] ;
};
struct __db_regionh {
   ssize_t___0 slh_first ;
};
struct __db_reg_env {
   DB_MUTEX mutex ;
   u_int32_t___1 magic ;
   int envpanic ;
   int majver ;
   int minver ;
   int patch ;
   u_int32_t___1 init_flags ;
   roff_t cipher_off ;
   struct __db_regionh regionq ;
   u_int32_t___1 refcnt ;
   roff_t rep_off ;
   size_t___0 pad ;
};
typedef struct __db_reg_env REGENV;
enum __anonenum_qam_name_op_78 {
    QAM_NAME_DISCARD = 0,
    QAM_NAME_RENAME = 1,
    QAM_NAME_REMOVE = 2
} ;
typedef enum __anonenum_qam_name_op_78 qam_name_op;
struct __db_txnhead;
typedef struct __db_txnhead DB_TXNHEAD;
struct __db_txnlist;
enum __anonenum_db_txnlist_type_54 {
    TXNLIST_DELETE = 0,
    TXNLIST_LSN = 1,
    TXNLIST_PGNO = 2,
    TXNLIST_TXNID = 3
} ;
typedef enum __anonenum_db_txnlist_type_54 db_txnlist_type;
struct __anonstruct_gen_array_55 {
   u_int32_t___1 generation ;
   u_int32_t___1 txn_min ;
   u_int32_t___1 txn_max ;
};
struct __db_headlink {
   struct __db_txnlist *lh_first ;
};
struct __db_txnhead {
   u_int32_t___1 maxid ;
   DB_LSN maxlsn ;
   DB_LSN ckplsn ;
   DB_LSN trunc_lsn ;
   u_int32_t___1 generation ;
   u_int32_t___1 gen_alloc ;
   struct __anonstruct_gen_array_55 *gen_array ;
   u_int___0 nslots ;
   struct __db_headlink head[1] ;
};
struct __anonstruct_links_56___0 {
   struct __db_txnlist *le_next ;
   struct __db_txnlist **le_prev ;
};
struct __anonstruct_t_58 {
   u_int32_t___1 txnid ;
   u_int32_t___1 generation ;
   int32_t___0 status ;
};
struct __anonstruct_l_59 {
   u_int32_t___1 ntxns ;
   u_int32_t___1 maxn ;
   DB_LSN *lsn_array ;
};
struct __anonstruct_p_60 {
   u_int32_t___1 nentries ;
   u_int32_t___1 maxentry ;
   int32_t___0 locked ;
   char *fname ;
   int32_t___0 fileid ;
   db_pgno_t *pgno_array ;
   u_int8_t___0 uid[20] ;
};
union __anonunion_u_57 {
   struct __anonstruct_t_58 t ;
   struct __anonstruct_l_59 l ;
   struct __anonstruct_p_60 p ;
};
struct __db_txnlist {
   db_txnlist_type type ;
   struct __anonstruct_links_56___0 links ;
   union __anonunion_u_57 u ;
};
struct __db_mpool;
typedef struct __db_mpool DB_MPOOL;
struct __db_mpreg;
struct __db_mpregh {
   struct __db_mpreg *lh_first ;
};
struct __db_mpoolfileh {
   struct __db_mpoolfile *tqh_first ;
   struct __db_mpoolfile **tqh_last ;
};
struct __db_mpool {
   DB_MUTEX *mutexp ;
   struct __db_mpregh dbregq ;
   struct __db_mpoolfileh dbmfq ;
   DB_ENV *dbenv ;
   u_int32_t___1 nreg ;
   REGINFO *reginfo ;
};
struct __anonstruct_q_77 {
   struct __db_mpreg *le_next ;
   struct __db_mpreg **le_prev ;
};
struct __db_mpreg {
   struct __anonstruct_q_77 q ;
   int32_t___0 ftype ;
   int (*pgin)(DB_ENV * , db_pgno_t  , void * , DBT * ) ;
   int (*pgout)(DB_ENV * , db_pgno_t  , void * , DBT * ) ;
};
struct ___db_pg_alloc_args {
   u_int32_t___1 type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t___0 fileid ;
   DB_LSN meta_lsn ;
   db_pgno_t meta_pgno ;
   DB_LSN page_lsn ;
   db_pgno_t pgno ;
   u_int32_t___1 ptype ;
   db_pgno_t next ;
};
typedef struct ___db_pg_alloc_args __db_pg_alloc_args;
struct ___db_pg_freedata_args {
   u_int32_t___1 type ;
   DB_TXN *txnid ;
   DB_LSN prev_lsn ;
   int32_t___0 fileid ;
   db_pgno_t pgno ;
   DB_LSN meta_lsn ;
   db_pgno_t meta_pgno ;
   DBT header ;
   db_pgno_t next ;
   DBT data ;
};
typedef struct ___db_pg_freedata_args __db_pg_freedata_args;
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct __db_envq {
   struct __db_env *tqh_first ;
   struct __db_env **tqh_last ;
};
struct __db_globals {
   struct __db_envq db_envq ;
   int (*j_close)(int  ) ;
   void (*j_dirfree)(char ** , int  ) ;
   int (*j_dirlist)(char const   * , char *** , int * ) ;
   int (*j_exists)(char const   * , int * ) ;
   void (*j_free)(void * ) ;
   int (*j_fsync)(int  ) ;
   int (*j_ioinfo)(char const   * , int  , u_int32_t___1 * , u_int32_t___1 * , u_int32_t___1 * ) ;
   void *(*j_malloc)(size_t___0  ) ;
   int (*j_map)(char * , size_t___0  , int  , int  , void ** ) ;
   int (*j_open)(char const   * , int   , ...) ;
   ssize_t___0 (*j_read)(int  , void * , size_t___0  ) ;
   void *(*j_realloc)(void * , size_t___0  ) ;
   int (*j_rename)(char const   * , char const   * ) ;
   int (*j_seek)(int  , size_t___0  , db_pgno_t  , u_int32_t___1  , int  , int  ) ;
   int (*j_sleep)(u_long___0  , u_long___0  ) ;
   int (*j_unlink)(char const   * ) ;
   int (*j_unmap)(void * , size_t___0  ) ;
   ssize_t___0 (*j_write)(int  , void const   * , size_t___0  ) ;
   int (*j_yield)(void) ;
};
struct __head {
   ssize_t___0 slh_first ;
};
struct __anonstruct_links_59 {
   ssize_t___0 sle_next ;
   ssize_t___0 sle_prev ;
};
struct __data {
   size_t___0 len ;
   struct __anonstruct_links_59 links ;
};
enum __anonenum_db_status_t_29 {
    DB_LSTAT_ABORTED = 1,
    DB_LSTAT_ERR = 2,
    DB_LSTAT_EXPIRED = 3,
    DB_LSTAT_FREE = 4,
    DB_LSTAT_HELD = 5,
    DB_LSTAT_NOTEXIST = 6,
    DB_LSTAT_PENDING = 7,
    DB_LSTAT_WAITING = 8
} ;
typedef enum __anonenum_db_status_t_29 db_status_t;
struct __hash_head {
   ssize_t___0 stqh_first ;
   ssize_t___0 stqh_last ;
};
typedef struct __hash_head DB_HASHTAB;
struct __anonstruct_db_timeval_t_59 {
   u_int32_t___1 tv_sec ;
   u_int32_t___1 tv_usec ;
};
typedef struct __anonstruct_db_timeval_t_59 db_timeval_t;
struct __flock {
   ssize_t___0 stqh_first ;
   ssize_t___0 stqh_last ;
};
struct __fobj {
   ssize_t___0 stqh_first ;
   ssize_t___0 stqh_last ;
};
struct __flocker {
   ssize_t___0 stqh_first ;
   ssize_t___0 stqh_last ;
};
struct __dobj {
   ssize_t___0 stqh_first ;
   ssize_t___0 stqh_last ;
};
struct __lkrs {
   ssize_t___0 stqh_first ;
   ssize_t___0 stqh_last ;
};
struct __db_lockregion {
   u_int32_t___1 need_dd ;
   u_int32_t___1 detect ;
   db_timeval_t next_timeout ;
   struct __flock free_locks ;
   struct __fobj free_objs ;
   struct __flocker free_lockers ;
   struct __dobj dd_objs ;
   struct __lkrs lockers ;
   db_timeout_t lk_timeout ;
   db_timeout_t tx_timeout ;
   u_int32_t___1 locker_t_size ;
   u_int32_t___1 object_t_size ;
   roff_t conf_off ;
   roff_t obj_off ;
   roff_t osynch_off ;
   roff_t locker_off ;
   roff_t lsynch_off ;
   DB_LOCK_STAT stat ;
};
typedef struct __db_lockregion DB_LOCKREGION;
struct __sh_dbt {
   u_int32_t___1 size ;
   ssize_t___0 off ;
};
typedef struct __sh_dbt SH_DBT;
struct __anonstruct_links_60 {
   ssize_t___0 stqe_next ;
   ssize_t___0 stqe_prev ;
};
struct __anonstruct_dd_links_61 {
   ssize_t___0 stqe_next ;
   ssize_t___0 stqe_prev ;
};
struct __waitl {
   ssize_t___0 stqh_first ;
   ssize_t___0 stqh_last ;
};
struct __holdl {
   ssize_t___0 stqh_first ;
   ssize_t___0 stqh_last ;
};
struct __db_lockobj {
   SH_DBT lockobj ;
   struct __anonstruct_links_60 links ;
   struct __anonstruct_dd_links_61 dd_links ;
   struct __waitl waiters ;
   struct __holdl holders ;
   u_int8_t___0 objdata[(int )sizeof(struct __db_ilock )] ;
};
typedef struct __db_lockobj DB_LOCKOBJ;
struct _child {
   ssize_t___0 slh_first ;
};
struct __anonstruct_child_link_62 {
   ssize_t___0 sle_next ;
   ssize_t___0 sle_prev ;
};
struct __anonstruct_links_63 {
   ssize_t___0 stqe_next ;
   ssize_t___0 stqe_prev ;
};
struct __anonstruct_ulinks_64 {
   ssize_t___0 stqe_next ;
   ssize_t___0 stqe_prev ;
};
struct _held {
   ssize_t___0 slh_first ;
};
struct __db_locker {
   u_int32_t___1 id ;
   u_int32_t___1 dd_id ;
   u_int32_t___1 nlocks ;
   u_int32_t___1 nwrites ;
   size_t___0 master_locker ;
   size_t___0 parent_locker ;
   struct _child child_locker ;
   struct __anonstruct_child_link_62 child_link ;
   struct __anonstruct_links_63 links ;
   struct __anonstruct_ulinks_64 ulinks ;
   struct _held heldby ;
   db_timeval_t lk_expire ;
   db_timeval_t tx_expire ;
   db_timeout_t lk_timeout ;
   u_int32_t___1 flags ;
};
typedef struct __db_locker DB_LOCKER;
struct __db_locktab {
   DB_ENV *dbenv ;
   REGINFO reginfo ;
   u_int8_t___0 *conflicts ;
   DB_HASHTAB *obj_tab ;
   DB_HASHTAB *locker_tab ;
};
typedef struct __db_locktab DB_LOCKTAB;
struct __anonstruct_links_65___0 {
   ssize_t___0 stqe_next ;
   ssize_t___0 stqe_prev ;
};
struct __anonstruct_locker_links_66 {
   ssize_t___0 sle_next ;
   ssize_t___0 sle_prev ;
};
struct __db_lock {
   DB_MUTEX mutex ;
   u_int32_t___1 holder ;
   u_int32_t___1 gen ;
   struct __anonstruct_links_65___0 links ;
   struct __anonstruct_locker_links_66 locker_links ;
   u_int32_t___1 refcount ;
   db_lockmode_t mode ;
   ssize_t___0 obj ;
   db_status_t status ;
};
struct __mpool;
typedef struct __mpool MPOOL;
struct __mpfq {
   ssize_t___0 stqh_first ;
   ssize_t___0 stqh_last ;
};
struct __mpool {
   DB_LSN lsn ;
   struct __mpfq mpfq ;
   u_int32_t___1 nreg ;
   roff_t regids ;
   int htab_buckets ;
   roff_t htab ;
   u_int32_t___1 last_checked ;
   u_int32_t___1 lru_count ;
   DB_MPOOL_STAT stat ;
   u_int32_t___1 put_counter ;
};
struct __db_regmaint_stat_t {
   u_int32_t___1 st_hint_hit ;
   u_int32_t___1 st_hint_miss ;
   u_int32_t___1 st_records ;
   u_int32_t___1 st_clears ;
   u_int32_t___1 st_destroys ;
   u_int32_t___1 st_max_locks ;
};
typedef struct __db_regmaint_stat_t REGMAINT_STAT;
struct __db_regmaint_t {
   u_int32_t___1 reglocks ;
   u_int32_t___1 regmutex_hint ;
   REGMAINT_STAT stat ;
   roff_t regmutexes[1] ;
};
typedef struct __db_regmaint_t REGMAINT;
enum __anonenum_TXN_EVENT_T_65 {
    TXN_CLOSE = 0,
    TXN_REMOVE = 1,
    TXN_TRADE = 2,
    TXN_TRADED = 3
} ;
typedef enum __anonenum_TXN_EVENT_T_65 TXN_EVENT_T;
struct __anonstruct_links_77 {
   struct __txn_event *tqe_next ;
   struct __txn_event **tqe_prev ;
};
struct __anonstruct_c_79 {
   DB *dbp ;
};
struct __anonstruct_r_80 {
   char *name ;
   u_int8_t___0 *fileid ;
};
struct __anonstruct_t_81 {
   DB_LOCK lock ;
   u_int32_t___1 locker ;
   DB *dbp ;
};
union __anonunion_u_78 {
   struct __anonstruct_c_79 c ;
   struct __anonstruct_r_80 r ;
   struct __anonstruct_t_81 t ;
};
struct __txn_event {
   TXN_EVENT_T op ;
   struct __anonstruct_links_77 links ;
   union __anonunion_u_78 u ;
};
struct tx_holding_buffer {
   int buffer_size ;
   unsigned char *buffer ;
};
struct mgsl_struct {
   int magic ;
   int flags ;
   int count ;
   int line ;
   int hw_version ;
   unsigned short close_delay ;
   unsigned short closing_wait ;
   int timeout ;
   int x_char ;
   int blocked_open ;
   unsigned char *xmit_buf ;
   int xmit_head ;
   int xmit_tail ;
   int xmit_cnt ;
   int num_tx_holding_buffers ;
   int get_tx_holding_index ;
   int put_tx_holding_index ;
   int tx_holding_count ;
   struct tx_holding_buffer tx_holding_buffers[5] ;
   int rx_enabled ;
   int rx_overflow ;
   int rx_rcc_underrun ;
   int tx_enabled ;
   int tx_active ;
   char device_name[25] ;
   unsigned int bus_type ;
   unsigned char bus ;
   unsigned char function ;
   unsigned int io_base ;
   unsigned int io_addr_size ;
   int io_addr_requested ;
   unsigned int irq_level ;
   unsigned long irq_flags ;
   int irq_requested ;
   unsigned int dma_level ;
   int dma_requested ;
   unsigned char serial_signals ;
   int irq_occurred ;
   unsigned int init_error ;
   int fDiagnosticsmode ;
   unsigned char *memory_base ;
   int shared_mem_requested ;
   unsigned char *lcr_base ;
   int lcr_mem_requested ;
   char flag_buf[4096] ;
   char char_buf[4096] ;
   int drop_rts_on_tx_done ;
   int loopmode_insert_requested ;
   int loopmode_send_done_requested ;
   int netcount ;
   int dosyncppp ;
};
struct __anonstruct_atomic_t_18 {
   int volatile   counter ;
};
typedef struct __anonstruct_atomic_t_18 atomic_t;
struct semaphore {
   atomic_t count ;
   int sleepers ;
};
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct reiserfs_list_bitmap;
struct buffer_head;
struct reiserfs_journal_cnode;
struct reiserfs_journal_list {
   unsigned long j_start ;
   unsigned long j_state ;
   unsigned long j_len ;
   atomic_t j_nonzerolen ;
   atomic_t j_commit_left ;
   atomic_t j_older_commits_done ;
   struct semaphore j_commit_lock ;
   unsigned long j_trans_id ;
   time_t___0 j_timestamp ;
   struct reiserfs_list_bitmap *j_list_bitmap ;
   struct buffer_head *j_commit_bh ;
   struct reiserfs_journal_cnode *j_realblock ;
   struct reiserfs_journal_cnode *j_freedlist ;
   struct list_head j_list ;
   struct list_head j_working_list ;
   struct list_head j_tail_bh_list ;
   struct list_head j_bh_list ;
   int j_refcount ;
};
struct super_block;
struct _spinlock_t {
   int locked ;
};
typedef struct _spinlock_t spinlock_t;
typedef unsigned int size_t;
typedef long long __quad_t;
typedef long __off_t;
typedef __quad_t __off64_t;
typedef struct _IO_FILE___0 FILE___0;
struct _IO_marker___0 {
   struct _IO_marker___0 *_next ;
   struct _IO_FILE___0 *_sbuf ;
   int _pos ;
};
struct _IO_FILE___0 {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker___0 *_markers ;
   struct _IO_FILE___0 *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15U * sizeof(int ) - 4U * sizeof(void *)) - sizeof(size_t )] ;
};
typedef unsigned short uint16_t;
struct _pthread_descr_struct {

};
struct _list {
   int data ;
   spinlock_t *lock ;
   struct _list *next ;
};
typedef struct _list list___0;
struct __anonstruct_pthread_mutex_t_16 {
   int __m_reserved ;
   int __m_count ;
   _pthread_descr __m_owner ;
   int __m_kind ;
   struct _pthread_fastlock __m_lock ;
};
struct cli_bm_patt {
   char *pattern ;
   char *virname ;
   char *offset ;
   char const   *viralias ;
   unsigned int length ;
   unsigned short target ;
   struct cli_bm_patt *next ;
};
struct cli_ac_patt {
   short *pattern ;
   unsigned int length ;
   unsigned int mindist ;
   unsigned int maxdist ;
   char *virname ;
   char *offset ;
   char const   *viralias ;
   unsigned short sigid ;
   unsigned short parts ;
   unsigned short partno ;
   unsigned short alt ;
   unsigned short *altn ;
   unsigned short type ;
   unsigned short target ;
   char **altc ;
   struct cli_ac_patt *next ;
};
struct cli_ac_node {
   char islast ;
   struct cli_ac_patt *list ;
   struct cli_ac_node *trans[256] ;
   struct cli_ac_node *fail ;
};
struct cli_md5_node {
   char *virname ;
   char *viralias ;
   unsigned char *md5 ;
   unsigned int size ;
   unsigned short fp ;
   struct cli_md5_node *next ;
};
struct cli_meta_node {
   int csize ;
   int size ;
   int method ;
   unsigned int crc32 ;
   unsigned int fileno ;
   unsigned int encrypted ;
   unsigned int maxdepth ;
   char *filename ;
   char *virname ;
   struct cli_meta_node *next ;
};
struct cl_node {
   unsigned int refcount ;
   unsigned int maxpatlen ;
   int *bm_shift ;
   struct cli_bm_patt **bm_suffix ;
   struct cli_ac_node *ac_root ;
   struct cli_ac_node **ac_nodetable ;
   unsigned int ac_partsigs ;
   unsigned int ac_nodes ;
   struct cli_md5_node **md5_hlist ;
   struct cli_meta_node *zip_mlist ;
   struct cli_meta_node *rar_mlist ;
};
#pragma merger(0,"/tmp/cil-Mbnne8MV.i","")
extern  __attribute__((__nothrow__)) void *malloc(unsigned int __size )  __attribute__((__malloc__)) ;
extern  __attribute__((__nothrow__)) void free(void *__ptr ) ;
extern  __attribute__((__nothrow__)) int abs(int __x )  __attribute__((__const__)) ;
static UDWORD CRCTab[256]  ;
static short crcInitialized  =    (short)0;
static void InitCRC(void) 
{ int I ;
  int J ;
  UDWORD C ;

  {
  if (crcInitialized) {
    return;
  }
  I = 0;
  while (I < 256) {
    C = (unsigned long )I;
    J = 0;
    while (J < 8) {
      if (C & 1UL) {
        C = (C >> 1) ^ 3988292384UL;
      } else {
        C >>= 1;
      }
      J ++;
    }
    CRCTab[I] = C;
    I ++;
  }
  crcInitialized = (short)1;
  return;
}
}
static UDWORD CalcCRC32(UDWORD StartCRC , UBYTE *Addr , UDWORD Size ) 
{ unsigned int I ;

  {
  I = 0U;
  while ((unsigned long )I < Size) {
    StartCRC = CRCTab[(int )((unsigned char )StartCRC) ^ (int )*(Addr + I)] ^ (StartCRC >> 8);
    I ++;
  }
  return (StartCRC);
}
}
static struct AudioVariables AudV[4]  ;
static int CurChannel  ;
static int ChannelDelta  ;
static UBYTE DecodeAudio(int Delta ) 
{ struct AudioVariables *V ;
  unsigned int Ch ;
  unsigned int NumMinDif ;
  unsigned int MinDif ;
  int PCh ;
  int I ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  V = & AudV[CurChannel];
  (V->ByteCount) ++;
  V->D4 = V->D3;
  V->D3 = V->D2;
  V->D2 = V->LastDelta - V->D1;
  V->D1 = V->LastDelta;
  PCh = ((((8 * V->LastChar + V->K1 * V->D1) + V->K2 * V->D2) + V->K3 * V->D3) + V->K4 * V->D4) + V->K5 * ChannelDelta;
  PCh = (PCh >> 3) & 255;
  Ch = (unsigned int )(PCh - Delta);
  I = (int )((signed char )Delta) << 3;
  tmp = abs(I);
  V->Dif[0] += (unsigned int )tmp;
  tmp___0 = abs(I - V->D1);
  V->Dif[1] += (unsigned int )tmp___0;
  tmp___1 = abs(I + V->D1);
  V->Dif[2] += (unsigned int )tmp___1;
  tmp___2 = abs(I - V->D2);
  V->Dif[3] += (unsigned int )tmp___2;
  tmp___3 = abs(I + V->D2);
  V->Dif[4] += (unsigned int )tmp___3;
  tmp___4 = abs(I - V->D3);
  V->Dif[5] += (unsigned int )tmp___4;
  tmp___5 = abs(I + V->D3);
  V->Dif[6] += (unsigned int )tmp___5;
  tmp___6 = abs(I - V->D4);
  V->Dif[7] += (unsigned int )tmp___6;
  tmp___7 = abs(I + V->D4);
  V->Dif[8] += (unsigned int )tmp___7;
  tmp___8 = abs(I - ChannelDelta);
  V->Dif[9] += (unsigned int )tmp___8;
  tmp___9 = abs(I + ChannelDelta);
  V->Dif[10] += (unsigned int )tmp___9;
  V->LastDelta = (int )((signed char )(Ch - (unsigned int )V->LastChar));
  ChannelDelta = V->LastDelta;
  V->LastChar = (int )Ch;
  if ((V->ByteCount & 31U) == 0U) {
    MinDif = V->Dif[0];
    NumMinDif = 0U;
    V->Dif[0] = 0U;
    I = 1;
    while ((unsigned int )I < sizeof(V->Dif) / sizeof(V->Dif[0])) {
      if (V->Dif[I] < MinDif) {
        MinDif = V->Dif[I];
        NumMinDif = (unsigned int )I;
      }
      V->Dif[I] = 0U;
      I ++;
    }
    switch ((int )NumMinDif) {
    case 1: ;
    if (V->K1 >= -16) {
      (V->K1) --;
    }
    break;
    case 2: ;
    if (V->K1 < 16) {
      (V->K1) ++;
    }
    break;
    case 3: ;
    if (V->K2 >= -16) {
      (V->K2) --;
    }
    break;
    case 4: ;
    if (V->K2 < 16) {
      (V->K2) ++;
    }
    break;
    case 5: ;
    if (V->K3 >= -16) {
      (V->K3) --;
    }
    break;
    case 6: ;
    if (V->K3 < 16) {
      (V->K3) ++;
    }
    break;
    case 7: ;
    if (V->K4 >= -16) {
      (V->K4) --;
    }
    break;
    case 8: ;
    if (V->K4 < 16) {
      (V->K4) ++;
    }
    break;
    case 9: ;
    if (V->K5 >= -16) {
      (V->K5) --;
    }
    break;
    case 10: ;
    if (V->K5 < 16) {
      (V->K5) ++;
    }
    break;
    }
  }
  return ((unsigned char )Ch);
}
}
void updateHash(hashThing *thing ) 
{ 

  {
  thing->hash = (unsigned long )thing;
  return;
}
}
void updateHashVoid(void *vp ) 
{ 

  {
  if (vp) {
    updateHash((hashThing *)vp);
    updateHashVoid(((hashThing *)vp)->kids.fst);
  }
  return;
}
}
void assignHash(pairPtr *p ) 
{ 

  {
  p->fst = (void *)p;
  p->snd = (void *)p;
  return;
}
}
void assignFstHash(hashThing *thing ) 
{ 

  {
  assignHash(& ((hashThing *)thing->kids.fst)->kids);
  return;
}
}
#pragma merger(0,"/tmp/cil-eA2jBBN3.i","")
extern  __attribute__((__nothrow__)) void *memset(void *__s , int __c , size_t___0 __n )  __attribute__((__nonnull__(1))) ;
extern  __attribute__((__nothrow__)) char *strerror(int __errnum ) ;
char *db_strerror(int error ) ;
int quit  ;
struct _statistics *perf  ;
char const   *progname  =    "ex_thread";
int punish  ;
int nlist  ;
int nreaders  ;
int verbose  ;
int nwriters  ;
DB *dbp  ;
DB_ENV *dbenv  ;
int nthreads  ;
char **list  ;
static char const   __db_lock_invalid[28]  = 
  {      (char const   )'%',      (char const   )'s',      (char const   )':',      (char const   )' ', 
        (char const   )'L',      (char const   )'o',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'i',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'o',      (char const   )' ',      (char const   )'l', 
        (char const   )'o',      (char const   )'n',      (char const   )'g',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
int __db_panic(DB_ENV *dbenv___0 , int errval ) 
{ 

  {
  return (-30978);
}
}
void __db_err(DB_ENV const   *dbenv___0 , char const   *fmt  , ...) 
{ 

  {
  return;
}
}
int __memp_fput(DB_MPOOLFILE *dbmfp , void *pgaddr , u_int32_t___1 flags ) 
{ 

  {
  return (0);
}
}
int __memp_fget(DB_MPOOLFILE *dbmfp , db_pgno_t *pgnoaddr , u_int32_t___1 flags ,
                void *addrp ) 
{ 

  {
  *((void **)addrp) = (void *)0;
  return (0);
}
}
int __db_pgerr(DB *dbp___1 , db_pgno_t pgno , int errval ) 
{ int tmp ;

  {
  __db_err((DB_ENV const   *)dbp___1->dbenv, "unable to create/retrieve page %lu",
           (unsigned long )pgno);
  tmp = __db_panic(dbp___1->dbenv, errval);
  return (tmp);
}
}
int log_compare(DB_LSN const   *lsn0 , DB_LSN const   *lsn1 ) 
{ int tmp ;
  int tmp___0 ;

  {
  if (lsn0->file != lsn1->file) {
    if (lsn0->file < lsn1->file) {
      tmp = -1;
    } else {
      tmp = 1;
    }
    return (tmp);
  }
  if (lsn0->offset != lsn1->offset) {
    if (lsn0->offset < lsn1->offset) {
      tmp___0 = -1;
    } else {
      tmp___0 = 1;
    }
    return (tmp___0);
  }
  return (0);
}
}
extern int ( /* missing proto */  memcpy)() ;
void *__ua_memcpy(void *dst , void const   *src , size_t___0 len ) 
{ void *tmp ;
  int tmp___0 ;

  {
  tmp___0 = memcpy((void * __restrict  )dst, (void const   * __restrict  )src, len);
  tmp = (void *)tmp___0;
  return (tmp);
}
}
static int __db_pg_free_recover_int(DB_ENV *dbenv___0 , __db_pg_freedata_args *argp ,
                                    DB *file_dbp , DB_LSN *lsnp , DB_MPOOLFILE *mpf ,
                                    db_recops op , int data ) 
{ DBMETA *meta ;
  DB_LSN copy_lsn ;
  PAGE *pagep ;
  db_pgno_t pgno ;
  int cmp_n ;
  int cmp_p ;
  int modified ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  meta = (DBMETA *)((void *)0);
  pagep = (PAGE *)((void *)0);
  ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
  if (ret != 0) {
    goto out;
  }
  modified = 0;
  __ua_memcpy((void *)(& copy_lsn), (void const   *)(& ((PAGE *)argp->header.data)->lsn),
              sizeof(DB_LSN ));
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& copy_lsn));
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence err: page LSN %lu %lu; prev LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )copy_lsn.file, (unsigned long )copy_lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence err: page LSN %lu %lu; prev LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )copy_lsn.file, (unsigned long )copy_lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if ((int )op == 4) {
    goto _L___3;
  } else {
    if ((int )op == 1) {
      _L___3: 
      if (cmp_p == 0) {
        goto _L___2;
      } else {
        if (copy_lsn.file == 0U) {
          tmp = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->meta_lsn));
          if (tmp <= 0) {
            _L___2: 
            while (1) {
              pagep->pgno = argp->pgno;
              pagep->prev_pgno = 0U;
              pagep->next_pgno = argp->next;
              pagep->entries = (unsigned short)0;
              pagep->hf_offset = (unsigned short )file_dbp->pgsize;
              pagep->level = (unsigned char)0;
              pagep->type = (unsigned char)0;
              break;
            }
            pagep->lsn = *lsnp;
            modified = 1;
          } else {
            goto _L___1;
          }
        } else {
          goto _L___1;
        }
      }
    } else {
      _L___1: 
      if (cmp_n == 0) {
        if ((int )op == 0) {
          goto _L___0;
        } else {
          if ((int )op == 3) {
            goto _L___0;
          } else {
            if ((int )op == 2) {
              _L___0: 
              memcpy((void * __restrict  )pagep, (void const   * __restrict  )argp->header.data,
                     argp->header.size);
              if (data) {
                memcpy((void * __restrict  )((u_int8_t___0 *)pagep + (int )pagep->hf_offset),
                       (void const   * __restrict  )argp->data.data, argp->data.size);
              }
              modified = 1;
            }
          }
        }
      }
    }
  }
  if (modified) {
    tmp___0 = 2;
  } else {
    tmp___0 = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp___0);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  pgno = 0U;
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& meta));
  if (ret != 0) {
    ret = __db_pgerr(file_dbp, pgno, ret);
    goto out;
  }
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& ((PAGE *)meta)->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& ((PAGE *)meta)->lsn), (DB_LSN const   *)(& argp->meta_lsn));
  if ((int )op == 4) {
    goto _L___4;
  } else {
    if ((int )op == 1) {
      _L___4: 
      if (cmp_p < 0) {
        if (((PAGE *)meta)->lsn.file == 0U) {
          if (! (((PAGE *)meta)->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence err: page LSN %lu %lu; prev LSN %lu %lu",
                     (unsigned long )((PAGE *)meta)->lsn.file, (unsigned long )((PAGE *)meta)->lsn.offset,
                     (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence err: page LSN %lu %lu; prev LSN %lu %lu",
                   (unsigned long )((PAGE *)meta)->lsn.file, (unsigned long )((PAGE *)meta)->lsn.offset,
                   (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      goto _L___6;
    } else {
      if ((int )op == 1) {
        _L___6: 
        meta->free = argp->pgno;
        if (meta->last_pgno < meta->free) {
          meta->last_pgno = meta->free;
        }
        ((PAGE *)meta)->lsn = *lsnp;
        modified = 1;
      } else {
        goto _L___5;
      }
    }
  } else {
    _L___5: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        meta->free = argp->next;
        ((PAGE *)meta)->lsn = argp->meta_lsn;
        modified = 1;
      } else {
        if ((int )op == 3) {
          meta->free = argp->next;
          ((PAGE *)meta)->lsn = argp->meta_lsn;
          modified = 1;
        } else {
          if ((int )op == 2) {
            meta->free = argp->next;
            ((PAGE *)meta)->lsn = argp->meta_lsn;
            modified = 1;
          }
        }
      }
    }
  }
  if (modified) {
    tmp___1 = 2;
  } else {
    tmp___1 = 0;
  }
  ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp___1);
  if (ret != 0) {
    goto out;
  }
  meta = (DBMETA *)((void *)0);
  *lsnp = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)meta, 0U);
  }
  return (ret);
}
}
extern  __attribute__((__nothrow__)) int pthread_mutex_destroy(pthread_mutex_t___0 *__mutex ) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_lock(pthread_mutex_t___0 *__mutex ) ;
extern  __attribute__((__nothrow__)) int pthread_mutex_unlock(pthread_mutex_t___0 *__mutex ) ;
extern  __attribute__((__nothrow__)) int pthread_cond_init(pthread_cond_t___0 * __restrict  __cond ,
                                                           pthread_condattr_t___0 const   * __restrict  __cond_attr ) ;
extern  __attribute__((__nothrow__)) int pthread_cond_signal(pthread_cond_t___0 *__cond ) ;
extern int pthread_cond_wait(pthread_cond_t___0 * __restrict  __cond , pthread_mutex_t___0 * __restrict  __mutex ) ;
extern  __attribute__((__nothrow__)) int pthread_condattr_init(pthread_condattr_t___0 *__attr ) ;
extern  __attribute__((__nothrow__)) int pthread_condattr_destroy(pthread_condattr_t___0 *__attr ) ;
int __db_pthread_mutex_init(DB_ENV *dbenv___0 , DB_MUTEX *mutexp , u_int32_t___1 flags ) ;
int __db_pthread_mutex_lock(DB_ENV *dbenv___0 , DB_MUTEX *mutexp ) ;
int __db_pthread_mutex_unlock(DB_ENV *dbenv___0 , DB_MUTEX *mutexp ) ;
int __db_pthread_mutex_destroy(DB_MUTEX *mutexp ) ;
int __db_pthread_mutex_init(DB_ENV *dbenv___0 , DB_MUTEX *mutexp , u_int32_t___1 flags ) 
{ u_int32_t___1 save ;
  int ret ;
  pthread_condattr_t___0 condattr ;
  pthread_condattr_t___0 *condattrp ;
  pthread_mutexattr_t___0 mutexattr ;
  pthread_mutexattr_t___0 *mutexattrp ;
  char *tmp ;

  {
  ret = 0;
  save = mutexp->flags & 16U;
  memset((void *)mutexp, 0, sizeof(*mutexp));
  mutexp->flags |= save;
  if (flags & 256U) {
    goto _L;
  } else {
    if (dbenv___0->flags & 32768U) {
      _L: 
      if (! (dbenv___0->flags & 1048576U)) {
        mutexp->flags |= 2U;
        return (0);
      }
    }
  }
  condattrp = (pthread_condattr_t___0 *)((void *)0);
  mutexattrp = (pthread_mutexattr_t___0 *)((void *)0);
  if (! (flags & 256U)) {
    ret = 0;
    mutexattrp = & mutexattr;
  }
  if (ret == 0) {
    ret = 0;
  }
  if ((unsigned int )mutexattrp != (unsigned int )((void *)0)) {

  }
  if (ret == 0) {
    if (flags & 128U) {
      if (! (flags & 256U)) {
        ret = pthread_condattr_init(& condattr);
      }
      if (ret == 0) {
        ret = pthread_cond_init((pthread_cond_t___0 * __restrict  )(& mutexp->cond),
                                (pthread_condattr_t___0 const   * __restrict  )condattrp);
      }
      mutexp->flags |= 128U;
      if ((unsigned int )condattrp != (unsigned int )((void *)0)) {
        pthread_condattr_destroy(condattrp);
      }
    }
  }
  if (ret == 0) {
    mutexp->flags |= 4U;
  } else {
    tmp = strerror(ret);
    __db_err((DB_ENV const   *)dbenv___0, "unable to initialize mutex: %s", tmp);
  }
  return (ret);
}
}
int __db_pthread_mutex_lock(DB_ENV *dbenv___0 , DB_MUTEX *mutexp ) 
{ u_int32_t___1 nspins ;
  int i ;
  int ret ;
  int waited ;
  int tmp ;
  char *tmp___0 ;

  {
  if (dbenv___0->flags & 1024U) {
    return (0);
  } else {
    if (mutexp->flags & 2U) {
      return (0);
    }
  }
  nspins = dbenv___0->tas_spins;
  while (nspins > 0U) {
    tmp = 0;
    if (tmp == 0) {
      break;
    }
    nspins --;
  }
  if (nspins == 0U) {
    ret = pthread_mutex_lock(& mutexp->mutex);
    if (ret != 0) {
      goto err;
    }
  }
  if (mutexp->flags & 128U) {
    waited = 0;
    while (mutexp->locked != 0U) {
      ret = pthread_cond_wait((pthread_cond_t___0 * __restrict  )(& mutexp->cond),
                              (pthread_mutex_t___0 * __restrict  )(& mutexp->mutex));
      if (ret != 0) {
        if (ret != 4) {
          if (ret != 62) {
            if (ret != 110) {
              pthread_mutex_unlock(& mutexp->mutex);
              return (ret);
            }
          }
        }
      }
      waited = 1;
    }
    if (waited) {
      (mutexp->mutex_set_wait) ++;
    } else {
      (mutexp->mutex_set_nowait) ++;
    }
    mutexp->locked = 1U;
    i = 5;
    while (1) {
      ret = pthread_mutex_unlock(& mutexp->mutex);
      if (ret == 14) {
        i --;
        if (! (i > 0)) {
          break;
        }
      } else {
        break;
      }
    }
    if (ret != 0) {
      goto err;
    }
  } else {
    if (nspins == dbenv___0->tas_spins) {
      (mutexp->mutex_set_nowait) ++;
    } else {
      if (nspins > 0U) {
        (mutexp->mutex_set_spin) ++;
        mutexp->mutex_set_spins += dbenv___0->tas_spins - nspins;
      } else {
        (mutexp->mutex_set_wait) ++;
      }
    }
    mutexp->locked = 1U;
  }
  return (0);
  err: 
  tmp___0 = strerror(ret);
  __db_err((DB_ENV const   *)dbenv___0, "unable to lock mutex: %s", tmp___0);
  return (ret);
}
}
int __db_pthread_mutex_unlock(DB_ENV *dbenv___0 , DB_MUTEX *mutexp ) 
{ int i ;
  int ret ;
  char *tmp ;

  {
  if (dbenv___0->flags & 1024U) {
    return (0);
  } else {
    if (mutexp->flags & 2U) {
      return (0);
    }
  }
  if (mutexp->flags & 128U) {
    ret = pthread_mutex_lock(& mutexp->mutex);
    if (ret != 0) {
      goto err;
    }
    mutexp->locked = 0U;
    ret = pthread_cond_signal(& mutexp->cond);
    if (ret != 0) {
      return (ret);
    }
  } else {
    mutexp->locked = 0U;
  }
  i = 5;
  while (1) {
    ret = pthread_mutex_unlock(& mutexp->mutex);
    if (ret == 14) {
      i --;
      if (! (i > 0)) {
        break;
      }
    } else {
      break;
    }
  }
  return (ret);
  err: 
  tmp = strerror(ret);
  __db_err((DB_ENV const   *)dbenv___0, "unable to unlock mutex: %s", tmp);
  return (ret);
}
}
int __db_pthread_mutex_destroy(DB_MUTEX *mutexp ) 
{ int ret ;
  char *tmp ;

  {
  if (mutexp->flags & 2U) {
    return (0);
  }
  ret = pthread_mutex_destroy(& mutexp->mutex);
  if (ret != 0) {
    tmp = strerror(ret);
    __db_err((DB_ENV const   *)((void *)0), "unable to destroy mutex: %s", tmp);
  }
  return (ret);
}
}
int __lock_put(DB_ENV *dbenv___0 , DB_LOCK *lock ) 
{ DB_LOCKTAB *lt ;
  int ret ;
  int run_dd ;

  {
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      return (0);
    }
  }
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  ret = 10;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  if (ret == 0) {
    if (run_dd) {

    }
  }
  return (ret);
}
}
static int __db_mutex_alloc_int(DB_ENV *dbenv___0 , REGINFO *infop , DB_MUTEX **storep ) 
{ int ret ;

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  infop = (REGINFO *)((void *)0);
  infop = infop;
  ret = 0;
  if (ret != 0) {

  }
  return (ret);
}
}
void __db_mutex_free(DB_ENV *dbenv___0 , REGINFO *infop , DB_MUTEX *mutexp ) 
{ 

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  infop = (REGINFO *)((void *)0);
  infop = infop;
  free((void *)mutexp);
  return;
}
}
int __db_mutex_setup(DB_ENV *dbenv___0 , REGINFO *infop , void *ptr , u_int32_t___1 flags ) 
{ DB_MUTEX *mutex ;
  REGMAINT *maint ;
  u_int32_t___1 iflags ;
  u_int32_t___1 offset ;
  int ret ;

  {
  ret = 0;
  mutex = (DB_MUTEX *)((void *)0);
  if (flags & 1U) {
    ret = __db_mutex_alloc_int(dbenv___0, infop, (DB_MUTEX **)ptr);
    if (ret != 0) {
      goto err;
    }
    mutex = *((DB_MUTEX **)ptr);
  } else {
    mutex = (DB_MUTEX *)ptr;
  }
  iflags = flags & 392U;
  switch ((int )infop->type) {
  case 2: 
  offset = (unsigned int )mutex + 1U;
  break;
  case 4: 
  offset = (unsigned int )mutex + 2U;
  break;
  default: 
  offset = (unsigned int )mutex;
  break;
  }
  maint = (REGMAINT *)((void *)0);
  ret = __db_pthread_mutex_init(dbenv___0, mutex, iflags);
  err: 
  if (ret != 0) {
    if (flags & 1U) {
      if ((unsigned int )mutex != (unsigned int )((void *)0)) {
        __db_mutex_free(dbenv___0, infop, mutex);
        *((DB_MUTEX **)ptr) = (DB_MUTEX *)((void *)0);
      }
    }
  }
  return (ret);
}
}
int __db_c_close(DBC *dbc ) 
{ DB *dbp___1 ;
  DBC *opd ;
  DBC_INTERNAL *cp ;
  DB_ENV *dbenv___0 ;
  int ret ;
  int t_ret ;

  {
  dbp___1 = dbc->dbp;
  dbenv___0 = dbp___1->dbenv;
  cp = dbc->internal;
  opd = cp->opd;
  ret = 0;
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  if ((unsigned int )opd != (unsigned int )((void *)0)) {
    opd->flags &= 4294967294U;
    while (1) {
      if ((unsigned int )opd->links.tqe_next != (unsigned int )((void *)0)) {
        (opd->links.tqe_next)->links.tqe_prev = opd->links.tqe_prev;
      } else {
        dbp___1->active_queue.tqh_last = opd->links.tqe_prev;
      }
      *(opd->links.tqe_prev) = opd->links.tqe_next;
      break;
    }
  }
  dbc->flags &= 4294967294U;
  while (1) {
    if ((unsigned int )dbc->links.tqe_next != (unsigned int )((void *)0)) {
      (dbc->links.tqe_next)->links.tqe_prev = dbc->links.tqe_prev;
    } else {
      dbp___1->active_queue.tqh_last = dbc->links.tqe_prev;
    }
    *(dbc->links.tqe_prev) = dbc->links.tqe_next;
    break;
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  t_ret = (*(dbc->c_am_close))(dbc, 0U, (int *)((void *)0));
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (dbenv___0->flags & 2U) {
    if (dbc->mylock.off != 0U) {
      t_ret = __lock_put(dbenv___0, & dbc->mylock);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
    memset((void *)(& dbc->mylock), 0, sizeof(dbc->mylock));
    if ((unsigned int )opd != (unsigned int )((void *)0)) {
      memset((void *)(& opd->mylock), 0, sizeof(opd->mylock));
    }
  }
  if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
    ((dbc->txn)->cursors) --;
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbp___1->mutexp);
    }
  }
  if ((unsigned int )opd != (unsigned int )((void *)0)) {
    if ((unsigned int )dbc->txn != (unsigned int )((void *)0)) {
      ((dbc->txn)->cursors) --;
    }
    while (1) {
      opd->links.tqe_next = (DBC *)((void *)0);
      opd->links.tqe_prev = dbp___1->free_queue.tqh_last;
      *(dbp___1->free_queue.tqh_last) = opd;
      dbp___1->free_queue.tqh_last = & opd->links.tqe_next;
      break;
    }
    opd = (DBC *)((void *)0);
  }
  while (1) {
    dbc->links.tqe_next = (DBC *)((void *)0);
    dbc->links.tqe_prev = dbp___1->free_queue.tqh_last;
    *(dbp___1->free_queue.tqh_last) = dbc;
    dbp___1->free_queue.tqh_last = & dbc->links.tqe_next;
    break;
  }
  if ((unsigned int )dbp___1->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbp___1->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbp___1->mutexp);
    }
  }
  return (ret);
}
}
int __dbreg_id_to_db(DB_ENV *dbenv___0 , DB_TXN *txn , DB **dbpp , int32_t___0 ndx ,
                     int inc ) 
{ int tmp ;

  {
  tmp = 0;
  *dbpp = (DB *)0;
  return (tmp);
}
}
int __dbreg_id_to_fname(DB_LOG *dblp , int32_t___0 lid , int have_lock , FNAME **fnamep ) 
{ 

  {
  *fnamep = (FNAME *)((void *)0);
  return (0);
}
}
int __db_cursor(DB *dbp___1 , DB_TXN *txn , DBC **dbcp , u_int32_t___1 flags ) 
{ 

  {
  *dbcp = (DBC *)10;
  return (0);
}
}
static int __db_txnlist_pgnoadd(DB_ENV *dbenv___0 , DB_TXNHEAD *hp , int32_t___0 fileid ,
                                u_int8_t___0 *uid , char *fname , db_pgno_t pgno ) 
{ void *tmp ;
  void *tmp___0 ;

  {
  tmp = malloc(sizeof(struct __db ));
  hp->head[0].lh_first = (struct __db_txnlist *)((struct __db *)tmp);
  tmp___0 = malloc(sizeof(struct __db *));
  (hp->head[0].lh_first)->links.le_prev = (struct __db_txnlist **)((struct __db **)tmp___0);
  return (0);
}
}
int __db_add_limbo(DB_ENV *dbenv___0 , void *info , int32_t___0 fileid , db_pgno_t pgno ,
                   int32_t___0 count ) 
{ DB_LOG *dblp ;
  FNAME *fnp ;
  int ret ;

  {
  dblp = (DB_LOG *)dbenv___0->lg_handle;
  ret = __dbreg_id_to_fname(dblp, fileid, 0, & fnp);
  if (ret != 0) {
    return (ret);
  }
  while (1) {
    ret = __db_txnlist_pgnoadd(dbenv___0, (DB_TXNHEAD *)info, fileid, fnp->ufid, (char *)((void *)((u_int8_t___0 *)dblp->reginfo.addr + fnp->name_off)),
                               pgno);
    if (ret != 0) {
      return (ret);
    }
    pgno ++;
    count --;
    if (! (count != 0)) {
      break;
    }
  }
  return (0);
}
}
int __db_pg_alloc_read(DB_ENV *dbenv___0 , void *recbuf , __db_pg_alloc_args **argpp ) 
{ __db_pg_alloc_args *argp ;
  u_int32_t___1 uinttmp ;
  u_int8_t___0 *bp ;
  int ret ;

  {
  ret = 10;
  if (ret != 0) {
    return (ret);
  }
  argp->txnid = (DB_TXN *)(argp + 1);
  bp = (u_int8_t___0 *)recbuf;
  memcpy((void * __restrict  )(& argp->type), (void const   * __restrict  )bp, sizeof(argp->type));
  bp += sizeof(argp->type);
  memcpy((void * __restrict  )(& (argp->txnid)->txnid), (void const   * __restrict  )bp,
         sizeof((argp->txnid)->txnid));
  bp += sizeof((argp->txnid)->txnid);
  memcpy((void * __restrict  )(& argp->prev_lsn), (void const   * __restrict  )bp,
         sizeof(DB_LSN ));
  bp += sizeof(DB_LSN );
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->fileid = (int )uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->meta_lsn), (void const   * __restrict  )bp,
         sizeof(argp->meta_lsn));
  bp += sizeof(argp->meta_lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->meta_pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& argp->page_lsn), (void const   * __restrict  )bp,
         sizeof(argp->page_lsn));
  bp += sizeof(argp->page_lsn);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->pgno = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->ptype = uinttmp;
  bp += sizeof(uinttmp);
  memcpy((void * __restrict  )(& uinttmp), (void const   * __restrict  )bp, sizeof(uinttmp));
  argp->next = uinttmp;
  bp += sizeof(uinttmp);
  *argpp = argp;
  return (0);
}
}
int __db_pg_alloc_recover(DB_ENV *dbenv___0 , DBT *dbtp , DB_LSN *lsnp , db_recops op ,
                          void *info ) 
{ __db_pg_alloc_args *argp ;
  DB *file_dbp ;
  DBC *dbc ;
  DBMETA *meta ;
  DB_MPOOLFILE *mpf ;
  PAGE *pagep ;
  db_pgno_t pgno ;
  int cmp_n ;
  int cmp_p ;
  int created ;
  int level ;
  int modified ;
  int ret ;
  int tmp ;
  int tmp___0 ;
  int __t_ret ;

  {
  meta = (DBMETA *)((void *)0);
  pagep = (PAGE *)((void *)0);
  while (1) {
    argp = (__db_pg_alloc_args *)((void *)0);
    dbc = (DBC *)((void *)0);
    file_dbp = (DB *)((void *)0);
    mpf = (DB_MPOOLFILE *)((void *)0);
    ret = __db_pg_alloc_read(dbenv___0, dbtp->data, & argp);
    if (ret != 0) {
      goto out;
    }
    ret = __dbreg_id_to_db(dbenv___0, argp->txnid, & file_dbp, argp->fileid, 0);
    if (ret != 0) {
      if (ret == -30898) {
        ret = 0;
        goto done;
      }
      goto out;
    }
    ret = __db_cursor(file_dbp, (DB_TXN *)((void *)0), & dbc, 0U);
    if (ret != 0) {
      goto out;
    }
    dbc->flags |= 16U;
    mpf = file_dbp->mpf;
    break;
  }
  pgno = 0U;
  ret = __memp_fget(mpf, & pgno, 0U, (void *)(& meta));
  if (ret != 0) {
    if ((int )op == 4) {
      ret = __db_pgerr(file_dbp, pgno, ret);
      goto out;
    } else {
      if ((int )op == 1) {
        ret = __db_pgerr(file_dbp, pgno, ret);
        goto out;
      } else {
        goto done;
      }
    }
  }
  modified = 0;
  created = modified;
  ret = __memp_fget(mpf, & argp->pgno, 0U, (void *)(& pagep));
  if (ret != 0) {
    ret = __memp_fget(mpf, & argp->pgno, 1U, (void *)(& pagep));
    if (ret != 0) {
      if (ret == 28) {
        goto do_meta;
      }
      ret = __db_pgerr(file_dbp, argp->pgno, ret);
      goto out;
    }
    modified = 1;
    created = modified;
  }
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& pagep->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& pagep->lsn), (DB_LSN const   *)(& argp->page_lsn));
  if (pagep->lsn.file == 0U) {
    cmp_p = 0;
  }
  if ((int )op == 4) {
    goto _L;
  } else {
    if ((int )op == 1) {
      _L: 
      if (cmp_p < 0) {
        if (pagep->lsn.file == 0U) {
          if (! (pagep->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                     (unsigned long )argp->page_lsn.file, (unsigned long )argp->page_lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )pagep->lsn.file, (unsigned long )pagep->lsn.offset,
                   (unsigned long )argp->page_lsn.file, (unsigned long )argp->page_lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if ((int )op == 4) {
    goto _L___4;
  } else {
    if ((int )op == 1) {
      _L___4: 
      if (cmp_p == 0) {
        goto _L___3;
      } else {
        if (argp->page_lsn.file == 0U) {
          if (pagep->lsn.file == 1U) {
            if (pagep->lsn.offset == 0U) {
              _L___3: 
              switch ((int )argp->ptype) {
              case 5: ;
              case 6: ;
              case 12: 
              level = 1;
              break;
              default: 
              level = 0;
              break;
              }
              while (1) {
                pagep->pgno = argp->pgno;
                pagep->prev_pgno = 0U;
                pagep->next_pgno = 0U;
                pagep->entries = (unsigned short)0;
                pagep->hf_offset = (unsigned short )file_dbp->pgsize;
                pagep->level = (unsigned char )level;
                pagep->type = (unsigned char )argp->ptype;
                break;
              }
              pagep->lsn = *lsnp;
              modified = 1;
            } else {
              goto _L___2;
            }
          } else {
            goto _L___2;
          }
        } else {
          goto _L___2;
        }
      }
    } else {
      _L___2: 
      if ((int )op == 0) {
        goto _L___1;
      } else {
        if ((int )op == 3) {
          goto _L___1;
        } else {
          if ((int )op == 2) {
            _L___1: 
            if (cmp_n == 0) {
              goto _L___0;
            } else {
              if (created) {
                _L___0: 
                while (1) {
                  pagep->pgno = argp->pgno;
                  pagep->prev_pgno = 0U;
                  pagep->next_pgno = argp->next;
                  pagep->entries = (unsigned short)0;
                  pagep->hf_offset = (unsigned short )file_dbp->pgsize;
                  pagep->level = (unsigned char)0;
                  pagep->type = (unsigned char)0;
                  break;
                }
                pagep->lsn = argp->page_lsn;
                modified = 1;
              }
            }
          }
        }
      }
    }
  }
  if (pagep->lsn.file == 0U) {
    if (argp->page_lsn.file == 0U) {
      if ((int )op == 0) {
        goto _L___5;
      } else {
        if ((int )op == 3) {
          goto _L___5;
        } else {
          if ((int )op == 2) {
            _L___5: 
            ret = __db_add_limbo(dbenv___0, info, argp->fileid, argp->pgno, 1);
            if (ret != 0) {
              goto out;
            }
          }
        }
      }
    }
  }
  if (modified) {
    tmp = 2;
  } else {
    tmp = 0;
  }
  ret = __memp_fput(mpf, (void *)pagep, (unsigned int )tmp);
  if (ret != 0) {
    goto out;
  }
  pagep = (PAGE *)((void *)0);
  do_meta: 
  modified = 0;
  cmp_n = log_compare((DB_LSN const   *)lsnp, (DB_LSN const   *)(& ((PAGE *)meta)->lsn));
  cmp_p = log_compare((DB_LSN const   *)(& ((PAGE *)meta)->lsn), (DB_LSN const   *)(& argp->meta_lsn));
  if ((int )op == 4) {
    goto _L___6;
  } else {
    if ((int )op == 1) {
      _L___6: 
      if (cmp_p < 0) {
        if (((PAGE *)meta)->lsn.file == 0U) {
          if (! (((PAGE *)meta)->lsn.offset == 1U)) {
            __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                     (unsigned long )((PAGE *)meta)->lsn.file, (unsigned long )((PAGE *)meta)->lsn.offset,
                     (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
            ret = 22;
            goto out;
          }
        } else {
          __db_err((DB_ENV const   *)dbenv___0, "Log sequence error: page LSN %lu %lu; previous LSN %lu %lu",
                   (unsigned long )((PAGE *)meta)->lsn.file, (unsigned long )((PAGE *)meta)->lsn.offset,
                   (unsigned long )argp->meta_lsn.file, (unsigned long )argp->meta_lsn.offset);
          ret = 22;
          goto out;
        }
      }
    }
  }
  if (cmp_p == 0) {
    if ((int )op == 4) {
      ((PAGE *)meta)->lsn = *lsnp;
      meta->free = argp->next;
      modified = 1;
    } else {
      if ((int )op == 1) {
        ((PAGE *)meta)->lsn = *lsnp;
        meta->free = argp->next;
        modified = 1;
      } else {
        goto _L___8;
      }
    }
  } else {
    _L___8: 
    if (cmp_n == 0) {
      if ((int )op == 0) {
        goto _L___7;
      } else {
        if ((int )op == 3) {
          goto _L___7;
        } else {
          if ((int )op == 2) {
            _L___7: 
            ((PAGE *)meta)->lsn = argp->meta_lsn;
            if (! (argp->page_lsn.file == 0U)) {
              meta->free = argp->pgno;
            }
            modified = 1;
          }
        }
      }
    }
  }
  if (argp->pgno > meta->last_pgno) {
    meta->last_pgno = argp->pgno;
    modified = 1;
  }
  if (modified) {
    tmp___0 = 2;
  } else {
    tmp___0 = 0;
  }
  ret = __memp_fput(mpf, (void *)meta, (unsigned int )tmp___0);
  if (ret != 0) {
    goto out;
  }
  meta = (DBMETA *)((void *)0);
  done: 
  *lsnp = argp->prev_lsn;
  ret = 0;
  out: 
  if ((unsigned int )pagep != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)pagep, 0U);
  }
  if ((unsigned int )meta != (unsigned int )((void *)0)) {
    __memp_fput(mpf, (void *)meta, 0U);
  }
  if (ret == 2) {
    if ((int )op == 2) {
      ret = 0;
    }
  }
  if ((unsigned int )argp != (unsigned int )((void *)0)) {

  }
  if ((unsigned int )dbc != (unsigned int )((void *)0)) {
    __t_ret = __db_c_close(dbc);
    if (__t_ret != 0) {
      if (ret == 0) {
        ret = __t_ret;
      }
    }
  }
  return (ret);
}
}
int __os_get_errno(void) 
{ 

  {
  return (0);
}
}
static char ebuf[40]  ;
extern int ( /* missing proto */  snprintf)() ;
char *db_strerror(int error ) 
{ char *p ;

  {
  if (error == 0) {
    return ((char *)"Successful return: 0");
  }
  if (error > 0) {
    p = strerror(error);
    if ((unsigned int )p != (unsigned int )((void *)0)) {
      return (p);
    }
    goto unknown_err;
  }
  switch (error) {
  case -30999: ;
  return ((char *)"DB_DONOTINDEX: Secondary index callback returns null");
  case -30998: ;
  return ((char *)"DB_FILEOPEN: Rename or remove while file is open.");
  case -30997: ;
  return ((char *)"DB_KEYEMPTY: Non-existent key/data pair");
  case -30996: ;
  return ((char *)"DB_KEYEXIST: Key/data pair already exists");
  case -30995: ;
  return ((char *)"DB_LOCK_DEADLOCK: Locker killed to resolve a deadlock");
  case -30994: ;
  return ((char *)"DB_LOCK_NOTGRANTED: Lock not granted");
  case -30993: ;
  return ((char *)"DB_NOSERVER: Fatal error, no RPC server");
  case -30992: ;
  return ((char *)"DB_NOSERVER_HOME: Home unrecognized at server");
  case -30991: ;
  return ((char *)"DB_NOSERVER_ID: Identifier unrecognized at server");
  case -30990: ;
  return ((char *)"DB_NOTFOUND: No matching key/data pair found");
  case -30989: ;
  return ((char *)"DB_OLDVERSION: Database requires a version upgrade");
  case -30988: ;
  return ((char *)"DB_PAGE_NOTFOUND: Requested page not found");
  case -30987: ;
  return ((char *)"DB_REP_DUPMASTER: A second master site appeared");
  case -30986: ;
  return ((char *)"DB_REP_HANDLE_DEAD: Handle is no longer valid.");
  case -30985: ;
  return ((char *)"DB_REP_HOLDELECTION: Need to hold an election");
  case -30984: ;
  return ((char *)"DB_REP_ISPERM: Permanent record written");
  case -30983: ;
  return ((char *)"DB_REP_NEWMASTER: A new master has declared itself");
  case -30982: ;
  return ((char *)"DB_REP_NEWSITE: A new site has entered the system");
  case -30981: ;
  return ((char *)"DB_REP_NOTPERM: Permanent log record not written.");
  case -30980: ;
  return ((char *)"DB_REP_OUTDATED: Insufficient logs on master to recover");
  case -30979: ;
  return ((char *)"DB_REP_UNAVAIL: Unable to elect a master");
  case -30978: ;
  return ((char *)"DB_RUNRECOVERY: Fatal error, run database recovery");
  case -30977: ;
  return ((char *)"DB_SECONDARY_BAD: Secondary index inconsistent with primary");
  case -30976: ;
  return ((char *)"DB_VERIFY_BAD: Database verification failed");
  default: ;
  break;
  }
  unknown_err: 
  snprintf((char * __restrict  )(ebuf), sizeof(ebuf), (char const   * __restrict  )"Unknown error: %d",
           error);
  return (ebuf);
}
}
struct __db_globals __db_global_values ;
struct __db_globals __db_global_values  = 
     {{(struct __db_env *)((void *)0), & __db_global_values.db_envq.tqh_first}, (int (*)(int  ))((void *)0),
    (void (*)(char ** , int  ))((void *)0), (int (*)(char const   * , char *** , int * ))((void *)0),
    (int (*)(char const   * , int * ))((void *)0), (void (*)(void * ))((void *)0),
    (int (*)(int  ))((void *)0), (int (*)(char const   * , int  , u_int32_t___1 * ,
                                          u_int32_t___1 * , u_int32_t___1 * ))((void *)0),
    (void *(*)(size_t___0  ))((void *)0), (int (*)(char * , size_t___0  , int  , int  ,
                                                   void ** ))((void *)0), (int (*)(char const   * ,
                                                                                   int  
                                                                                   , ...))((void *)0),
    (ssize_t___0 (*)(int  , void * , size_t___0  ))((void *)0), (void *(*)(void * ,
                                                                           size_t___0  ))((void *)0),
    (int (*)(char const   * , char const   * ))((void *)0), (int (*)(int  , size_t___0  ,
                                                                     db_pgno_t  ,
                                                                     u_int32_t___1  ,
                                                                     int  , int  ))((void *)0),
    (int (*)(u_long___0  , u_long___0  ))((void *)0), (int (*)(char const   * ))((void *)0),
    (int (*)(void * , size_t___0  ))((void *)0), (ssize_t___0 (*)(int  , void const   * ,
                                                                  size_t___0  ))((void *)0),
    (int (*)(void))((void *)0)};
static char const   __db_locker_invalid[20]  = 
  {      (char const   )'L',      (char const   )'o',      (char const   )'c',      (char const   )'k', 
        (char const   )'e',      (char const   )'r',      (char const   )' ',      (char const   )'i', 
        (char const   )'s',      (char const   )' ',      (char const   )'n',      (char const   )'o', 
        (char const   )'t',      (char const   )' ',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )'\000'};
int __db_close(DB *dbp___1 , DB_TXN *txn , u_int32_t___1 flags ) ;
extern int ( /* missing proto */  unlink)() ;
int __os_unlink(DB_ENV *dbenv___0 , char const   *path ) 
{ int ret ;
  int retries ;
  char *tmp___1 ;

  {
  retries = 0;
  retry: 
  if ((unsigned int )__db_global_values.j_unlink != (unsigned int )((void *)0)) {
    ret = (*(__db_global_values.j_unlink))(path);
  } else {
    ret = unlink(path);
  }
  if (ret == -1) {
    ret = __os_get_errno();
    if (ret == 4) {
      goto _L;
    } else {
      if (ret == 16) {
        _L: 
        retries ++;
        if (retries < 100) {
          goto retry;
        }
      }
    }
    if (ret != 2) {
      tmp___1 = strerror(ret);
    }
  }
  return (ret);
}
}
void __os_free(DB_ENV *dbenv___0 , void *ptr ) 
{ 

  {
  dbenv___0 = (DB_ENV *)((void *)0);
  dbenv___0 = dbenv___0;
  if ((unsigned int )__db_global_values.j_free != (unsigned int )((void *)0)) {
    (*(__db_global_values.j_free))(ptr);
  } else {
    free(ptr);
  }
  return;
}
}
extern int ( /* missing proto */  fclose)() ;
int __bam_db_close(DB *dbp___1 ) 
{ BTREE *t ;

  {
  t = (BTREE *)dbp___1->bt_internal;
  if ((unsigned int )t == (unsigned int )((void *)0)) {
    return (0);
  }
  if ((unsigned int )t->re_fp != (unsigned int )((void *)0)) {
    fclose(t->re_fp);
  }
  if ((unsigned int )t->re_source != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)t->re_source);
  }
  __os_free(dbp___1->dbenv, (void *)t);
  dbp___1->bt_internal = (void *)0;
  return (0);
}
}
int __db_cursor_int(DB *dbp___1 , DB_TXN *txn , DBTYPE dbtype , db_pgno_t root , int is_opd ,
                    u_int32_t___1 lockerid , DBC **dbcp ) 
{ 

  {
  return (0);
}
}
int __db_not_txn_env(DB_ENV *dbenv___0 ) 
{ 

  {
  if (dbenv___0) {
    return (22);
  } else {
    return (0);
  }
}
}
int __db_check_txn(DB *dbp___1 , DB_TXN *txn , u_int32_t___1 assoc_lid , int read_op ) 
{ DB_ENV *dbenv___0 ;
  int tmp ;

  {
  dbenv___0 = dbp___1->dbenv;
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      return (0);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (dbp___1->flags & 2097152U) {
      return (0);
    }
  }
  if ((unsigned int )txn == (unsigned int )((void *)0)) {
    if (! read_op) {
      if (dbp___1->flags & 536870912U) {
        __db_err((DB_ENV const   *)dbenv___0, "DB handle previously used in transaction, missing transaction handle");
        return (22);
      }
    }
    if (dbp___1->cur_lid >= 2147483648U) {
      goto open_err;
    }
  } else {
    if (dbp___1->cur_lid >= 2147483648U) {
      if (dbp___1->cur_lid != txn->txnid) {
        goto open_err;
      }
    }
    if (! ((unsigned int )dbenv___0->tx_handle != (unsigned int )((void *)0))) {
      tmp = __db_not_txn_env(dbenv___0);
      return (tmp);
    }
    if (! (dbp___1->flags & 536870912U)) {
      __db_err((DB_ENV const   *)dbenv___0, "Transaction specified for a DB handle opened outside a transaction");
      return (22);
    }
  }
  if (! read_op) {
    if (dbp___1->associate_lid != 0U) {
      if ((unsigned int )txn != (unsigned int )((void *)0)) {
        if (dbp___1->associate_lid != assoc_lid) {
          __db_err((DB_ENV const   *)dbenv___0, "Operation forbidden while secondary index is being created");
          return (22);
        }
      }
    }
  }
  return (0);
  open_err: 
  __db_err((DB_ENV const   *)dbenv___0, "Transaction that opened the DB handle is still active");
  return (22);
}
}
static int __db_wrlock_err(DB_ENV *dbenv___0 ) 
{ 

  {
  if (dbenv___0) {
    return (1);
  } else {
    return (0);
  }
}
}
int __lock_get(DB_ENV *dbenv___0 , u_int32_t___1 locker , u_int32_t___1 flags , DBT const   *obj ,
               db_lockmode_t lock_mode , DB_LOCK *lock ) 
{ int ret ;

  {
  if ((unsigned int )dbenv___0->lg_handle != (unsigned int )((void *)0)) {
    if (((DB_LOG *)dbenv___0->lg_handle)->flags & 1U) {
      lock->off = 0U;
      return (0);
    }
  }
  if (! ((((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex);
  }
  ret = 0;
  if (! ((((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (((DB_LOCKTAB *)dbenv___0->lk_handle)->reginfo.rp)->mutex);
  }
  return (ret);
}
}
int __lock_downgrade(DB_ENV *dbenv___0 , DB_LOCK *lock , db_lockmode_t new_mode ,
                     u_int32_t___1 flags ) 
{ struct __db_lock *lockp ;
  DB_LOCKER *sh_locker ;
  DB_LOCKOBJ *obj ;
  DB_LOCKREGION *region ;
  DB_LOCKTAB *lt ;
  u_int32_t___1 indx ;
  int ret ;
  int tmp ;
  u_int32_t___1 tmp___0 ;

  {
  flags = 0U;
  flags = flags;
  if (! (dbenv___0->flags & 4096U)) {
    if ((unsigned int )dbenv___0->reginfo != (unsigned int )((void *)0)) {
      if (((REGENV *)((REGINFO *)dbenv___0->reginfo)->primary)->envpanic != 0) {
        tmp = 0;
        return (tmp);
      }
    }
  }
  ret = 0;
  if (dbenv___0->flags & 1024U) {
    return (0);
  }
  lt = (DB_LOCKTAB *)dbenv___0->lk_handle;
  region = (DB_LOCKREGION *)lt->reginfo.primary;
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  lockp = (struct __db_lock *)((void *)((u_int8_t___0 *)lt->reginfo.addr + lock->off));
  if (lock->gen != lockp->gen) {
    __db_err((DB_ENV const   *)dbenv___0, __db_lock_invalid, "lock_downgrade");
    ret = 22;
    goto out;
  }
  tmp___0 = 0U;
  indx = tmp___0 % region->locker_t_size;
  ret = 0;
  if (ret != 0) {
    goto _L;
  } else {
    if ((unsigned int )sh_locker == (unsigned int )((void *)0)) {
      _L: 
      if (ret == 0) {
        ret = 22;
      }
      __db_err((DB_ENV const   *)dbenv___0, __db_locker_invalid);
      goto out;
    }
  }
  if ((int )lockp->mode == 2) {
    goto _L___0;
  } else {
    if ((int )lockp->mode == 8) {
      goto _L___0;
    } else {
      if ((int )lockp->mode == 4) {
        goto _L___0;
      } else {
        if ((int )lockp->mode == 6) {
          _L___0: 
          if (! ((int )new_mode == 2)) {
            if (! ((int )new_mode == 8)) {
              if (! ((int )new_mode == 4)) {
                if (! ((int )new_mode == 6)) {
                  (sh_locker->nwrites) --;
                }
              }
            }
          }
        }
      }
    }
  }
  if ((int )new_mode == 8) {
    sh_locker->flags |= 2U;
  }
  lockp->mode = new_mode;
  obj = (DB_LOCKOBJ *)((u_int8_t___0 *)lockp + lockp->obj);
  out: 
  if (! ((lt->reginfo.rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & (lt->reginfo.rp)->mutex);
  }
  return (ret);
}
}
DB *__db_s_first(DB *pdbp ) 
{ DB *sdbp ;

  {
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  sdbp = pdbp->s_secondaries.lh_first;
  if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
    (sdbp->s_refcnt) ++;
  }
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  return (sdbp);
}
}
int __db_secondary_corrupt(DB *dbp___1 ) 
{ 

  {
  if (dbp___1->dbenv) {
    return (-30977);
  } else {
    return (0);
  }
}
}
void __os_ufree(DB_ENV *dbenv___0 , void *ptr ) 
{ 

  {
  if ((unsigned int )dbenv___0 != (unsigned int )((void *)0)) {
    if ((unsigned int )dbenv___0->db_free != (unsigned int )((void *)0)) {
      (*(dbenv___0->db_free))(ptr);
    } else {
      goto _L;
    }
  } else {
    _L: 
    if ((unsigned int )__db_global_values.j_free != (unsigned int )((void *)0)) {
      (*(__db_global_values.j_free))(ptr);
    } else {
      free(ptr);
    }
  }
  return;
}
}
int __db_s_next(DB **sdbpp ) 
{ DB *sdbp ;
  DB *pdbp ;
  DB *closeme ;
  int ret ;

  {
  sdbp = *sdbpp;
  pdbp = sdbp->s_primary;
  closeme = (DB *)((void *)0);
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  (sdbp->s_refcnt) --;
  if (sdbp->s_refcnt == 0U) {
    while (1) {
      if ((unsigned int )sdbp->s_links.le_next != (unsigned int )((void *)0)) {
        (sdbp->s_links.le_next)->s_links.le_prev = sdbp->s_links.le_prev;
      }
      *(sdbp->s_links.le_prev) = sdbp->s_links.le_next;
      break;
    }
    closeme = sdbp;
  }
  sdbp = sdbp->s_links.le_next;
  if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
    (sdbp->s_refcnt) ++;
  }
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  *sdbpp = sdbp;
  if ((unsigned int )closeme != (unsigned int )((void *)0)) {
    ret = __db_close(closeme, (DB_TXN *)((void *)0), 0U);
  } else {
    ret = 0;
  }
  return (ret);
}
}
extern  __attribute__((__nothrow__)) int munmap(void *__addr , size_t___0 __len ) ;
extern  __attribute__((__nothrow__)) int munlock(void const   *__addr , size_t___0 __len ) ;
int __os_unmapfile(DB_ENV *dbenv___0 , void *addr , size_t___0 len ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int err ;
  int ret ;
  int retries ;
  int tmp___2 ;

  {
  if ((unsigned int )__db_global_values.j_unmap != (unsigned int )((void *)0)) {
    tmp = (*(__db_global_values.j_unmap))(addr, len);
    return (tmp);
  }
  if (dbenv___0->flags & 256U) {
    while (1) {
      tmp___0 = munlock((void const   *)addr, len);
      if (tmp___0 != 0) {
        tmp___1 = 0;
        if (! (tmp___1 == 4)) {
          break;
        }
      } else {
        break;
      }
    }
  }
  retries = 0;
  err = retries;
  while (1) {
    ret = munmap(addr, len);
    if (ret != 0) {
      err = 0;
      if (err == 4) {
        goto _L;
      } else {
        if (err == 16) {
          _L: 
          retries ++;
          if (! (retries < 100)) {
            break;
          }
        } else {
          break;
        }
      }
    } else {
      break;
    }
  }
  if (ret) {
    tmp___2 = err;
  } else {
    tmp___2 = 0;
  }
  return (tmp___2);
}
}
char *__memp_fns(DB_MPOOL *dbmp , MPOOLFILE *mfp ) 
{ 

  {
  if (mfp->path_off == 0U) {
    return ((char *)"temporary");
  }
  return ((char *)((void *)((u_int8_t___0 *)(dbmp->reginfo)->addr + mfp->path_off)));
}
}
char *__memp_fn(DB_MPOOLFILE *dbmfp ) 
{ char *tmp ;

  {
  tmp = __memp_fns((DB_MPOOL *)(dbmfp->dbenv)->mp_handle, dbmfp->mfp);
  return (tmp);
}
}
int __memp_mf_sync(DB_MPOOL *dbmp , MPOOLFILE *mfp ) 
{ 

  {
  return (0);
}
}
void __db_shalloc_free(void *regionp , void *ptr ) 
{ struct __data *elp ;
  struct __data *lastp ;
  struct __data *newp ;
  struct __head *hp ;
  size_t___0 free_size ;
  size_t___0 *sp ;
  int merged ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  sp = (size_t___0 *)ptr;
  while (*(sp + -1) == 1U) {
    sp --;
  }
  ptr = (void *)sp;
  newp = (struct __data *)((u_int8_t___0 *)ptr - sizeof(size_t___0 ));
  free_size = newp->len;
  hp = (struct __head *)regionp;
  if (hp->slh_first == -1) {
    elp = (struct __data *)((void *)0);
  } else {
    elp = (struct __data *)((u_int8_t___0 *)hp + hp->slh_first);
  }
  lastp = (struct __data *)((void *)0);
  while (1) {
    if ((unsigned int )elp != (unsigned int )((void *)0)) {
      if (! ((unsigned int )((void *)elp) < (unsigned int )ptr)) {
        break;
      }
    } else {
      break;
    }
    lastp = elp;
    if (elp->links.sle_next == -1) {
      elp = (struct __data *)((void *)0);
    } else {
      elp = (struct __data *)((u_int8_t___0 *)elp + elp->links.sle_next);
    }
  }
  merged = 0;
  if ((unsigned int )((u_int8_t___0 *)ptr + free_size) == (unsigned int )((u_int8_t___0 *)elp)) {
    newp->len += elp->len + sizeof(size_t___0 );
    while (1) {
      if (elp->links.sle_next != -1) {
        ((struct __data *)((u_int8_t___0 *)elp + elp->links.sle_next))->links.sle_prev = elp->links.sle_prev - elp->links.sle_next;
        *((ssize_t___0 *)((u_int8_t___0 *)elp + elp->links.sle_prev)) += elp->links.sle_next;
      } else {
        *((ssize_t___0 *)((u_int8_t___0 *)elp + elp->links.sle_prev)) = -1;
      }
      break;
    }
    if ((unsigned int )lastp != (unsigned int )((void *)0)) {
      while (1) {
        if (lastp->links.sle_next != -1) {
          newp->links.sle_next = (u_int8_t___0 *)((struct __data *)((u_int8_t___0 *)lastp + lastp->links.sle_next)) - (u_int8_t___0 *)newp;
          if (newp->links.sle_next == -1) {
            tmp = 0;
          } else {
            tmp = - newp->links.sle_next;
          }
          ((struct __data *)((u_int8_t___0 *)lastp + lastp->links.sle_next))->links.sle_prev = tmp + ((u_int8_t___0 *)(& newp->links.sle_next) - (u_int8_t___0 *)newp);
        } else {
          newp->links.sle_next = -1;
        }
        lastp->links.sle_next = (u_int8_t___0 *)newp - (u_int8_t___0 *)lastp;
        if (lastp->links.sle_next == -1) {
          tmp___0 = 0;
        } else {
          tmp___0 = - lastp->links.sle_next;
        }
        newp->links.sle_prev = tmp___0 + ((u_int8_t___0 *)(& lastp->links.sle_next) - (u_int8_t___0 *)lastp);
        break;
      }
    } else {
      while (1) {
        if (hp->slh_first != -1) {
          newp->links.sle_next = hp->slh_first - ((u_int8_t___0 *)newp - (u_int8_t___0 *)hp);
          if (newp->links.sle_next == -1) {
            tmp___1 = 0;
          } else {
            tmp___1 = - newp->links.sle_next;
          }
          ((struct __data *)((u_int8_t___0 *)hp + hp->slh_first))->links.sle_prev = tmp___1 + ((u_int8_t___0 *)(& newp->links.sle_next) - (u_int8_t___0 *)newp);
        } else {
          newp->links.sle_next = -1;
        }
        hp->slh_first = (u_int8_t___0 *)newp - (u_int8_t___0 *)hp;
        newp->links.sle_prev = (u_int8_t___0 *)(& hp->slh_first) - (u_int8_t___0 *)newp;
        break;
      }
    }
    merged = 1;
  }
  if ((unsigned int )lastp != (unsigned int )((void *)0)) {
    if ((unsigned int )(((u_int8_t___0 *)lastp + lastp->len) + sizeof(size_t___0 )) == (unsigned int )((u_int8_t___0 *)newp)) {
      lastp->len += newp->len + sizeof(size_t___0 );
      if (merged) {
        while (1) {
          if (newp->links.sle_next != -1) {
            ((struct __data *)((u_int8_t___0 *)newp + newp->links.sle_next))->links.sle_prev = newp->links.sle_prev - newp->links.sle_next;
            *((ssize_t___0 *)((u_int8_t___0 *)newp + newp->links.sle_prev)) += newp->links.sle_next;
          } else {
            *((ssize_t___0 *)((u_int8_t___0 *)newp + newp->links.sle_prev)) = -1;
          }
          break;
        }
      }
      merged = 1;
    }
  }
  if (! merged) {
    if ((unsigned int )lastp == (unsigned int )((void *)0)) {
      while (1) {
        if (hp->slh_first != -1) {
          newp->links.sle_next = hp->slh_first - ((u_int8_t___0 *)newp - (u_int8_t___0 *)hp);
          if (newp->links.sle_next == -1) {
            tmp___2 = 0;
          } else {
            tmp___2 = - newp->links.sle_next;
          }
          ((struct __data *)((u_int8_t___0 *)hp + hp->slh_first))->links.sle_prev = tmp___2 + ((u_int8_t___0 *)(& newp->links.sle_next) - (u_int8_t___0 *)newp);
        } else {
          newp->links.sle_next = -1;
        }
        hp->slh_first = (u_int8_t___0 *)newp - (u_int8_t___0 *)hp;
        newp->links.sle_prev = (u_int8_t___0 *)(& hp->slh_first) - (u_int8_t___0 *)newp;
        break;
      }
    } else {
      while (1) {
        if (lastp->links.sle_next != -1) {
          newp->links.sle_next = (u_int8_t___0 *)((struct __data *)((u_int8_t___0 *)lastp + lastp->links.sle_next)) - (u_int8_t___0 *)newp;
          if (newp->links.sle_next == -1) {
            tmp___3 = 0;
          } else {
            tmp___3 = - newp->links.sle_next;
          }
          ((struct __data *)((u_int8_t___0 *)lastp + lastp->links.sle_next))->links.sle_prev = tmp___3 + ((u_int8_t___0 *)(& newp->links.sle_next) - (u_int8_t___0 *)newp);
        } else {
          newp->links.sle_next = -1;
        }
        lastp->links.sle_next = (u_int8_t___0 *)newp - (u_int8_t___0 *)lastp;
        if (lastp->links.sle_next == -1) {
          tmp___4 = 0;
        } else {
          tmp___4 = - lastp->links.sle_next;
        }
        newp->links.sle_prev = tmp___4 + ((u_int8_t___0 *)(& lastp->links.sle_next) - (u_int8_t___0 *)lastp);
        break;
      }
    }
  }
  return;
}
}
int __memp_mf_discard(DB_MPOOL *dbmp , MPOOLFILE *mfp ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOL_STAT *sp ;
  MPOOL *mp ;
  int ret ;

  {
  dbenv___0 = dbmp->dbenv;
  mp = (MPOOL *)(dbmp->reginfo + 0)->primary;
  ret = 0;
  if (mfp->file_written) {
    if (! mfp->deadfile) {
      ret = __memp_mf_sync(dbmp, mfp);
    }
  }
  mfp->deadfile = 1;
  if (! (mfp->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
  }
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  while (1) {
    if (mfp->q.stqe_next != -1) {
      ((struct __mpoolfile *)((u_int8_t___0 *)mfp + mfp->q.stqe_next))->q.stqe_prev = mfp->q.stqe_prev + ((u_int8_t___0 *)mfp - (u_int8_t___0 *)((struct __mpoolfile *)((u_int8_t___0 *)mfp + mfp->q.stqe_next)));
      *((ssize_t___0 *)((u_int8_t___0 *)mfp + mfp->q.stqe_prev)) += mfp->q.stqe_next;
    } else {
      mp->mpfq.stqh_last = mfp->q.stqe_prev + ((u_int8_t___0 *)mfp - (u_int8_t___0 *)(& mp->mpfq));
      *((ssize_t___0 *)((u_int8_t___0 *)mfp + mfp->q.stqe_prev)) = -1;
    }
    break;
  }
  sp = & mp->stat;
  sp->st_cache_hit += mfp->stat.st_cache_hit;
  sp->st_cache_miss += mfp->stat.st_cache_miss;
  sp->st_map += mfp->stat.st_map;
  sp->st_page_create += mfp->stat.st_page_create;
  sp->st_page_in += mfp->stat.st_page_in;
  sp->st_page_out += mfp->stat.st_page_out;
  if (mfp->path_off != 0U) {
    __db_shalloc_free((dbmp->reginfo + 0)->addr, (void *)((u_int8_t___0 *)(dbmp->reginfo)->addr + mfp->path_off));
  }
  if (mfp->fileid_off != 0U) {
    __db_shalloc_free((dbmp->reginfo + 0)->addr, (void *)((u_int8_t___0 *)(dbmp->reginfo)->addr + mfp->fileid_off));
  }
  if (mfp->pgcookie_off != 0U) {
    __db_shalloc_free((dbmp->reginfo + 0)->addr, (void *)((u_int8_t___0 *)(dbmp->reginfo)->addr + mfp->pgcookie_off));
  }
  __db_shalloc_free((dbmp->reginfo + 0)->addr, (void *)mfp);
  if (! (((dbmp->reginfo)->rp)->mutex.flags & 2U)) {
    __db_pthread_mutex_unlock(dbenv___0, & ((dbmp->reginfo)->rp)->mutex);
  }
  return (ret);
}
}
extern int ( /* missing proto */  close)() ;
int __os_closehandle(DB_ENV *dbenv___0 , DB_FH *fhp ) 
{ int ret ;
  int retries ;
  char *tmp___1 ;

  {
  ret = 0;
  if ((int )fhp->flags & 2) {
    retries = 0;
    while (1) {
      if ((unsigned int )__db_global_values.j_close != (unsigned int )((void *)0)) {
        ret = (*(__db_global_values.j_close))(fhp->fd);
      } else {
        ret = close(fhp->fd);
      }
      if (ret != 0) {
        ret = __os_get_errno();
        if (ret == 4) {
          goto _L;
        } else {
          if (ret == 16) {
            _L: 
            retries ++;
            if (! (retries < 100)) {
              break;
            }
          } else {
            break;
          }
        }
      } else {
        break;
      }
    }
    if (ret != 0) {
      tmp___1 = strerror(ret);
    }
    if ((int )fhp->flags & 4) {
      __os_unlink(dbenv___0, (char const   *)fhp->name);
      __os_free(dbenv___0, (void *)fhp->name);
    }
  }
  __os_free(dbenv___0, (void *)fhp);
  return (ret);
}
}
int __db_appname(DB_ENV *dbenv___0 , APPNAME appname , char const   *file , u_int32_t___1 tmp_oflags ,
                 DB_FH **fhpp , char **namep ) 
{ 

  {
  return (0);
}
}
int __memp_fclose(DB_MPOOLFILE *dbmfp , u_int32_t___1 flags ) 
{ DB_ENV *dbenv___0 ;
  DB_MPOOL *dbmp ;
  MPOOLFILE *mfp ;
  char *rpath ;
  u_int32_t___1 ref ;
  int deleted ;
  int ret ;
  int t_ret ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  dbenv___0 = dbmfp->dbenv;
  dbmp = (DB_MPOOL *)dbenv___0->mp_handle;
  ret = 0;
  if ((unsigned int )dbmp == (unsigned int )((void *)0)) {
    goto done;
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbmp->mutexp);
    }
  }
  (dbmfp->ref) --;
  ref = dbmfp->ref;
  if (ref == 0U) {
    if (dbmfp->flags & 4U) {
      while (1) {
        if ((unsigned int )dbmfp->q.tqe_next != (unsigned int )((void *)0)) {
          (dbmfp->q.tqe_next)->q.tqe_prev = dbmfp->q.tqe_prev;
        } else {
          dbmp->dbmfq.tqh_last = dbmfp->q.tqe_prev;
        }
        *(dbmfp->q.tqe_prev) = dbmfp->q.tqe_next;
        break;
      }
    }
  }
  if (ref == 0U) {
    if ((unsigned int )dbmfp->fhp != (unsigned int )((void *)0)) {
      ((dbmfp->fhp)->ref) --;
      if ((dbmfp->fhp)->ref > 0) {
        dbmfp->fhp = (DB_FH *)((void *)0);
      }
    }
  }
  if ((unsigned int )dbmp->mutexp != (unsigned int )((void *)0)) {
    if (! ((dbmp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbmp->mutexp);
    }
  }
  if (ref != 0U) {
    return (0);
  }
  if (dbmfp->pinref != 0U) {
    tmp = __memp_fn(dbmfp);
    __db_err((DB_ENV const   *)dbenv___0, "%s: close: %lu blocks left pinned", tmp,
             (unsigned long )dbmfp->pinref);
    ret = __db_panic(dbenv___0, -30978);
  }
  if ((unsigned int )dbmfp->addr != (unsigned int )((void *)0)) {
    ret = __os_unmapfile(dbenv___0, dbmfp->addr, dbmfp->len);
    if (ret != 0) {
      tmp___0 = db_strerror(ret);
      tmp___1 = __memp_fn(dbmfp);
      __db_err((DB_ENV const   *)dbenv___0, "%s: %s", tmp___1, tmp___0);
    }
  }
  if ((unsigned int )dbmfp->fhp != (unsigned int )((void *)0)) {
    if ((unsigned int )(dbmfp->fhp)->mutexp != (unsigned int )((void *)0)) {
      __db_mutex_free(dbenv___0, dbmp->reginfo, (dbmfp->fhp)->mutexp);
      (dbmfp->fhp)->mutexp = (DB_MUTEX *)((void *)0);
    }
    t_ret = __os_closehandle(dbenv___0, dbmfp->fhp);
    if (t_ret != 0) {
      tmp___2 = db_strerror(t_ret);
      tmp___3 = __memp_fn(dbmfp);
      __db_err((DB_ENV const   *)dbenv___0, "%s: %s", tmp___3, tmp___2);
      if (ret == 0) {
        ret = t_ret;
      }
    }
    dbmfp->fhp = (DB_FH *)((void *)0);
  }
  mfp = dbmfp->mfp;
  if (! (dbmfp->flags & 4U)) {
    goto done;
  }
  deleted = 0;
  if (! (mfp->mutex.flags & 2U)) {
    __db_pthread_mutex_lock(dbenv___0, & mfp->mutex);
  }
  (mfp->mpf_cnt) --;
  if (mfp->mpf_cnt == 0U) {
    goto _L;
  } else {
    if (flags & 4U) {
      _L: 
      if (flags & 4U) {
        mfp->deadfile = 1;
      } else {
        if (mfp->flags & 256U) {
          mfp->deadfile = 1;
        } else {
          if (mfp->unlink_on_close) {
            mfp->deadfile = 1;
          }
        }
      }
      if (mfp->unlink_on_close) {
        t_ret = __db_appname(dbmp->dbenv, (enum __anonenum_APPNAME_39 )1, (char const   *)((void *)((u_int8_t___0 *)(dbmp->reginfo)->addr + mfp->path_off)),
                             0U, (DB_FH **)((void *)0), & rpath);
        if (t_ret != 0) {
          if (ret == 0) {
            ret = t_ret;
          }
        }
        if (t_ret == 0) {
          tmp___4 = __os_unlink(dbmp->dbenv, (char const   *)rpath);
          t_ret = tmp___4 != 0;
          if (t_ret) {
            if (ret == 0) {
              ret = t_ret;
            }
          }
          __os_free(dbenv___0, (void *)rpath);
        }
      }
      if (mfp->block_cnt == 0U) {
        t_ret = __memp_mf_discard(dbmp, mfp);
        if (t_ret != 0) {
          if (ret == 0) {
            ret = t_ret;
          }
        }
        deleted = 1;
      }
    }
  }
  if (deleted == 0) {
    if (! (mfp->mutex.flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, & mfp->mutex);
    }
  }
  done: 
  if ((unsigned int )dbmfp->pgcookie != (unsigned int )((void *)0)) {
    __os_free(dbenv___0, (dbmfp->pgcookie)->data);
    __os_free(dbenv___0, (void *)dbmfp->pgcookie);
  }
  __os_free(dbenv___0, (void *)dbmfp);
  return (ret);
}
}
int __qam_nameop(DB *dbp___1 , DB_TXN *txn , char const   *newname , qam_name_op op ) 
{ 

  {
  if (dbp___1->dbenv) {
    if (dbp___1->q_internal) {
      if (((QUEUE *)dbp___1->q_internal)->page_ext) {
        return (1);
      } else {
        return (0);
      }
    } else {
      return (0);
    }
  } else {
    return (0);
  }
}
}
int __ham_db_close(DB *dbp___1 ) 
{ 

  {
  if ((unsigned int )dbp___1->h_internal == (unsigned int )((void *)0)) {
    return (0);
  }
  __os_free(dbp___1->dbenv, dbp___1->h_internal);
  dbp___1->h_internal = (void *)0;
  return (0);
}
}
int __qam_db_close(DB *dbp___1 , u_int32_t___1 flags ) 
{ DB_MPOOLFILE *mpf ;
  MPFARRAY *array ;
  QUEUE *t ;
  struct __qmpf *mpfp ;
  u_int32_t___1 i ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  ret = 0;
  t = (QUEUE *)dbp___1->q_internal;
  if ((unsigned int )t == (unsigned int )((void *)0)) {
    return (0);
  }
  array = & t->array1;
  again: 
  mpfp = array->mpfarray;
  if ((unsigned int )mpfp != (unsigned int )((void *)0)) {
    i = array->low_extent;
    while (i <= array->hi_extent) {
      mpf = mpfp->mpf;
      mpfp->mpf = (DB_MPOOLFILE *)((void *)0);
      if ((unsigned int )mpf != (unsigned int )((void *)0)) {
        if (flags & 256U) {
          tmp = 4;
        } else {
          tmp = 0;
        }
        t_ret = __memp_fclose(mpf, (unsigned int )tmp);
        if (t_ret != 0) {
          if (ret == 0) {
            ret = t_ret;
          }
        }
      }
      i ++;
      mpfp ++;
    }
    __os_free(dbp___1->dbenv, (void *)array->mpfarray);
  }
  if (t->array2.n_extent != 0U) {
    array = & t->array2;
    array->n_extent = 0U;
    goto again;
  }
  if (flags & 256U) {
    t_ret = __qam_nameop(dbp___1, (DB_TXN *)((void *)0), (char const   *)((void *)0),
                         (enum __anonenum_qam_name_op_78 )0);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  if ((unsigned int )t->path != (unsigned int )((void *)0)) {
    __os_free(dbp___1->dbenv, (void *)t->path);
  }
  __os_free(dbp___1->dbenv, (void *)t);
  dbp___1->q_internal = (void *)0;
  return (ret);
}
}
int __dbenv_close(DB_ENV *dbenv___0 , int rep_check ) 
{ 

  {
  if (__db_global_values.j_free) {
    if (dbenv___0->crypto_handle) {
      if (dbenv___0->passwd) {
        if (dbenv___0->passwd_len) {
          if (((DB_CIPHER *)dbenv___0->crypto_handle)->data) {
            if (((DB_CIPHER *)dbenv___0->crypto_handle)->flags) {
              dbenv___0->passwd = (char *)0;
            } else {
              dbenv___0->passwd = (char *)1;
            }
          } else {
            dbenv___0->passwd = (char *)1;
          }
        } else {
          dbenv___0->passwd = (char *)1;
        }
      } else {
        dbenv___0->passwd = (char *)1;
      }
    } else {
      dbenv___0->passwd = (char *)1;
    }
  } else {
    dbenv___0->passwd = (char *)1;
  }
  return (0);
}
}
int __db_s_done(DB *sdbp ) 
{ DB *pdbp ;
  int doclose ;
  int tmp___0 ;

  {
  pdbp = sdbp->s_primary;
  doclose = 0;
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  (sdbp->s_refcnt) --;
  if (sdbp->s_refcnt == 0U) {
    while (1) {
      if ((unsigned int )sdbp->s_links.le_next != (unsigned int )((void *)0)) {
        (sdbp->s_links.le_next)->s_links.le_prev = sdbp->s_links.le_prev;
      }
      *(sdbp->s_links.le_prev) = sdbp->s_links.le_next;
      break;
    }
    doclose = 1;
  }
  if ((unsigned int )pdbp->mutexp != (unsigned int )((void *)0)) {
    if (! ((pdbp->mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(pdbp->dbenv, pdbp->mutexp);
    }
  }
  if (doclose) {
    tmp___0 = __db_close(sdbp, (DB_TXN *)((void *)0), 0U);
  } else {
    tmp___0 = 0;
  }
  return (tmp___0);
}
}
int __bam_c_rget(DBC *dbc , DBT *data ) 
{ 

  {
  return (0);
}
}
int __db_c_get(DBC *dbc_arg , DBT *key , DBT *data , u_int32_t___1 flags ) 
{ DB *dbp___1 ;
  DBC *dbc ;
  DBC *dbc_n ;
  DBC *opd ;
  DBC_INTERNAL *cp ;
  DBC_INTERNAL *cp_n ;
  DB_MPOOLFILE *mpf ;
  db_pgno_t pgno ;
  u_int32_t___1 multi ;
  u_int32_t___1 tmp_dirty ;
  u_int32_t___1 tmp_flags ;
  u_int32_t___1 tmp_rmw ;
  u_int8_t___0 type ;
  int ret ;
  int t_ret ;
  int tmp ;
  int tmp___1 ;

  {
  dbp___1 = dbc_arg->dbp;
  mpf = dbp___1->mpf;
  dbc_n = (DBC *)((void *)0);
  opd = (DBC *)((void *)0);
  tmp_rmw = flags & 268435456U;
  flags &= 4026531839U;
  tmp_dirty = flags & 33554432U;
  flags &= 4261412863U;
  multi = flags & 201326592U;
  flags &= 4093640703U;
  if (flags == 13U) {
    if (tmp_rmw) {
      dbc_arg->flags |= 32U;
    }
    if (tmp_dirty) {
      dbc_arg->flags |= 4U;
    }
    ret = __bam_c_rget(dbc_arg, data);
    if (tmp_rmw) {
      dbc_arg->flags &= 4294967263U;
    }
    if (tmp_dirty) {
      dbc_arg->flags &= 4294967291U;
    }
    return (ret);
  }
  if (flags == 5U) {
    goto _L;
  } else {
    if (flags == 6U) {
      _L: 
      if ((dbp___1->dbenv)->flags & 2U) {
        if (! (dbc_arg->flags & 384U)) {
          tmp = __db_wrlock_err(dbp___1->dbenv);
          return (tmp);
        }
        if (dbc_arg->flags & 128U) {
          ret = __lock_get(dbp___1->dbenv, dbc_arg->locker, 32U, (DBT const   *)(& dbc_arg->lock_dbt),
                           (enum __anonenum_db_lockmode_t_50 )2, & dbc_arg->mylock);
          if (ret != 0) {
            return (ret);
          }
        }
      }
    }
  }
  cp = dbc_arg->internal;
  if ((unsigned int )cp->opd != (unsigned int )((void *)0)) {
    if (flags == 7U) {
      goto _L___1;
    } else {
      if (flags == 11U) {
        goto _L___1;
      } else {
        if (flags == 18U) {
          goto _L___1;
        } else {
          if (flags == 19U) {
            goto _L___1;
          } else {
            if (flags == 25U) {
              _L___1: 
              if (tmp_rmw) {
                ret = (*(dbc_arg->c_am_writelock))(dbc_arg);
                if (ret != 0) {
                  return (ret);
                }
              }
              ret = 0;
              if (ret != 0) {
                return (ret);
              }
              ret = (*(opd->c_am_get))(opd, key, data, flags, (db_pgno_t *)((void *)0));
              switch (ret) {
              case 0: ;
              goto done;
              case -30990: ;
              if (flags == 18U) {
                goto _L___0;
              } else {
                if (flags == 25U) {
                  _L___0: 
                  ret = __db_c_close(opd);
                  if (ret != 0) {
                    goto err;
                  }
                  opd = (DBC *)((void *)0);
                  break;
                }
              }
              goto err;
              default: ;
              goto err;
              }
            }
          }
        }
      }
    }
  }
  switch ((int )flags) {
  case 7: ;
  case 11: ;
  case 18: ;
  case 19: ;
  case 20: ;
  case 25: ;
  case 26: 
  tmp_flags = 24U;
  break;
  default: 
  tmp_flags = 0U;
  break;
  }
  if (tmp_dirty) {
    dbc_arg->flags |= 4U;
  }
  if (dbc_arg->flags & 64U) {
    dbc_n = dbc_arg;
  } else {
    ret = 0;
    if (tmp_dirty) {
      dbc_arg->flags &= 4294967291U;
    }
    if (ret != 0) {
      goto err;
    }
    while (1) {
      dbc_n->rskey = dbc_arg->rskey;
      dbc_n->rkey = dbc_arg->rkey;
      dbc_n->rdata = dbc_arg->rdata;
      break;
    }
  }
  if (tmp_rmw) {
    dbc_n->flags |= 32U;
  }
  switch ((int )multi) {
  case 67108864: 
  dbc_n->flags |= 512U;
  break;
  case 134217728: 
  dbc_n->flags |= 1024U;
  break;
  case 201326592: 
  dbc_n->flags |= 1536U;
  break;
  case 0: ;
  default: ;
  break;
  }
  pgno = 0U;
  ret = (*(dbc_n->c_am_get))(dbc_n, key, data, flags, & pgno);
  if (tmp_rmw) {
    dbc_n->flags &= 4294967263U;
  }
  if (tmp_dirty) {
    dbc_arg->flags &= 4294967291U;
  }
  dbc_n->flags &= 4294965759U;
  if (ret != 0) {
    goto err;
  }
  cp_n = dbc_n->internal;
  if (pgno != 0U) {
    ret = 0;
    if (ret != 0) {
      goto err;
    }
    switch ((int )flags) {
    case 9: ;
    case 18: ;
    case 20: ;
    case 28: ;
    case 31: ;
    case 30: 
    tmp_flags = 9U;
    break;
    case 17: ;
    case 25: ;
    case 26: 
    tmp_flags = 17U;
    break;
    case 10: ;
    case 11: ;
    case 12: 
    tmp_flags = flags;
    break;
    default: 
    ret = 0;
    goto err;
    }
    ret = (*((cp_n->opd)->c_am_get))(cp_n->opd, key, data, tmp_flags, (db_pgno_t *)((void *)0));
    if (ret != 0) {
      goto err;
    }
  }
  done: 
  if ((unsigned int )dbc_n == (unsigned int )((void *)0)) {
    cp_n = dbc_arg->internal;
  } else {
    cp_n = dbc_n->internal;
  }
  if (! (key->flags & 2U)) {
    if ((unsigned int )cp_n->page == (unsigned int )((void *)0)) {
      ret = __memp_fget(mpf, & cp_n->pgno, 0U, (void *)(& cp_n->page));
      if (ret != 0) {
        goto err;
      }
    }
    ret = 0;
    if (ret != 0) {
      goto err;
    }
  }
  if (multi != 0U) {
    if ((unsigned int )dbc_n == (unsigned int )((void *)0)) {
      if (! (multi & 134217728U)) {
        if ((unsigned int )(dbc_arg->internal)->opd == (unsigned int )((void *)0)) {
          dbc_n = dbc_arg;
        } else {
          goto _L___2;
        }
      } else {
        _L___2: 
        if (dbc_arg->flags & 64U) {
          dbc_n = dbc_arg;
        } else {
          ret = 0;
          if (ret != 0) {
            goto err;
          }
          ret = (*(dbc_n->c_am_get))(dbc_n, key, data, 7U, & pgno);
          if (ret != 0) {
            goto err;
          }
        }
      }
      cp_n = dbc_n->internal;
    }
    if ((unsigned int )opd != (unsigned int )((void *)0)) {
      cp_n->opd = opd;
      opd = (DBC *)((void *)0);
    }
    data->size = data->ulen;
    ret = (*(dbc_n->c_am_bulk))(dbc_n, data, flags | multi);
  } else {
    if (! (data->flags & 2U)) {
      if ((unsigned int )opd != (unsigned int )((void *)0)) {
        dbc = opd;
      } else {
        if ((unsigned int )cp_n->opd != (unsigned int )((void *)0)) {
          dbc = cp_n->opd;
        } else {
          dbc = dbc_n;
        }
      }
      type = ((PAGE *)(dbc->internal)->page)->type;
      if ((int )type == 5) {
        tmp___1 = 1;
      } else {
        if ((int )type == 2) {
          tmp___1 = 1;
        } else {
          tmp___1 = 0;
        }
      }
      ret = 0;
    }
  }
  err: 
  key->flags &= 4294967293U;
  data->flags &= 4294967293U;
  if ((unsigned int )opd != (unsigned int )((void *)0)) {
    t_ret = 0;
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  t_ret = 0;
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if (flags == 5U) {
    goto _L___3;
  } else {
    if (flags == 6U) {
      _L___3: 
      if (dbc_arg->flags & 128U) {
        __lock_downgrade(dbp___1->dbenv, & dbc_arg->mylock, (enum __anonenum_db_lockmode_t_50 )4,
                         0U);
      }
    }
  }
  return (ret);
}
}
int __db_close(DB *dbp___1 , DB_TXN *txn , u_int32_t___1 flags ) 
{ DB_ENV *dbenv___0 ;
  u_int32_t___1 dbpflags ;
  int db_ref ;
  int deferred_close ;
  int ret ;
  int t_ret ;

  {
  dbenv___0 = dbp___1->dbenv;
  ret = 0;
  deferred_close = ret;
  if ((unsigned int )txn != (unsigned int )((void *)0)) {
    __db_check_txn(dbp___1, txn, 0U, 0);
  }
  dbpflags = dbp___1->flags;
  ret = 0;
  if (deferred_close) {
    return (ret);
  }
  t_ret = __bam_db_close(dbp___1);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  t_ret = __ham_db_close(dbp___1);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  t_ret = __qam_db_close(dbp___1, dbpflags);
  if (t_ret != 0) {
    if (ret == 0) {
      ret = t_ret;
    }
  }
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_lock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  (dbenv___0->db_ref) --;
  db_ref = dbenv___0->db_ref;
  if ((unsigned int )dbenv___0->dblist_mutexp != (unsigned int )((void *)0)) {
    if (! ((dbenv___0->dblist_mutexp)->flags & 2U)) {
      __db_pthread_mutex_unlock(dbenv___0, dbenv___0->dblist_mutexp);
    }
  }
  if (dbenv___0->flags & 16U) {
    if (db_ref == 0) {
      t_ret = __dbenv_close(dbenv___0, 0);
      if (t_ret != 0) {
        if (ret == 0) {
          ret = t_ret;
        }
      }
    }
  }
  memset((void *)dbp___1, 219, sizeof(*dbp___1));
  __os_free(dbenv___0, (void *)dbp___1);
  return (ret);
}
}
int __db_c_del(DBC *dbc , u_int32_t___1 flags ) ;
static int __db_c_del_secondary(DBC *dbc ) 
{ DB *pdbp ;
  DBC *pdbc ;
  DBT skey ;
  DBT pkey ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  memset((void *)(& skey), 0, sizeof(DBT ));
  memset((void *)(& pkey), 0, sizeof(DBT ));
  skey.flags |= 40U;
  ret = __db_c_get(dbc, & skey, & pkey, 7U);
  if (ret != 0) {
    return (ret);
  }
  pdbp = (dbc->dbp)->s_primary;
  ret = __db_cursor_int(pdbp, dbc->txn, pdbp->type, 0U, 0, dbc->locker, & pdbc);
  if (ret != 0) {
    return (ret);
  }
  if ((pdbp->dbenv)->flags & 2U) {
    pdbc->flags |= 256U;
  }
  if (! (dbc->flags & 8U)) {
    if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
      if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
        tmp = 268435456;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  } else {
    tmp = 0;
  }
  ret = __db_c_get(pdbc, & pkey, & skey, (unsigned int )(tmp | 28));
  if (ret == 0) {
    ret = __db_c_del(pdbc, 0U);
  } else {
    if (ret == -30990) {
      ret = __db_secondary_corrupt(pdbp);
    }
  }
  t_ret = __db_c_close(pdbc);
  if (t_ret != 0) {
    if (ret != 0) {
      ret = t_ret;
    }
  }
  return (ret);
}
}
int __db_c_del_primary(DBC *dbc ) 
{ DB *dbp___1 ;
  DB *sdbp ;
  DBC *sdbc ;
  DBT data ;
  DBT pkey ;
  DBT skey ;
  DBT temppkey ;
  DBT tempskey ;
  int ret ;
  int t_ret ;
  int tmp ;

  {
  dbp___1 = dbc->dbp;
  memset((void *)(& pkey), 0, sizeof(DBT ));
  memset((void *)(& data), 0, sizeof(DBT ));
  ret = __db_c_get(dbc, & pkey, & data, 7U);
  if (ret != 0) {
    return (ret);
  }
  sdbp = __db_s_first(dbp___1);
  while (1) {
    if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
      if (! (ret == 0)) {
        break;
      }
    } else {
      break;
    }
    memset((void *)(& skey), 0, sizeof(DBT ));
    ret = (*(sdbp->s_callback))(sdbp, (DBT const   *)(& pkey), (DBT const   *)(& data),
                                & skey);
    if (ret != 0) {
      if (ret == -30999) {
        goto __Cont;
      }
      if (skey.flags & 1U) {
        __os_ufree(sdbp->dbenv, skey.data);
        skey.flags &= 4294967294U;
      }
      goto done;
    }
    ret = __db_cursor_int(sdbp, dbc->txn, sdbp->type, 0U, 0, dbc->locker, & sdbc);
    if (ret != 0) {
      goto done;
    }
    if ((sdbp->dbenv)->flags & 2U) {
      sdbc->flags |= 256U;
    }
    memset((void *)(& tempskey), 0, sizeof(DBT ));
    tempskey.data = skey.data;
    tempskey.size = skey.size;
    memset((void *)(& temppkey), 0, sizeof(DBT ));
    temppkey.data = pkey.data;
    temppkey.size = pkey.size;
    if (! (dbc->flags & 8U)) {
      if (! (((dbc->dbp)->dbenv)->flags & 2U)) {
        if ((unsigned int )((dbc->dbp)->dbenv)->lk_handle != (unsigned int )((void *)0)) {
          tmp = 268435456;
        } else {
          tmp = 0;
        }
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
    ret = __db_c_get(sdbc, & tempskey, & temppkey, (unsigned int )(tmp | 10));
    if (ret == 0) {
      ret = __db_c_del(sdbc, 34U);
    } else {
      if (ret == -30990) {
        ret = __db_secondary_corrupt(dbp___1);
      }
    }
    if (skey.flags & 1U) {
      __os_ufree(sdbp->dbenv, skey.data);
      skey.flags &= 4294967294U;
    }
    t_ret = __db_c_close(sdbc);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
    if (ret != 0) {
      goto done;
    }
    __Cont: 
    ret = __db_s_next(& sdbp);
  }
  done: 
  if ((unsigned int )sdbp != (unsigned int )((void *)0)) {
    t_ret = __db_s_done(sdbp);
    if (t_ret != 0) {
      if (ret == 0) {
        ret = t_ret;
      }
    }
  }
  return (ret);
}
}
int __db_c_del(DBC *dbc , u_int32_t___1 flags ) 
{ DB *dbp___1 ;
  DBC *opd ;
  int ret ;
  int tmp ;

  {
  dbp___1 = dbc->dbp;
  if ((dbp___1->dbenv)->flags & 2U) {
    if (! (dbc->flags & 384U)) {
      tmp = __db_wrlock_err(dbp___1->dbenv);
      return (tmp);
    }
    if (dbc->flags & 128U) {
      ret = __lock_get(dbp___1->dbenv, dbc->locker, 32U, (DBT const   *)(& dbc->lock_dbt),
                       (enum __anonenum_db_lockmode_t_50 )2, & dbc->mylock);
      if (ret != 0) {
        return (ret);
      }
    }
  }
  if (flags != 34U) {
    if (dbp___1->flags & 33554432U) {
      ret = __db_c_del_secondary(dbc);
      goto done;
    }
  }
  if ((unsigned int )dbp___1->s_secondaries.lh_first != (unsigned int )((void *)0)) {
    ret = __db_c_del_primary(dbc);
    if (ret != 0) {
      goto done;
    }
  }
  opd = (dbc->internal)->opd;
  if ((unsigned int )opd == (unsigned int )((void *)0)) {
    ret = (*(dbc->c_am_del))(dbc);
  } else {
    ret = (*(dbc->c_am_writelock))(dbc);
    if (ret == 0) {
      ret = (*(opd->c_am_del))(opd);
    }
  }
  done: 
  if (dbc->flags & 128U) {
    __lock_downgrade(dbp___1->dbenv, & dbc->mylock, (enum __anonenum_db_lockmode_t_50 )4,
                     0U);
  }
  return (ret);
}
}
static void mgsl_free_intermediate_txbuffer_memory(struct mgsl_struct *info ) 
{ int i ;

  {
  i = 0;
  while (i < info->num_tx_holding_buffers) {
    if (info->tx_holding_buffers[i].buffer) {
      free((void *)info->tx_holding_buffers[i].buffer);
      info->tx_holding_buffers[i].buffer = (unsigned char *)((void *)0);
    }
    i ++;
  }
  info->get_tx_holding_index = 0;
  info->put_tx_holding_index = 0;
  info->tx_holding_count = 0;
  return;
}
}
static int flush_older_commits(struct super_block *s , struct reiserfs_journal_list *jl ) 
{ struct reiserfs_journal_list *other_jl ;
  struct reiserfs_journal_list *first_jl ;
  struct list_head *entry ;
  unsigned long trans_id ;
  unsigned long other_trans_id ;
  unsigned long first_trans_id ;
  struct list_head  const  *__mptr ;
  struct list_head  const  *__mptr___0 ;

  {
  trans_id = jl->j_trans_id;
  first_jl = jl;
  entry = jl->j_list.prev;
  while (1) {
    __mptr = (struct list_head  const  *)entry;
    other_jl = (struct reiserfs_journal_list *)((char *)__mptr - (unsigned int )(& ((struct reiserfs_journal_list *)0)->j_list));
    if (other_jl->j_older_commits_done.counter) {
      break;
    }
    first_jl = other_jl;
    entry = other_jl->j_list.prev;
  }
  if ((unsigned int )first_jl == (unsigned int )jl) {
    return (0);
  }
  first_trans_id = first_jl->j_trans_id;
  entry = & first_jl->j_list;
  while (1) {
    __mptr___0 = (struct list_head  const  *)entry;
    other_jl = (struct reiserfs_journal_list *)((char *)__mptr___0 - (unsigned int )(& ((struct reiserfs_journal_list *)0)->j_list));
    other_trans_id = other_jl->j_trans_id;
    if (other_trans_id < trans_id) {
      if (other_jl->j_commit_left.counter != (int volatile   )0) {

      }
      entry = entry->next;
      return (0);
    } else {
      return (0);
    }
  }
  return (0);
}
}
int ptrMain(int argc , char **argv ) 
{ UDWORD dw ;
  unsigned char ch ;
  UBYTE *addr ;
  hashThing *ht ;
  struct mgsl_struct mgsl_s ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  tmp = malloc(sizeof(UBYTE ) * 16U);
  addr = (UBYTE *)tmp;
  InitCRC();
  dw = CalcCRC32(0UL, addr, 4UL);
  ChannelDelta = 0;
  CurChannel = 0;
  ch = DecodeAudio(44);
  tmp___0 = malloc(sizeof(hashThing ));
  ht = (hashThing *)tmp___0;
  tmp___1 = malloc(sizeof(hashThing ));
  ht->kids.fst = tmp___1;
  tmp___2 = malloc(sizeof(hashThing ));
  ht->kids.snd = tmp___2;
  assignFstHash(ht);
  updateHash(ht);
  updateHashVoid((void *)ht);
  i = __db_pg_free_recover_int((DB_ENV *)0, (__db_pg_freedata_args *)0, (DB *)0, (DB_LSN *)0,
                               (DB_MPOOLFILE *)0, (enum __anonenum_db_recops_55 )0,
                               10);
  i = __db_pg_alloc_recover((DB_ENV *)0, (DBT *)0, (DB_LSN *)0, (enum __anonenum_db_recops_55 )0,
                            (void *)0);
  mgsl_free_intermediate_txbuffer_memory(& mgsl_s);
  i = __db_c_del((DBC *)0, 0U);
  i = __db_c_close((DBC *)0);
  i = flush_older_commits((struct super_block *)0, (struct reiserfs_journal_list *)0);
  return (0);
}
}
#pragma merger(0,"/tmp/cil-TXNLw2V5.i","")
void _spin_lock(spinlock_t *lock ) ;
int _spin_trylock(spinlock_t *lock ) ;
void _spin_unlock(spinlock_t *lock ) ;
extern struct _IO_FILE___0 *stderr ;
extern int fprintf(FILE___0 * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
void _spin_lock(spinlock_t *lock ) 
{ 

  {
  lock->locked = 1;
  return;
}
}
int _spin_trylock(spinlock_t *lock ) 
{ 

  {
  if (lock->locked == 0) {
    lock->locked = 1;
    return (0);
  } else {
    return (1);
  }
}
}
void _spin_unlock(spinlock_t *lock ) 
{ 

  {
  if (lock->locked == 1) {
    lock->locked = 0;
  } else {
    fprintf((FILE___0 * __restrict  )stderr, (char const   * __restrict  )"Double unlock!\n");
  }
  return;
}
}
#pragma merger(0,"/tmp/cil-h6cc03rA.i","")
struct __anonstruct_pthread_mutex_t_16 cli_ref_mutex  =    {0, 0, (struct _pthread_descr_struct *)0, 0, {0L, 0}};
static int targettab[6]  = {      0,      502,      511,      519, 
        520,      515};
void miniMunge2(int *x , spinlock_t *l ) 
{ int i ;
  int *p ;

  {
  i = 10;
  p = & i;
  (*p) ++;
  _spin_lock(l);
  (*x) ++;
  _spin_unlock(l);
  return;
}
}
void miniMunge(int *argX , spinlock_t *argLock ) 
{ 

  {
  miniMunge2(argX, argLock);
  miniMunge2(argX, argLock);
  return;
}
}
void accList(void *arg ) 
{ list___0 *l ;
  int *px ;
  spinlock_t *pl ;

  {
  l = (list___0 *)arg;
  while (l) {
    px = & l->data;
    pl = l->lock;
    miniMunge(px, pl);
    l = l->next;
  }
  return;
}
}
list___0 *makeList(int size ) 
{ list___0 *result ;
  list___0 *prev ;
  void *tmp ;
  void *tmp___0 ;

  {
  result = (list___0 *)0;
  prev = (list___0 *)0;
  while (size > 0) {
    tmp = malloc(sizeof(list___0 ));
    result = (list___0 *)tmp;
    tmp___0 = malloc(sizeof(spinlock_t ));
    result->lock = (spinlock_t *)tmp___0;
    result->data = 0;
    result->next = prev;
    prev = result;
  }
  return (result);
}
}
int cli_validatesig(unsigned short target , unsigned short ftype , char const   *offstr ,
                    unsigned long fileoff , int desc , char const   *virname ) 
{ long off ;
  long tmp ;

  {
  if (target) {
    if ((int )target >= 6) {
      fprintf((FILE___0 * __restrict  )stderr, (char const   * __restrict  )"Bad target in signature (%s)\n",
              virname);
      return (0);
    } else {
      if (targettab[target] != (int )ftype) {
        fprintf((FILE___0 * __restrict  )stderr, (char const   * __restrict  )"Type: %d, expected: %d (%s)\n",
                ftype, targettab[target], virname);
        return (0);
      }
    }
  }
  if (offstr) {
    if (desc != -1) {
      tmp = 10L;
      off = tmp;
      if (off == -1L) {
        fprintf((FILE___0 * __restrict  )stderr, (char const   * __restrict  )"Bad offset in signature (%s)\n",
                virname);
        return (0);
      }
      if (fileoff != (unsigned long )off) {
        fprintf((FILE___0 * __restrict  )stderr, (char const   * __restrict  )"Virus offset: %d, expected: %d (%s)\n",
                fileoff, off, virname);
        return (0);
      }
    }
  }
  return (1);
}
}
int cli_bm_scanbuff(char const   *buffer , unsigned int length , char const   **virname ,
                    struct cl_node  const  *root , unsigned long offset , unsigned short ftype ,
                    int fd ) 
{ unsigned int i ;
  unsigned int j ;
  unsigned int shift ;
  unsigned int off ;
  unsigned int found ;
  uint16_t idx ;
  struct cli_bm_patt *p ;
  char const   *bp ;
  char prefix ;
  int tmp ;

  {
  found = 0U;
  if (! root->bm_shift) {
    return (0);
  }
  if (length < 3U) {
    return (0);
  }
  i = 0U;
  while (i < (length - 3U) + 1U) {
    idx = (unsigned short )((211 * (int )((unsigned char )*(buffer + i)) + 37 * (int )((unsigned char )*(buffer + (i + 1U)))) + (int )((unsigned char )*(buffer + (i + 2U))));
    shift = (unsigned int )*(root->bm_shift + (int )idx);
    if (shift == 0U) {
      prefix = (char )*(buffer + ((i - 3U) + 3U));
      p = *(root->bm_suffix + (int )idx);
      while (1) {
        if (p) {
          if (! ((int )*(p->pattern + 0) != (int )prefix)) {
            break;
          }
        } else {
          break;
        }
        p = p->next;
      }
      while (1) {
        if (p) {
          if (! ((int )*(p->pattern + 0) == (int )prefix)) {
            break;
          }
        } else {
          break;
        }
        off = (i - 3U) + 3U;
        bp = buffer + off;
        found = 1U;
        j = 0U;
        while (1) {
          if (j < p->length) {
            if (! (off < length)) {
              break;
            }
          } else {
            break;
          }
          if ((int const   )*(bp + j) != (int const   )*(p->pattern + j)) {
            found = 0U;
            break;
          }
          j ++;
          off ++;
        }
        if (found) {
          if (p->length == j) {
            if (p->target) {
              goto _L___0;
            } else {
              if (p->offset) {
                _L___0: 
                off = (unsigned int )(((offset + (unsigned long )i) - 3UL) + 3UL);
                if (fd == -1) {
                  if (! ftype) {
                    p = p->next;
                    continue;
                  } else {
                    goto _L;
                  }
                } else {
                  _L: 
                  tmp = cli_validatesig(p->target, ftype, (char const   *)p->offset,
                                        (unsigned long )off, fd, (char const   *)p->virname);
                  if (! tmp) {
                    p = p->next;
                    continue;
                  }
                }
              }
            }
            if (virname) {
              *virname = (char const   *)p->virname;
            }
            return (1);
          }
        }
        p = p->next;
      }
      shift = 1U;
    }
    i += shift;
  }
  return (0);
}
}
int main(int argc , char **argv ) 
{ list___0 *aList ;

  {
  aList = makeList(10);
  accList((void *)aList);
  accList((void *)aList);
  ptrMain(argc, argv);
  return (0);
}
}
