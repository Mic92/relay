open Fstructs
open Callg
open Cil
open Scope
open Lockset
open Backed_summary
open Guarded_access

(*******************************************************************)
(* state and function summary                                      *)

(* Per program-point state *)
type lockState = fullLS

type corrState = {
  writeCorrs : straintMap;
  readCorrs : straintMap;
}

type state = {
  lState : lockState;
  cState : corrState;
}

(* Represention of a summary. No double-locking error checks. *)
type summary

(* Singletons representing \bottom *)
val bottomLS : lockState
  
val bottomCS : corrState

val bottom : state

val bottomSummary : summary
    
(* State w/ empty sets *)
val emptyLS : lockState

val emptyCS : corrState

val emptyState : state

(* compare to bottom *)
val isBottomLS : lockState -> bool

val isBottomCS : corrState -> bool

val isBottomState : state -> bool

val isBottomSummary : summary -> bool

val summOutstate : summary -> state

val makeSumm: state -> state -> summary

val makeCState : correlation CMap.t -> correlation CMap.t -> corrState

val makeState: lockState -> corrState -> state
  


(*******************************************************************)
(* operations for transforming state                               *)

(** Combine the lock state portion of the state *)
val combineLStates : lockState -> lockState -> lockState

(** Combine the read/write access portion of the state *)
val combineCStates : corrState -> corrState -> corrState

val combineStates : state -> state -> state

(** True if the first state is a subset of the second *)
val lStateSubset : lockState -> lockState -> bool

val cStateSubset : corrState -> corrState -> bool

val statesSubset : state -> state -> bool

val addWriteCorr : fullLS -> corrState -> 
  lv -> location -> fKey -> scope -> corrState

val addReadCorr : fullLS -> corrState -> 
  lv -> location -> fKey -> scope -> corrState

val resolveScope : state -> fundec -> state

val iterWrites : (lv -> correlation -> unit) -> corrState -> unit

val iterReads : (lv -> correlation -> unit) -> corrState -> unit

val listWriteCorr : corrState -> (lv * correlation) list

val listReadCorr : corrState -> (lv * correlation) list

val listMods : state -> (lv * scope) list


(*******************************************************************)
(* ugly-printing functions / debug support *)

val printLockset : fullLS -> unit

val printCorrState : corrState -> unit

val printState : state -> unit

val printSummary : fKey -> unit

val deserializeFromFile : string -> summary


(** Implementation of function summary *)
module RaceSum : Backed_summary.S with type sum = summary

class type raceSummary = object
  inherit RaceSum.data
  method getMods : fKey -> (lv * scope) list
end

val sum : raceSummary


val initSummaries : Config.settings -> simpleCallG -> unit
